Think of the **pipeline** as a house blueprint. Each part has a role, and together they describe how your build/test/deploy flows. Iâ€™ll name every core component, tell you *what it does*, *why it matters*, and give you an **example snippet**.

---

## ðŸ”‘ Main Components of a Jenkins Pipeline

### 1. `pipeline`

* **What**: The root block of a declarative pipeline. Everything lives inside it.
* **Why**: Provides structure. Without it, Jenkins doesnâ€™t know youâ€™re writing a declarative pipeline.
* **Example**:

  ```groovy
  pipeline {
      agent any
      stages {
          stage('Hello') {
              steps {
                  echo 'Hi from Jenkins'
              }
          }
      }
  }
  ```

---

### 2. `agent`

* **What**: Defines *where* the pipeline or a stage runs (which Jenkins node, Docker container, or environment).
* **Why**: Your jobs donâ€™t all run on the Jenkins master; you can distribute them (e.g., build on Linux, test on Windows).
* **Example**:

  ```groovy
  pipeline {
      agent any     // run on any available node
  }
  ```

  Or more specific:

  ```groovy
  stage('Build in Docker') {
      agent {
          docker { image 'node:18' }
      }
      steps {
          sh 'node -v'
      }
  }
  ```

---

### 3. `stages`

* **What**: A collection of ordered **stage** blocks.
* **Why**: Lets you break your workflow into logical chunks (Build, Test, Deploy). Each shows up separately in the Jenkins UI.
* **Example**:

  ```groovy
  stages {
      stage('Build') { ... }
      stage('Test') { ... }
      stage('Deploy') { ... }
  }
  ```

---

### 4. `stage`

* **What**: A single phase in the pipeline.
* **Why**: Helps organize the flow and visualize progress/failures. A failed stage usually means that part of the lifecycle broke.
* **Example**:

  ```groovy
  stage('Lint') {
      steps {
          sh 'npm run lint'
      }
  }
  ```

---

### 5. `steps`

* **What**: The actual tasks to perform inside a stage. Each `sh`, `echo`, `git`, etc. is a step.
* **Why**: This is where the real work happens. Without steps, your pipeline is just empty labels.
* **Example**:

  ```groovy
  steps {
      echo 'Cloning repo...'
      git url: 'https://github.com/example/app.git', branch: 'main'
      sh 'npm install'
  }
  ```

---

### 6. `environment`

* **What**: Defines environment variables available during the pipeline.
* **Why**: Useful for secrets, API keys, or setting `NODE_ENV` / `JAVA_HOME`. Keeps configs clean.
* **Example**:

  ```groovy
  environment {
      NODE_ENV = 'test'
      API_KEY = credentials('my-api-key')   // securely injects a Jenkins credential
  }
  ```

---

### 7. `post`

* **What**: Defines actions to run after the pipeline or a stage finishes.
* **Why**: Cleanup, notifications, archiving logs. You can scope it to always, success, failure, unstable, etc.
* **Example**:

  ```groovy
  post {
      always {
          echo 'Pipeline finished (success or fail)'
      }
      success {
          echo 'Build passed!'
      }
      failure {
          mail to: 'team@example.com',
               subject: "Build Failed",
               body: "Check Jenkins console."
      }
  }
  ```

---

### 8. `when`

* **What**: Conditional logic for stages.
* **Why**: Skip or run stages based on branch, environment, or params. Saves time and resources.
* **Example**:

  ```groovy
  stage('Deploy') {
      when {
          branch 'main'
      }
      steps {
          echo 'Deploying only from main branch'
      }
  }
  ```

---

### 9. `input`

* **What**: Pauses the pipeline for human approval or data entry.
* **Why**: Useful before production deploys or destructive actions.
* **Example**:

  ```groovy
  stage('Approval') {
      steps {
          input message: 'Deploy to production?', ok: 'Yes, do it!'
      }
  }
  ```

---

### 10. `parallel`

* **What**: Run multiple branches of stages at the same time.
* **Why**: Speeds up pipelines (e.g., run unit tests and integration tests simultaneously).
* **Example**:

  ```groovy
  stage('Tests') {
      parallel {
          stage('Unit Tests') {
              steps { sh 'npm run test:unit' }
          }
          stage('Integration Tests') {
              steps { sh 'npm run test:integration' }
          }
      }
  }
  ```

---

### 11. `options`

* **What**: Sets pipeline-wide or stage-wide behaviors.
* **Why**: Things like timeout, retry, timestamps.
* **Example**:

  ```groovy
  pipeline {
      options {
          timeout(time: 1, unit: 'HOURS')
          buildDiscarder(logRotator(numToKeepStr: '10'))
      }
  }
  ```

---

### 12. `triggers`

* **What**: Defines when Jenkins should start the pipeline automatically.
* **Why**: Automates CI/CD instead of manual starts.
* **Example**:

  ```groovy
  triggers {
      pollSCM('H/15 * * * *')    // poll Git every 15 minutes
  }
  ```

---

### 13. `parameters`

* **What**: Allows passing user input into the pipeline at build start.
* **Why**: Useful for running different environments or versions.
* **Example**:

  ```groovy
  parameters {
      string(name: 'BRANCH', defaultValue: 'main', description: 'Git branch to build')
  }

  stage('Checkout') {
      steps {
          git branch: "${params.BRANCH}", url: 'https://github.com/example/app.git'
      }
  }
  ```

---

### 14. `tools`

* **What**: Auto-installs and configures tools (e.g., JDK, Maven, Node) available in Jenkins.
* **Why**: Makes sure your pipeline runs with the right tool versions.
* **Example**:

  ```groovy
  tools {
      nodejs 'Node18'
  }
  stage('Check Version') {
      steps {
          sh 'node -v'
      }
  }
  ```

---

### 15. `libraries`

* **What**: Shared libraries that multiple pipelines can use.
* **Why**: DRY (Donâ€™t Repeat Yourself). Encapsulate common build logic across teams.
* **Example** (in `Jenkinsfile`):

  ```groovy
  @Library('my-shared-lib') _
  ```

---

### 16. `script`

* **What**: Escape hatch for raw Groovy scripting inside declarative pipelines.
* **Why**: Declarative is limited; `script` gives you flexibility when you need logic.
* **Example**:

  ```groovy
  stage('Custom Logic') {
      steps {
          script {
              if (env.BRANCH_NAME == 'dev') {
                  echo "Running on dev branch"
              }
          }
      }
  }
  ```

---

âœ… These are the **building blocks** of a Jenkins declarative pipeline. Together, they let you:

* Define where jobs run (`agent`)
* Organize into lifecycle phases (`stages`, `stage`)
* Run actual work (`steps`)
* Control behavior (`when`, `input`, `parallel`)
* Automate cleanups (`post`, `options`, `triggers`)
* Keep it configurable (`environment`, `parameters`, `tools`, `libraries`, `script`)

---