A production-grade **Declarative Jenkinsfile** for a Node.js app that:

* pulls code from GitHub,
* installs dependencies,
* runs linter & tests (with dev deps),
* builds a production artifact,
* archives the artifact in Jenkins,
* and deploys to a remote server (via SSH + `rsync`), with a safe stop/start and quick health check.

I’ll give the Jenkinsfile first, then explain every important piece and what you must configure in Jenkins (credentials, labels, etc.). Copy/paste, adapt, and you’ll have a solid CI/CD baseline.

> Notes: this pipeline uses Docker for reproducible build environment (`node:18`), `sshagent` for secure SSH usage, and `rsync + systemd` on the remote host. Adjust images, ports, and credential IDs to match your infra.

---

# Jenkinsfile (production-ready)

```groovy
pipeline {
  agent { docker { image 'node:18-bullseye' } } // reproducible build image
  options {
    // keep logs tidy and make pipeline interruptible
    timeout(time: 60, unit: 'MINUTES')
    ansiColor('xterm')
    buildDiscarder(logRotator(numToKeepStr: '25'))
  }

  environment {
    // configure these in Jenkins -> Credentials & Global properties
    // e.g. NPM_TOKEN for private registries (optional)
    NPM_TOKEN = credentials('npm-token')              // optional
    DEPLOY_SSH_CREDENTIALS = 'deploy-ssh-key'         // ssh private key stored in Jenkins (credential type: SSH Username with private key)
    REMOTE_USER = 'deploy'                            // remote ssh user
    REMOTE_HOST = 'your.server.com'                   // replace with your server host or set via parameters
    REMOTE_APP_DIR = '/opt/myapp'                     // where app will live on remote
    SERVICE_NAME = 'myapp.service'                    // systemd service name on remote
    NODE_ENV = 'production'                           // default for build/deploy stages
  }

  parameters {
    string(name: 'BRANCH', defaultValue: 'main', description: 'Git branch to build/deploy')
    booleanParam(name: 'RUN_DEPLOY', defaultValue: true, description: 'If true deploy to REMOTE_HOST after successful build')
  }

  stages {
    stage('Checkout') {
      steps {
        // Use the pipeline checkout; you can add credentialsId if repo is private
        checkout([$class: 'GitSCM',
          branches: [[name: "*/${params.BRANCH}"]],
          userRemoteConfigs: [[url: 'https://github.com/RydKrm/Learning-Jenkins.git']]
        ])
        echo "Checked out branch ${params.BRANCH}"
      }
    }

    stage('Install') {
      environment { NODE_ENV = 'development' } // allow devDependencies for tests/lint
      steps {
        sh 'node -v && npm -v'
        // Prefer npm ci for reproducible installs if package-lock.json present
        script {
          if (fileExists('package-lock.json')) {
            sh 'npm ci'
          } else {
            sh 'npm install --include=dev'
          }
        }
      }
    }

    stage('Lint') {
      steps {
        // assumes you have lint script in package.json (npm run lint)
        sh 'npm run lint || true' // do not fail pipeline on lint by default; change as policy
      }
    }

    stage('Test') {
      environment { NODE_ENV = 'test' } // ensure app does not start listening in index.js
      steps {
        // run tests in band to avoid port conflicts in CI environment
        sh 'npm run test -- --runInBand --detectOpenHandles'
      }
      post {
        always {
          junit allowEmptyResults: true, testResults: 'reports/junit-*.xml' // if your jest outputs junit xml
        }
      }
    }

    stage('Build') {
      environment { NODE_ENV = 'production' }
      steps {
        // build artifacts (webpack, tsc, etc.)
        sh 'npm run build'
        // make a tar artifact (helps with deploy)
        sh '''
           mkdir -p release
           # copy package.json & production node_modules if needed (or use npm ci --omit=dev on remote)
           cp -r package.json package-lock.json dist release/ || true
           tar -czf release/app-${env.BUILD_NUMBER}.tar.gz -C release .
        '''
      }
      post {
        success {
          archiveArtifacts artifacts: "release/app-${env.BUILD_NUMBER}.tar.gz", fingerprint: true
        }
      }
    }

    stage('Publish Artifact (optional)') {
      when { expression { return false } } // toggle if you push to artifact repo (Nexus/Artifactory)
      steps {
        // e.g. npm publish or upload to artifact repo
        echo "Publish step is currently disabled — enable if needed"
      }
    }

    stage('Deploy') {
      when {
        allOf {
          expression { return params.RUN_DEPLOY }
          branch 'main'
        }
      }
      steps {
        script {
          // prepare remote folder name and artifact path
          def artifact = "release/app-${env.BUILD_NUMBER}.tar.gz"
          if (!fileExists(artifact)) {
            error "Artifact ${artifact} missing — build stage must produce it."
          }

          // install ssh tools inside docker image (Debian-based image)
          sh 'apt-get update -qq && apt-get install -y -qq openssh-client rsync || true'

          // use sshagent to inject private key and perform rsync + remote commands
          sshagent([env.DEPLOY_SSH_CREDENTIALS]) {
            // copy artifact to remote tmp dir
            sh """
              rsync -avz -e 'ssh -o StrictHostKeyChecking=no' ${artifact} ${env.REMOTE_USER}@${env.REMOTE_HOST}:/tmp/
            """

            // remote deploy sequence: extract to new release dir, switch symlink, restart systemd
            def remoteCmd = """
              set -e
              mkdir -p ${env.REMOTE_APP_DIR}/releases
              RELEASE_DIR=${env.REMOTE_APP_DIR}/releases/${env.BUILD_NUMBER}
              mkdir -p \${RELEASE_DIR}
              tar -xzf /tmp/$(basename ${artifact}) -C \${RELEASE_DIR} || exit 1
              # install production dependencies on remote (omit dev deps)
              cd \${RELEASE_DIR}
              if [ -f package-lock.json ]; then
                  npm ci --omit=dev --production
              else
                  npm install --production
              fi
              # atomically update current symlink
              ln -sfn \${RELEASE_DIR} ${env.REMOTE_APP_DIR}/current
              # ensure correct permissions
              chown -R ${env.REMOTE_USER}:${env.REMOTE_USER} ${env.REMOTE_APP_DIR}
              # restart service
              sudo systemctl daemon-reload || true
              sudo systemctl restart ${env.SERVICE_NAME}
              sleep 3
              # simple healthcheck (adjust path/port as needed)
              curl -f --silent http://127.0.0.1:3030/ || (echo 'healthcheck failed' && exit 2)
            """

            // run remote command
            sh "ssh -o StrictHostKeyChecking=no ${env.REMOTE_USER}@${env.REMOTE_HOST} '${remoteCmd}'"
          } // end sshagent
        } // end script
      } // end steps

      post {
        success {
          echo "Deploy succeeded to ${env.REMOTE_HOST}"
        }
        failure {
          echo "Deploy failed. Please investigate and roll back if necessary."
        }
      }
    } // end Deploy
  } // end stages

  post {
    always {
      echo "Pipeline ${currentBuild.fullDisplayName} finished with status: ${currentBuild.currentResult}"
    }
    success {
      echo "Build succeeded. Artifact archived."
    }
    failure {
      mail to: 'ops@example.com',
           subject: "FAILED: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
           body: "Pipeline failed on ${env.BUILD_URL}"
    }
  }
}
```

---

# Explanation — what each piece does & why it matters

**`agent { docker { image 'node:18-bullseye' } }`**

* Runs the pipeline inside a reproducible container with Node 18. Keeps builds consistent across machines.
* If your Jenkins doesn't support Docker agent, change to `agent any` and ensure Node is installed on the agent.

**`options`**

* `timeout` prevents hung builds from eating up executors.
* `ansiColor` gives readable colored logs.
* `buildDiscarder` keeps your build history tidy.

**`environment`**

* Central place for secrets and settings.
* `credentials('npm-token')` reads from Jenkins Credentials plugin. Don’t hardcode secrets.

**`parameters`**

* Makes the run configurable (branch, whether to deploy). Good for manual promotions.

**Checkout**

* Uses Jenkins GitSCM to fetch the requested branch. For private repos, add `credentialsId` in `userRemoteConfigs`.

**Install**

* Uses `npm ci` when `package-lock.json` exists (deterministic).
* `NODE_ENV=development` during install to include devDependencies for lint & tests.

**Lint**

* Keeps code quality checks visible. I left it non-blocking (`|| true`) so teams can adopt lint progressively; change if you want strict enforcement.

**Test**

* `NODE_ENV=test` ensures server code won’t call `listen()` if guarded (like your `index.js`).
* Uses `--runInBand` to execute test files sequentially inside CI and avoid port collisions.
* `--detectOpenHandles` helps surface stray resources.
* Posts JUnit results if available.

**Build**

* Runs `npm run build` to produce production artifacts (bundle, transpile).
* Creates a versioned tarball `release/app-${BUILD_NUMBER}.tar.gz` and archives it. Archiving fingerprints artifacts for traceability.

**Publish Artifact (optional)**

* Placeholder if you push to Artifactory/Nexus.

**Deploy**

* Only runs on `main` and if `RUN_DEPLOY` true.
* Uses `sshagent` and an SSH credential stored in Jenkins (`deploy-ssh-key`) — avoids embedding keys in pipelines.
* Copies artifact to `/tmp`, unpacks into a release dir, runs `npm ci --omit=dev --production` on the remote, updates `current` symlink, and restarts systemd service.
* Healthcheck via `curl` to ensure app comes up; script returns non-zero on failure to fail the stage.

**Post**

* Notifies on failure (email is an example).
* Always prints pipeline status.

---

# What you must configure in Jenkins (practical checklist)

1. **Credentials**

   * `deploy-ssh-key` — type: **SSH Username with private key** (user=deploy, key=private key). Allow this user to run `sudo systemctl restart` on remote or run service without sudo.
   * `npm-token` — (optional) for private registries, type: **Secret text** or **Username/Password**.

2. **Remote server**

   * Ensure `deploy` user exists and has:

     * write access to `/opt/myapp` (or chosen `REMOTE_APP_DIR`),
     * `sudo` rights for systemctl if required, or better: create a systemd service that the `deploy` user can restart without sudo via `sudoers` config.
   * Create a systemd service unit (example below).

3. **Jenkins node / Docker**

   * For `agent { docker { ... } }`, Jenkins must have Docker plugin and Docker installed on controller/agent.
   * Alternatively switch to `agent any` and install Node/ssh/rsync on the agent.

4. **Jest / test reporting**

   * If you want test results in Jenkins, configure Jest to output JUnit XML (`jest-junit`) into `reports/junit-*.xml`, then the `junit` step will consume them.

---

# Example minimal `systemd` unit for Node app (place on remote host)

```ini
[Unit]
Description=MyApp Node.js
After=network.target

[Service]
Type=simple
User=deploy
WorkingDirectory=/opt/myapp/current
ExecStart=/usr/bin/node dist/server.js
Restart=on-failure
Environment=NODE_ENV=production
Environment=PORT=3030

[Install]
WantedBy=multi-user.target
```

* Adjust `ExecStart` to point at your built entrypoint.
* After deploying new `current` symlink, `systemctl restart myapp.service` will pick up the new release.

---

# Quick troubleshooting + hardening tips

* Use `npm ci --omit=dev` on remote to avoid shipping devDependencies.
* Add a `roll-back` step: keep the previous symlink and re-point it if healthcheck fails.
* Use a load balancer and drain traffic before restart for zero-downtime.
* Use a signed artifact repository for added security.
* Use `credentialsId` for Git checkout if repo is private.
* Use a `deploy` pipeline that requires manual approval for production (an `input` step).

---