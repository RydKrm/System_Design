## **Part 1: Code Section (.text) and Data Sections**

Before a process can execute, the program must be organized into distinct memory sections. Let's understand each one deeply.

### **The Code Section (.text) - Where Instructions Live**

The code section, also called the **text segment**, contains the actual machine instructions that the CPU will execute. This is where your compiled functions live as binary code.

**Key Characteristics:**

The code section is **read-only** - the operating system marks these memory pages as non-writable. This is a security feature that prevents the program from accidentally (or maliciously) modifying its own instructions. If your program tries to write to the code section, the OS immediately terminates it with a segmentation fault.

The code section has a **fixed size** determined at compile time. Once your program is compiled, the amount of code doesn't change during execution.

The code section is **shareable** - if you run the same program multiple times, the OS can share a single copy of the code section between multiple processes to save memory.

**What's Inside?**

Let's examine what actually goes into the code section using our example:

c

````c
int add(int a, int b) {
    return a + b;
}

int main() {
    int x = 5;
    int result = add(10, x);
    return 0;
}
```

After compilation, the code section contains:
```
Code Section (.text) Memory Layout:

Address      Machine Code         Assembly           Original C
─────────────────────────────────────────────────────────────────
0x401126:    55                   push   rbp         
0x401127:    48 89 e5             mov    rbp, rsp    } int add(int a, int b) {
0x40112a:    89 7d fc             mov    [rbp-4], edi   (store parameter a)
0x40112d:    89 75 f8             mov    [rbp-8], esi   (store parameter b)
0x401130:    8b 55 fc             mov    edx, [rbp-4]   (load a)
0x401133:    8b 45 f8             mov    eax, [rbp-8]   (load b)
0x401136:    01 d0                add    eax, edx       return a + b;
0x401138:    5d                   pop    rbp         
0x401139:    c3                   ret                }

0x40113a:    55                   push   rbp         
0x40113b:    48 89 e5             mov    rbp, rsp    } int main() {
0x40113e:    48 83 ec 10          sub    rsp, 16       (allocate stack space)
0x401142:    c7 45 fc 05 00...    mov    [rbp-4], 5    int x = 5;
0x401149:    8b 75 fc             mov    esi, [rbp-4]  (load x as 2nd param)
0x40114c:    bf 0a 00 00 00       mov    edi, 10       (load 10 as 1st param)
0x401151:    e8 d0 ff ff ff       call   0x401126      result = add(10, x);
0x401156:    89 45 f8             mov    [rbp-8], eax  (store result)
0x401159:    b8 00 00 00 00       mov    eax, 0        return 0;
0x40115e:    c9                   leave              
0x40115f:    c3                   ret                }
```

**How the CPU Uses the Code Section:**

The **Program Counter (PC)** register (also called Instruction Pointer on x86) always points to the next instruction to execute. The CPU continuously:

1. Fetches the instruction at address PC
2. Decodes what operation it represents
3. Executes that operation
4. Increments PC to the next instruction
```
Instruction Execution Flow:

PC = 0x40113a  →  Fetch: 0x55 (push rbp)
                  Decode: Push base pointer
                  Execute: Stack operation
                  PC = 0x40113b

PC = 0x40113b  →  Fetch: 0x48 89 e5 (mov rbp, rsp)
                  Decode: Move stack pointer to base pointer
                  Execute: Register operation
                  PC = 0x40113e

... and so on ...
````

When you call a function like `add()`, the `call` instruction:

- Pushes the return address (next instruction after call) onto the stack
- Sets PC to the function's address (0x401126)
- Execution jumps to that location in the code section

### **The Data Sections - Where Variables Live**

Variables need storage, and depending on their type and initialization, they go into different sections.

#### **The .data Section - Initialized Global/Static Variables**

This section contains global and static variables that have **explicit initial values** defined in your code.

c

````c
// These go in .data section
int global_counter = 100;           // 4 bytes, value 100
char message[] = "Hello";           // 6 bytes: 'H','e','l','l','o','\0'
static double pi = 3.14159;         // 8 bytes, value 3.14159
int array[3] = {10, 20, 30};        // 12 bytes with values

// At compile time, these values are embedded in executable
```

**Memory Layout of .data Section:**
```
.data Section Memory Layout:

Address      Size    Variable            Value (Hexadecimal)
─────────────────────────────────────────────────────────────
0x404000:    4 bytes global_counter      64 00 00 00  (100 in little-endian)
0x404004:    6 bytes message             48 65 6C 6C 6F 00  ("Hello\0")
0x40400a:    8 bytes pi                  6E 86 1B F0 F9 21 09 40  (3.14159)
0x404012:    4 bytes array[0]            0A 00 00 00  (10)
0x404016:    4 bytes array[1]            14 00 00 00  (20)
0x40401a:    4 bytes array[2]            1E 00 00 00  (30)
````

**Key Points:**

- The .data section is **readable and writable** - your program can modify these variables during execution
- The section has a **fixed size** known at compile time
- The initial values are **stored in the executable file** itself
- When the program loads, these bytes are **copied from disk to RAM** exactly as they appear in the executable

**Example of Modifying .data:**

c

```c
global_counter = 100;  // Initial value from .data
// In memory: 0x404000 contains 0x00000064

global_counter++;      // Modify it
// Now memory: 0x404000 contains 0x00000065

global_counter = 500;  // Change again
// Now memory: 0x404000 contains 0x000001F4
```

The memory address stays the same (0x404000), but the value stored there changes.

#### **The .bss Section - Uninitialized Global/Static Variables**

BSS stands for "Block Started by Symbol" (historical name). This section contains global and static variables that are **declared but not explicitly initialized**, or initialized to zero.

c

````c
// These go in .bss section
int uninitialized_var;              // No initial value
static int zero_init = 0;           // Explicitly zero
char buffer[1024];                  // Large uninitialized array
static long numbers[100];           // Another uninitialized array
```

**Why Have a Separate .bss Section?**

This is a clever optimization! Instead of storing thousands of zeros in the executable file for large uninitialized arrays, the .bss section stores **only the size** information. When the program loads, the OS simply allocates the memory and zeros it out.
```
Consider this:
char buffer[1000000];  // 1 MB array

If this were in .data:
- Executable file size: +1 MB (all zeros stored)
- Disk space wasted: 1 MB
- Load time: Must read 1 MB of zeros from disk

In .bss:
- Executable file size: +8 bytes (just the size metadata)
- Disk space wasted: almost nothing
- Load time: OS zeros memory efficiently using fast CPU instructions
```

**Memory Layout of .bss Section:**
```
.bss Section Memory Layout (after OS zeros it):

Address      Size       Variable            Value
─────────────────────────────────────────────────────────
0x404100:    4 bytes    uninitialized_var   00 00 00 00  (0)
0x404104:    4 bytes    zero_init           00 00 00 00  (0)
0x404108:    1024 bytes buffer              00 00 00 ... (all zeros)
0x404508:    400 bytes  numbers             00 00 00 ... (all zeros)
```

**Key Differences Between .data and .bss:**
```
.data Section:
- Contains: Variables with non-zero initial values
- In executable: Values are stored
- At load time: Copied from disk to RAM
- Example: int x = 5;

.bss Section:
- Contains: Variables with zero or no initial value
- In executable: Only size information stored
- At load time: OS allocates and zeros memory
- Example: int x = 0; or int x;
````

### **Read-Only Data Section (.rodata)**

There's also a **read-only data section** for constants and literal strings:

c

````c
const int MAX_SIZE = 1000;          // .rodata
const char* greeting = "Hello";     // "Hello" string in .rodata
printf("Error: %d\n", error);       // "Error: %d\n" in .rodata
```

This section is marked read-only by the OS, similar to the code section. Trying to modify these values causes a segmentation fault.
```
.rodata Section Memory Layout:

Address      Data                    Description
────────────────────────────────────────────────────────
0x402000:    E8 03 00 00            MAX_SIZE = 1000
0x402004:    48 65 6C 6C 6F 00      "Hello\0"
0x40200a:    45 72 72 6F 72 ...     "Error: %d\n\0"
```

### **Complete Memory Layout of Sections**
```
Complete Static Memory Layout:

┌────────────────────────────────┐ 0x405000
│     .bss Section               │
│  (Uninitialized Data)          │
│  - Zero or no initial value    │
│  - Writable                    │
│  - Zeroed by OS at load        │
│  Examples:                     │
│    int uninit;                 │
│    char buffer[1024];          │
├────────────────────────────────┤ 0x404000
│     .data Section              │
│  (Initialized Data)            │
│  - Non-zero initial values     │
│  - Writable                    │
│  - Copied from executable      │
│  Examples:                     │
│    int counter = 10;           │
│    char msg[] = "Hi";          │
├────────────────────────────────┤ 0x402000
│     .rodata Section            │
│  (Read-Only Data)              │
│  - Constant strings/values     │
│  - Read-only                   │
│  Examples:                     │
│    const int MAX = 100;        │
│    "Hello World" strings       │
├────────────────────────────────┤ 0x401000
│     .text Section              │
│  (Code/Instructions)           │
│  - Machine code                │
│  - Read-only, executable       │
│  - Function definitions        │
│  Examples:                     │
│    main() instructions         │
│    add() instructions          │
└────────────────────────────────┘ 0x400000
````

---
