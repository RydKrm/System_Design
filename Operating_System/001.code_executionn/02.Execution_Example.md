# From Code to Process: A Deep Journey with a Real Example

Let me walk you through the **entire journey** using a concrete example - a simple C program. We'll follow this program from the moment you write it until it becomes a running process in memory.

## **Our Example Program**

Let's create a simple program that demonstrates all the concepts:

```c
// hello.c
#include <stdio.h>

// Global initialized variable (goes to .data section)
int counter = 10;

// Global uninitialized variable (goes to .bss section)
int result;

// Function definition (goes to .text section)
int add(int a, int b) {
    return a + b;
}

int main() {
    // Local variable (goes to stack)
    int x = 5;
    
    // Dynamic memory allocation (goes to heap)
    int *ptr = (int*)malloc(sizeof(int));
    *ptr = 20;
    
    // Function call
    result = add(counter, x);
    
    printf("Result: %d\n", result);
    printf("Pointer value: %d\n", *ptr);
    
    free(ptr);
    return 0;
}
```

Now let's follow this program through every stage!

---

## **Stage 1: Writing and Saving the Source Code**

You type this code in a text editor and save it as `hello.c`. At this point, it's just a text file on your hard disk.

```
Hard Disk:
┌─────────────────────────────┐
│  /home/user/hello.c         │
│  ─────────────────────      │
│  Plain text file            │
│  Size: ~450 bytes           │
│  Human-readable             │
│  CPU cannot execute this!   │
└─────────────────────────────┘
```

---

## **Stage 2: The Compilation Process in Detail**

Let's compile our program step by step:

```bash
gcc hello.c -o hello
```

But what really happens? Let's break it down:

### **Phase A: Preprocessing**

The preprocessor handles all directives starting with `#`:

```bash
gcc -E hello.c -o hello.i
```

**What happens:**

- `#include <stdio.h>` is replaced with the entire contents of stdio.h (thousands of lines!)
- All comments are removed
- Macros are expanded

**Before preprocessing:**

```c
#include <stdio.h>

int counter = 10;
// This is a comment
```

**After preprocessing (hello.i):**

```c
// ... thousands of lines from stdio.h ...
typedef struct _IO_FILE FILE;
extern FILE *stdin;
extern FILE *stdout;
// ... more from stdio.h ...

int counter = 10;

int add(int a, int b) {
    return a + b;
}
// ... rest of the code without comments
```

The file grows from ~450 bytes to over 17,000 bytes!

### **Phase B: Compilation to Assembly**

```bash
gcc -S hello.i -o hello.s
```

The compiler translates C code into assembly language:

**From C code:**

```c
int add(int a, int b) {
    return a + b;
}
```

**To Assembly (hello.s):**

```assembly
add:
    push    rbp                  ; Save base pointer
    mov     rbp, rsp             ; Set up stack frame
    mov     DWORD PTR [rbp-4], edi   ; Store parameter 'a'
    mov     DWORD PTR [rbp-8], esi   ; Store parameter 'b'
    mov     edx, DWORD PTR [rbp-4]   ; Load 'a' into edx
    mov     eax, DWORD PTR [rbp-8]   ; Load 'b' into eax
    add     eax, edx             ; Add them: eax = eax + edx
    pop     rbp                  ; Restore base pointer
    ret                          ; Return to caller

main:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 16              ; Allocate 16 bytes on stack
    mov     DWORD PTR [rbp-4], 5 ; x = 5
    mov     edi, 4               ; Prepare malloc argument
    call    malloc               ; Call malloc
    ; ... more assembly code ...
```

Assembly is still human-readable but much closer to machine code. Each instruction directly maps to a CPU operation.

### **Phase C: Assembly to Object Code**

```bash
gcc -c hello.s -o hello.o
```

The assembler converts assembly to binary machine code:

**Assembly instruction:**

```assembly
mov eax, 5
```

**Becomes machine code (in hello.o):**

```
B8 05 00 00 00  (hexadecimal)
10111000 00000101 00000000 00000000 00000000  (binary)
```

The object file `hello.o` now contains:

- Binary machine instructions
- Data for initialized variables
- Symbol table (function names, variable names)
- **BUT** - it has unresolved references!

```
Object File (hello.o):
┌─────────────────────────────────┐
│ Machine Code for add():         │
│ B8 05 00 00 00 ...              │
│                                 │
│ Machine Code for main():        │
│ 55 48 89 E5 ...                 │
│                                 │
│ Symbol Table:                   │
│ - add (defined here)            │
│ - main (defined here)           │
│ - printf (UNDEFINED - external!)│
│ - malloc (UNDEFINED - external!)│
│ - free (UNDEFINED - external!)  │
│                                 │
│ Data Section:                   │
│ counter: 0x0A (value 10)        │
└─────────────────────────────────┘
```

Notice `printf`, `malloc`, and `free` are **undefined** - we call them but they're in external libraries!

### **Phase D: Linking**

```bash
gcc hello.o -o hello
```

The linker resolves all external references and creates the final executable:

```
Linking Process:
┌─────────────┐     ┌──────────────┐     ┌─────────────┐
│  hello.o    │     │  libc.so     │     │   hello     │
│             │     │ (C library)  │     │ (executable)│
│ - add()     │     │              │     │             │
│ - main()    │ ──> │ - printf()   │ ──> │ Complete    │
│ - printf(?) │     │ - malloc()   │     │ program     │
│ - malloc(?) │     │ - free()     │     │ with all    │
│ - free(?)   │     │              │     │ references  │
│             │     │              │     │ resolved    │
└─────────────┘     └──────────────┘     └─────────────┘
```

The linker:

1. Combines your object file with library code
2. Resolves all "UNDEFINED" symbols by finding them in libraries
3. Assigns final memory addresses to all functions and variables
4. Creates the complete executable file

**Final executable structure (hello):**

```
Executable File (hello):
┌─────────────────────────────────────┐
│ ELF HEADER                          │
│ - Entry point: 0x401040 (main)     │
│ - Type: Executable                  │
│ - Architecture: x86-64              │
├─────────────────────────────────────┤
│ .text SECTION (Code)                │
│ Address: 0x401000                   │
│ - Machine code for add()            │
│ - Machine code for main()           │
│ - Jump instructions to printf()     │
│ Size: ~2 KB                         │
├─────────────────────────────────────┤
│ .data SECTION (Initialized Data)    │
│ Address: 0x404000                   │
│ - counter: 10 (0x0A)                │
│ Size: ~100 bytes                    │
├─────────────────────────────────────┤
│ .bss SECTION (Uninitialized)        │
│ Address: 0x404100                   │
│ - result: (no value yet)            │
│ Size: ~100 bytes                    │
├─────────────────────────────────────┤
│ DYNAMIC LINKING INFO                │
│ - Needs: libc.so.6                  │
│ - printf at: (to be resolved)       │
│ - malloc at: (to be resolved)       │
└─────────────────────────────────────┘

Total size: ~8-10 KB
```

---

## **Stage 3: The Executable on Disk**

Now we have `hello` - a complete executable program sitting on the hard disk:

```bash
$ ls -lh hello
-rwxr-xr-x 1 user user 8.5K Dec 4 10:30 hello
```

This is a **program** - passive, inactive, just sitting there. Let's see what's inside:

```bash
$ file hello
hello: ELF 64-bit LSB executable, x86-64

$ readelf -h hello
ELF Header:
  Entry point address: 0x401040
  
$ objdump -d hello | grep -A 10 "<add>:"
0000000000401126 <add>:
  401126: 55                    push   %rbp
  401127: 48 89 e5              mov    %rsp,%rbp
  40112a: 89 7d fc              mov    %edi,-0x4(%rbp)
  40112d: 89 75 f8              mov    %esi,-0x8(%rbp)
  401130: 8b 55 fc              mov    -0x4(%rbp),%edx
  401133: 8b 45 f8              mov    -0x8(%rbp),%eax
  401136: 01 d0                 add    %edx,%eax
  401138: 5d                    pop    %rbp
  401139: c3                    ret
```

The program exists, but nothing is happening. No CPU cycles, no memory used.

---

## **Stage 4: Execution - Creating the Process**

Now let's run it:

```bash
$ ./hello
```

**What happens in the next milliseconds is fascinating!**

### **Step 1: The Shell Creates a New Process**

When you press Enter, the shell (bash) makes a system call:

```c
// Simplified view of what bash does
pid_t pid = fork();  // Create a child process

if (pid == 0) {
    // Child process
    execve("./hello", argv, envp);  // Replace with our program
}
```

The OS creates a **new process** and assigns it a Process ID:

```
Operating System:
┌─────────────────────────────────┐
│ Creating new process...         │
│ PID: 12345                      │
│ Parent PID: 5678 (bash)         │
│ State: NEW                      │
└─────────────────────────────────┘
```

### **Step 2: The Loader Allocates Memory**

The OS loader examines our executable and allocates virtual memory:

```
Virtual Memory Space for Process 12345:
┌──────────────────────────┐ 0x7FFFFFFFFFFF (High)
│                          │
│        STACK             │ ← Will grow down
│     (Not allocated yet)  │
│                          │
├──────────────────────────┤ 0x7FFFF0000000
│                          │
│     (Empty space)        │
│                          │
├──────────────────────────┤ 0x600000000000
│         HEAP             │ ← Will grow up
│   (Initially empty)      │
├──────────────────────────┤ 0x404200
│    .bss SECTION          │ ← result = ???
│  (Uninitialized Data)    │
│  Will be zeroed out      │
├──────────────────────────┤ 0x404000
│    .data SECTION         │ ← counter = 10
│   (Initialized Data)     │
│  Copied from executable  │
├──────────────────────────┤ 0x401000
│    .text SECTION         │ ← Code for main(), add()
│   (Program Code)         │
│  Copied from executable  │
│     READ-ONLY            │
└──────────────────────────┘ 0x400000 (Low)
```

### **Step 3: Loading Sections into Memory**

The loader copies data from the executable file on disk into RAM:

```
From Disk to RAM:
┌─────────────────┐          ┌─────────────────┐
│  hello (disk)   │          │   RAM (Process) │
│                 │          │                 │
│ .text section   │ ─copy──> │ 0x401000: B8 05 │
│ (machine code)  │          │ 0x401005: 00 00 │
│                 │          │ ...             │
├─────────────────┤          ├─────────────────┤
│ .data section   │ ─copy──> │ 0x404000: 0A 00 │
│ counter = 10    │          │ (counter = 10)  │
│                 │          │                 │
├─────────────────┤          ├─────────────────┤
│ .bss section    │ ─zero──> │ 0x404100: 00 00 │
│ result (uninit) │          │ (result = 0)    │
└─────────────────┘          └─────────────────┘
```

### **Step 4: Dynamic Linking**

Since our program uses `printf`, `malloc`, and `free` from the C library, the loader must load `libc.so.6`:

```
Dynamic Linking:
┌──────────────────────────────────┐
│ Loading shared libraries...     │
│                                  │
│ libc.so.6 mapped to memory at:  │
│ 0x7FFFF7A00000                   │
│                                  │
│ Resolving symbols:               │
│ ✓ printf  → 0x7FFFF7A50000      │
│ ✓ malloc  → 0x7FFFF7A60000      │
│ ✓ free    → 0x7FFFF7A61000      │
└──────────────────────────────────┘
```

### **Step 5: Process Control Block (PCB) Creation**

The OS creates a PCB for our process:

```
Process Control Block (PCB) - PID 12345:
┌────────────────────────────────────────┐
│ Process ID: 12345                      │
│ Parent Process ID: 5678 (bash)         │
│ Process State: READY                   │
│ Priority: 20                           │
│ Program Counter: 0x401040 (main entry) │
│ CPU Registers: [All zeroed]            │
│                                        │
│ Memory Information:                    │
│ - Code segment: 0x401000-0x402000      │
│ - Data segment: 0x404000-0x404100      │
│ - BSS segment:  0x404100-0x404200      │
│ - Heap start:   0x600000000000         │
│ - Stack start:  0x7FFFFFFFFFFF         │
│                                        │
│ Open Files:                            │
│ - fd 0: stdin                          │
│ - fd 1: stdout                         │
│ - fd 2: stderr                         │
│                                        │
│ Accounting:                            │
│ - CPU time used: 0 ms                  │
│ - Start time: 10:30:45.123             │
└────────────────────────────────────────┘
```

### **Step 6: Initial Stack Setup**

The loader sets up the initial stack frame with command-line arguments and environment variables:

```
Initial Stack (grows downward):
┌──────────────────────────┐ 0x7FFFFFFFFFFF
│ Environment variables    │
│ HOME=/home/user          │
│ PATH=/usr/bin:...        │
├──────────────────────────┤
│ Command-line arguments   │
│ argc = 1                 │
│ argv[0] = "./hello"      │
│ argv[1] = NULL           │
├──────────────────────────┤
│ Return address: (exit)   │
├──────────────────────────┤ ← Stack Pointer (SP)
│    (ready for main)      │
└──────────────────────────┘
```

---

## **Stage 5: Execution - The Process Runs!**

The OS scheduler places our process in the READY state, and eventually it gets CPU time:

```
Process State Transition:
NEW → READY → RUNNING
```

### **Instruction Execution - Let's Follow the CPU!**

The Program Counter starts at `0x401040` (the entry point - our `main` function).

**Instruction 1:**

```
PC: 0x401040
Instruction: push rbp  (55)

What happens:
- CPU fetches byte 0x55 from memory address 0x401040
- Decodes it: "push base pointer to stack"
- Executes: Stack Pointer decreases, old rbp value saved
- PC increments to 0x401041
```

**Instruction 2:**

```
PC: 0x401041
Instruction: mov rbp, rsp  (48 89 E5)

What happens:
- Set up new stack frame
- rbp now points to current stack position
- PC increments to 0x401044
```

**Instructions 3-5: Allocate local variable `x = 5`**

```
PC: 0x401044
Instruction: sub rsp, 16  (48 83 EC 10)

What happens:
- Allocate 16 bytes on stack for local variables
- PC increments

PC: 0x401048
Instruction: mov DWORD PTR [rbp-4], 5

What happens:
- Store value 5 at location rbp-4
- This is our variable 'x'
```

**Memory state after `int x = 5;`:**

```
Stack (at rbp-4):
┌──────────────────────────┐
│ ...                      │
├──────────────────────────┤ ← rbp
│ old rbp value            │
├──────────────────────────┤ ← rbp-4
│ 0x00000005 (x = 5)       │
├──────────────────────────┤
│ ...                      │
└──────────────────────────┘
```

**Next: Dynamic memory allocation `malloc(sizeof(int))`**

```
PC: 0x401050
Instruction: mov edi, 4

What happens:
- Load argument 4 into edi register
- This is the size parameter for malloc

PC: 0x401055  
Instruction: call 0x7FFFF7A60000  (malloc)

What happens:
- Save return address on stack
- Jump to malloc function in libc
- malloc executes, allocates 4 bytes from heap
- Returns address in rax register, say 0x600000001000
```

**Heap after malloc:**

```
Heap:
┌──────────────────────────┐ 0x600000000000
│ Heap metadata            │
├──────────────────────────┤ 0x600000001000
│ 0x00000000 (4 bytes)     │ ← ptr points here
├──────────────────────────┤
│ (unallocated)            │
└──────────────────────────┘
```

**Next: Store value `*ptr = 20;`**

```
PC: 0x40105A
Instruction: mov DWORD PTR [rax], 20

What happens:
- rax contains 0x600000001000 (from malloc)
- Store value 20 at that address
```

**Updated heap:**

```
Heap:
┌──────────────────────────┐
│ Heap metadata            │
├──────────────────────────┤ 0x600000001000
│ 0x00000014 (20 decimal)  │ ← *ptr = 20
├──────────────────────────┤
│ (unallocated)            │
└──────────────────────────┘
```

**Next: Function call `result = add(counter, x);`**

```
PC: 0x401060
Instructions:
mov edi, DWORD PTR [0x404000]  ; Load counter (10) into edi
mov esi, DWORD PTR [rbp-4]     ; Load x (5) into esi
call 0x401126                   ; Call add function

Stack before call:
┌──────────────────────────┐
│ ...                      │
├──────────────────────────┤ ← SP
│ return address: 0x401068 │
├──────────────────────────┤
│ rbp of main              │
├──────────────────────────┤
│ x = 5                    │
└──────────────────────────┘

Inside add function:
PC: 0x401126
- push rbp
- mov rbp, rsp
- Parameters: edi=10, esi=5
- mov edx, edi      ; edx = 10
- mov eax, esi      ; eax = 5
- add eax, edx      ; eax = 15
- return (value in eax)

After return:
- PC back to 0x401068
- eax contains 15
- Store to result: mov [0x404100], eax
```

**Data section after function call:**

```
.data section:
┌──────────────────────────┐ 0x404000
│ counter: 0x0000000A (10) │
├──────────────────────────┤ 0x404100 (.bss)
│ result: 0x0000000F (15)  │
└──────────────────────────┘
```

**Next: Print statements**

```
PC: 0x401070
Instruction: lea rdi, [format_string]  ; "Result: %d\n"
            mov esi, DWORD PTR [0x404100]  ; result = 15
            call 0x7FFFF7A50000  ; printf

What happens:
- Jump to printf in libc
- printf accesses output buffer
- Makes system call to write to stdout
- "Result: 15" appears on your terminal!
```

**Complete Memory Layout During Execution:**

```
Full Process Memory Map (PID 12345):

┌──────────────────────────┐ 0x7FFFFFFFFFFF
│    STACK (active)        │
│  ┌────────────────────┐  │
│  │ Return address     │  │
│  │ Old rbp            │  │
│  │ x = 5             │  │ ← rbp, rsp
│  │ ptr = 0x60000...   │  │
│  └────────────────────┘  │
├──────────────────────────┤ 0x7FFFF7A00000
│   libc.so.6 (shared)     │
│  - printf()              │
│  - malloc()              │
│  - free()                │
├──────────────────────────┤ 0x600000001000
│    HEAP (active)         │
│  ┌────────────────────┐  │
│  │ *ptr = 20          │  │ ← Allocated by malloc
│  └────────────────────┘  │
├──────────────────────────┤ 0x404100
│    .bss section          │
│  result = 15             │
├──────────────────────────┤ 0x404000
│    .data section         │
│  counter = 10            │
├──────────────────────────┤ 0x401000
│    .text section         │
│  (Machine code)          │
│  - main() instructions   │
│  - add() instructions    │
└──────────────────────────┘ 0x400000
```

---

## **Stage 6: Process Termination**

After executing `free(ptr)` and reaching `return 0;`:

```
PC: 0x401090
Instruction: mov eax, 0    ; Return value
            leave          ; Restore stack
            ret            ; Return to OS

What happens:
- Return value (0) in eax register
- OS receives control
- Makes exit system call
```

The OS:

1. Marks process state as TERMINATED
2. Frees all allocated memory (stack, heap, code, data)
3. Closes all open file descriptors
4. Updates parent process (bash) that child finished
5. Removes PCB
6. Returns CPU to other processes

```
Final State:
┌──────────────────────────────────┐
│ Process 12345: TERMINATED        │
│ Exit code: 0 (success)           │
│ Total CPU time: 2 milliseconds   │
│ Memory freed: ~8 MB              │
│                                  │
│ Output produced:                 │
│ Result: 15                       │
│ Pointer value: 20                │
└──────────────────────────────────┘
```

Your terminal prompt returns, and the process is gone - it lived for just milliseconds!

---

## **Summary: From Code to Process with Our Example**

Let me trace the complete journey of our specific example:

**1. Source Code (hello.c):** 450 bytes of human-readable C code with variables and functions

**2. Preprocessed (hello.i):** ~17 KB after including stdio.h and expanding macros

**3. Assembly (hello.s):** Translated to assembly language instructions that humans can still read

**4. Object Code (hello.o):** Binary machine code with unresolved external references

**5. Executable (hello):** ~8.5 KB complete program with all references resolved

**6. Loading:** OS allocates ~8 MB virtual memory, copies code and data sections

**7. Process Creation:** PCB created, PID 12345 assigned, state changes NEW → READY → RUNNING

**8. Execution:**

- Stack: Holds local variable `x = 5`
- Heap: Holds dynamically allocated integer `*ptr = 20`
- Data: Holds initialized `counter = 10`
- BSS: Holds computed `result = 15`
- Text: CPU executes machine instructions

**9. Output:** "Result: 15" and "Pointer value: 20" appear on screen

**10. Termination:** Memory freed, PCB destroyed, resources returned to OS

This entire journey - from text to running process to termination - happens in milliseconds, yet involves intricate cooperation between your code, the compiler toolchain, the operating system, and the hardware. This is the magic of how computers bring code to life!