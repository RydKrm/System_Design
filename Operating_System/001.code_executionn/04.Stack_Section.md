## **Part 2: The Stack - Function Calls and Local Variables**

Now we enter the dynamic parts of memory - sections that grow and shrink during program execution. The stack is fascinating because it's the mechanism that makes function calls work.

### **What is the Stack?**

The stack is a **LIFO (Last In, First Out)** data structure used to manage function calls and local variables. Think of it like a stack of plates - you can only add or remove plates from the top.

**Why Do We Need a Stack?**

Consider this scenario:

c

````c
void functionC() {
    int c = 3;
    printf("C: %d\n", c);
}

void functionB() {
    int b = 2;
    functionC();
    printf("B: %d\n", b);
}

void functionA() {
    int a = 1;
    functionB();
    printf("A: %d\n", a);
}

int main() {
    functionA();
    return 0;
}
```

When main calls functionA, which calls functionB, which calls functionC, the program needs to:
1. Remember where to return after each function completes
2. Keep each function's local variables separate
3. Restore the previous function's context when returning

The stack solves all these problems elegantly!

### **Stack Pointers: The Dynamic Duo**

Two CPU registers work together to manage the stack:

**Stack Pointer (SP/RSP):**
- Points to the **current top** of the stack
- Changes constantly as data is pushed/popped
- Always points to the last item pushed

**Base Pointer (BP/RBP):**
- Points to the **base of the current function's stack frame**
- Provides a stable reference point for accessing local variables and parameters
- Stays constant throughout a function's execution
```
Stack Registers:

┌─────────────────────────┐ Lower Address
│                         │
│    Previous frames      │
│                         │
├─────────────────────────┤ ← RBP (Base Pointer)
│  Current function's     │    Stable reference point
│  stack frame            │    
│  - Local variables      │
│  - Saved registers      │
│  - Parameters           │
├─────────────────────────┤ ← RSP (Stack Pointer)
│    (Available space)    │    Moves up/down frequently
│                         │
└─────────────────────────┘ Higher Address
```

### **Stack Frames: One Per Function Call**

Each function call creates a **stack frame** (also called activation record) containing:

1. **Function parameters** - arguments passed to the function
2. **Return address** - where to continue after function returns
3. **Saved base pointer** - previous function's RBP value
4. **Local variables** - variables declared inside the function
5. **Saved registers** - any registers the function needs to preserve
```
Anatomy of a Stack Frame:

┌─────────────────────────┐ Lower Address
│   Parameters            │  (Pushed by caller)
│   - Parameter N         │
│   - ...                 │
│   - Parameter 1         │
├─────────────────────────┤
│   Return Address        │  (Pushed by CALL instruction)
├─────────────────────────┤
│   Old RBP               │  (Pushed by function prologue)
├─────────────────────────┤ ← RBP (points here)
│   Local Variable 1      │
│   Local Variable 2      │
│   ...                   │
│   Local Variable N      │
├─────────────────────────┤ ← RSP (points here)
│   (Next allocation)     │
└─────────────────────────┘ Higher Address
````

### **Deep Example: Stack in Action**

Let's trace the stack through a complete function call sequence:

c

````c
int add(int a, int b) {
    int result = a + b;
    return result;
}

int calculate(int x) {
    int y = 10;
    int sum = add(x, y);
    return sum;
}

int main() {
    int num = 5;
    int answer = calculate(num);
    return 0;
}
```

**Initial State - main() starts:**
```
Assembly prologue for main():
push rbp              ; Save old base pointer
mov rbp, rsp          ; Set new base pointer
sub rsp, 16           ; Allocate 16 bytes for local variables
```
```
Stack State After main() Prologue:

Address      Content              Description
─────────────────────────────────────────────────────────
0x7FFF8000   [Return to OS]       Return address from main
0x7FFF7FF8   [Old RBP]            Saved base pointer
0x7FFF7FF0   ???                  Space for 'num' ← RBP points here
0x7FFF7FE8   ???                  Space for 'answer' ← RSP points here
```

**Step 1: Assign `num = 5`:**
```
mov DWORD PTR [rbp-8], 5

Stack:
Address      Content              
─────────────────────────────────
0x7FFF8000   [Return to OS]      
0x7FFF7FF8   [Old RBP]           ← RBP
0x7FFF7FF0   0x00000005          num = 5
0x7FFF7FE8   ???                 ← RSP
```

**Step 2: Prepare to call `calculate(num)`:**
```
mov edi, DWORD PTR [rbp-8]   ; Load num (5) into edi register
call calculate                ; Push return address and jump
```

The CALL instruction automatically:
1. Pushes the return address (next instruction) onto stack
2. Jumps to calculate's first instruction
```
Stack After CALL:
Address      Content                  Description
─────────────────────────────────────────────────────────
0x7FFF8000   [Return to OS]          
0x7FFF7FF8   [Old RBP from OS]       
0x7FFF7FF0   0x00000005              main's num
0x7FFF7FE8   ???                     main's answer space
0x7FFF7FE0   0x00401150              Return address ← RSP
                                     (back to main)
Parameters: edi = 5 (the value of x)
```

**Step 3: Enter `calculate()` function:**
```
calculate() prologue:
push rbp              ; Save main's RBP
mov rbp, rsp          ; Set calculate's base pointer
sub rsp, 16           ; Allocate space for local variables
```
```
Stack After calculate() Prologue:
Address      Content                  Description
─────────────────────────────────────────────────────────
0x7FFF8000   [Return to OS]          
0x7FFF7FF8   [Old RBP from OS]       
0x7FFF7FF0   0x00000005              main's num
0x7FFF7FE8   ???                     main's answer
0x7FFF7FE0   0x00401150              Return to main
0x7FFF7FD8   0x7FFF7FF8              Saved main's RBP ← RBP
0x7FFF7FD0   ???                     Space for 'y'
0x7FFF7FC8   ???                     Space for 'sum' ← RSP
```

**Step 4: Assign `y = 10` in calculate():**
```
mov DWORD PTR [rbp-8], 10

Stack:
Address      Content                  
─────────────────────────────────────
0x7FFF7FE0   0x00401150              Return to main
0x7FFF7FD8   0x7FFF7FF8              Saved RBP ← RBP
0x7FFF7FD0   0x0000000A              y = 10
0x7FFF7FC8   ???                     sum (not yet set) ← RSP

Note: x is in edi register (value 5), not on stack
```

**Step 5: Prepare to call `add(x, y)`:**
```
mov esi, DWORD PTR [rbp-8]   ; Load y (10) into esi
mov edi, [already has x=5]    ; x already in edi
call add                      ; Call add function
```
```
Stack After CALL add:
Address      Content                  Description
─────────────────────────────────────────────────────────
0x7FFF7FE0   0x00401150              Return to main
0x7FFF7FD8   0x7FFF7FF8              calculate's saved RBP
0x7FFF7FD0   0x0000000A              calculate's y
0x7FFF7FC8   ???                     calculate's sum
0x7FFF7FC0   0x00401165              Return to calculate ← RSP

Parameters: edi = 5 (a), esi = 10 (b)
```

**Step 6: Enter `add()` function:**
```
add() prologue:
push rbp
mov rbp, rsp
sub rsp, 16
```
```
Stack After add() Prologue:
Address      Content                  Description
─────────────────────────────────────────────────────────
0x7FFF7FE0   0x00401150              Return to main
0x7FFF7FD8   0x7FFF7FF8              calculate's saved RBP
0x7FFF7FD0   0x0000000A              calculate's y
0x7FFF7FC8   ???                     calculate's sum
0x7FFF7FC0   0x00401165              Return to calculate
0x7FFF7FB8   0x7FFF7FD8              Saved calculate's RBP ← RBP
0x7FFF7FB0   ???                     Space for 'result' ← RSP

Parameters: edi = 5 (a), esi = 10 (b)
```

**Step 7: Execute `result = a + b` in add():**
```
mov edx, edi          ; edx = 5 (a)
mov eax, esi          ; eax = 10 (b)
add eax, edx          ; eax = 15
mov [rbp-8], eax      ; result = 15
```
```
Stack:
Address      Content                  
─────────────────────────────────────
0x7FFF7FC0   0x00401165              Return to calculate
0x7FFF7FB8   0x7FFF7FD8              Saved RBP ← RBP
0x7FFF7FB0   0x0000000F              result = 15 ← RSP
```

**Step 8: Return from `add()`:**
```
add() epilogue:
mov eax, [rbp-8]      ; Load result (15) into eax (return value register)
leave                 ; Equivalent to: mov rsp, rbp; pop rbp
ret                   ; Pop return address and jump there
```

The LEAVE instruction:
1. Moves RSP to RBP (deallocates local variables)
2. Pops the old RBP value from stack

The RET instruction:
1. Pops the return address from stack
2. Jumps to that address
```
Stack After Returning from add():
Address      Content                  Description
─────────────────────────────────────────────────────────
0x7FFF7FE0   0x00401150              Return to main
0x7FFF7FD8   0x7FFF7FF8              calculate's saved RBP ← RBP
0x7FFF7FD0   0x0000000A              calculate's y
0x7FFF7FC8   ???                     calculate's sum ← RSP

Return value in eax = 15
```

**Step 9: Store return value in `sum`:**
```
mov [rbp-16], eax     ; sum = 15 (from eax)

Stack:
Address      Content                  
─────────────────────────────────────
0x7FFF7FE0   0x00401150              Return to main
0x7FFF7FD8   0x7FFF7FF8              Saved RBP ← RBP
0x7FFF7FD0   0x0000000A              y = 10
0x7FFF7FC8   0x0000000F              sum = 15 ← RSP
```

**Step 10: Return from `calculate()`:**
```
calculate() epilogue:
mov eax, [rbp-16]     ; Load sum (15) into eax
leave                 ; Restore calculate's stack frame
ret                   ; Return to main
```
```
Stack After Returning from calculate():
Address      Content                  Description
─────────────────────────────────────────────────────────
0x7FFF8000   [Return to OS]          
0x7FFF7FF8   [Old RBP from OS]       ← RBP (restored)
0x7FFF7FF0   0x00000005              main's num
0x7FFF7FE8   ???                     main's answer ← RSP

Return value in eax = 15
```

**Step 11: Store return value in `answer`:**
```
mov [rbp-16], eax     ; answer = 15

Final Stack in main():
Address      Content                  
─────────────────────────────────────
0x7FFF8000   [Return to OS]          
0x7FFF7FF8   [Old RBP from OS]       ← RBP
0x7FFF7FF0   0x00000005              num = 5
0x7FFF7FE8   0x0000000F              answer = 15 ← RSP
```

### **Stack Growth and Shrinkage**

The stack **grows downward** (toward lower memory addresses) and **shrinks upward** (toward higher memory addresses):
```
Stack Growth Pattern:

Initial (empty):
┌─────────────────┐ 0x7FFFFFFFF (High)
│                 │
│   Available     │
│                 │
└─────────────────┘ ← RSP

After push operations (grows DOWN):
┌─────────────────┐ 0x7FFFFFFFF
│   Available     │
├─────────────────┤
│   Data 3        │
├─────────────────┤
│   Data 2        │
├─────────────────┤
│   Data 1        │ ← RSP (moved down)
├─────────────────┤
│                 │
└─────────────────┘ Lower Address

After pop operations (shrinks UP):
┌─────────────────┐ 0x7FFFFFFFF
│   Available     │
├─────────────────┤
│   Data 3        │ ← RSP (moved up)
├─────────────────┤
│   (deallocated) │
├─────────────────┤
│   (deallocated) │
└─────────────────┘
```

**Stack Operations:**
```
PUSH operation (grows stack):
1. Decrement RSP (move down)
2. Write data at RSP

Example:
push rax
; Equivalent to:
sub rsp, 8        ; Move stack pointer down 8 bytes
mov [rsp], rax    ; Write rax value at new top

POP operation (shrinks stack):
1. Read data from RSP
2. Increment RSP (move up)

Example:
pop rax
; Equivalent to:
mov rax, [rsp]    ; Read value at top
add rsp, 8        ; Move stack pointer up 8 bytes
```

### **How RBP and RSP Work Together**

**During Function Execution:**

RBP acts as an **anchor point** - a fixed reference to access all local variables and parameters using constant offsets:
```
Accessing Variables Using RBP:

Function has:
- Parameter 'a' at [rbp+16]
- Parameter 'b' at [rbp+24]
- Local 'x' at [rbp-8]
- Local 'y' at [rbp-16]

┌─────────────────┐ Higher Address
│  Parameter b    │ RBP + 24
├─────────────────┤
│  Parameter a    │ RBP + 16
├─────────────────┤
│  Return address │ RBP + 8
├─────────────────┤
│  Old RBP        │ RBP (base pointer points here)
├─────────────────┤
│  Local x        │ RBP - 8
├─────────────────┤
│  Local y        │ RBP - 16
└─────────────────┘ ← RSP (stack pointer)

To access x: mov eax, [rbp-8]
To access y: mov ebx, [rbp-16]
To access a: mov ecx, [rbp+16]

Offsets are CONSTANT throughout function!
````

RSP moves frequently but RBP stays fixed, making variable access predictable and easy for the compiler to manage.

### **Stack Overflow**

What happens if the stack grows too much?

c

````c
void recursive() {
    int data[1000];     // Allocate 4KB per call
    recursive();        // Infinite recursion!
}
```

Each call adds a new stack frame. Eventually:
```
Stack Overflow:

┌─────────────────┐ 0x7FFFFFFFF (Stack start)
│   Frame 1       │
├─────────────────┤
│   Frame 2       │
├─────────────────┤
│   ...           │
├─────────────────┤
│   Frame 10000   │
├─────────────────┤ ← RSP tries to go below...
│─────────────────│ ← Stack limit! (e.g., 0x7FFF000000)
│                 │
│   GUARD PAGE    │ ← OS detects write here
│                 │
└─────────────────┘

Result: SEGMENTATION FAULT - Stack overflow!
````

The OS places a **guard page** below the stack. Any access to this page triggers a segmentation fault, protecting other memory regions.

--- 
