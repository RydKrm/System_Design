## **Part 3: The Heap - Dynamic Memory**

Now let's explore the heap - a completely different beast from the stack.

### **Why Do We Need Heap Memory?**

The stack has severe limitations:

**1. Fixed Size at Compile Time:**

c

```c
// Stack allocation - size must be known at compile time
int array[100];     // OK - compiler knows size
int n = get_user_input();
int array[n];       // Not allowed in C (allowed in C99 as VLA, but limited)
```

**2. Lifetime Tied to Function Scope:**

c

```c
int* create_array() {
    int local_array[100];    // On stack
    return local_array;      // DANGER! Returning pointer to dead stack memory!
}
// When function returns, stack frame is destroyed!
// Pointer now points to invalid memory!
```

**3. Limited Total Size:**

c

````c
void function() {
    int huge[10000000];      // 40 MB on stack
    // STACK OVERFLOW! Stack typically only 1-8 MB total
}
```

The heap solves all these problems by providing:
- **Dynamic allocation** - size determined at runtime
- **Flexible lifetime** - memory lives until explicitly freed
- **Large size** - heap can grow to gigabytes

### **What is the Heap?**

The heap is a large region of memory managed by the **memory allocator** (part of the C library). Unlike the stack's automatic management, heap memory requires **explicit allocation and deallocation**.
```
Heap vs Stack Comparison:

STACK:
- Automatic allocation (declaring variables)
- Automatic deallocation (function returns)
- Fast (just move stack pointer)
- Limited size (~1-8 MB)
- LIFO order
- Fixed size at compile time

HEAP:
- Manual allocation (malloc, new)
- Manual deallocation (free, delete)
- Slower (complex allocator algorithms)
- Large size (GBs available)
- Any order
- Size determined at runtime
````


**How Heap Memory Works**

**Basic Heap Operations:**

```c
// Allocate memory
int* ptr = (int*)malloc(sizeof(int) * 100);  // 400 bytes

// Use the memory
ptr[0] = 10;
ptr[1] = 20;

// Free the memory when done
free(ptr);
```

**What Happens During `malloc(400)`:**

```
Step-by-Step malloc Execution:

1. Program calls malloc(400)
   ↓
2. malloc searches its free list for suitable block
   ↓
3. Finds block (or requests more memory from OS)
   ↓
4. Splits block if necessary
   ↓
5. Marks block as "in use"
   ↓
6. Returns pointer to usable memory
```

### **Heap Memory Structure**

The heap uses **metadata** to track allocations:

```
Heap Block Structure:

┌─────────────────────────┐
│  METADATA (Header)      │
│  - Size: 400 bytes      │
│  - Status: IN_USE       │
│  - Magic number         │
│  - Prev block pointer   │
│  - Next block pointer   │
├─────────────────────────┤ ← malloc returns THIS address
│                         │
│  USER DATA              │
│  (400 bytes requested)  │
│                         │
├─────────────────────────┤
│  METADATA (Footer)      │
│  - Size (duplicate)     │
└─────────────────────────┘
```

**Complete Heap Layout Example:**

```c
int* a = (int*)malloc(16);     // Allocate 16 bytes
int* b = (int*)malloc(32);     // Allocate 32 bytes
free(a);                        // Free first allocation
int* c = (int*)malloc(8);      // Allocate 8 bytes
```

```
Heap State After Each Operation:

After malloc(16):
┌─────────────────────────┐ 0x600000000000 (Heap start)
│ Header: size=16, used   │
├─────────────────────────┤ 0x600000000010 ← 'a' points here
│ [16 bytes for user]     │
├─────────────────────────┤ 0x600000000020
│ Footer: size=16         │
├─────────────────────────┤
│ Header: free, size=...  │ (Rest of heap)
└─────────────────────────┘

After malloc(32):
┌─────────────────────────┐
│ Header: size=16, used   │
├─────────────────────────┤ ← 'a'
│ [16 bytes]              │
├─────────────────────────┤
│ Footer: size=16         │
├─────────────────────────┤
│ Header: size=32, used   │
├─────────────────────────┤ ← 'b' points here
│ [32 bytes for user]     │
├─────────────────────────┤
│ Footer: size=32         │
├─────────────────────────┤
│ Header: free, size=...  │
└─────────────────────────┘

After free(a):
┌─────────────────────────┐
│ Header: size=16, FREE   │ ← Block marked free!
├─────────────────────────┤
│ [16 bytes available]    │
├─────────────────────────┤
│ Footer: size=16         │
├─────────────────────────┤
│ Header: size=32, used   │
├─────────────────────────┤ ← 'b' still valid
│ [32 bytes]              │
├─────────────────────────┤
│ Footer: size=32         │
├─────────────────────────┤
│ Header: free, size=...  │
└─────────────────────────┘

After malloc(8):
┌─────────────────────────┐
│ Header: size=8, used    │ ← Reused freed block!
├─────────────────────────┤ ← 'c' points here
│ [8 bytes for user]      │
├─────────────────────────┤
│ Header: size=8, FREE    │ ← Split remainder
├─────────────────────────┤
│ [8 bytes available]     │
├─────────────────────────┤
│ Footer: size=8          │
├─────────────────────────┤
│ Header: size=32, used   │
├─────────────────────────┤ ← 'b'
│ [32 bytes]              │
└─────────────────────────┘
```

### **Heap Allocation Strategies**

Memory allocators use different strategies to find free blocks:

**First Fit:**

```
Find the FIRST free block large enough

Free List: [16 bytes free] → [32 bytes free] → [64 bytes free]
malloc(20) finds first block ≥ 20 bytes
Result: Uses the 32-byte block
```

**Best Fit:**

```
Find the SMALLEST free block that fits

Free List: [16 bytes] → [32 bytes] → [64 bytes]
malloc(20) finds smallest block ≥ 20 bytes
Result: Uses the 32-byte block (best fit)
```

**Worst Fit:**

```
Find the LARGEST free block

Free List: [16 bytes] → [32 bytes] → [64 bytes]
malloc(20) uses largest block
Result: Uses 64-byte block, leaves 44 bytes free
```

### **Heap Growth**

When the heap runs out of space, the allocator requests more memory from the OS:

```
Heap Growth Process:

Initial heap:
┌─────────────────┐ 0x600000100000 (Heap end)
│  All allocated  │
│  No free space  │
└─────────────────┘ 0x600000000000 (Heap start)

malloc(1000) called, but no space!
↓
Allocator calls sbrk() or mmap() system call
↓
OS extends heap:

┌─────────────────┐ 0x600000200000 (New heap end)
│  New free space │ ← 1 MB added
│  Available      │
├─────────────────┤ 0x600000100000 (Old end)
│  All allocated  │
└─────────────────┘ 0x600000000000
```

---

## **Part 4: Heap Memory Problems**

The heap's manual management creates numerous potential problems. Let's explore each one deeply.

### **Problem 1: Memory Leaks**

**What is a Memory Leak?**

A memory leak occurs when you allocate heap memory but lose all pointers to it without freeing it. The memory becomes **unreachable and unfreeable** - it's lost forever until the program terminates.

```c
void memory_leak_example() {
    int* ptr = (int*)malloc(1000 * sizeof(int));  // Allocate 4000 bytes
    
    // Use the memory
    ptr[0] = 10;
    
    // Function returns WITHOUT calling free(ptr)
    // The pointer 'ptr' is destroyed, but the heap memory remains allocated!
}

int main() {
    for (int i = 0; i < 1000; i++) {
        memory_leak_example();  // Leaks 4000 bytes each iteration!
    }
    // Total leak: 4 MB!
}
```

**Visualization of Memory Leak:**

```
Heap State Over Time:

Iteration 1:
┌─────────────────────┐
│ Allocated: 4000 bytes│ ← No pointer to this!
├─────────────────────┤
│ Free space          │
└─────────────────────┘

Iteration 2:
┌─────────────────────┐
│ Leaked: 4000 bytes  │ ← Lost forever
├─────────────────────┤
│ Allocated: 4000 bytes│ ← No pointer to this either!
├─────────────────────┤
│ Free space          │
└─────────────────────┘

Iteration 1000:
┌─────────────────────┐
│ Leaked: 4000 bytes  │
│ Leaked: 4000 bytes  │
│ Leaked: 4000 bytes  │
│ ... 1000 times ...  │ ← 4 MB of unusable memory!
├─────────────────────┤
│ Free space (little) │
└─────────────────────┘

Eventually: OUT OF MEMORY!
```

**Common Memory Leak Patterns:**

```c
// Pattern 1: Reassigning pointer
int* ptr = (int*)malloc(100);
ptr = (int*)malloc(200);    // LEAK! Lost first allocation

// Pattern 2: Losing pointer in struct
struct Node {
    int* data;
};
struct Node node;
node.data = (int*)malloc(100);
// If node goes out of scope without freeing data → LEAK

// Pattern 3: Exception/early return
int* ptr = (int*)malloc(100);
if (error_condition) {
    return;    // LEAK! Forgot to free before return
}
free(ptr);     // This line never executes
```

**Real-World Impact:**

Long-running programs (servers, databases) with memory leaks will:

1. Gradually consume more and more RAM
2. Slow down due to memory pressure
3. Eventually crash with "Out of Memory" errors
4. Force system administrators to restart them periodically

### **Problem 2: Dangling Pointers (Use-After-Free)**

**What is a Dangling Pointer?**

A dangling pointer points to memory that has been freed. Accessing this memory is **undefined behavior** - anything can happen!

```c
int* ptr = (int*)malloc(sizeof(int));
*ptr = 42;
free(ptr);       // Memory freed

*ptr = 100;      // DANGER! Writing to freed memory
int x = *ptr;    // DANGER! Reading freed memory
```

**Why is This Dangerous?**

```
After free(ptr), the memory might be:

Scenario 1 - Reallocated to someone else:
┌─────────────────────┐
│ Your freed memory   │
│ NOW being used by   │
│ another allocation! │
└─────────────────────┘ ← ptr still points here

*ptr = 100;  // Corrupts someone else's data!

Scenario 2 - Returned to OS:
┌─────────────────────┐
│ Memory unmapped     │
│ Not in your process │
│ anymore!            │
└─────────────────────┘ ← ptr points to invalid address

*ptr = 100;  // SEGMENTATION FAULT!

Scenario 3 - Still "appears" to work:
┌─────────────────────┐
│ Freed but not yet   │
│ overwritten         │
│ Old value: 42       │
└─────────────────────┘

int x = *ptr;  // Might still read 42!
               // BUG is hidden, appears later!
```

**Real Example:**

```c
struct User {
    char name[50];
    int age;
};

struct User* create_user(const char* name, int age) {
    struct User* user = (struct User*)malloc(sizeof(struct User));
    strcpy(user->name, name);
    user->age = age;
    return user;
}

void dangerous_code() {
    struct User* alice = create_user("Alice", 30);
    printf("Name: %s\n", alice->name);  // OK
    
    free(alice);  // Free the memory
    
    // Much later in the code...
    printf("Name: %s\n", alice->name);  // DANGER! Dangling pointer
    
    // Even worse:
    alice->age = 40;  // Might corrupt other data!
}
```

**Timeline of Corruption:**

```
Time T1:
┌─────────────────────┐ 0x600000001000
│ User struct         │
│ name: "Alice"       │
│ age: 30             │
└─────────────────────┘ ← alice points here (VALID)

Time T2 (after free):
┌─────────────────────┐ 0x600000001000
│ Freed memory        │
│ (data still there)  │
└─────────────────────┘ ← alice points here (DANGLING!)

Time T3 (memory reused):
┌─────────────────────┐ 0x600000001000
│ DIFFERENT data now! │
│ name: "x\x9a\x..."  │ ← Garbage
│ age: 2847593        │ ← Random value
└─────────────────────┘ ← alice points here (CORRUPTED!)

printf(alice->name);  // Prints garbage or crashes!
```

### **Problem 3: Double Free**

**What is Double Free?**

Freeing the same memory twice corrupts the heap's internal data structures.

```c
int* ptr = (int*)malloc(100);
free(ptr);    // First free - OK
free(ptr);    // Second free - CORRUPTION!
```

**Why is This Catastrophic?**

```
Heap Internal Structure:

After malloc(100):
┌─────────────────────────┐
│ Header: IN_USE, size=100│
├─────────────────────────┤ ← ptr
│ [100 bytes user data]   │
├─────────────────────────┤
│ Footer: IN_USE, size=100│
└─────────────────────────┘

After first free(ptr):
┌─────────────────────────┐
│ Header: FREE, size=100  │
│ next_free → (link)      │ ← Added to free list
├─────────────────────────┤
│ [100 bytes available]   │
├─────────────────────────┤
│ Footer: FREE, size=100  │
└─────────────────────────┘

After second free(ptr):
Heap allocator tries to free already-free block!
- Corrupts free list pointers
- May create circular references
- Breaks heap's internal consistency

Next malloc may:
- Return invalid addresses
- Crash with assertion failure
- Cause arbitrary code execution (security vulnerability!)
```

**Real-World Example:**

```c
void complex_free_logic(int* ptr, int condition) {
    if (condition > 10) {
        free(ptr);    // Free here
    }
    
    // ... lots of code ...
    
    if (condition > 5) {
        free(ptr);    // Might free again! DOUBLE FREE!
    }
}
```

### **Problem 4: Heap Fragmentation**

**What is Fragmentation?**

Even though total free memory is sufficient, allocations fail because free memory is **scattered in small chunks**.

```c
// Create fragmentation
int* a = (int*)malloc(100);
int* b = (int*)malloc(100);
int* c = (int*)malloc(100);
int* d = (int*)malloc(100);

free(b);  // Free middle block
free(d);  // Free another middle block

// Now try to allocate 200 bytes
int* big = (int*)malloc(200);  // Might FAIL!
```

**Fragmentation Visualization:**

```
Initial State:
┌──────┬──────┬──────┬──────┐
│  a   │  b   │  c   │  d   │ Each 100 bytes
│ 100  │ 100  │ 100  │ 100  │
└──────┴──────┴──────┴──────┘

After free(b) and free(d):
┌──────┬──────┬──────┬──────┐
│  a   │ FREE │  c   │ FREE │
│ 100  │ 100  │ 100  │ 100  │
└──────┴──────┴──────┴──────┘
        ↑             ↑
        └─────────────┘
        Total free: 200 bytes

malloc(200) FAILS because:
- Need contiguous 200 bytes
- Have two separate 100-byte chunks
- Cannot combine non-adjacent blocks!

Memory Layout:
┌──────┐
│  a   │ 100 bytes used
├──────┤
│ FREE │ 100 bytes free ← Too small
├──────┤
│  c   │ 100 bytes used ← Blocks the gap
├──────┤
│ FREE │ 100 bytes free ← Too small
└──────┘

Total: 200 bytes free, but cannot allocate 200 contiguous bytes!
```

**Types of Fragmentation:**

```
External Fragmentation:
Free memory exists but in unusable chunks
┌────┬──┬────┬──┬────┬──┐
│Used│Fr│Used│Fr│Used│Fr│
└────┴──┴────┴──┴────┴──┘
     Small gaps everywhere

Internal Fragmentation:
Allocated more than needed, wasted space inside blocks
Request: 100 bytes
Allocated: 128 bytes (allocator rounds up)
Wasted: 28 bytes

┌─────────────────────┐
│ Used: 100 bytes     │
├─────────────────────┤
│ Wasted: 28 bytes    │ ← Internal fragmentation
└─────────────────────┘
```

### **Problem 5: Buffer Overflow on Heap**

**What is Heap Buffer Overflow?**

Writing beyond allocated memory boundaries corrupts adjacent heap structures.

```c
int* array = (int*)malloc(10 * sizeof(int));  // 40 bytes

// Write beyond bounds
array[10] = 999;   // ERROR! Writing to 41st-44th byte
array[100] = 999;  // DISASTER! Writing far beyond
```

**Heap Corruption:**

```
Heap Layout:
┌─────────────────────────┐ Block 1
│ Header: size=40, used   │
├─────────────────────────┤ ← array points here
│ array[0]                │
│ array[1]                │
│ ...                     │
│ array[9]                │ ← Last valid element
├─────────────────────────┤
│ Footer: size=40         │
├─────────────────────────┤ Block 2
│ Header: size=?, used    │ ← Next block's header
├─────────────────────────┤
│ Someone else's data     │
└─────────────────────────┘

array[10] = 999; // Writes HERE! ↓
├─────────────────────────┤
│ Footer: CORRUPTED!      │ ← Overwrites footer
├─────────────────────────┤
│ Header: CORRUPTED!      │ ← Corrupts next block's header!
└─────────────────────────┘

Results:
- Heap allocator reads corrupted metadata
- Future malloc/free operations crash
- Security vulnerability (can be exploited!)
```

### **Problem 6: Memory Allocation Failures**

**What if malloc Returns NULL?**

When the heap is exhausted, `malloc` returns NULL. Many programmers forget to check!

```c
// Dangerous code - no NULL check
int* ptr = (int*)malloc(1000000000);  // Request 1 GB
*ptr = 42;  // If malloc failed, this is NULL dereference → CRASH!

// Correct code - check for NULL
int* ptr = (int*)malloc(1000000000);
if (ptr == NULL) {
    fprintf(stderr, "Out of memory!\n");
    // Handle error gracefully
    return -1;
}
*ptr = 42;  // Safe
```

---

## **Summary: Complete Memory Picture**

Let's put everything together:

```
Complete Process Memory Layout:

┌─────────────────────────────┐ 0x7FFFFFFFFFFF (High Address)
│                             │
│         STACK               │ ↓ Grows DOWN
│  - Function calls           │   LIFO structure
│  - Local variables          │   Automatic management
│  - Return addresses         │   Fast allocation
│  - RBP/RSP pointers         │   Limited size (~8 MB)
│                             │
├─────────────────────────────┤
│      (Unused space)         │ ← Gap between stack and heap
├─────────────────────────────┤
│                             │
│         HEAP                │ ↑ Grows UP
│  - malloc allocations       │   Manual management
│  - Dynamic size             │   Slower allocation
│  - Large capacity (GBs)     │   Flexible lifetime
│  - Fragmentation prone      │   Needs free()
│                             │
├─────────────────────────────┤ 0x600000000000
│     .bss Section            │
│  - Uninitialized globals    │   Zeroed by OS
│  - Static variables = 0     │   Size known at compile
│  Example: int buffer[1024]; │
│                             │
├─────────────────────────────┤ 0x404000
│     .data Section           │
│  - Initialized globals      │   Values in executable
│  - Static with values       │   Writable
│  Example: int count = 10;   │
│                             │
├─────────────────────────────┤ 0x402000
│     .rodata Section         │
│  - Constant data            │   Read-only
│  - String literals          │   Shared
│  Example: "Hello World"     │
│                             │
├─────────────────────────────┤ 0x401000
│     .text Section           │
│  - Machine instructions     │   Read-only, executable
│  - Function code            │   Shared between processes
│  - PC points here           │   CPU fetches from here
│                             │
└─────────────────────────────┘ 0x400000 (Low Address)
```

**Memory Management Comparison:**

```
╔══════════════════════════════════════════════════════════════╗
║  Feature    │    Stack      │    Heap      │  .data/.bss     ║
╠══════════════════════════════════════════════════════════════╣
║ Allocation  │  Automatic    │   Manual     │  Static         ║
║ Lifetime    │  Function     │   Explicit   │  Program        ║
║ Speed       │  Very Fast    │   Slower     │  N/A            ║
║ Size        │  Limited      │   Large      │  Fixed          ║
║ Growth      │  Downward     │   Upward     │  None           ║
║ Fragmentation│  No          │   Yes        │  No             ║
║ Management  │  Compiler     │   Programmer │  Loader         ║
╚══════════════════════════════════════════════════════════════╝
```

Understanding these memory sections and how they work together is fundamental to writing efficient, correct, and secure programs!