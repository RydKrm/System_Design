# Socket Communication Mastery: A Developer's Complete Guide to Real-Time Communication in Node.js with TypeScript

## Table of Contents
1. [Introduction: The World of Real-Time Communication](#introduction)
2. [Understanding Sockets: The Foundation](#understanding-sockets)
3. [TCP Sockets: Building Reliable Connections](#tcp-sockets)
4. [WebSockets: Bridging the Browser Gap](#websockets)
5. [Socket.IO: The Swiss Army Knife](#socketio)
6. [Advanced Patterns: Production-Ready Solutions](#advanced-patterns)
7. [Best Practices: Lessons from the Trenches](#best-practices)

---

## Introduction: The World of Real-Time Communication {#introduction}

Imagine you're building the next big chat application, a real-time gaming platform, or a live dashboard that updates stock prices every millisecond. How do you make your application respond instantly to changes? How do you push data from your server to clients without them constantly asking, "Any updates? Any updates?" 

Welcome to the world of socket programming‚Äîthe backbone of real-time communication in modern applications.

### What You'll Learn

In this comprehensive guide, we'll journey from the fundamental concepts of network communication to building production-ready, scalable socket applications. Think of this as your mentor sitting beside you, explaining not just the "how" but the "why" behind every decision.

**By the end of this guide, you'll be able to:**
- Understand the difference between HTTP requests and socket connections
- Build TCP servers that can handle thousands of concurrent connections
- Create WebSocket applications that work seamlessly in browsers
- Implement advanced features like rooms, namespaces, and message queues
- Design scalable architectures with load balancing and monitoring

### Prerequisites

Before we dive in, make sure you're comfortable with:
- JavaScript and TypeScript basics
- Node.js fundamentals
- Basic understanding of networking (what is an IP address, port, etc.)
- Promise-based programming and async/await

Don't worry if you're not an expert‚Äîwe'll explain everything step by step!

---

## Understanding Sockets: The Foundation {#understanding-sockets}

### The Problem with Traditional HTTP

Let's start with a story. Imagine you're at a restaurant, and every time you want to know if your food is ready, you have to walk to the kitchen and ask the chef. The chef says "not yet," so you go back to your table. Two minutes later, you repeat this process. This is essentially how traditional HTTP works‚Äîthe client (you) must initiate every communication with the server (chef).

```javascript
// Traditional HTTP approach - client must always initiate
setInterval(async () => {
  const response = await fetch('/api/messages');
  const data = await response.json();
  updateUI(data);
}, 1000); // Poll every second - inefficient!
```

This approach, called **polling**, has several problems:
- **Inefficient**: Constant requests even when nothing changes
- **Delayed**: Updates only come when you ask
- **Resource-heavy**: Each request creates a new connection
- **Bandwidth waste**: HTTP headers are sent with every request

### Enter Sockets: A Better Way

Now imagine the chef has a bell system. When your food is ready, the chef rings your specific bell, and you know instantly. You don't need to keep checking‚Äîthe kitchen will notify you. This is how sockets work!

**A socket is a communication endpoint that allows bidirectional, real-time data exchange between a client and server over a persistent connection.**

### Socket Characteristics

**Persistent Connection**: Unlike HTTP requests that open, send data, receive response, and close, socket connections stay open until explicitly closed.

**Bidirectional**: Both client and server can initiate communication at any time.

**Low Overhead**: Once established, data can flow without HTTP headers and handshake overhead.

**Real-time**: Data is delivered immediately when sent, without polling delays.

### Types of Sockets

Think of sockets as different types of communication channels:

#### 1. TCP Sockets (Transmission Control Protocol)
**The Reliable Messenger**

TCP is like sending a registered letter. It guarantees:
- **Delivery**: Data will arrive (or you'll know it failed)
- **Order**: Messages arrive in the exact order sent
- **Integrity**: Data isn't corrupted during transmission

```typescript
// TCP ensures this sequence is preserved
client.write("Hello");     // Message 1
client.write("World");     // Message 2
client.write("!");         // Message 3
// Server receives: "Hello", "World", "!" in that exact order
```

**Use TCP when:** Building chat applications, file transfers, database connections, any scenario where data integrity is crucial.

#### 2. UDP Sockets (User Datagram Protocol)
**The Speed Demon**

UDP is like shouting across a crowded room. It's fast but:
- **No delivery guarantee**: Messages might not arrive
- **No order guarantee**: Messages might arrive out of sequence
- **No error correction**: Corrupted data isn't automatically retransmitted

```typescript
// UDP doesn't guarantee this sequence
client.send("Hello");     // Might arrive 3rd
client.send("World");     // Might arrive 1st  
client.send("!");         // Might not arrive at all
```

**Use UDP when:** Real-time gaming (position updates), live video streaming, DNS lookups, scenarios where speed matters more than perfect delivery.

#### 3. WebSockets
**The Browser-Friendly Bridge**

WebSockets are like TCP but designed specifically for web browsers:
- **HTTP-compatible**: Can pass through firewalls and proxies
- **Full-duplex**: Bidirectional communication like TCP
- **Web-standard**: Natively supported in all modern browsers

```typescript
// WebSocket handshake starts as HTTP then upgrades
const ws = new WebSocket('ws://localhost:8080');
ws.onmessage = (event) => {
  console.log('Received:', event.data); // Real-time data!
};
```

**Use WebSockets when:** Building web applications that need real-time features like live chat, collaborative editing, real-time dashboards.

### Key Socket Concepts

Before we dive into code, let's understand the fundamental concepts:

#### Binding and Listening
**Server-side concepts**

```typescript
// Server "binds" to an address and "listens" for connections
const server = net.createServer();
server.listen(3000, 'localhost'); // Bind to localhost:3000
console.log('Server listening on localhost:3000');
```

Think of this as setting up a phone number. The server says, "I'm available at this address (localhost) on this extension (port 3000). Call me!"

#### Connecting
**Client-side concept**

```typescript
// Client "connects" to a server
const client = net.connect(3000, 'localhost');
console.log('Connected to server');
```

This is like dialing the server's phone number to establish communication.

#### Events and Callbacks
**The communication flow**

Sockets are event-driven. Instead of continuously checking for data, you register event handlers:

```typescript
socket.on('data', (data) => {
  console.log('Received data:', data.toString());
});

socket.on('close', () => {
  console.log('Connection closed');
});

socket.on('error', (error) => {
  console.error('Socket error:', error);
});
```

Think of these as different ringtones for different types of calls‚Äîdata arriving, connection ending, or something going wrong.

---

## TCP Sockets: Building Reliable Connections {#tcp-sockets}

Now that we understand the theory, let's build our first real-time application using TCP sockets. We'll create a simple chat server that demonstrates all the fundamental concepts.

### The Architecture: Client-Server Model

Before writing code, let's understand what we're building:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    TCP Connection    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Client 1  ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                      ‚îÇ             ‚îÇ
‚îÇ   Client 2  ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ   Server    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                      ‚îÇ             ‚îÇ
‚îÇ   Client 3  ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**The server:**
- Listens for incoming connections
- Manages multiple client connections simultaneously
- Broadcasts messages between clients
- Handles client disconnections gracefully

**The client:**
- Connects to the server
- Sends user messages to the server
- Receives messages from other clients via the server

### Building Our First TCP Server

Let's start with a basic TCP server. I'll explain every line of code as we build it:

```typescript
// src/tcp-server-basic.ts
import * as net from 'net';

// First, let's create a simple echo server
const server = net.createServer();

// This event fires when a client connects
server.on('connection', (socket: net.Socket) => {
  console.log('New client connected!');
  
  // Send a welcome message
  socket.write('Welcome to our TCP server!\n');
  
  // Listen for data from this client
  socket.on('data', (data: Buffer) => {
    const message = data.toString().trim();
    console.log('Received:', message);
    
    // Echo the message back
    socket.write(`Echo: ${message}\n`);
  });
  
  // Handle client disconnection
  socket.on('close', () => {
    console.log('Client disconnected');
  });
});

// Start listening for connections
server.listen(3000, () => {
  console.log('TCP Server listening on port 3000');
});
```

**Let's break this down:**

1. **`net.createServer()`**: Creates a new TCP server instance
2. **`server.on('connection', ...)`**: Registers a callback for when clients connect
3. **`socket.write()`**: Sends data to a specific client
4. **`socket.on('data', ...)`**: Listens for data from a client
5. **`Buffer`**: Node.js represents raw data as Buffer objects (we convert to string)

### Testing Our Basic Server

Create a simple test client to verify our server works:

```typescript
// src/tcp-client-test.ts
import * as net from 'net';

const client = net.connect(3000, 'localhost');

client.on('connect', () => {
  console.log('Connected to server');
  client.write('Hello from client!');
});

client.on('data', (data: Buffer) => {
  console.log('Server says:', data.toString());
  
  // Send another message after 2 seconds
  setTimeout(() => {
    client.write('This is a second message');
  }, 2000);
});

client.on('close', () => {
  console.log('Connection closed');
});
```

**Running the example:**
1. Open terminal 1: `npx ts-node src/tcp-server-basic.ts`
2. Open terminal 2: `npx ts-node src/tcp-client-test.ts`

You'll see the server echo back your messages!

### Building a Real Chat Server

Now let's evolve our echo server into a proper chat server that can handle multiple clients and broadcast messages:

```typescript
// src/tcp-chat-server.ts
import * as net from 'net';

// Interface to represent a connected client
interface ChatClient {
  id: string;
  socket: net.Socket;
  username: string | null;
  connectedAt: Date;
}

class TCPChatServer {
  private server: net.Server;
  private clients: Map<string, ChatClient> = new Map();
  private port: number;
  
  constructor(port: number = 3000) {
    this.port = port;
    this.server = net.createServer();
    this.setupServerEvents();
  }
  
  private setupServerEvents(): void {
    // When server starts listening
    this.server.on('listening', () => {
      console.log(`üöÄ Chat server started on port ${this.port}`);
      console.log('Waiting for clients to connect...');
    });
    
    // When a new client connects
    this.server.on('connection', (socket: net.Socket) => {
      this.handleNewConnection(socket);
    });
    
    // When server encounters an error
    this.server.on('error', (error: Error) => {
      console.error('‚ùå Server error:', error.message);
    });
  }
  
  private handleNewConnection(socket: net.Socket): void {
    // Generate unique ID for this client
    const clientId = `${socket.remoteAddress}:${socket.remotePort}-${Date.now()}`;
    
    // Create client object
    const client: ChatClient = {
      id: clientId,
      socket,
      username: null, // Will be set when user provides username
      connectedAt: new Date()
    };
    
    // Store client
    this.clients.set(clientId, client);
    console.log(`üë§ New connection: ${clientId}`);
    
    // Send welcome message
    this.sendToClient(client, 'üéâ Welcome to TCP Chat Server!');
    this.sendToClient(client, 'üìù Please enter your username:');
    
    // Set up event handlers for this client
    this.setupClientEvents(client);
  }
  
  private setupClientEvents(client: ChatClient): void {
    // Handle incoming data from client
    client.socket.on('data', (data: Buffer) => {
      this.handleClientData(client, data);
    });
    
    // Handle client disconnection
    client.socket.on('close', () => {
      this.handleClientDisconnect(client);
    });
    
    // Handle client errors
    client.socket.on('error', (error: Error) => {
      console.error(`‚ùå Client ${client.id} error:`, error.message);
      this.handleClientDisconnect(client);
    });
    
    // Handle timeout (optional - prevents idle connections)
    client.socket.setTimeout(300000); // 5 minutes
    client.socket.on('timeout', () => {
      this.sendToClient(client, '‚è∞ Connection timeout. Goodbye!');
      client.socket.destroy();
    });
  }
  
  private handleClientData(client: ChatClient, data: Buffer): void {
    const message = data.toString().trim();
    
    // If client hasn't set username yet
    if (!client.username) {
      this.handleUsernameRegistration(client, message);
      return;
    }
    
    // Handle chat commands
    if (message.startsWith('/')) {
      this.handleCommand(client, message);
      return;
    }
    
    // Regular chat message
    this.handleChatMessage(client, message);
  }
  
  private handleUsernameRegistration(client: ChatClient, username: string): void {
    // Validate username
    if (!username || username.length < 2) {
      this.sendToClient(client, '‚ùå Username must be at least 2 characters long');
      return;
    }
    
    // Check if username is taken
    const existingUser = Array.from(this.clients.values())
      .find(c => c.username?.toLowerCase() === username.toLowerCase());
    
    if (existingUser) {
      this.sendToClient(client, '‚ùå Username already taken. Try another:');
      return;
    }
    
    // Set username
    client.username = username;
    console.log(`üìù Client ${client.id} registered as: ${username}`);
    
    // Welcome the user
    this.sendToClient(client, `‚úÖ Welcome, ${username}!`);
    this.sendToClient(client, 'üí¨ You can now start chatting!');
    this.sendToClient(client, 'üìã Commands: /users, /help, /quit');
    
    // Notify other users
    this.broadcastMessage(`üëã ${username} joined the chat!`, client.id);
  }
  
  private handleCommand(client: ChatClient, command: string): void {
    const [cmd, ...args] = command.toLowerCase().split(' ');
    
    switch (cmd) {
      case '/users':
        this.handleUsersCommand(client);
        break;
        
      case '/help':
        this.handleHelpCommand(client);
        break;
        
      case '/quit':
        this.sendToClient(client, 'üëã Goodbye!');
        client.socket.end();
        break;
        
      case '/whisper':
      case '/pm':
        this.handleWhisperCommand(client, args);
        break;
        
      default:
        this.sendToClient(client, `‚ùì Unknown command: ${cmd}. Type /help for available commands.`);
    }
  }
  
  private handleUsersCommand(client: ChatClient): void {
    const users = Array.from(this.clients.values())
      .filter(c => c.username)
      .map(c => c.username);
    
    this.sendToClient(client, `üë• Online users (${users.length}):`);
    users.forEach(username => {
      this.sendToClient(client, `   - ${username}`);
    });
  }
  
  private handleHelpCommand(client: ChatClient): void {
    this.sendToClient(client, 'üìã Available commands:');
    this.sendToClient(client, '   /users - Show online users');
    this.sendToClient(client, '   /whisper <username> <message> - Send private message');
    this.sendToClient(client, '   /pm <username> <message> - Send private message');
    this.sendToClient(client, '   /quit - Leave the chat');
    this.sendToClient(client, '   /help - Show this help');
  }
  
  private handleWhisperCommand(client: ChatClient, args: string[]): void {
    if (args.length < 2) {
      this.sendToClient(client, '‚ùå Usage: /whisper <username> <message>');
      return;
    }
    
    const targetUsername = args[0];
    const message = args.slice(1).join(' ');
    
    const targetClient = Array.from(this.clients.values())
      .find(c => c.username?.toLowerCase() === targetUsername.toLowerCase());
    
    if (!targetClient) {
      this.sendToClient(client, `‚ùå User "${targetUsername}" not found`);
      return;
    }
    
    if (targetClient.id === client.id) {
      this.sendToClient(client, '‚ùå You cannot whisper to yourself!');
      return;
    }
    
    // Send whisper to target
    this.sendToClient(targetClient, `ü§´ [Whisper from ${client.username}]: ${message}`);
    
    // Confirm to sender
    this.sendToClient(client, `ü§´ [Whispered to ${targetClient.username}]: ${message}`);
  }
  
  private handleChatMessage(client: ChatClient, message: string): void {
    if (!message.trim()) return;
    
    console.log(`üí¨ ${client.username}: ${message}`);
    
    // Broadcast message to all other clients
    const formattedMessage = `üí¨ ${client.username}: ${message}`;
    this.broadcastMessage(formattedMessage, client.id);
  }
  
  private handleClientDisconnect(client: ChatClient): void {
    console.log(`üëã Client disconnected: ${client.id} (${client.username || 'unknown'})`);
    
    // Remove from clients list
    this.clients.delete(client.id);
    
    // Notify other users if user had a username
    if (client.username) {
      this.broadcastMessage(`üëã ${client.username} left the chat`);
    }
  }
  
  // Helper method to send message to a specific client
  private sendToClient(client: ChatClient, message: string): void {
    try {
      client.socket.write(message + '\n');
    } catch (error) {
      console.error(`‚ùå Failed to send message to ${client.id}:`, error);
      this.handleClientDisconnect(client);
    }
  }
  
  // Helper method to broadcast message to all clients except sender
  private broadcastMessage(message: string, excludeClientId?: string): void {
    this.clients.forEach((client, clientId) => {
      if (clientId !== excludeClientId && client.username) {
        this.sendToClient(client, message);
      }
    });
  }
  
  // Start the server
  public start(): void {
    this.server.listen(this.port);
  }
  
  // Stop the server
  public stop(): Promise<void> {
    return new Promise((resolve) => {
      // Close all client connections
      this.clients.forEach(client => {
        this.sendToClient(client, 'üîå Server is shutting down. Goodbye!');
        client.socket.end();
      });
      
      // Close server
      this.server.close(() => {
        console.log('üõë Server stopped');
        resolve();
      });
    });
  }
  
  // Get server statistics
  public getStats(): {
    connectedClients: number;
    registeredUsers: number;
    uptime: number;
  } {
    const registeredUsers = Array.from(this.clients.values())
      .filter(c => c.username).length;
    
    return {
      connectedClients: this.clients.size,
      registeredUsers,
      uptime: Date.now() - this.server.listening ? Date.now() : 0
    };
  }
}

// Create and start the server
const chatServer = new TCPChatServer(3000);
chatServer.start();

// Graceful shutdown handling
process.on('SIGINT', async () => {
  console.log('\nüõë Received interrupt signal. Shutting down gracefully...');
  await chatServer.stop();
  process.exit(0);
});

// Log server stats every 30 seconds
setInterval(() => {
  const stats = chatServer.getStats();
  console.log(`üìä Server stats: ${stats.connectedClients} connected, ${stats.registeredUsers} registered`);
}, 30000);
```

### Building the Interactive Chat Client

Now let's create a user-friendly client that allows interactive chatting:

```typescript
// src/tcp-chat-client.ts
import * as net from 'net';
import * as readline from 'readline';

class TCPChatClient {
  private socket: net.Socket;
  private rl: readline.Interface;
  private host: string;
  private port: number;
  private isConnected: boolean = false;
  
  constructor(host: string = 'localhost', port: number = 3000) {
    this.host = host;
    this.port = port;
    
    // Create socket
    this.socket = new net.Socket();
    
    // Create readline interface for user input
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    
    this.setupSocketEvents();
    this.setupReadlineEvents();
  }
  
  private setupSocketEvents(): void {
    // Connection established
    this.socket.on('connect', () => {
      this.isConnected = true;
      console.log(`‚úÖ Connected to chat server at ${this.host}:${this.port}`);
      console.log('üéØ Follow the prompts to start chatting!\n');
    });
    
    // Data received from server
    this.socket.on('data', (data: Buffer) => {
      const message = data.toString();
      
      // Clear current input line and show server message
      process.stdout.clearLine(0);
      process.stdout.cursorTo(0);
      console.log(message.trim());
      
      // Restore input prompt
      this.rl.prompt();
    });
    
    // Connection closed
    this.socket.on('close', () => {
      this.isConnected = false;
      console.log('\nüîå Connection to server closed');
      this.rl.close();
    });
    
    // Connection error
    this.socket.on('error', (error: Error) => {
      console.error(`‚ùå Connection error: ${error.message}`);
      this.isConnected = false;
      this.rl.close();
    });
  }
  
  private setupReadlineEvents(): void {
    // Handle user input
    this.rl.on('line', (input: string) => {
      const trimmedInput = input.trim();
      
      if (!this.isConnected) {
        console.log('‚ùå Not connected to server');
        return;
      }
      
      if (!trimmedInput) {
        this.rl.prompt();
        return;
      }
      
      // Handle local client commands
      if (trimmedInput === '/clear') {
        console.clear();
        this.rl.prompt();
        return;
      }
      
      // Send to server
      try {
        this.socket.write(trimmedInput);
        this.rl.prompt();
      } catch (error) {
        console.error('‚ùå Failed to send message:', error);
      }
    });
    
    // Handle Ctrl+C
    this.rl.on('SIGINT', () => {
      console.log('\nüëã Goodbye!');
      this.disconnect();
    });
  }
  
  public connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      console.log(`üîå Connecting to ${this.host}:${this.port}...`);
      
      this.socket.connect(this.port, this.host, () => {
        resolve();
      });
      
      this.socket.on('error', reject);
    });
  }
  
  public disconnect(): void {
    if (this.isConnected) {
      this.socket.end();
    }
    this.rl.close();
    process.exit(0);
  }
}

// Create client and connect
async function main() {
  const client = new TCPChatClient();
  
  try {
    await client.connect();
    
    // Start interactive session
    console.log('üí¨ Chat client ready! Start typing to chat.');
    console.log('üìã Special commands: /clear (clear screen), Ctrl+C (quit)');
    
  } catch (error) {
    console.error('‚ùå Failed to connect:', error);
    process.exit(1);
  }
}

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});

// Start the client
main();
```

### Testing Our Chat Server

**Step 1: Start the server**
```bash
npx ts-node src/tcp-chat-server.ts
```

**Step 2: Connect multiple clients**
```bash
# Terminal 2
npx ts-node src/tcp-chat-client.ts

# Terminal 3
npx ts-node src/tcp-chat-client.ts

# Terminal 4
npx ts-node src/tcp-chat-client.ts
```

**Step 3: Try these interactions:**
1. Set usernames for each client
2. Send public messages
3. Use `/users` to see online users
4. Try `/whisper username message` for private messages
5. Use `/help` to see all commands

### Understanding What We Built

**Key Concepts Demonstrated:**

1. **Connection Management**: We maintain a Map of connected clients, each with their own state
2. **Event-Driven Architecture**: Everything responds to events (data, connection, disconnection)
3. **State Management**: Clients have different states (connected but no username vs. registered user)
4. **Broadcasting**: Messages are sent to multiple clients simultaneously
5. **Command Processing**: We distinguish between chat messages and commands
6. **Error Handling**: Graceful handling of network errors and disconnections
7. **Resource Cleanup**: Proper cleanup when clients disconnect

**Production Considerations We Addressed:**

- **Memory Management**: Removing disconnected clients from our Map
- **Input Validation**: Checking username length and availability
- **Timeout Handling**: Preventing idle connections from consuming resources
- **Graceful Shutdown**: Properly closing all connections when server stops
- **Error Recovery**: Handling network errors without crashing

This TCP chat server demonstrates all the fundamental patterns you'll use in socket programming. The principles we've learned here apply to any real-time application you'll build.

---

## WebSockets: Bridging the Browser Gap {#websockets}

While TCP sockets are powerful, they have a limitation: web browsers can't use them directly. This is where WebSockets come to the rescue. Think of WebSockets as TCP sockets that speak the web's language.

### Understanding the WebSocket Handshake

WebSockets are clever‚Äîthey start as a regular HTTP request and then "upgrade" to a persistent connection. Here's how it works:

```
Client Request (HTTP):
GET /chat HTTP/1.1
Host: localhost:8080
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13

Server Response (HTTP):
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=

// Now it becomes a WebSocket connection!
```

This handshake allows WebSockets to:
- Pass through firewalls (they look like HTTP initially)
- Work with proxies and load balancers
- Provide the same persistent, bidirectional communication as TCP

### Building a WebSocket Server

Let's build a real-time collaboration platform using WebSockets. Imagine Google Docs, but simpler‚Äîmultiple users can edit a shared document simultaneously.

```typescript
// src/websocket-collaborative-server.ts
import * as WebSocket from 'ws';
import * as http from 'http';
import { v4 as uuidv4 } from 'uuid';

// Types for our collaborative editor
interface User {
  id: string;
  name: string;
  ws: WebSocket;
  cursor: { line: number; column: number };
  connectedAt: Date;
}

interface Document {
  id: string;
  title: string;
  content: string;
  lastModified: Date;
  version: number; // For conflict resolution
}

interface Message {
  type: 'user_join' | 'user_leave' | 'document_update' | 'cursor_move' | 'error' | 'sync';
  payload: any;
  timestamp: Date;
  userId?: string;
}

class CollaborativeWebSocketServer {
  private server: http.Server;
  private wss: WebSocket.Server;
  private users: Map<string, User> = new Map();
  private documents: Map<string, Document> = new Map();
  private port: number;

  constructor(port: number = 8080) {
    this.port = port;
    
    // Create HTTP server
    this.server = http.createServer((req, res) => {
      // Serve a simple HTML client for testing
      if (req.url === '/' || req.url === '/index.html') {
        this.serveHTMLClient(res);
      } else {
        res.writeHead(404);
        res.end('Not found');
      }
    });

    // Create WebSocket server
    this.wss = new WebSocket.Server({ server: this.server });
    
    // Initialize with a default document
    this.createDocument('default', 'Shared Document', 'Welcome to our collaborative editor!\nStart typing to see real-time collaboration in action.');
    
    this.setupWebSocketEvents();
  }

  private setupWebSocketEvents(): void {
    this.wss.on('connection', (ws: WebSocket, request: http.IncomingMessage) => {
      console.log(`üîå New WebSocket connection from ${request.socket.remoteAddress}`);
      this.handleNewConnection(ws, request);
    });

    this.wss.on('error', (error: Error) => {
      console.error('‚ùå WebSocket server error:', error);
    });
  }

  private handleNewConnection(ws: WebSocket, request: http.IncomingMessage): void {
    // Generate unique user ID
    const userId = uuidv4();
    
    // Create user object (we'll set name when they send it)
    const user: User = {
      id: userId,
      name: `User-${userId.substr(0, 8)}`, // Default name
      ws,
      cursor: { line: 0, column: 0 },
      connectedAt: new Date()
    };

    // Store user
    this.users.set(userId, user);

    // Set up WebSocket event handlers
    ws.on('message', (data: WebSocket.Data) => {
      this.handleMessage(userId, data);
    });

    ws.on('close', (code: number, reason: string) => {
      this.handleDisconnection(userId, code, reason);
    });

    ws.on('error', (error: Error) => {
      console.error(`‚ùå WebSocket error for user ${userId}:`, error);
    });

    // Send welcome message and current document state
    this.sendToUser(userId, {
      type: 'sync',
      payload: {
        userId,
        documents: Array.from(this.documents.values()),
        users: this.getConnectedUsersInfo()
      },
      timestamp: new Date()
    });

    // Notify other users
    this.broadcastToOthers(userId, {
      type: 'user_join',
      payload: { user: this.getUserInfo(user) },
      timestamp: new Date(),
      userId
    });
  }

  private handleMessage(userId: string, data: WebSocket.Data): void {
    try {
      const message: Message = JSON.parse(data.toString());
      
      switch (message.type) {
        case 'user_join':
          this.handleUserJoin(userId, message.payload);
          break;
          
        case 'document_update':
          this.handleDocumentUpdate(userId, message.payload);
          break;
          
        case 'cursor_move':
          this.handleCursorMove(userId, message.payload);
          break;
          
        default:
          console.log(`ü§∑ Unknown message type: ${message.type}`);
      }
    } catch (error) {
      console.error(`‚ùå Error parsing message from ${userId}:`, error);
      this.sendToUser(userId, {
        type: 'error',
        payload: { message: 'Invalid message format' },
        timestamp: new Date()
      });
    }
  }

  private handleUserJoin(userId: string, payload: { name: string }): void {
    const user = this.users.get(userId);
    if (!user) return;

    // Update user name
    user.name = payload.name || user.name;
    console.log(`üë§ User ${userId} set name to: ${user.name}`);

    // Notify all users about the name change
    this.broadcast({
      type: 'user_join',
      payload: { user: this.getUserInfo(user) },
      timestamp: new Date(),
      userId
    });
  }

  private handleDocumentUpdate(userId: string, payload: {
    documentId: string;
    operation: 'insert' | 'delete' | 'replace';
    position: { line: number; column: number };
    content?: string;
    length?: number;
  }): void {
    const user = this.users.get(userId);
    const document = this.documents.get(payload.documentId);
    
    if (!user || !document) {
      this.sendToUser(userId, {
        type: 'error',
        payload: { message: 'Invalid document or user' },
        timestamp: new Date()
      });
      return;
    }

    // Apply the operation to the document
    const result = this.applyDocumentOperation(document, payload);
    
    if (result.success) {
      console.log(`üìù Document "${document.title}" updated by ${user.name}`);
      
      // Broadcast the change to all other users
      this.broadcastToOthers(userId, {
        type: 'document_update',
        payload: {
          documentId: payload.documentId,
          operation: payload,
          appliedBy: user.name,
          newVersion: document.version
        },
        timestamp: new Date(),
        userId
      });
    } else {
      // Send error back to user
      this.sendToUser(userId, {
        type: 'error',
        payload: { message: result.error },
        timestamp: new Date()
      });
    }
  }

  private applyDocumentOperation(document: Document, operation: any): { success: boolean; error?: string } {
    try {
      const lines = document.content.split('\n');
      const { line, column } = operation.position;

      // Validate position
      if (line < 0 || line >= lines.length || column < 0 || column > lines[line].length) {
        return { success: false, error: 'Invalid position' };
      }

      switch (operation.operation) {
        case 'insert':
          if (!operation.content) {
            return { success: false, error: 'No content provided for insert operation' };
          }
          
          // Insert content at position
          const insertLines = operation.content.split('\n');
          if (insertLines.length === 1) {
            // Single line insert
            lines[line] = lines[line].slice(0, column) + operation.content + lines[line].slice(column);
          } else {
            // Multi-line insert
            const beforeInsert = lines[line].slice(0, column);
            const afterInsert = lines[line].slice(column);
            
            lines[line] = beforeInsert + insertLines[0];
            
            for (let i = 1; i < insertLines.length - 1; i++) {
              lines.splice(line + i, 0, insertLines[i]);
            }
            
            lines.splice(line + insertLines.length - 1, 0, insertLines[insertLines.length - 1] + afterInsert);
          }
          break;

        case 'delete':
          if (!operation.length || operation.length <= 0) {
            return { success: false, error: 'Invalid delete length' };
          }
          
          // Delete content from position
          lines[line] = lines[line].slice(0, column) + lines[line].slice(column + operation.length);
          break;

        case 'replace':
          if (!operation.content || !operation.length) {
            return { success: false, error: 'Replace operation needs both content and length' };
          }
          
          // Replace content at position
          lines[line] = lines[line].slice(0, column) + operation.content + lines[line].slice(column + operation.length);
          break;

        default:
          return { success: false, error: 'Unknown operation type' };
      }

      // Update document
      document.content = lines.join('\n');
      document.lastModified = new Date();
      document.version++;

      return { success: true };
    } catch (error) {
      return { success: false, error: `Operation failed: ${error}` };
    }
  }

  private handleCursorMove(userId: string, payload: { line: number; column: number }): void {
    const user = this.users.get(userId);
    if (!user) return;

    // Update user cursor position
    user.cursor = payload;

    // Broadcast cursor position to other users
    this.broadcastToOthers(userId, {
      type: 'cursor_move',
      payload: {
        userId,
        userName: user.name,
        cursor: payload
      },
      timestamp: new Date(),
      userId
    });
  }

  private handleDisconnection(userId: string, code: number, reason: string): void {
    const user = this.users.get(userId);
    if (user) {
      console.log(`üëã User ${user.name} (${userId}) disconnected: ${code} - ${reason}`);
      
      // Remove user
      this.users.delete(userId);
      
      // Notify other users
      this.broadcast({
        type: 'user_leave',
        payload: { 
          userId,
          userName: user.name
        },
        timestamp: new Date()
      });
    }
  }

  private createDocument(id: string, title: string, content: string): Document {
    const document: Document = {
      id,
      title,
      content,
      lastModified: new Date(),
      version: 1
    };

    this.documents.set(id, document);
    console.log(`üìÑ Created document: ${title}`);
    return document;
  }

  // Helper methods
  private sendToUser(userId: string, message: Message): void {
    const user = this.users.get(userId);
    if (user && user.ws.readyState === WebSocket.OPEN) {
      try {
        user.ws.send(JSON.stringify(message));
      } catch (error) {
        console.error(`‚ùå Failed to send message to ${userId}:`, error);
      }
    }
  }

  private broadcast(message: Message): void {
    this.users.forEach((user) => {
      this.sendToUser(user.id, message);
    });
  }

  private broadcastToOthers(excludeUserId: string, message: Message): void {
    this.users.forEach((user, userId) => {
      if (userId !== excludeUserId) {
        this.sendToUser(userId, message);
      }
    });
  }

  private getUserInfo(user: User): any {
    return {
      id: user.id,
      name: user.name,
      cursor: user.cursor,
      connectedAt: user.connectedAt
    };
  }

  private getConnectedUsersInfo(): any[] {
    return Array.from(this.users.values()).map(user => this.getUserInfo(user));
  }

  private serveHTMLClient(res: http.ServerResponse): void {
    const html = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Editor</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
        }
        .header h1 {
            margin: 0;
            font-size: 24px;
        }
        .user-info {
            margin-top: 10px;
            font-size: 14px;
            opacity: 0.9;
        }
        .main-content {
            display: flex;
            height: 600px;
        }
        .editor-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .editor {
            flex: 1;
            border: none;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            resize: none;
            outline: none;
        }
        .sidebar {
            width: 300px;
            border-left: 1px solid #ddd;
            background: #f8f9fa;
        }
        .users-panel {
            padding: 20px;
            border-bottom: 1px solid #ddd;
        }
        .users-panel h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 16px;
        }
        .user-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px;
            background: white;
            border-radius: 4px;
            border-left: 4px solid #3498db;
        }
        .user-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #27ae60;
            margin-right: 10px;
        }
        .activity-panel {
            padding: 20px;
            flex: 1;
        }
        .activity-panel h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 16px;
        }
        .activity-log {
            height: 300px;
            overflow-y: auto;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            font-size: 12px;
        }
        .activity-item {
            margin-bottom: 5px;
            color: #666;
        }
        .activity-item.join { color: #27ae60; }
        .activity-item.leave { color: #e74c3c; }
        .activity-item.edit { color: #3498db; }
        .name-input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-left: 10px;
        }
        .connection-status {
            padding: 10px 20px;
            background: #27ae60;
            color: white;
            text-align: center;
            font-weight: bold;
        }
        .connection-status.disconnected {
            background: #e74c3c;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìù Collaborative Document Editor</h1>
            <div class="user-info">
                Your name: <input type="text" id="nameInput" class="name-input" placeholder="Enter your name" maxlength="20">
                <span id="userId"></span>
            </div>
        </div>
        
        <div id="connectionStatus" class="connection-status disconnected">
            Connecting...
        </div>
        
        <div class="main-content">
            <div class="editor-area">
                <textarea id="editor" class="editor" placeholder="Start typing to collaborate in real-time..."></textarea>
            </div>
            
            <div class="sidebar">
                <div class="users-panel">
                    <h3>üë• Online Users (<span id="userCount">0</span>)</h3>
                    <div id="usersList"></div>
                </div>
                
                <div class="activity-panel">
                    <h3>üìä Activity Log</h3>
                    <div id="activityLog" class="activity-log"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class CollaborativeEditor {
            constructor() {
                this.ws = null;
                this.userId = null;
                this.isConnected = false;
                this.users = new Map();
                this.currentDocument = null;
                
                this.editor = document.getElementById('editor');
                this.nameInput = document.getElementById('nameInput');
                this.connectionStatus = document.getElementById('connectionStatus');
                this.usersList = document.getElementById('usersList');
                this.userCount = document.getElementById('userCount');
                this.activityLog = document.getElementById('activityLog');
                
                this.setupEventHandlers();
                this.connect();
            }
            
            connect() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = \`\${protocol}//\${window.location.host}\`;
                
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    this.isConnected = true;
                    this.updateConnectionStatus(true);
                    this.log('Connected to server', 'join');
                };
                
                this.ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    this.handleMessage(message);
                };
                
                this.ws.onclose = () => {
                    this.isConnected = false;
                    this.updateConnectionStatus(false);
                    this.log('Disconnected from server', 'leave');
                    
                    // Try to reconnect after 3 seconds
                    setTimeout(() => this.connect(), 3000);
                };
                
                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.log('Connection error', 'leave');
                };
            }
            
            setupEventHandlers() {
                // Editor input
                this.editor.addEventListener('input', (e) => {
                    if (this.isConnected && this.currentDocument) {
                        // Simplified: send the entire content (in real app, you'd send operations)
                        this.sendMessage({
                            type: 'document_update',
                            payload: {
                                documentId: this.currentDocument.id,
                                operation: 'replace',
                                position: { line: 0, column: 0 },
                                content: this.editor.value,
                                length: this.currentDocument.content.length
                            }
                        });
                    }
                });
                
                // Cursor movement (simplified)
                this.editor.addEventListener('click', (e) => {
                    this.sendCursorPosition();
                });
                
                this.editor.addEventListener('keyup', (e) => {
                    this.sendCursorPosition();
                });
                
                // Name input
                this.nameInput.addEventListener('change', (e) => {
                    if (this.isConnected) {
                        this.sendMessage({
                            type: 'user_join',
                            payload: { name: e.target.value }
                        });
                    }
                });
            }
            
            handleMessage(message) {
                switch (message.type) {
                    case 'sync':
                        this.handleSync(message.payload);
                        break;
                    case 'user_join':
                        this.handleUserJoin(message.payload);
                        break;
                    case 'user_leave':
                        this.handleUserLeave(message.payload);
                        break;
                    case 'document_update':
                        this.handleDocumentUpdate(message.payload);
                        break;
                    case 'cursor_move':
                        this.handleCursorMove(message.payload);
                        break;
                    case 'error':
                        this.handleError(message.payload);
                        break;
                }
            }
            
            handleSync(payload) {
                this.userId = payload.userId;
                document.getElementById('userId').textContent = \`(ID: \${this.userId.substr(0, 8)})\`;
                
                // Load document
                if (payload.documents && payload.documents.length > 0) {
                    this.currentDocument = payload.documents[0];
                    this.editor.value = this.currentDocument.content;
                }
                
                // Load users
                payload.users.forEach(user => {
                    this.users.set(user.id, user);
                });
                this.updateUsersList();
            }
            
            handleUserJoin(payload) {
                this.users.set(payload.user.id, payload.user);
                this.updateUsersList();
                this.log(\`\${payload.user.name} joined\`, 'join');
            }
            
            handleUserLeave(payload) {
                this.users.delete(payload.userId);
                this.updateUsersList();
                this.log(\`\${payload.userName} left\`, 'leave');
            }
            
            handleDocumentUpdate(payload) {
                if (payload.documentId === this.currentDocument?.id) {
                    // In a real implementation, you'd apply the specific operation
                    // For demo purposes, we'll just note the change
                    this.log(\`Document edited by \${payload.appliedBy}\`, 'edit');
                    
                    // Update document version
                    this.currentDocument.version = payload.newVersion;
                }
            }
            
            handleCursorMove(payload) {
                // In a real implementation, you'd show other users' cursors
                console.log(\`\${payload.userName} moved cursor to \${payload.cursor.line}:\${payload.cursor.column}\`);
            }
            
            handleError(payload) {
                this.log(\`Error: \${payload.message}\`, 'leave');
            }
            
            sendMessage(message) {
                if (this.isConnected) {
                    message.timestamp = new Date();
                    this.ws.send(JSON.stringify(message));
                }
            }
            
            sendCursorPosition() {
                const textarea = this.editor;
                const cursor = this.getCursorPosition(textarea);
                
                this.sendMessage({
                    type: 'cursor_move',
                    payload: cursor
                });
            }
            
            getCursorPosition(textarea) {
                const text = textarea.value.substring(0, textarea.selectionStart);
                const lines = text.split('\\n');
                return {
                    line: lines.length - 1,
                    column: lines[lines.length - 1].length
                };
            }
            
            updateConnectionStatus(connected) {
                this.connectionStatus.textContent = connected ? 'Connected' : 'Disconnected';
                this.connectionStatus.className = \`connection-status \${connected ? '' : 'disconnected'}\`;
            }
            
            updateUsersList() {
                const userArray = Array.from(this.users.values());
                this.userCount.textContent = userArray.length;
                
                this.usersList.innerHTML = userArray.map(user => \`
                    <div class="user-item">
                        <div class="user-status"></div>
                        <div>\${user.name} \${user.id === this.userId ? '(You)' : ''}</div>
                    </div>
                \`).join('');
            }
            
            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = \`activity-item \${type}\`;
                logEntry.textContent = \`[\${timestamp}] \${message}\`;
                
                this.activityLog.appendChild(logEntry);
                this.activityLog.scrollTop = this.activityLog.scrollHeight;
                
                // Keep only last 50 log entries
                while (this.activityLog.children.length > 50) {
                    this.activityLog.removeChild(this.activityLog.firstChild);
                }
            }
        }
        
        // Initialize the collaborative editor
        document.addEventListener('DOMContentLoaded', () => {
            new CollaborativeEditor();
        });
    </script>
</body>
</html>`;

    res.writeHead(200, { 'Content-Type': 'text/html' });
    res.end(html);
  }

  // Server control methods
  public start(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.server.listen(this.port, (error?: Error) => {
        if (error) {
          reject(error);
        } else {
          console.log(`üöÄ WebSocket collaborative server started on port ${this.port}`);
          console.log(`üìÑ Open http://localhost:${this.port} to test the collaborative editor`);
          resolve();
        }
      });
    });
  }

  public stop(): Promise<void> {
    return new Promise((resolve) => {
      // Close all WebSocket connections
      this.users.forEach(user => {
        if (user.ws.readyState === WebSocket.OPEN) {
          user.ws.close(1001, 'Server shutting down');
        }
      });

      this.server.close(() => {
        console.log('üõë WebSocket server stopped');
        resolve();
      });
    });
  }

  public getStats(): {
    connectedUsers: number;
    documents: number;
    totalMessages: number;
  } {
    return {
      connectedUsers: this.users.size,
      documents: this.documents.size,
      totalMessages: 0 // Would track this in a real implementation
    };
  }
}

// Create and start the server
const collaborativeServer = new CollaborativeWebSocketServer(8080);
collaborativeServer.start().catch(console.error);

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log('\nüõë Received interrupt signal. Shutting down gracefully...');
  await collaborativeServer.stop();
  process.exit(0);
});

// Log server stats every 30 seconds
setInterval(() => {
  const stats = collaborativeServer.getStats();
  console.log(`üìä Server stats: ${stats.connectedUsers} users, ${stats.documents} documents`);
}, 30000);
```

### Testing Our Collaborative Editor

**Step 1: Start the server**
```bash
npx ts-node src/websocket-collaborative-server.ts
```

**Step 2: Open multiple browser windows**
- Go to `http://localhost:8080` in multiple browser windows
- Enter different names in each window
- Start typing in one window and see it appear in others!

### Understanding WebSocket vs TCP Differences

Let's compare what we just built with our TCP chat server:

| Feature | TCP Server | WebSocket Server |
|---------|------------|------------------|
| **Connection** | Direct TCP socket | HTTP upgrade to WebSocket |
| **Client** | Custom TCP client | Web browser |
| **Data Format** | Raw text/binary | JSON messages |
| **Browser Support** | ‚ùå Not directly | ‚úÖ Native support |
| **Firewall Friendly** | ‚ùå Often blocked | ‚úÖ HTTP-compatible |
| **Protocol Overhead** | Low | Medium (JSON + WS headers) |

### Key WebSocket Concepts Demonstrated

**1. Message-Based Communication**
Unlike TCP's stream-based approach, WebSockets send discrete messages:

```typescript
// TCP - stream of bytes
socket.write('Hello');
socket.write('World');
// Might be received as 'HelloWorld' or 'Hel' + 'loWorld'

// WebSocket - discrete messages  
ws.send('Hello');
ws.send('World');
// Always received as two separate messages
```

**2. JSON Protocol Design**
We designed a structured message protocol:

```typescript
interface Message {
  type: string;        // What kind of message is this?
  payload: any;        // The actual data
  timestamp: Date;     // When was it sent?
  userId?: string;     // Who sent it?
}
```

This makes our protocol self-documenting and extensible.

**3. State Synchronization**
The collaborative editor demonstrates a key concept in real-time applications: keeping multiple clients in sync. We handle:

- **Initial sync**: New users get current document state
- **Operation broadcasting**: Changes are sent to all users
- **Conflict resolution**: Version numbers help detect conflicts
- **User presence**: Who's online and what they're doing

### Building a Real-Time Dashboard

Let's create another WebSocket example‚Äîa real-time dashboard that monitors system metrics:

```typescript
// src/websocket-dashboard.ts
import * as WebSocket from 'ws';
import * as http from 'http';
import * as os from 'os';

interface SystemMetrics {
  timestamp: Date;
  cpu: {
    usage: number;
    cores: number;
  };
  memory: {
    total: number;
    used: number;
    free: number;
    usage: number;
  };
  uptime: number;
  loadAverage: number[];
}

class SystemDashboard {
  private server: http.Server;
  private wss: WebSocket.Server;
  private clients: Set<WebSocket> = new Set();
  private metricsInterval: NodeJS.Timeout | null = null;
  private port: number;

  constructor(port: number = 3001) {
    this.port = port;
    this.server = http.createServer(this.handleHttpRequest.bind(this));
    this.wss = new WebSocket.Server({ server: this.server });
    this.setupWebSocketEvents();
  }

  private setupWebSocketEvents(): void {
    this.wss.on('connection', (ws: WebSocket) => {
      console.log('üìä Dashboard client connected');
      
      this.clients.add(ws);
      
      // Send current metrics immediately
      this.sendMetrics(ws);
      
      ws.on('close', () => {
        console.log('üìä Dashboard client disconnected');
        this.clients.delete(ws);
      });
      
      ws.on('error', (error) => {
        console.error('Dashboard client error:', error);
        this.clients.delete(ws);
      });
    });
  }

  private async getSystemMetrics(): Promise<SystemMetrics> {
    const cpuUsage = await this.getCPUUsage();
    const totalMem = os.totalmem();
    const freeMem = os.freemem();
    const usedMem = totalMem - freeMem;

    return {
      timestamp: new Date(),
      cpu: {
        usage: cpuUsage,
        cores: os.cpus().length
      },
      memory: {
        total: totalMem,
        used: usedMem,
        free: freeMem,
        usage: (usedMem / totalMem) * 100
      },
      uptime: os.uptime(),
      loadAverage: os.loadavg()
    };
  }

  private getCPUUsage(): Promise<number> {
    return new Promise((resolve) => {
      const startMeasure = this.cpuAverage();
      
      setTimeout(() => {
        const endMeasure = this.cpuAverage();
        const idleDifference = endMeasure.idle - startMeasure.idle;
        const totalDifference = endMeasure.total - startMeasure.total;
        const percentageCPU = 100 - ~~(100 * idleDifference / totalDifference);
        
        resolve(percentageCPU);
      }, 100);
    });
  }

  private cpuAverage(): { idle: number; total: number } {
    const cpus = os.cpus();
    let idle = 0;
    let total = 0;

    for (const cpu of cpus) {
      for (const type in cpu.times) {
        total += cpu.times[type as keyof typeof cpu.times];
      }
      idle += cpu.times.idle;
    }

    return { idle: idle / cpus.length, total: total / cpus.length };
  }

  private async sendMetrics(ws?: WebSocket): Promise<void> {
    const metrics = await this.getSystemMetrics();
    const message = JSON.stringify({
      type: 'metrics',
      data: metrics
    });

    if (ws) {
      ws.send(message);
    } else {
      this.clients.forEach(client => {
        if (client.readyState === WebSocket.OPEN) {
          client.send(message);
        }
      });
    }
  }

