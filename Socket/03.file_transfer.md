# File Transfer Between Client and Server Using Socket.IO, Node.js, and TypeScript

## Chapter Overview: Understanding Real-Time File Transfer

File transfer over network sockets represents one of the fundamental operations in distributed computing. When we combine the event-driven architecture of Node.js with the real-time capabilities of Socket.IO and the type safety of TypeScript, we create a robust foundation for handling file operations across network boundaries.

### Core Concepts

**Socket-based Communication** operates on the principle of persistent connections between client and server. Unlike traditional HTTP requests that follow a request-response pattern, socket connections maintain an open channel that allows bidirectional communication. This makes them ideal for file transfer operations where we need real-time progress updates and efficient data streaming.

**Event-Driven Architecture** forms the backbone of our implementation. Both client and server emit and listen for specific events, creating a choreographed dance of data exchange. Events like `file-upload-start`, `file-chunk`, `upload-progress`, and `file-upload-complete` provide clear semantic meaning to our communication protocol.

**Binary Data Handling** requires special consideration. Files are binary data that must be properly encoded for transmission over network sockets. We'll use Buffer objects in Node.js and ArrayBuffer objects in the browser to handle this binary data efficiently.

## Implementation Architecture

Let's build our file transfer system step by step, starting with the foundational types and interfaces.### Chapter 1: Server-Side Implementation

```typescript
 // shared/types.ts
// These types define the contract between client and server

export interface FileMetadata {
  fileName: string;
  fileSize: number;
  fileType: string;
  uploadId: string;
  checksum?: string;  // Optional for integrity verification
}

export interface FileChunk {
  uploadId: string;
  chunkIndex: number;
  totalChunks: number;
  data: Buffer | ArrayBuffer;
  isLastChunk: boolean;
}

export interface UploadProgress {
  uploadId: string;
  bytesUploaded: number;
  totalBytes: number;
  percentage: number;
  speed?: number;  // bytes per second
}

export interface UploadResult {
  success: boolean;
  uploadId: string;
  fileName: string;
  filePath?: string;
  error?: string;
}

// Socket event names - centralized to avoid typos
export const SOCKET_EVENTS = {
  // Client to Server
  FILE_UPLOAD_START: 'file-upload-start',
  FILE_CHUNK: 'file-chunk',
  FILE_UPLOAD_CANCEL: 'file-upload-cancel',
  
  // Server to Client
  UPLOAD_READY: 'upload-ready',
  UPLOAD_PROGRESS: 'upload-progress',
  UPLOAD_COMPLETE: 'upload-complete',
  UPLOAD_ERROR: 'upload-error',
  
  // Bidirectional
  CONNECTION: 'connection',
  DISCONNECT: 'disconnect'
} as const;

export type SocketEvents = typeof SOCKET_EVENTS[keyof typeof SOCKET_EVENTS];
```

## Chapter 1: Server-Side Implementation
The server acts as the orchestrator of file transfer operations. It must handle multiple concurrent uploads, manage file streams, and provide progress feedback to clients.

```typescript
// server/fileServer.ts
import express from 'express';
import { createServer } from 'http';
import { Server as SocketIOServer, Socket } from 'socket.io';
import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import { 
  FileMetadata, 
  FileChunk, 
  UploadProgress, 
  UploadResult,
  SOCKET_EVENTS 
} from '../shared/types';

// Configuration constants
const UPLOAD_DIR = path.join(__dirname, 'uploads');
const MAX_FILE_SIZE = 100 * 1024 * 1024; // 100MB
const CHUNK_SIZE = 1024 * 64; // 64KB chunks

// Interface for tracking active uploads
interface ActiveUpload {
  metadata: FileMetadata;
  filePath: string;
  writeStream: fs.WriteStream;
  receivedChunks: number;
  bytesReceived: number;
  startTime: number;
  lastProgressTime: number;
}

export class FileTransferServer {
  private app: express.Application;
  private server: any;
  private io: SocketIOServer;
  private activeUploads: Map<string, ActiveUpload> = new Map();

  constructor(port: number = 3000) {
    this.app = express();
    this.server = createServer(this.app);
    this.io = new SocketIOServer(this.server, {
      cors: {
        origin: "*", // Configure appropriately for production
        methods: ["GET", "POST"]
      },
      maxHttpBufferSize: CHUNK_SIZE * 2 // Allow slightly larger than chunk size
    });

    this.initializeUploadDirectory();
    this.setupSocketHandlers();
    this.setupExpressRoutes();
  }

  /**
   * Ensures the upload directory exists
   */
  private initializeUploadDirectory(): void {
    if (!fs.existsSync(UPLOAD_DIR)) {
      fs.mkdirSync(UPLOAD_DIR, { recursive: true });
      console.log(`Created upload directory: ${UPLOAD_DIR}`);
    }
  }

  /**
   * Sets up Socket.IO event handlers
   */
  private setupSocketHandlers(): void {
    this.io.on(SOCKET_EVENTS.CONNECTION, (socket: Socket) => {
      console.log(`Client connected: ${socket.id}`);

      // Handle file upload initiation
      socket.on(SOCKET_EVENTS.FILE_UPLOAD_START, (metadata: FileMetadata) => {
        this.handleUploadStart(socket, metadata);
      });

      // Handle incoming file chunks
      socket.on(SOCKET_EVENTS.FILE_CHUNK, (chunk: FileChunk) => {
        this.handleFileChunk(socket, chunk);
      });

      // Handle upload cancellation
      socket.on(SOCKET_EVENTS.FILE_UPLOAD_CANCEL, (uploadId: string) => {
        this.handleUploadCancel(socket, uploadId);
      });

      // Handle disconnection
      socket.on(SOCKET_EVENTS.DISCONNECT, () => {
        this.handleDisconnect(socket);
        console.log(`Client disconnected: ${socket.id}`);
      });
    });
  }

  /**
   * Handles the initiation of a file upload
   */
  private async handleUploadStart(socket: Socket, metadata: FileMetadata): Promise<void> {
    try {
      // Validate file size
      if (metadata.fileSize > MAX_FILE_SIZE) {
        socket.emit(SOCKET_EVENTS.UPLOAD_ERROR, {
          success: false,
          uploadId: metadata.uploadId,
          fileName: metadata.fileName,
          error: `File size exceeds maximum allowed size of ${MAX_FILE_SIZE / (1024 * 1024)}MB`
        } as UploadResult);
        return;
      }

      // Sanitize filename to prevent directory traversal attacks
      const sanitizedFileName = this.sanitizeFileName(metadata.fileName);
      const filePath = path.join(UPLOAD_DIR, `${metadata.uploadId}_${sanitizedFileName}`);

      // Create write stream
      const writeStream = fs.createWriteStream(filePath);

      // Store upload information
      const activeUpload: ActiveUpload = {
        metadata,
        filePath,
        writeStream,
        receivedChunks: 0,
        bytesReceived: 0,
        startTime: Date.now(),
        lastProgressTime: Date.now()
      };

      this.activeUploads.set(metadata.uploadId, activeUpload);

      // Notify client that server is ready to receive chunks
      socket.emit(SOCKET_EVENTS.UPLOAD_READY, {
        success: true,
        uploadId: metadata.uploadId,
        fileName: metadata.fileName
      } as UploadResult);

      console.log(`Upload started: ${metadata.fileName} (${metadata.fileSize} bytes)`);

    } catch (error) {
      socket.emit(SOCKET_EVENTS.UPLOAD_ERROR, {
        success: false,
        uploadId: metadata.uploadId,
        fileName: metadata.fileName,
        error: `Failed to initialize upload: ${error}`
      } as UploadResult);
    }
  }

  /**
   * Handles incoming file chunks
   */
  private async handleFileChunk(socket: Socket, chunk: FileChunk): Promise<void> {
    const activeUpload = this.activeUploads.get(chunk.uploadId);
    
    if (!activeUpload) {
      socket.emit(SOCKET_EVENTS.UPLOAD_ERROR, {
        success: false,
        uploadId: chunk.uploadId,
        error: 'Upload session not found'
      } as UploadResult);
      return;
    }

    try {
      // Convert ArrayBuffer to Buffer if necessary (for browser compatibility)
      let dataBuffer: Buffer;
      if (chunk.data instanceof ArrayBuffer) {
        dataBuffer = Buffer.from(chunk.data);
      } else {
        dataBuffer = chunk.data as Buffer;
      }

      // Write chunk to file
      await new Promise<void>((resolve, reject) => {
        activeUpload.writeStream.write(dataBuffer, (error) => {
          if (error) reject(error);
          else resolve();
        });
      });

      // Update progress tracking
      activeUpload.receivedChunks++;
      activeUpload.bytesReceived += dataBuffer.length;

      // Calculate and emit progress (throttled to avoid overwhelming client)
      const now = Date.now();
      if (now - activeUpload.lastProgressTime > 100) { // Update every 100ms
        const progress = this.calculateProgress(activeUpload);
        socket.emit(SOCKET_EVENTS.UPLOAD_PROGRESS, progress);
        activeUpload.lastProgressTime = now;
      }

      // Handle completion
      if (chunk.isLastChunk) {
        await this.completeUpload(socket, activeUpload);
      }

    } catch (error) {
      await this.handleUploadError(socket, chunk.uploadId, `Error processing chunk: ${error}`);
    }
  }

  /**
   * Completes a file upload
   */
  private async completeUpload(socket: Socket, activeUpload: ActiveUpload): Promise<void> {
    return new Promise((resolve) => {
      activeUpload.writeStream.end(() => {
        // Verify file size matches expected size
        const actualSize = fs.statSync(activeUpload.filePath).size;
        const expectedSize = activeUpload.metadata.fileSize;

        if (actualSize !== expectedSize) {
          this.handleUploadError(
            socket, 
            activeUpload.metadata.uploadId, 
            `File size mismatch. Expected: ${expectedSize}, Actual: ${actualSize}`
          );
          resolve();
          return;
        }

        // Send final progress update
        const finalProgress = this.calculateProgress(activeUpload);
        socket.emit(SOCKET_EVENTS.UPLOAD_PROGRESS, { ...finalProgress, percentage: 100 });

        // Send completion notification
        socket.emit(SOCKET_EVENTS.UPLOAD_COMPLETE, {
          success: true,
          uploadId: activeUpload.metadata.uploadId,
          fileName: activeUpload.metadata.fileName,
          filePath: activeUpload.filePath
        } as UploadResult);

        // Cleanup
        this.activeUploads.delete(activeUpload.metadata.uploadId);
        
        const uploadDuration = Date.now() - activeUpload.startTime;
        console.log(`Upload completed: ${activeUpload.metadata.fileName} in ${uploadDuration}ms`);
        
        resolve();
      });
    });
  }

  /**
   * Calculates upload progress
   */
  private calculateProgress(activeUpload: ActiveUpload): UploadProgress {
    const percentage = (activeUpload.bytesReceived / activeUpload.metadata.fileSize) * 100;
    const elapsed = (Date.now() - activeUpload.startTime) / 1000; // seconds
    const speed = elapsed > 0 ? activeUpload.bytesReceived / elapsed : 0;

    return {
      uploadId: activeUpload.metadata.uploadId,
      bytesUploaded: activeUpload.bytesReceived,
      totalBytes: activeUpload.metadata.fileSize,
      percentage: Math.min(percentage, 100),
      speed: Math.round(speed)
    };
  }

  /**
   * Handles upload cancellation
   */
  private async handleUploadCancel(socket: Socket, uploadId: string): Promise<void> {
    const activeUpload = this.activeUploads.get(uploadId);
    if (activeUpload) {
      activeUpload.writeStream.destroy();
      
      // Remove incomplete file
      try {
        fs.unlinkSync(activeUpload.filePath);
      } catch (error) {
        console.error(`Failed to remove incomplete file: ${error}`);
      }

      this.activeUploads.delete(uploadId);
      console.log(`Upload cancelled: ${activeUpload.metadata.fileName}`);
    }
  }

  /**
   * Handles upload errors
   */
  private async handleUploadError(socket: Socket, uploadId: string, errorMessage: string): Promise<void> {
    const activeUpload = this.activeUploads.get(uploadId);
    if (activeUpload) {
      activeUpload.writeStream.destroy();
      
      // Remove incomplete file
      try {
        fs.unlinkSync(activeUpload.filePath);
      } catch (error) {
        console.error(`Failed to remove incomplete file: ${error}`);
      }

      this.activeUploads.delete(uploadId);
    }

    socket.emit(SOCKET_EVENTS.UPLOAD_ERROR, {
      success: false,
      uploadId,
      error: errorMessage
    } as UploadResult);

    console.error(`Upload error: ${errorMessage}`);
  }

  /**
   * Handles client disconnection
   */
  private handleDisconnect(socket: Socket): void {
    // Clean up any active uploads for this socket
    // In a production system, you might want to preserve uploads across reconnections
    this.activeUploads.forEach((upload, uploadId) => {
      upload.writeStream.destroy();
      try {
        fs.unlinkSync(upload.filePath);
      } catch (error) {
        console.error(`Failed to cleanup file on disconnect: ${error}`);
      }
    });
  }

  /**
   * Sanitizes filename to prevent security issues
   */
  private sanitizeFileName(fileName: string): string {
    return fileName
      .replace(/[^a-zA-Z0-9.-]/g, '_') // Replace special characters
      .replace(/\.{2,}/g, '.') // Replace multiple dots
      .substring(0, 255); // Limit length
  }

  /**
   * Sets up Express routes for file management
   */
  private setupExpressRoutes(): void {
    this.app.use('/uploads', express.static(UPLOAD_DIR));
    
    this.app.get('/health', (req, res) => {
      res.json({ status: 'OK', activeUploads: this.activeUploads.size });
    });
  }

  /**
   * Starts the server
   */
  public start(port: number = 3000): void {
    this.server.listen(port, () => {
      console.log(`File transfer server listening on port ${port}`);
      console.log(`Upload directory: ${UPLOAD_DIR}`);
    });
  }
}

// Usage example
const fileServer = new FileTransferServer();
fileServer.start(3000);
```

## Chapter 2: Client-Side Implementation
The client-side implementation handles file selection, chunking, and upload coordination with real-time progress feedback.

```typescript
// client/fileClient.ts
import { io, Socket } from 'socket.io-client';
import { 
  FileMetadata, 
  FileChunk, 
  UploadProgress, 
  UploadResult,
  SOCKET_EVENTS 
} from '../shared/types';

// Configuration constants
const CHUNK_SIZE = 1024 * 64; // 64KB chunks - matches server
const MAX_CONCURRENT_CHUNKS = 3; // Limit concurrent chunk uploads

export interface UploadOptions {
  onProgress?: (progress: UploadProgress) => void;
  onComplete?: (result: UploadResult) => void;
  onError?: (error: string) => void;
  onStart?: (uploadId: string) => void;
}

export class FileTransferClient {
  private socket: Socket;
  private activeUploads: Map<string, AbortController> = new Map();

  constructor(serverUrl: string = 'http://localhost:3000') {
    this.socket = io(serverUrl, {
      transports: ['websocket', 'polling'], // Fallback to polling if websocket fails
      timeout: 20000, // 20 second timeout
      forceNew: true
    });

    this.setupEventHandlers();
  }

  /**
   * Sets up Socket.IO event handlers
   */
  private setupEventHandlers(): void {
    this.socket.on('connect', () => {
      console.log('Connected to file transfer server');
    });

    this.socket.on('disconnect', () => {
      console.log('Disconnected from file transfer server');
      // Cancel all active uploads
      this.activeUploads.forEach((controller) => {
        controller.abort();
      });
      this.activeUploads.clear();
    });

    this.socket.on('connect_error', (error) => {
      console.error('Connection error:', error);
    });
  }

  /**
   * Uploads a file with progress tracking
   */
  public async uploadFile(file: File, options: UploadOptions = {}): Promise<string> {
    return new Promise<string>((resolve, reject) => {
      // Generate unique upload ID
      const uploadId = this.generateUploadId();
      
      // Create abort controller for cancellation support
      const abortController = new AbortController();
      this.activeUploads.set(uploadId, abortController);

      // Validate file
      if (!this.validateFile(file)) {
        reject(new Error('File validation failed'));
        return;
      }

      // Create file metadata
      const metadata: FileMetadata = {
        fileName: file.name,
        fileSize: file.size,
        fileType: file.type,
        uploadId,
        checksum: undefined // Could implement checksum calculation here
      };

      // Set up event listeners for this upload
      const handleUploadReady = (result: UploadResult) => {
        if (result.uploadId === uploadId) {
          if (result.success) {
            options.onStart?.(uploadId);
            this.startChunkUpload(file, uploadId, options, abortController.signal)
              .then(() => resolve(uploadId))
              .catch(reject);
          } else {
            this.cleanup(uploadId);
            reject(new Error(result.error || 'Upload initialization failed'));
          }
          this.socket.off(SOCKET_EVENTS.UPLOAD_READY, handleUploadReady);
        }
      };

      const handleUploadProgress = (progress: UploadProgress) => {
        if (progress.uploadId === uploadId) {
          options.onProgress?.(progress);
        }
      };

      const handleUploadComplete = (result: UploadResult) => {
        if (result.uploadId === uploadId) {
          this.cleanup(uploadId);
          options.onComplete?.(result);
          this.socket.off(SOCKET_EVENTS.UPLOAD_COMPLETE, handleUploadComplete);
          this.socket.off(SOCKET_EVENTS.UPLOAD_PROGRESS, handleUploadProgress);
          this.socket.off(SOCKET_EVENTS.UPLOAD_ERROR, handleUploadError);
        }
      };

      const handleUploadError = (result: UploadResult) => {
        if (result.uploadId === uploadId) {
          this.cleanup(uploadId);
          const errorMessage = result.error || 'Unknown upload error';
          options.onError?.(errorMessage);
          reject(new Error(errorMessage));
          this.socket.off(SOCKET_EVENTS.UPLOAD_READY, handleUploadReady);
          this.socket.off(SOCKET_EVENTS.UPLOAD_COMPLETE, handleUploadComplete);
          this.socket.off(SOCKET_EVENTS.UPLOAD_PROGRESS, handleUploadProgress);
          this.socket.off(SOCKET_EVENTS.UPLOAD_ERROR, handleUploadError);
        }
      };

      // Register event listeners
      this.socket.on(SOCKET_EVENTS.UPLOAD_READY, handleUploadReady);
      this.socket.on(SOCKET_EVENTS.UPLOAD_PROGRESS, handleUploadProgress);
      this.socket.on(SOCKET_EVENTS.UPLOAD_COMPLETE, handleUploadComplete);
      this.socket.on(SOCKET_EVENTS.UPLOAD_ERROR, handleUploadError);

      // Handle abort signal
      abortController.signal.addEventListener('abort', () => {
        this.socket.emit(SOCKET_EVENTS.FILE_UPLOAD_CANCEL, uploadId);
        this.cleanup(uploadId);
        reject(new Error('Upload cancelled'));
      });

      // Start the upload process
      this.socket.emit(SOCKET_EVENTS.FILE_UPLOAD_START, metadata);
    });
  }

  /**
   * Starts the chunk upload process
   */
  private async startChunkUpload(
    file: File, 
    uploadId: string, 
    options: UploadOptions,
    abortSignal: AbortSignal
  ): Promise<void> {
    const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
    let chunksUploaded = 0;

    // Create a promise for each chunk
    const chunkPromises: Promise<void>[] = [];

    for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
      // Limit concurrent uploads
      if (chunkPromises.length >= MAX_CONCURRENT_CHUNKS) {
        await Promise.race(chunkPromises);
        // Remove completed promises
        const completedIndex = chunkPromises.findIndex(p => 
          p.then(() => true, () => true)
        );
        if (completedIndex !== -1) {
          chunkPromises.splice(completedIndex, 1);
        }
      }

      const chunkPromise = this.uploadChunk(
        file, 
        chunkIndex, 
        totalChunks, 
        uploadId, 
        abortSignal
      ).then(() => {
        chunksUploaded++;
      });

      chunkPromises.push(chunkPromise);
    }

    // Wait for all chunks to complete
    await Promise.all(chunkPromises);
  }

  /**
   * Uploads a single chunk
   */
  private async uploadChunk(
    file: File,
    chunkIndex: number,
    totalChunks: number,
    uploadId: string,
    abortSignal: AbortSignal
  ): Promise<void> {
    return new Promise<void>((resolve, reject) => {
      if (abortSignal.aborted) {
        reject(new Error('Upload aborted'));
        return;
      }

      const start = chunkIndex * CHUNK_SIZE;
      const end = Math.min(start + CHUNK_SIZE, file.size);
      const isLastChunk = chunkIndex === totalChunks - 1;

      // Read file chunk
      const fileReader = new FileReader();
      const blob = file.slice(start, end);

      fileReader.onload = (event) => {
        if (!event.target?.result) {
          reject(new Error('Failed to read file chunk'));
          return;
        }

        const chunk: FileChunk = {
          uploadId,
          chunkIndex,
          totalChunks,
          data: event.target.result as ArrayBuffer,
          isLastChunk
        };

        // Check abort signal before sending
        if (abortSignal.aborted) {
          reject(new Error('Upload aborted'));
          return;
        }

        // Send chunk to server
        this.socket.emit(SOCKET_EVENTS.FILE_CHUNK, chunk);
        resolve();
      };

      fileReader.onerror = () => {
        reject(new Error(`Failed to read chunk ${chunkIndex}`));
      };

      // Handle abort during file reading
      abortSignal.addEventListener('abort', () => {
        fileReader.abort();
        reject(new Error('Upload aborted'));
      });

      fileReader.readAsArrayBuffer(blob);
    });
  }

  /**
   * Validates a file before upload
   */
  private validateFile(file: File): boolean {
    // Check file size (100MB limit)
    const maxSize = 100 * 1024 * 1024;
    if (file.size > maxSize) {
      console.error(`File too large: ${file.size} bytes (max: ${maxSize})`);
      return false;
    }

    // Check if file is empty
    if (file.size === 0) {
      console.error('Cannot upload empty file');
      return false;
    }

    // Additional validations could go here (file type, etc.)
    return true;
  }

  /**
   * Generates a unique upload ID
   */
  private generateUploadId(): string {
    return `upload_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Cancels an active upload
   */
  public cancelUpload(uploadId: string): void {
    const controller = this.activeUploads.get(uploadId);
    if (controller) {
      controller.abort();
    }
  }

  /**
   * Cancels all active uploads
   */
  public cancelAllUploads(): void {
    this.activeUploads.forEach((controller) => {
      controller.abort();
    });
    this.activeUploads.clear();
  }

  /**
   * Cleans up resources for an upload
   */
  private cleanup(uploadId: string): void {
    this.activeUploads.delete(uploadId);
  }

  /**
   * Gets connection status
   */
  public isConnected(): boolean {
    return this.socket.connected;
  }

  /**
   * Disconnects from the server
   */
  public disconnect(): void {
    this.cancelAllUploads();
    this.socket.disconnect();
  }
}

// Usage example with HTML file input
export function setupFileUpload(
  fileInputId: string, 
  progressBarId: string,
  statusId: string,
  serverUrl?: string
): void {
  const fileInput = document.getElementById(fileInputId) as HTMLInputElement;
  const progressBar = document.getElementById(progressBarId) as HTMLProgressElement;
  const status = document.getElementById(statusId) as HTMLElement;
  
  const client = new FileTransferClient(serverUrl);

  fileInput.addEventListener('change', async (event) => {
    const file = (event.target as HTMLInputElement).files?.[0];
    if (!file) return;

    status.textContent = 'Uploading...';
    progressBar.value = 0;

    try {
      const uploadId = await client.uploadFile(file, {
        onProgress: (progress) => {
          progressBar.value = progress.percentage;
          status.textContent = `Uploading: ${progress.percentage.toFixed(1)}% 
            (${formatBytes(progress.speed || 0)}/s)`;
        },
        onComplete: (result) => {
          status.textContent = `Upload complete: ${result.fileName}`;
          progressBar.value = 100;
        },
        onError: (error) => {
          status.textContent = `Upload failed: ${error}`;
          progressBar.value = 0;
        }
      });
      
      console.log('Upload started with ID:', uploadId);
    } catch (error) {
      status.textContent = `Upload error: ${error}`;
      progressBar.value = 0;
    }
  });
}

// Utility function to format bytes
function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}
```

The client-side implementation handles file selection, chunking, and upload coordination with real-time progress feedback.

## Chapter 3: Complete HTML Client Example

```typescript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File Transfer Client</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
        }

        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .upload-area {
            border: 3px dashed #cbd5e0;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #667eea;
            background-color: #f7fafc;
        }

        .upload-area.dragover {
            border-color: #667eea;
            background-color: #ebf8ff;
            transform: scale(1.02);
        }

        .file-input {
            display: none;
        }

        .upload-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .upload-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .progress-container {
            margin: 20px 0;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e2e8f0;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255,255,255,0.2),
                transparent
            );
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .status {
            margin: 15px 0;
            padding: 15px;
            border-radius: 8px;
            font-weight: 500;
            text-align: center;
        }

        .status.info {
            background-color: #ebf8ff;
            color: #2b6cb0;
            border: 1px solid #bee3f8;
        }

        .status.success {
            background-color: #f0fff4;
            color: #22543d;
            border: 1px solid #c6f6d5;
        }

        .status.error {
            background-color: #fed7d7;
            color: #c53030;
            border: 1px solid #feb2b2;
        }

        .file-info {
            background: #f7fafc;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            display: none;
        }

        .file-info h3 {
            margin: 0 0 10px 0;
            color: #4a5568;
        }

        .file-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            font-size: 14px;
            color: #718096;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .cancel-button {
            background: #e53e3e;
            color: white;
            border: none;
            padding: 10px 25px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .cancel-button:hover {
            background: #c53030;
            transform: translateY(-1px);
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
        }

        .connected {
            background: #c6f6d5;
            color: #22543d;
        }

        .disconnected {
            background: #fed7d7;
            color: #c53030;
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connectionStatus">Connecting...</div>
    
    <div class="container">
        <h1>üìÅ File Transfer Client</h1>
        
        <div class="upload-area" id="uploadArea">
            <div style="font-size: 3em; margin-bottom: 20px;">‚òÅÔ∏è</div>
            <h3>Drop files here or click to browse</h3>
            <p>Maximum file size: 100MB</p>
            <button class="upload-button" onclick="document.getElementById('fileInput').click()">
                Choose Files
            </button>
            <input type="file" id="fileInput" class="file-input" multiple>
        </div>

        <div class="file-info" id="fileInfo">
            <h3>File Information</h3>
            <div class="file-details" id="fileDetails"></div>
        </div>

        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div style="display: flex; justify-content: space-between; margin-top: 10px; font-size: 14px; color: #718096;">
                <span id="progressText">0%</span>
                <span id="speedText">0 B/s</span>
            </div>
        </div>

        <div class="status info" id="status" style="display: none;">
            Ready to upload files
        </div>

        <div class="controls" id="controls" style="display: none;">
            <button class="cancel-button" onclick="cancelCurrentUpload()">Cancel Upload</button>
        </div>
    </div>

    <script>
        // File Transfer Client Implementation
        class FileTransferClient {
            constructor(serverUrl = 'http://localhost:3000') {
                this.socket = io(serverUrl);
                this.activeUploads = new Map();
                this.setupEventHandlers();
            }

            setupEventHandlers() {
                this.socket.on('connect', () => {
                    console.log('Connected to server');
                    this.updateConnectionStatus(true);
                });

                this.socket.on('disconnect', () => {
                    console.log('Disconnected from server');
                    this.updateConnectionStatus(false);
                });

                this.socket.on('connect_error', (error) => {
                    console.error('Connection error:', error);
                    this.updateConnectionStatus(false);
                });
            }

            updateConnectionStatus(connected) {
                const statusEl = document.getElementById('connectionStatus');
                if (connected) {
                    statusEl.textContent = 'üü¢ Connected';
                    statusEl.className = 'connection-status connected';
                } else {
                    statusEl.textContent = 'üî¥ Disconnected';
                    statusEl.className = 'connection-status disconnected';
                }
            }

            async uploadFile(file, options = {}) {
                return new Promise((resolve, reject) => {
                    const uploadId = this.generateUploadId();
                    const abortController = new AbortController();
                    this.activeUploads.set(uploadId, abortController);

                    const metadata = {
                        fileName: file.name,
                        fileSize: file.size,
                        fileType: file.type,
                        uploadId
                    };

                    const handleUploadReady = (result) => {
                        if (result.uploadId === uploadId) {
                            if (result.success) {
                                options.onStart?.(uploadId);
                                this.startChunkUpload(file, uploadId, options, abortController.signal)
                                    .then(() => resolve(uploadId))
                                    .catch(reject);
                            } else {
                                this.cleanup(uploadId);
                                reject(new Error(result.error || 'Upload failed'));
                            }
                            this.socket.off('upload-ready', handleUploadReady);
                        }
                    };

                    const handleProgress = (progress) => {
                        if (progress.uploadId === uploadId) {
                            options.onProgress?.(progress);
                        }
                    };

                    const handleComplete = (result) => {
                        if (result.uploadId === uploadId) {
                            this.cleanup(uploadId);
                            options.onComplete?.(result);
                            this.socket.off('upload-complete', handleComplete);
                            this.socket.off('upload-progress', handleProgress);
                            this.socket.off('upload-error', handleError);
                        }
                    };

                    const handleError = (result) => {
                        if (result.uploadId === uploadId) {
                            this.cleanup(uploadId);
                            const error = result.error || 'Unknown error';
                            options.onError?.(error);
                            reject(new Error(error));
                            this.socket.off('upload-ready', handleUploadReady);
                            this.socket.off('upload-complete', handleComplete);
                            this.socket.off('upload-progress', handleProgress);
                            this.socket.off('upload-error', handleError);
                        }
                    };

                    this.socket.on('upload-ready', handleUploadReady);
                    this.socket.on('upload-progress', handleProgress);
                    this.socket.on('upload-complete', handleComplete);
                    this.socket.on('upload-error', handleError);

                    abortController.signal.addEventListener('abort', () => {
                        this.socket.emit('file-upload-cancel', uploadId);
                        this.cleanup(uploadId);
                        reject(new Error('Upload cancelled'));
                    });

                    this.socket.emit('file-upload-start', metadata);
                });
            }

            async startChunkUpload(file, uploadId, options, abortSignal) {
                const CHUNK_SIZE = 64 * 1024; // 64KB
                const totalChunks = Math.ceil(file.size / CHUNK_SIZE);

                for (let i = 0; i < totalChunks; i++) {
                    if (abortSignal.aborted) throw new Error('Upload aborted');
                    
                    await this.uploadChunk(file, i, totalChunks, uploadId, CHUNK_SIZE);
                }
            }

            async uploadChunk(file, chunkIndex, totalChunks, uploadId, chunkSize) {
                return new Promise((resolve, reject) => {
                    const start = chunkIndex * chunkSize;
                    const end = Math.min(start + chunkSize, file.size);
                    const blob = file.slice(start, end);
                    const reader = new FileReader();

                    reader.onload = (event) => {
                        const chunk = {
                            uploadId,
                            chunkIndex,
                            totalChunks,
                            data: event.target.result,
                            isLastChunk: chunkIndex === totalChunks - 1
                        };

                        this.socket.emit('file-chunk', chunk);
                        resolve();
                    };

                    reader.onerror = () => reject(new Error('Failed to read chunk'));
                    reader.readAsArrayBuffer(blob);
                });
            }

            generateUploadId() {
                return `upload_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            }

            cancelUpload(uploadId) {
                const controller = this.activeUploads.get(uploadId);
                if (controller) {
                    controller.abort();
                }
            }

            cleanup(uploadId) {
                this.activeUploads.delete(uploadId);
            }
        }

        // UI Controller
        class UIController {
            constructor() {
                this.client = new FileTransferClient();
                this.currentUploadId = null;
                this.setupUI();
            }

            setupUI() {
                const fileInput = document.getElementById('fileInput');
                const uploadArea = document.getElementById('uploadArea');

                // File input change
                fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.handleFileSelection(e.target.files[0]);
                    }
                });

                // Drag and drop
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });

                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });

                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    
                    if (e.dataTransfer.files.length > 0) {
                        this.handleFileSelection(e.dataTransfer.files[0]);
                    }
                });

                // Click to browse
                uploadArea.addEventListener('click', () => {
                    fileInput.click();
                });
            }

            handleFileSelection(file) {
                this.showFileInfo(file);
                this.startUpload(file);
            }

            showFileInfo(file) {
                const fileInfo = document.getElementById('fileInfo');
                const fileDetails = document.getElementById('fileDetails');
                
                fileDetails.innerHTML = `
                    <div><strong>Name:</strong> ${file.name}</div>
                    <div><strong>Size:</strong> ${this.formatBytes(file.size)}</div>
                    <div><strong>Type:</strong> ${file.type || 'Unknown'}</div>
                    <div><strong>Last Modified:</strong> ${new Date(file.lastModified).toLocaleDateString()}</div>
                `;
                
                fileInfo.style.display = 'block';
            }

            async startUpload(file) {
                const progressContainer = document.getElementById('progressContainer');
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                const speedText = document.getElementById('speedText');
                const status = document.getElementById('status');
                const controls = document.getElementById('controls');

                // Show progress elements
                progressContainer.style.display = 'block';
                controls.style.display = 'block';

                try {
                    this.currentUploadId = await this.client.uploadFile(file, {
                        onStart: (uploadId) => {
                            this.showStatus('Starting upload...', 'info');
                        },
                        onProgress: (progress) => {
                            const percentage = Math.round(progress.percentage);
                            progressFill.style.width = `${percentage}%`;
                            progressText.textContent = `${percentage}%`;
                            speedText.textContent = this.formatBytes(progress.speed || 0) + '/s';
                            
                            this.showStatus(
                                `Uploading: ${this.formatBytes(progress.bytesUploaded)} / ${this.formatBytes(progress.totalBytes)}`,
                                'info'
                            );
                        },
                        onComplete: (result) => {
                            this.showStatus(`‚úÖ Upload completed: ${result.fileName}`, 'success');
                            this.resetUI();
                        },
                        onError: (error) => {
                            this.showStatus(`‚ùå Upload failed: ${error}`, 'error');
                            this.resetUI();
                        }
                    });
                } catch (error) {
                    this.showStatus(`‚ùå Upload error: ${error.message}`, 'error');
                    this.resetUI();
                }
            }

            showStatus(message, type = 'info') {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status ${type}`;
                status.style.display = 'block';
            }

            resetUI() {
                setTimeout(() => {
                    document.getElementById('progressContainer').style.display = 'none';
                    document.getElementById('controls').style.display = 'none';
                    document.getElementById('fileInfo').style.display = 'none';
                    document.getElementById('fileInput').value = '';
                    this.currentUploadId = null;
                }, 3000);
            }

            formatBytes(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
            }
        }

        // Initialize the application
        const uiController = new UIController();

        // Global function for cancel button
        function cancelCurrentUpload() {
            if (uiController.currentUploadId) {
                uiController.client.cancelUpload(uiController.currentUploadId);
                uiController.showStatus('Upload cancelled', 'error');
                uiController.resetUI();
            }
        }
    </script>
</body>
</html>

```


To demonstrate the complete implementation, let's create a full HTML client that showcases the file transfer capabilities.

## Chapter 4: Deep Dive into Architecture and Best Practices

### Understanding the Socket Communication Flow

The file transfer system operates through a carefully orchestrated sequence of events that ensure reliable data transmission:

1. **Connection Establishment**: The client establishes a WebSocket connection to the server using Socket.IO, which provides automatic reconnection and fallback to HTTP long-polling if WebSocket fails.

2. **Upload Initiation**: When a file is selected, the client sends a `file-upload-start` event containing file metadata. This allows the server to validate the request before any data transfer begins.

3. **Chunked Transfer**: Files are divided into fixed-size chunks (64KB by default) to prevent memory overflow and enable progress tracking. Each chunk contains sequence information and a flag indicating if it's the final chunk.

4. **Progress Monitoring**: The server emits progress events at regular intervals, providing real-time feedback about upload speed and completion percentage.

5. **Completion Verification**: The server validates the received file size against the expected size and emits a completion event.

### Memory Management and Performance Considerations

**Streaming vs. Buffering**: The server uses Node.js streams to write incoming chunks directly to disk, avoiding the need to buffer entire files in memory. This approach allows handling files larger than available RAM.

**Concurrency Control**: The client limits concurrent chunk uploads to prevent overwhelming the server and network. This is particularly important for large files with many chunks.

**Error Recovery**: Both client and server implement proper error handling and cleanup procedures. Incomplete files are automatically removed, and resources are freed when uploads are cancelled or fail.

### Security Considerations

**Filename Sanitization**: The server sanitizes uploaded filenames to prevent directory traversal attacks and other security vulnerabilities.

**File Size Limits**: Both client and server enforce maximum file size limits to prevent abuse and resource exhaustion.

**Upload Directory Isolation**: Files are stored in a dedicated directory with restricted permissions, separate from application code.

**Connection Authentication**: In production environments, you should implement proper authentication and authorization mechanisms to control who can upload files.

### Scalability Patterns

**Horizontal Scaling**: For multiple server instances, consider using Redis or another shared store to track upload sessions across servers.

**Load Balancing**: Socket.IO supports sticky sessions, which are required when scaling across multiple processes.

**Storage Considerations**: For production deployments, consider using cloud storage services (AWS S3, Google Cloud Storage) instead of local filesystem storage.

### Error Handling Strategies

The implementation includes comprehensive error handling at multiple levels:

- **Network-level**: Socket.IO automatically handles connection drops and provides reconnection logic
- **Application-level**: Custom error events communicate specific failure reasons to clients
- **File-level**: Checksum verification ensures data integrity (optional but recommended for critical applications)

### Testing and Debugging

When testing your file transfer implementation:

1. **Test with various file sizes**: From small text files to large media files
2. **Simulate network interruptions**: Test reconnection and resume capabilities
3. **Test concurrent uploads**: Verify the system handles multiple simultaneous uploads
4. **Monitor memory usage**: Ensure the server doesn't leak memory during large file transfers

This implementation provides a solid foundation for real-time file transfer using modern web technologies. The combination of TypeScript's type safety, Socket.IO's real-time capabilities, and Node.js's streaming performance creates a robust and scalable solution suitable for production use.