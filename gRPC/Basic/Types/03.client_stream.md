# **Chapter: Client Streaming RPC – Many Requests, One Response**

Think of walking into a restaurant. Instead of giving your full order at once, you tell the waiter:

* “One chicken biryani.”
* Then after a pause, “Also, add a mango lassi.”
* Later: “Oh, and some naan, too.”

You stream multiple requests, but in the end, the waiter comes back with a **single consolidated bill**.

That’s exactly **Client Streaming RPC**:

* **Client sends multiple messages** (stream of requests).
* **Server waits** until the stream ends.
* **Server responds once** with a final message.

---

## **1. What is Client Streaming RPC?**

* **Unary RPC:** One request → one response.
* **Server Streaming RPC:** One request → multiple responses.
* **Client Streaming RPC:** Multiple requests → one response.

In Client Streaming:

* The client opens a connection and keeps writing multiple requests (`call.write()`).
* After sending everything, the client calls `call.end()`.
* The server processes all requests and replies once.

---

## **2. Why Do We Need Client Streaming?**

You could try to use Unary RPC by sending a giant request object (like an array of data). But that has limits. Client Streaming makes sense when:

1. **Large or variable input size**

   * Example: uploading a 500 MB file. Sending it as one giant unary message is inefficient or impossible. Client Streaming lets you break it into **chunks**.

2. **Progressive input**

   * Sometimes the client **doesn’t know all inputs upfront**. For example, sensor readings coming in gradually. Client can keep streaming until done.

3. **Efficiency**

   * Instead of multiple Unary calls (one for each piece of data), Client Streaming reduces overhead by keeping **one connection open**.

👉 Client Streaming is like saying: *“I’ll send you pieces of the puzzle, and when I’m done, you give me the final picture.”*

---

## **3. Defining Client Streaming in Protobuf**

Let’s create a service where a client streams multiple numbers to the server, and the server replies with their **sum**.

```proto
syntax = "proto3";

package calculator;

message Number {
  int32 value = 1;
}

message SumResult {
  int32 sum = 1;
}

service Calculator {
  // Client streaming: multiple Number requests, one SumResult response
  rpc ComputeSum (stream Number) returns (SumResult);
}
```

Notice the `stream` keyword is now **before the request type**, not the response.

---

## **4. Server-Side Implementation**

In Node.js:

```js
function ComputeSum(call, callback) {
  let total = 0;

  // Handle each incoming request
  call.on("data", (number) => {
    console.log("Received:", number.value);
    total += number.value;
  });

  // When client finishes streaming
  call.on("end", () => {
    callback(null, { sum: total });
  });
}
```

* `call.on("data")`: triggered for every streamed request.
* `call.on("end")`: client finished sending → server replies once.

---

## **5. Client-Side Streaming**

Client sends multiple requests before closing:

```js
const call = client.ComputeSum((err, response) => {
  if (err) {
    console.error("Error:", err);
  } else {
    console.log("Final Sum:", response.sum);
  }
});

// Send multiple requests
call.write({ value: 10 });
call.write({ value: 20 });
call.write({ value: 30 });

// End the stream
call.end();
```

---

## **6. Lifecycle of a Client Streaming RPC**

1. **Client starts the call.**
2. **Client sends multiple requests** (`call.write()`).
3. **Client ends the stream** (`call.end()`).
4. **Server processes all requests.**
5. **Server responds with one final message.**

---

## **7. Real-World Example**

### **Banking System – Deposit Transactions**

Imagine a user wants to deposit money multiple times in one session:

* Deposit 500 BDT.
* Deposit 1200 BDT.
* Deposit 300 BDT.

Instead of making 3 separate RPC calls (Unary), the client streams all deposits, and the server replies with:

> “✅ Total deposited: 2000 BDT.”

This pattern reduces **round-trips** and is efficient when many inputs must be aggregated into **one meaningful result**.

---

## **8. Pros and Cons**

**Pros:**

* Efficient for sending large or continuous data sets.
* Client doesn’t need to know all data upfront.
* Reduces multiple calls into a single session.

**Cons:**

* More complex than Unary.
* Server only responds once (so client waits longer for result).
* Not good for real-time feedback (Server Streaming or BiDi Streaming is better for that).

---

## **Key Takeaways**

* **Client Streaming = multiple requests, single response.**
* Useful for large uploads, incremental inputs, or aggregating many values.
* Defined in `.proto` with `rpc MethodName (stream Request) returns (Response);`.
* Server listens with `call.on("data")` and responds once on `call.on("end")`.
* Client writes many times, then closes with `call.end()`.

---

👉 Unary RPC: *“Tell me one thing.”*
👉 Server Streaming: *“Tell me one thing, but give me many answers.”*
👉 Client Streaming: *“I’ll tell you many things, and you give me one final answer.”*