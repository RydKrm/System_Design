## **Chapter: Unary RPCs – The Classic Call and Response**

When people talk to each other, most exchanges are **one-to-one**:

* You ask a question.
* I give you an answer.

That’s exactly what a **Unary RPC (Remote Procedure Call)** models.

It’s the simplest pattern in gRPC: **one request from the client, one response from the server.**

---

### **1. What is a Unary RPC?**

In gRPC, a Unary RPC works like calling a local function:

```ts
response = Service.Method(request)
```

But instead of running inside the same process, the request travels over the network. gRPC + Protobuf handle the heavy lifting:

* Serialize the request (turn it into bytes).
* Send it to the server.
* Server runs the method.
* Serialize the response.
* Send it back to the client.

From the developer’s perspective, it still *feels* like a normal function call.

---

### **2. Why Unary RPCs Exist**

They exist because most business logic fits this pattern:

* “Get me user details.”
* “Place an order.”
* “Validate my login.”

In REST, the same thing would be a `GET` or `POST`. In gRPC, it’s a Unary RPC.

Advantages:

* **Type-safe:** request and response must match the `.proto` contract.
* **Efficient:** binary serialization (Protobuf) → smaller and faster than JSON/HTTP.
* **Simple:** easiest entry point into gRPC before tackling streaming.

---

### **3. Defining a Unary RPC in Protobuf**

Here’s a `.proto` file for a simple user lookup service:

```proto
syntax = "proto3";

package users;

message GetUserRequest {
  int32 id = 1;
}

message GetUserResponse {
  int32 id = 1;
  string name = 2;
  bool active = 3;
}

service UserService {
  // Unary RPC: one request, one response
  rpc GetUser (GetUserRequest) returns (GetUserResponse);
}
```

* **Request message**: carries the input (`id`).
* **Response message**: carries the output (`id`, `name`, `active`).
* **Service**: `UserService` defines the API.
* **Method**: `GetUser` is declared as `rpc Request returns Response`.

---

### **4. Server-Side Flow**

On the server, you implement the logic. Example (Node.js style):

```js
function GetUser(call, callback) {
  const userId = call.request.id;
  // Mock lookup
  const user = { id: userId, name: "Alice", active: true };
  callback(null, user);
}
```

Steps:

1. The server receives the request object (`call.request`).
2. Executes business logic (e.g., database lookup).
3. Builds a response object.
4. Sends it back with `callback`.

---

### **5. Client-Side Flow**

The client just calls it like a function:

```js
client.GetUser({ id: 123 }, (err, response) => {
  if (!err) {
    console.log("User:", response);
  }
});
```

* The client stub (`client.GetUser`) was auto-generated from the `.proto`.
* You pass the request object.
* You receive the response object.

Under the hood, gRPC:

* Opens an HTTP/2 stream.
* Sends Protobuf-encoded request.
* Waits for the server’s response.
* Decodes it back into a usable object.

---

### **6. Lifecycle of a Unary RPC**

1. **Client constructs request.**
2. **Protobuf serialization.** → turns `{ id: 123 }` into compact bytes.
3. **gRPC transport.** → sends it via HTTP/2 to the server.
4. **Server receives + deserializes.**
5. **Business logic executes.**
6. **Server serializes response.**
7. **Client receives + deserializes.**
8. **Application consumes result.**

All this happens in milliseconds.

---

### **7. Example Use Cases**

Unary RPCs fit well in classic request-response interactions:

* Fetch a product by ID.
* Authenticate a user.
* Submit a payment.
* Ask for weather at a location.

Whenever you’d normally think “API endpoint,” Unary RPC is your go-to in gRPC.

---

### **8. Pros and Cons**

**Pros:**

* Simple, intuitive.
* Easy to migrate from REST.
* Great for most business calls.

**Cons:**

* Not optimal when multiple messages need to flow in sequence (that’s where streaming RPCs shine).
* Still requires setup of `.proto` and gRPC server/client.

---

### **Key Takeaways**

* **Unary RPC = one request, one response.**
* It feels like calling a function, but runs across a network.
* Defined in `.proto` with `rpc Method(Request) returns (Response)`.
* Best for simple, transactional operations.
* It’s the foundation—you master this before moving to streaming RPCs.

---