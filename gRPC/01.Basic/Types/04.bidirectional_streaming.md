# **Chapter: Bidirectional Streaming RPC – Many Requests, Many Responses**

Imagine a **chat application**. You and I are exchanging messages continuously:

* I type a message → you receive it.
* You reply → I receive it.
* We keep going, back and forth.

This is exactly **Bidirectional Streaming**:

* **Client sends multiple requests**.
* **Server sends multiple responses**.
* Both streams operate independently and simultaneously.

---

## **1. What is Bidirectional Streaming?**

* Unlike **Unary RPC** (1 ↔ 1), **Server Streaming** (1 → many), and **Client Streaming** (many → 1), **Bidirectional Streaming** allows:

```
Client <----> Server
Many requests   Many responses
```

* The client and server can send messages **at their own pace**.
* No need to wait for the other side to finish first.

---

## **2. Why Do We Need Bidirectional Streaming?**

Some scenarios demand **real-time, two-way communication**:

1. **Chat / Messaging Systems**

   * Multiple messages sent by client, server replies with new messages as they arrive.

2. **Real-time Data Processing**

   * IoT devices streaming sensor data, server sending alerts or feedback instantly.

3. **Collaborative Applications**

   * Multiplayer games, document editing, live auctions.

**Unary RPC or single-direction streaming cannot handle this elegantly**, because they are either one-shot or one-way. BiDi Streaming solves this.

---

## **3. Defining Bidirectional Streaming in Protobuf**

Let’s define a simple chat service:

```proto
syntax = "proto3";

package chat;

message ChatMessage {
  string user = 1;
  string message = 2;
}

service ChatService {
  // BiDi streaming: multiple requests, multiple responses
  rpc Chat (stream ChatMessage) returns (stream ChatMessage);
}
```

* `stream` appears **on both request and response**.
* This tells gRPC that messages can flow **in both directions** independently.

---

## **4. Server-Side Implementation**

Node.js example:

```js
function Chat(call) {
  // When a client sends a message
  call.on("data", (msg) => {
    console.log(`${msg.user}: ${msg.message}`);

    // Respond immediately with acknowledgment
    call.write({ user: "Server", message: `Received: ${msg.message}` });
  });

  call.on("end", () => {
    console.log("Client ended the chat.");
    call.end(); // close the server stream
  });
}
```

* `call.on("data")` → triggered for every incoming client message.
* `call.write()` → server can respond instantly, multiple times.
* `call.on("end")` → client closes its sending stream; server ends its stream.

---

## **5. Client-Side Implementation**

Node.js example:

```js
const call = client.Chat();

// Listen to server messages
call.on("data", (msg) => {
  console.log(`${msg.user}: ${msg.message}`);
});

// Send messages to server
call.write({ user: "Alice", message: "Hi Server!" });
call.write({ user: "Alice", message: "How are you?" });

// End client stream when done
// (server can still send messages until it decides to end)
call.end();
```

* The client can **send multiple messages asynchronously**.
* The client listens for responses in real-time via `data` event.

---

## **6. Lifecycle of a Bidirectional Streaming RPC**

1. Client opens stream.
2. Server opens stream.
3. **Client sends multiple messages** (`call.write()`).
4. **Server sends multiple messages** (`call.write()`).
5. Both streams operate **independently**, can be interleaved.
6. Either side closes the stream → the other side is notified.

---

## **7. Real-World Example**

### **Collaborative Document Editing**

* Multiple users are editing a document simultaneously.

* Each keystroke or update is sent as a **streamed request**.

* The server processes and broadcasts updates as **streamed responses** to all clients.

* Benefits:

  * Low latency updates.
  * Real-time synchronization.
  * Efficient use of one persistent connection instead of many short calls.

Another example: **stock price alerts**

* Client streams subscription requests for certain stocks.
* Server streams price updates as they happen.

---

## **8. Pros and Cons**

**Pros:**

* Full-duplex communication → real-time, interactive applications.
* Reduces latency; messages processed as they arrive.
* Single persistent connection → fewer overheads.

**Cons:**

* More complex to implement and manage.
* Both server and client must handle asynchronous streams carefully.
* Error handling and connection management is critical.

---

## **Key Takeaways**

* **Bidirectional Streaming = multiple requests, multiple responses.**
* Both sides operate independently.
* Defined in `.proto` with `rpc MethodName (stream Request) returns (stream Response);`.
* Ideal for **chat apps, live data feeds, collaborative tools, and games**.
* It’s the ultimate flexibility pattern in gRPC.

---

👉 Unary RPC: *“Ask once, answer once.”*
👉 Server Streaming: *“Ask once, get many answers.”*
👉 Client Streaming: *“Send many, get one answer.”*
👉 Bidirectional Streaming: *“Send many, receive many, in real-time.”*

---