## **Chapter: Protobuf Syntax and Data Types**

Before you can use Protocol Buffers in your project, you need to know how to *speak its grammar*. That grammar lives in `.proto` files. Think of these as **contracts**: they describe exactly what data looks like, down to its fields and types.

The Protobuf compiler (`protoc`) then reads this contract and generates source code for you in whatever language you want.

---

### **1. Syntax Declaration**

Every `.proto` file starts with a `syntax` line:

```proto
syntax = "proto3";
```

* This declares which version of Protobuf rules you’re following.
* **`proto3`** is the modern standard (simpler than `proto2`, which had required/optional keywords).
* Always put this line first—without it, Protobuf assumes old defaults.

---

### **2. Defining a Message**

The heart of Protobuf is the **message**. A message is like a class or struct—it groups related fields into a single object.

Example:

```proto
message User {
  int32 id = 1;
  string name = 2;
  bool is_active = 3;
}
```

* `message` → keyword introducing a new type.
* `User` → the name of the message type.
* Each field has:

  * **Type** (`int32`, `string`, `bool`)
  * **Name** (`id`, `name`, `is_active`)
  * **Tag number** (`= 1`, `= 2`, `= 3`)

The **tag number** is critical. This number uniquely identifies a field in the binary encoding. Once assigned, you should never reuse it for a different field.

---

### **3. Field Rules**

In proto3, all fields are **optional by default**. That means they can be present or absent.

* If absent, they take a **default value** (0 for numbers, empty string for strings, false for booleans).
* You can mark a field as `repeated` if it can appear multiple times (like an array).

Example:

```proto
message Post {
  int32 id = 1;
  string content = 2;
  repeated string tags = 3; // array of strings
}
```

Here, `tags` can hold multiple values: `["golang", "grpc", "protobuf"]`.

---

### **4. Basic Scalar Data Types**

Protobuf supports a set of built-in primitive types. They map neatly to common programming languages:

| Protobuf Type | Meaning                         | Default Value |
| ------------- | ------------------------------- | ------------- |
| `int32`       | 32-bit signed integer           | 0             |
| `int64`       | 64-bit signed integer           | 0             |
| `uint32`      | 32-bit unsigned integer         | 0             |
| `uint64`      | 64-bit unsigned integer         | 0             |
| `sint32`      | Signed int with ZigZag encoding | 0             |
| `sint64`      | Same, 64-bit                    | 0             |
| `bool`        | Boolean                         | false         |
| `string`      | UTF-8 text                      | ""            |
| `bytes`       | Raw sequence of bytes           | empty         |
| `float`       | 32-bit floating point           | 0.0           |
| `double`      | 64-bit floating point           | 0.0           |

Notes:

* `sint32`/`sint64` are optimized for negative numbers (they use ZigZag encoding).
* `bytes` is for arbitrary binary data (images, files, etc.).

---

### **5. Nested Messages**

Messages can contain other messages, allowing you to model complex objects.

```proto
message User {
  int32 id = 1;
  string name = 2;

  message Address {
    string street = 1;
    string city = 2;
  }

  Address address = 3;
}
```

Here, `User` has an `Address` nested inside. In generated code, this becomes a structured object.

---

### **6. Enumerations (Enums)**

Protobuf also supports **enums**, useful for fixed sets of values.

```proto
enum Status {
  UNKNOWN = 0; // must start at 0
  ACTIVE = 1;
  INACTIVE = 2;
}

message User {
  int32 id = 1;
  string name = 2;
  Status status = 3;
}
```

* Enums map to integers in binary.
* By convention, the first value is `0`.

---

### **7. Packages and Imports**

To organize your `.proto` files, you can use `package` (like namespaces) and `import`.

```proto
syntax = "proto3";

package ecommerce;

import "google/protobuf/timestamp.proto";

message Order {
  int32 id = 1;
  google.protobuf.Timestamp created_at = 2;
}
```

This way you can keep things modular across large systems.

---

### **8. Services (for gRPC)**

While Protobuf itself is about data, you can also define **RPC services** inside `.proto` files (used with gRPC).

```proto
service UserService {
  rpc GetUser(UserRequest) returns (UserResponse);
}
```

This describes an API endpoint: `GetUser` takes a `UserRequest` and returns a `UserResponse`.

---

### **Key Takeaways**

* `.proto` files define the **structure** of your data, not the logic.
* Every field has a **type**, **name**, and **unique tag number**.
* Proto3 makes all fields optional by default, with sensible defaults.
* You get arrays via `repeated`, choices via `enum`, and nesting via sub-messages.
* Messages are strongly typed, compact, and future-proof if you handle field numbers correctly.

---