# Docker Networking: Complete Guide for Microservices

## How Containers Connect and Communicate

## Table of Contents

1. [Docker Networking Fundamentals](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#fundamentals)
2. [How Container Communication Works](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#communication)
3. [Docker Network Types](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#network-types)
4. [Microservices Communication Example](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#microservices-example)
5. [DNS and Service Discovery](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#dns-discovery)
6. [Network Isolation and Security](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#isolation)
7. [Real-World Microservices Setup](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#real-world)
8. [Advanced Networking Concepts](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#advanced)
9. [Troubleshooting Network Issues](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#troubleshooting)
10. [Best Practices](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#best-practices)

---

## Docker Networking Fundamentals {#fundamentals}

### What is Docker Networking?

**Simple Explanation:** Docker networking allows containers to communicate with each other and with the outside world. It creates virtual networks that connect containers together.

### The Basic Concept

```
WITHOUT DOCKER NETWORK:
═══════════════════════════════════════════════════
Containers are isolated, can't talk to each other

┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│ Container 1  │  │ Container 2  │  │ Container 3  │
│ (isolated)   │  │ (isolated)   │  │ (isolated)   │
└──────────────┘  └──────────────┘  └──────────────┘
      ✗                 ✗                 ✗
   Can't communicate!

WITH DOCKER NETWORK:
═══════════════════════════════════════════════════
Containers on same network can communicate

┌─────────────────────────────────────────────────┐
│          Docker Network: mynetwork              │
│                                                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│  │ Container 1  │  │ Container 2  │  │ Container 3  │
│  │ 172.18.0.2   │━━│ 172.18.0.3   │━━│ 172.18.0.4   │
│  └──────────────┘  └──────────────┘  └──────────────┘
│         ✓                ✓                 ✓        │
└─────────────────────────────────────────────────┘
   Can communicate by IP or name!
```

---

## How Container Communication Works {#communication}

### The Complete Communication Flow

Let me show you EXACTLY how containers talk to each other:

```
SCENARIO: Frontend calls Backend API
═══════════════════════════════════════════════════

Step 1: Create Network
$ docker network create myapp-network

Step 2: Start Backend
$ docker run -d \
  --name backend \
  --network myapp-network \
  -p 8080:8080 \
  backend-image

Step 3: Start Frontend
$ docker run -d \
  --name frontend \
  --network myapp-network \
  -p 3000:3000 \
  frontend-image

Now they can communicate!
```

### Visual: Complete Communication Flow

```
DETAILED COMMUNICATION PROCESS:
═══════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────┐
│ Host Machine (Your Computer)                           │
│ IP: 192.168.1.100                                       │
│                                                         │
│  ┌────────────────────────────────────────────────┐    │
│  │ Docker Network: myapp-network                  │    │
│  │ Subnet: 172.18.0.0/16                         │    │
│  │                                                │    │
│  │  ┌──────────────────┐    ┌──────────────────┐ │    │
│  │  │ Frontend         │    │ Backend          │ │    │
│  │  │ Container        │    │ Container        │ │    │
│  │  │                  │    │                  │ │    │
│  │  │ Name: frontend   │    │ Name: backend    │ │    │
│  │  │ IP: 172.18.0.2   │    │ IP: 172.18.0.3   │ │    │
│  │  │ Port: 3000       │    │ Port: 8080       │ │    │
│  │  └────────┬─────────┘    └────────▲─────────┘ │    │
│  │           │                       │           │    │
│  │           │  HTTP Request         │           │    │
│  │           │  GET http://backend:8080/api      │    │
│  │           └───────────────────────┘           │    │
│  │                                                │    │
│  └────────────────────────────────────────────────┘    │
│           │                                             │
│           │ Port Mapping                                │
│           ▼                                             │
│  Host: localhost:3000 ──→ frontend:3000                │
│  Host: localhost:8080 ──→ backend:8080                 │
└─────────────────────────────────────────────────────────┘
           │
           │ Internet Access
           ▼
     [External World]
```

### Step-by-Step: How Frontend Calls Backend

```
COMMUNICATION SEQUENCE:
═══════════════════════════════════════════════════

1. Frontend wants to call Backend API
   Frontend code: fetch('http://backend:8080/api/users')
   
2. Frontend container looks up "backend"
   ├─ Queries Docker's internal DNS server
   └─ DNS returns: backend = 172.18.0.3

3. Frontend creates TCP connection
   ├─ Source: 172.18.0.2:random_port
   └─ Destination: 172.18.0.3:8080

4. Network routes packet
   ├─ Both containers on myapp-network
   ├─ Direct communication (no NAT needed)
   └─ Packet delivered to backend container

5. Backend receives request
   ├─ Backend app listening on port 8080
   ├─ Processes request
   └─ Sends response back

6. Frontend receives response
   └─ Data returned to frontend app

ENTIRE PROCESS: ~10 milliseconds!
```

### Visual: Packet Flow

```
PACKET JOURNEY:
═══════════════════════════════════════════════════

Time 0ms: Frontend sends HTTP request
┌──────────────────────────────────────┐
│ Frontend Container (172.18.0.2)      │
│                                      │
│ Application: fetch('http://backend..│
│     ↓                                │
│ TCP/IP Stack                         │
│     ↓                                │
│ Network Interface (eth0)             │
└──────────────┬───────────────────────┘
               │ Packet:
               │ From: 172.18.0.2:45678
               │ To: 172.18.0.3:8080
               │ Data: GET /api/users
               ▼
┌──────────────────────────────────────┐
│ Docker Bridge Network                │
│ (Virtual Switch)                     │
│                                      │
│ Routing decision:                    │
│ Destination 172.18.0.3 is on this   │
│ network, forward directly            │
└──────────────┬───────────────────────┘
               │ Packet forwarded
               ▼
┌──────────────────────────────────────┐
│ Backend Container (172.18.0.3)      │
│                                      │
│ Network Interface (eth0)             │
│     ↓                                │
│ TCP/IP Stack                         │
│     ↓                                │
│ Application: Express server on :8080 │
│     ↓                                │
│ Process request, generate response   │
└──────────────────────────────────────┘

Time 10ms: Response sent back
(Same path in reverse)
```

---

## Docker Network Types {#network-types}

### 1. Bridge Network (Most Common for Microservices)

```
BRIDGE NETWORK:
═══════════════════════════════════════════════════

Default for user-created networks
Containers get private IPs
Can communicate by name (DNS)

┌─────────────────────────────────────────────────┐
│ Host: 192.168.1.100                             │
│                                                 │
│  ┌───────────────────────────────────────────┐ │
│  │ Bridge Network: docker0                   │ │
│  │ Subnet: 172.17.0.0/16                     │ │
│  │                                           │ │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  │ │
│  │  │ Web     │  │ API     │  │ DB      │  │ │
│  │  │172.17.0.2│ │172.17.0.3│ │172.17.0.4│ │ │
│  │  └─────────┘  └─────────┘  └─────────┘  │ │
│  │                                           │ │
│  └───────────────────────────────────────────┘ │
│         │                                       │
│         │ NAT (Network Address Translation)     │
│         ▼                                       │
│  eth0: 192.168.1.100                           │
└─────────────────────────────────────────────────┘
         │
         │ Internet
         ▼
```

**Create and Use:**

```bash
# Create bridge network
$ docker network create myapp-network

# Inspect network
$ docker network inspect myapp-network
[
  {
    "Name": "myapp-network",
    "Driver": "bridge",
    "Subnet": "172.18.0.0/16",
    "Gateway": "172.18.0.1"
  }
]

# Connect container to network
$ docker run -d \
  --name web \
  --network myapp-network \
  nginx

# Container gets:
# - IP address: 172.18.0.2
# - DNS name: web
# - Can reach other containers by name
```

### 2. Host Network

```
HOST NETWORK:
═══════════════════════════════════════════════════

Container shares host's network stack
No network isolation
Best performance (no bridge overhead)

┌─────────────────────────────────────────────────┐
│ Host Network: 192.168.1.100                     │
│                                                 │
│  Container uses host's network directly         │
│  ┌───────────────────────────────────────────┐ │
│  │ Container                                 │ │
│  │ - No separate IP                          │ │
│  │ - Uses host's 192.168.1.100              │ │
│  │ - Port 80 on container = Port 80 on host │ │
│  └───────────────────────────────────────────┘ │
└─────────────────────────────────────────────────┘
```

**When to Use:**

```bash
# Use for:
✓ Maximum performance
✓ Network monitoring tools
✓ Services that need host network

# Don't use for:
✗ Multiple containers on same port
✗ Network isolation needed
✗ Port conflicts

# Usage:
$ docker run --network host nginx
# nginx binds to host's port 80 directly
```

### 3. None Network

```
NONE NETWORK:
═══════════════════════════════════════════════════

No network access at all
Complete isolation

┌─────────────────────────────────────────────────┐
│ Container with network: none                    │
│  ┌───────────────────────────────────────────┐ │
│  │ Container                                 │ │
│  │ - No network interface                    │ │
│  │ - No IP address                           │ │
│  │ - Can't communicate                       │ │
│  └───────────────────────────────────────────┘ │
└─────────────────────────────────────────────────┘
```

**When to Use:**

```bash
# Use for:
✓ Batch processing (no network needed)
✓ Maximum security
✓ Testing in isolation

# Usage:
$ docker run --network none myapp
```

### 4. Custom Networks (User-Defined Bridge)

```
CUSTOM BRIDGE NETWORK:
═══════════════════════════════════════════════════

Better than default bridge:
✓ Automatic DNS resolution
✓ Better isolation
✓ Custom configuration

$ docker network create \
  --driver bridge \
  --subnet 172.20.0.0/16 \
  --gateway 172.20.0.1 \
  custom-network
```

---

## Microservices Communication Example {#microservices-example}

### Scenario: E-Commerce Application with 5 Services

Let me show you a COMPLETE microservices setup with 5 services:

```
ARCHITECTURE:
═══════════════════════════════════════════════════

┌─────────────────────────────────────────────────┐
│ API Gateway (nginx)                             │
│ Port: 80                                        │
│ Routes requests to services                     │
└──────────┬──────────────────────────────────────┘
           │
     ┌─────┴─────┬──────────┬──────────┐
     │           │          │          │
     ▼           ▼          ▼          ▼
┌─────────┐ ┌─────────┐ ┌────────┐ ┌────────┐
│ User    │ │ Product │ │ Order  │ │ Payment│
│ Service │ │ Service │ │ Service│ │ Service│
│ :3001   │ │ :3002   │ │ :3003  │ │ :3004  │
└────┬────┘ └────┬────┘ └────┬───┘ └────┬───┘
     │           │          │         │
     └───────────┴──────────┴─────────┘
                 │
                 ▼
         ┌──────────────┐
         │ PostgreSQL   │
         │ Database     │
         │ :5432        │
         └──────────────┘
```

### Docker Compose Setup

```yaml
# docker-compose.yml
version: '3.8'

services:
  # API Gateway (Entry point)
  gateway:
    image: nginx:alpine
    container_name: api-gateway
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    networks:
      - frontend-network
    depends_on:
      - user-service
      - product-service
      - order-service
      - payment-service

  # Service 1: User Service
  user-service:
    build: ./services/user-service
    container_name: user-service
    ports:
      - "3001:3001"
    environment:
      - SERVICE_NAME=user-service
      - DATABASE_URL=postgres://postgres:password@database:5432/users
      - PORT=3001
    networks:
      - frontend-network
      - backend-network
    depends_on:
      - database

  # Service 2: Product Service
  product-service:
    build: ./services/product-service
    container_name: product-service
    ports:
      - "3002:3002"
    environment:
      - SERVICE_NAME=product-service
      - DATABASE_URL=postgres://postgres:password@database:5432/products
      - PORT=3002
    networks:
      - frontend-network
      - backend-network
    depends_on:
      - database

  # Service 3: Order Service
  order-service:
    build: ./services/order-service
    container_name: order-service
    ports:
      - "3003:3003"
    environment:
      - SERVICE_NAME=order-service
      - DATABASE_URL=postgres://postgres:password@database:5432/orders
      - USER_SERVICE_URL=http://user-service:3001
      - PRODUCT_SERVICE_URL=http://product-service:3002
      - PAYMENT_SERVICE_URL=http://payment-service:3004
      - PORT=3003
    networks:
      - frontend-network
      - backend-network
    depends_on:
      - database
      - user-service
      - product-service
      - payment-service

  # Service 4: Payment Service
  payment-service:
    build: ./services/payment-service
    container_name: payment-service
    ports:
      - "3004:3004"
    environment:
      - SERVICE_NAME=payment-service
      - DATABASE_URL=postgres://postgres:password@database:5432/payments
      - PORT=3004
    networks:
      - frontend-network
      - backend-network
    depends_on:
      - database

  # Database
  database:
    image: postgres:14
    container_name: postgres-db
    environment:
      - POSTGRES_PASSWORD=password
      - POSTGRES_MULTIPLE_DATABASES=users,products,orders,payments
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-databases.sh:/docker-entrypoint-initdb.d/init-databases.sh
    networks:
      - backend-network
    ports:
      - "5432:5432"

# Networks
networks:
  frontend-network:
    driver: bridge
  backend-network:
    driver: bridge

# Volumes
volumes:
  postgres_data:
```

### Network Topology Explanation

```
NETWORK SEGMENTATION:
═══════════════════════════════════════════════════

┌─────────────────────────────────────────────────┐
│ frontend-network (172.18.0.0/16)               │
│                                                 │
│  ┌───────────┐                                 │
│  │  Gateway  │ (Exposed: port 80)              │
│  │172.18.0.2 │                                 │
│  └─────┬─────┘                                 │
│        │                                       │
│    ┌───┴───┬───────────┬───────────┐         │
│    ▼       ▼           ▼           ▼         │
│ ┌─────┐ ┌─────┐ ┌───────┐ ┌─────────┐       │
│ │User │ │Prod │ │ Order │ │ Payment │       │
│ │.0.3 │ │.0.4 │ │  .0.5 │ │   .0.6  │       │
│ └──┬──┘ └──┬──┘ └───┬───┘ └────┬────┘       │
└────┼──────┼────────┼──────────┼─────────────┘
     │      │        │          │
     │      │        │          │ (Both networks)
┌────┼──────┼────────┼──────────┼─────────────┐
│ backend-network (172.19.0.0/16)              │
│    ▼      ▼        ▼          ▼              │
│ ┌─────┐ ┌─────┐ ┌───────┐ ┌─────────┐       │
│ │User │ │Prod │ │ Order │ │ Payment │       │
│ │.0.2 │ │.0.3 │ │  .0.4 │ │   .0.5  │       │
│ └──┬──┘ └──┬──┘ └───┬───┘ └────┬────┘       │
│    │       │        │           │            │
│    └───────┴────────┴───────────┘            │
│                     │                        │
│                     ▼                        │
│            ┌──────────────┐                  │
│            │  Database    │                  │
│            │  172.19.0.6  │                  │
│            └──────────────┘                  │
└─────────────────────────────────────────────┘

SECURITY:
✓ Gateway can reach all services (frontend-network)
✓ Services can reach each other (frontend-network)
✓ Services can reach database (backend-network)
✗ Gateway CANNOT reach database directly
✗ Database only accessible from services
```

### How Services Communicate

```javascript
// order-service/index.js
// How Order Service calls other services

const express = require('express');
const axios = require('axios');
const app = express();

// Service URLs from environment
const USER_SERVICE = process.env.USER_SERVICE_URL;    // http://user-service:3001
const PRODUCT_SERVICE = process.env.PRODUCT_SERVICE_URL;  // http://product-service:3002
const PAYMENT_SERVICE = process.env.PAYMENT_SERVICE_URL;  // http://payment-service:3004

// Create order endpoint
app.post('/orders', async (req, res) => {
  const { userId, productId, quantity } = req.body;
  
  try {
    // Step 1: Verify user exists (call user-service)
    console.log(`Calling ${USER_SERVICE}/users/${userId}`);
    const userResponse = await axios.get(`${USER_SERVICE}/users/${userId}`);
    const user = userResponse.data;
    
    // Step 2: Get product details (call product-service)
    console.log(`Calling ${PRODUCT_SERVICE}/products/${productId}`);
    const productResponse = await axios.get(`${PRODUCT_SERVICE}/products/${productId}`);
    const product = productResponse.data;
    
    // Step 3: Calculate total
    const totalAmount = product.price * quantity;
    
    // Step 4: Process payment (call payment-service)
    console.log(`Calling ${PAYMENT_SERVICE}/payments`);
    const paymentResponse = await axios.post(`${PAYMENT_SERVICE}/payments`, {
      userId,
      amount: totalAmount
    });
    
    // Step 5: Create order in database
    const order = await createOrderInDB({
      userId,
      productId,
      quantity,
      totalAmount,
      paymentId: paymentResponse.data.id
    });
    
    res.json(order);
    
  } catch (error) {
    console.error('Error creating order:', error.message);
    res.status(500).json({ error: 'Failed to create order' });
  }
});

app.listen(3003, () => {
  console.log('Order Service listening on port 3003');
});
```

### Communication Flow for Creating Order

```
INTER-SERVICE COMMUNICATION FLOW:
═══════════════════════════════════════════════════

Client Request:
POST http://localhost/api/orders
{
  "userId": 123,
  "productId": 456,
  "quantity": 2
}

Step 1: Gateway → Order Service
┌──────────────┐
│   Gateway    │
└──────┬───────┘
       │ POST /api/orders
       │ (nginx forwards to order-service)
       ▼
┌──────────────┐
│Order Service │
│ :3003        │
└──────┬───────┘
       │
       │ [Order Service makes 3 internal calls]
       │
       ├─→ Step 2: Order Service → User Service
       │   GET http://user-service:3001/users/123
       │   ┌──────────────┐
       │   │ User Service │
       │   │ :3001        │
       │   └──────┬───────┘
       │          │ Returns user data
       │   ←──────┘
       │
       ├─→ Step 3: Order Service → Product Service
       │   GET http://product-service:3002/products/456
       │   ┌─────────────────┐
       │   │ Product Service │
       │   │ :3002           │
       │   └──────┬──────────┘
       │          │ Returns product data
       │   ←──────┘
       │
       └─→ Step 4: Order Service → Payment Service
           POST http://payment-service:3004/payments
           ┌─────────────────┐
           │ Payment Service │
           │ :3004           │
           └──────┬──────────┘
                  │ Returns payment confirmation
           ←──────┘

Step 5: Order Service → Database
┌──────────────┐
│Order Service │
└──────┬───────┘
       │ INSERT INTO orders...
       ▼
┌──────────────┐
│  PostgreSQL  │
│  :5432       │
└──────────────┘

Step 6: Response to Client
┌──────────────┐
│Order Service │
└──────┬───────┘
       │ Order created successfully
       ▼
┌──────────────┐
│   Gateway    │
└──────┬───────┘
       │ 200 OK { orderId: 789, ... }
       ▼
    Client
```

---

## DNS and Service Discovery {#dns-discovery}

### How Docker DNS Works

```
DOCKER DNS RESOLUTION:
═══════════════════════════════════════════════════

When container calls: http://backend:8080

Step 1: Application makes DNS query
┌──────────────────────────────┐
│ Container: frontend          │
│                              │
│ Code: fetch('http://backend')│
│   ↓                          │
│ OS: "What is IP of backend?" │
└──────────────┬───────────────┘
               │ DNS Query
               ▼
Step 2: Docker's embedded DNS
┌──────────────────────────────┐
│ Docker DNS Server            │
│ (Runs on 127.0.0.11)        │
│                              │
│ Checks network:              │
│ Is "backend" on same network?│
│ Yes! IP is 172.18.0.3       │
└──────────────┬───────────────┘
               │ DNS Response
               ▼
Step 3: Container gets IP
┌──────────────────────────────┐
│ Container: frontend          │
│                              │
│ Resolved: backend = 172.18.0.3│
│   ↓                          │
│ Connect to 172.18.0.3:8080  │
└──────────────────────────────┘
```

### DNS Resolution Examples

```bash
# Inside frontend container
$ docker exec frontend nslookup backend
Server:    127.0.0.11  # Docker's DNS
Address:   127.0.0.11:53

Name:      backend
Address:   172.18.0.3  # Backend's IP

# Ping by name
$ docker exec frontend ping backend
PING backend (172.18.0.3): 56 data bytes
64 bytes from 172.18.0.3: icmp_seq=0 time=0.089 ms

# Check DNS configuration
$ docker exec frontend cat /etc/resolv.conf
nameserver 127.0.0.11  # Docker's DNS
options ndots:0
```

### Service Discovery Pattern

```javascript
// Automatic service discovery using DNS

// ❌ BAD: Hardcoded IPs
const USER_SERVICE = 'http://172.18.0.3:3001';
const PRODUCT_SERVICE = 'http://172.18.0.4:3002';

// ✅ GOOD: Use service names (DNS resolves automatically)
const USER_SERVICE = 'http://user-service:3001';
const PRODUCT_SERVICE = 'http://product-service:3002';

// Even better: Use environment variables
const USER_SERVICE = process.env.USER_SERVICE_URL || 'http://user-service:3001';
```

---

## Network Isolation and Security {#isolation}

### Isolating Services with Multiple Networks

```yaml
# Secure microservices setup
version: '3.8'

services:
  # Public-facing services
  gateway:
    image: nginx
    networks:
      - public-network
      - api-network

  # API services (accessible from gateway)
  api-service:
    image: myapi
    networks:
      - api-network
      - database-network

  # Database (only accessible from api)
  database:
    image: postgres
    networks:
      - database-network

networks:
  public-network:      # Gateway only
  api-network:         # Gateway + API services
  database-network:    # API services + Database only
```

**Security Topology:**

```
NETWORK ISOLATION:
═══════════════════════════════════════════════════

┌─────────────────────────────────────────────────┐
│ public-network                                  │
│  ┌──────────┐                                   │
│  │ Gateway  │ (Exposed to internet: port 80)    │
│  └────┬─────┘                                   │
└───────┼─────────────────────────────────────────┘
        │
┌───────┼─────────────────────────────────────────┐
│ api-network                                     │
│  ┌────▼─────┐                                   │
│  │ Gateway  │                                   │
│  └──────────┘                                   │
│       │                                         │
│  ┌────▼────────┐                                │
│  │ API Service │                                │
│  └────┬────────┘                                │
└───────┼─────────────────────────────────────────┘
        │
┌───────┼─────────────────────────────────────────┐
│ database-network                                │
│  ┌────▼────────┐                                │
│  │ API Service │                                │
│  └────┬────────┘                                │
│       │                                         │
│  ┌────▼────────┐                                │
│  │  Database   │ (Not accessible from outside) │
│  └─────────────┘                                │
└─────────────────────────────────────────────────┘

SECURITY RULES:
✓ Internet → Gateway (port 80 only)
✓ Gateway → API Service
✓ API Service → Database
✗ Internet → Database (blocked!)
✗ Gateway → Database (blocked!)
```

---


# Advanced Topics, Real-World Examples & Best Practices

## Real-World Microservices Setup {#real-world}

### Complete E-Commerce System with Network Segmentation

```yaml
# docker-compose.yml - Production-Ready Microservices
version: '3.8'

services:
  # ═══════════════════════════════════════════════════
  # PUBLIC TIER (Internet-facing)
  # ═══════════════════════════════════════════════════
  
  # Nginx Reverse Proxy
  nginx:
    image: nginx:alpine
    container_name: nginx-gateway
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
    networks:
      - public-tier
    restart: unless-stopped

  # ═══════════════════════════════════════════════════
  # APPLICATION TIER (Microservices)
  # ═══════════════════════════════════════════════════
  
  # User Service
  user-service:
    build: ./services/user
    container_name: user-svc
    environment:
      - DB_HOST=user-db
      - DB_PORT=5432
      - DB_NAME=users
      - REDIS_HOST=cache
      - KAFKA_BROKERS=kafka:9092
    networks:
      - public-tier       # Accessible from nginx
      - app-tier          # Can call other services
      - user-db-tier      # Can access user DB
      - cache-tier        # Can access cache
    depends_on:
      - user-db
      - cache
    deploy:
      replicas: 3         # Scale to 3 instances
      
  # Product Service
  product-service:
    build: ./services/product
    container_name: product-svc
    environment:
      - DB_HOST=product-db
      - DB_PORT=5432
      - DB_NAME=products
      - REDIS_HOST=cache
      - ELASTICSEARCH_URL=http://elasticsearch:9200
    networks:
      - public-tier
      - app-tier
      - product-db-tier
      - cache-tier
      - search-tier
    depends_on:
      - product-db
      - cache
      - elasticsearch
      
  # Order Service
  order-service:
    build: ./services/order
    container_name: order-svc
    environment:
      - DB_HOST=order-db
      - DB_PORT=5432
      - USER_SERVICE_URL=http://user-service:3001
      - PRODUCT_SERVICE_URL=http://product-service:3002
      - PAYMENT_SERVICE_URL=http://payment-service:3004
      - KAFKA_BROKERS=kafka:9092
    networks:
      - public-tier
      - app-tier
      - order-db-tier
      - message-tier
    depends_on:
      - order-db
      - kafka
      
  # Payment Service
  payment-service:
    build: ./services/payment
    container_name: payment-svc
    environment:
      - DB_HOST=payment-db
      - STRIPE_API_KEY=${STRIPE_API_KEY}
    networks:
      - app-tier
      - payment-db-tier
    depends_on:
      - payment-db
      
  # Notification Service (Event-driven)
  notification-service:
    build: ./services/notification
    container_name: notification-svc
    environment:
      - KAFKA_BROKERS=kafka:9092
      - EMAIL_SERVICE_URL=${EMAIL_SERVICE_URL}
    networks:
      - message-tier
    depends_on:
      - kafka

  # ═══════════════════════════════════════════════════
  # DATA TIER (Databases)
  # ═══════════════════════════════════════════════════
  
  # User Database
  user-db:
    image: postgres:14
    container_name: user-database
    environment:
      POSTGRES_DB: users
      POSTGRES_PASSWORD: ${USER_DB_PASSWORD}
    volumes:
      - user-db-data:/var/lib/postgresql/data
    networks:
      - user-db-tier
    restart: unless-stopped
      
  # Product Database
  product-db:
    image: postgres:14
    container_name: product-database
    environment:
      POSTGRES_DB: products
      POSTGRES_PASSWORD: ${PRODUCT_DB_PASSWORD}
    volumes:
      - product-db-data:/var/lib/postgresql/data
    networks:
      - product-db-tier
    restart: unless-stopped
      
  # Order Database
  order-db:
    image: postgres:14
    container_name: order-database
    environment:
      POSTGRES_DB: orders
      POSTGRES_PASSWORD: ${ORDER_DB_PASSWORD}
    volumes:
      - order-db-data:/var/lib/postgresql/data
    networks:
      - order-db-tier
    restart: unless-stopped
      
  # Payment Database
  payment-db:
    image: postgres:14
    container_name: payment-database
    environment:
      POSTGRES_DB: payments
      POSTGRES_PASSWORD: ${PAYMENT_DB_PASSWORD}
    volumes:
      - payment-db-data:/var/lib/postgresql/data
    networks:
      - payment-db-tier
    restart: unless-stopped

  # ═══════════════════════════════════════════════════
  # INFRASTRUCTURE TIER (Cache, Search, Messaging)
  # ═══════════════════════════════════════════════════
  
  # Redis Cache
  cache:
    image: redis:alpine
    container_name: redis-cache
    networks:
      - cache-tier
    restart: unless-stopped
      
  # Elasticsearch
  elasticsearch:
    image: elasticsearch:8.5.0
    container_name: elasticsearch
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
    networks:
      - search-tier
    restart: unless-stopped
      
  # Kafka
  kafka:
    image: confluentinc/cp-kafka:latest
    container_name: kafka-broker
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092
    networks:
      - message-tier
    depends_on:
      - zookeeper
      
  # Zookeeper (required by Kafka)
  zookeeper:
    image: confluentinc/cp-zookeeper:latest
    container_name: zookeeper
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
    networks:
      - message-tier

# ═══════════════════════════════════════════════════
# NETWORKS (Network Segmentation)
# ═══════════════════════════════════════════════════
networks:
  public-tier:          # Internet-facing services
    driver: bridge
  app-tier:             # Inter-service communication
    driver: bridge
  user-db-tier:         # User service → User DB
    driver: bridge
  product-db-tier:      # Product service → Product DB
    driver: bridge
  order-db-tier:        # Order service → Order DB
    driver: bridge
  payment-db-tier:      # Payment service → Payment DB
    driver: bridge
  cache-tier:           # Services → Redis
    driver: bridge
  search-tier:          # Services → Elasticsearch
    driver: bridge
  message-tier:         # Services → Kafka
    driver: bridge

# ═══════════════════════════════════════════════════
# VOLUMES (Persistent Storage)
# ═══════════════════════════════════════════════════
volumes:
  user-db-data:
  product-db-data:
  order-db-data:
  payment-db-data:
```

### Network Topology Visualization

```
COMPLETE NETWORK ARCHITECTURE:
═══════════════════════════════════════════════════

┌─────────────────────────────────────────────────┐
│ INTERNET                                        │
└──────────────────┬──────────────────────────────┘
                   │
                   │ HTTP/HTTPS
                   ▼
┌─────────────────────────────────────────────────┐
│ public-tier                                     │
│  ┌──────────┐                                   │
│  │  Nginx   │ (Port 80, 443)                    │
│  └────┬─────┘                                   │
└───────┼─────────────────────────────────────────┘
        │
        │ Reverse proxy routes
        │
┌───────┼─────────────────────────────────────────┐
│ app-tier                                        │
│       │                                         │
│  ┌────▼─────┬──────────┬──────────┬─────────┐  │
│  │   User   │ Product  │  Order   │ Payment │  │
│  │  Service │ Service  │ Service  │ Service │  │
│  └────┬─────┴────┬─────┴────┬─────┴────┬────┘  │
└───────┼──────────┼──────────┼──────────┼───────┘
        │          │          │          │
        │          │          │          │
   ┌────┼────┐ ┌───┼────┐ ┌──┼────┐ ┌───┼────┐
   │         │ │        │ │       │ │        │
   ▼         ▼ ▼        ▼ ▼       ▼ ▼        ▼
┌─────────┐ ┌──────────┐ ┌────────┐ ┌─────────┐
│user-db  │ │product-db│ │order-db│ │payment  │
│-tier    │ │-tier     │ │-tier   │ │-db-tier │
│┌───────┐│ │┌────────┐│ │┌──────┐│ │┌───────┐│
││User DB││ ││Product ││ ││Order ││ ││Payment││
││:5432  ││ ││DB:5432 ││ ││DB    ││ ││DB     ││
│└───────┘│ │└────────┘│ │└──────┘│ │└───────┘│
└─────────┘ └──────────┘ └────────┘ └─────────┘

ADDITIONAL INFRASTRUCTURE:
┌─────────────────────────────────────────────────┐
│ cache-tier                                      │
│  ┌─────────┐                                    │
│  │  Redis  │ (Shared cache)                     │
│  └─────────┘                                    │
└─────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────┐
│ search-tier                                     │
│  ┌──────────────┐                               │
│  │Elasticsearch │ (Product search)              │
│  └──────────────┘                               │
└─────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────┐
│ message-tier                                    │
│  ┌────────┐    ┌─────────────┐                 │
│  │ Kafka  │────│ Zookeeper   │                 │
│  └────────┘    └─────────────┘                 │
└─────────────────────────────────────────────────┘
```

### Communication Patterns

```javascript
// order-service/src/orderController.js
// Real-world service-to-service communication

const axios = require('axios');
const kafka = require('kafka-node');

// Service URLs (from environment or service discovery)
const USER_SERVICE = process.env.USER_SERVICE_URL;
const PRODUCT_SERVICE = process.env.PRODUCT_SERVICE_URL;
const PAYMENT_SERVICE = process.env.PAYMENT_SERVICE_URL;

// Kafka producer for async messaging
const Producer = kafka.Producer;
const client = new kafka.KafkaClient({ kafkaHost: process.env.KAFKA_BROKERS });
const producer = new Producer(client);

// Create order with multiple service calls
async function createOrder(req, res) {
  const { userId, items } = req.body;
  
  try {
    // 1. Synchronous call: Verify user
    console.log(`[Order Service] Calling User Service: ${USER_SERVICE}/users/${userId}`);
    const userResponse = await axios.get(`${USER_SERVICE}/users/${userId}`, {
      timeout: 5000,  // 5 second timeout
      headers: {
        'X-Request-ID': req.headers['x-request-id'] || generateRequestId(),
        'X-Service': 'order-service'
      }
    });
    
    if (!userResponse.data) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // 2. Synchronous call: Validate products and get prices
    console.log(`[Order Service] Calling Product Service: ${PRODUCT_SERVICE}/products/validate`);
    const productResponse = await axios.post(`${PRODUCT_SERVICE}/products/validate`, {
      items
    }, {
      timeout: 5000
    });
    
    const validatedItems = productResponse.data;
    const totalAmount = validatedItems.reduce((sum, item) => sum + (item.price * item.quantity), 0);
    
    // 3. Synchronous call: Process payment
    console.log(`[Order Service] Calling Payment Service: ${PAYMENT_SERVICE}/payments`);
    const paymentResponse = await axios.post(`${PAYMENT_SERVICE}/payments`, {
      userId,
      amount: totalAmount,
      currency: 'USD'
    }, {
      timeout: 10000  // Payment might take longer
    });
    
    // 4. Save order to database
    const order = await saveOrderToDB({
      userId,
      items: validatedItems,
      totalAmount,
      paymentId: paymentResponse.data.id,
      status: 'confirmed'
    });
    
    // 5. Asynchronous event: Publish order created event
    console.log('[Order Service] Publishing order.created event to Kafka');
    const payload = [{
      topic: 'order.created',
      messages: JSON.stringify({
        orderId: order.id,
        userId: order.userId,
        totalAmount: order.totalAmount,
        timestamp: new Date().toISOString()
      })
    }];
    
    producer.send(payload, (err, data) => {
      if (err) console.error('Kafka publish error:', err);
      else console.log('Event published successfully');
    });
    
    // Return response
    res.status(201).json({
      orderId: order.id,
      status: 'confirmed',
      totalAmount: order.totalAmount
    });
    
  } catch (error) {
    console.error('[Order Service] Error creating order:', error.message);
    
    // Handle different types of errors
    if (error.code === 'ECONNREFUSED') {
      return res.status(503).json({ 
        error: 'Service unavailable',
        service: error.config?.url
      });
    }
    
    if (error.response) {
      // Service returned error
      return res.status(error.response.status).json({
        error: error.response.data.error || 'Service error'
      });
    }
    
    // Generic error
    res.status(500).json({ error: 'Failed to create order' });
  }
}

module.exports = { createOrder };
```

---

## Advanced Networking Concepts {#advanced}

### 1. Load Balancing with Docker Networks

```yaml
# Load balancing multiple instances
version: '3.8'

services:
  # Nginx as load balancer
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx-lb.conf:/etc/nginx/nginx.conf:ro
    networks:
      - app-network
    depends_on:
      - api

  # API service (scaled to 3 instances)
  api:
    build: ./api
    networks:
      - app-network
    deploy:
      replicas: 3
    environment:
      - INSTANCE_ID=${HOSTNAME}

networks:
  app-network:
```

**nginx-lb.conf:**

```nginx
events {
    worker_connections 1024;
}

http {
    # Docker's internal DNS resolves 'api' to all 3 instances!
    upstream api_backend {
        # Docker provides automatic round-robin load balancing
        server api:3000;
        # No need to specify multiple servers - Docker handles it!
    }

    server {
        listen 80;

        location / {
            proxy_pass http://api_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }
}
```

**How It Works:**

```
AUTOMATIC LOAD BALANCING:
═══════════════════════════════════════════════════

Request 1:
Client → Nginx → DNS lookup "api"
                 → Returns: 172.18.0.2 (api_1)

Request 2:
Client → Nginx → DNS lookup "api"
                 → Returns: 172.18.0.3 (api_2)

Request 3:
Client → Nginx → DNS lookup "api"
                 → Returns: 172.18.0.4 (api_3)

Docker's DNS automatically rotates through all instances!
```

### 2. Health Check-Based Routing

```yaml
services:
  api:
    build: ./api
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 30s
    deploy:
      replicas: 3
```

```javascript
// api/src/health.js
// Health check endpoint

const express = require('express');
const router = express.Router();

router.get('/health', async (req, res) => {
  try {
    // Check database connection
    await db.ping();
    
    // Check external dependencies
    await cache.ping();
    
    // Return healthy status
    res.status(200).json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      memory: process.memoryUsage()
    });
  } catch (error) {
    // Service unhealthy
    res.status(503).json({
      status: 'unhealthy',
      error: error.message
    });
  }
});

module.exports = router;
```

### 3. Network Aliases

```yaml
services:
  api:
    image: myapi
    networks:
      app-network:
        aliases:
          - api-server
          - backend-api
          - primary-api

  # Other services can reach this service using any alias:
  # http://api:3000
  # http://api-server:3000
  # http://backend-api:3000
  # http://primary-api:3000
```

### 4. Static IP Addresses

```yaml
networks:
  app-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16
          gateway: 172.20.0.1

services:
  api:
    networks:
      app-network:
        ipv4_address: 172.20.0.10  # Static IP

  database:
    networks:
      app-network:
        ipv4_address: 172.20.0.20  # Static IP
```

---

## Troubleshooting Network Issues {#troubleshooting}

### Issue 1: Containers Can't Communicate

```bash
# Problem
$ docker-compose logs api
Error: getaddrinfo ENOTFOUND database

# Debug Step 1: Check if containers are running
$ docker-compose ps
NAME        STATUS
api         Up
database    Up

# Debug Step 2: Check networks
$ docker network ls
NETWORK ID     NAME              DRIVER
abc123         myapp_default     bridge

$ docker network inspect myapp_default
# Check "Containers" section - are both containers listed?

# Debug Step 3: Check if on same network
$ docker inspect api | grep Networks -A 10
$ docker inspect database | grep Networks -A 10

# Debug Step 4: Test DNS resolution
$ docker exec api ping database
# Should resolve and ping successfully

$ docker exec api nslookup database
# Should return IP address

# Debug Step 5: Test connectivity
$ docker exec api curl http://database:5432
# Or use telnet/nc to test port

# SOLUTIONS:

# Solution 1: Ensure same network in docker-compose.yml
services:
  api:
    networks:
      - mynetwork
  database:
    networks:
      - mynetwork

networks:
  mynetwork:

# Solution 2: Connect manually if needed
$ docker network connect myapp_default database

# Solution 3: Check firewall rules (if on Linux)
$ sudo iptables -L DOCKER-USER
```

### Issue 2: DNS Not Resolving Service Names

```bash
# Problem
$ docker exec api ping backend
ping: bad address 'backend'

# Cause: Default bridge network doesn't have DNS!

# Solution: Use custom network (not default bridge)
# docker-compose.yml
services:
  api:
    networks:
      - custom-network  # Don't use default bridge!

networks:
  custom-network:
    driver: bridge
```

### Issue 3: Port Conflicts

```bash
# Problem
Error: bind: address already in use

# Debug
$ lsof -i :8080
COMMAND   PID   USER
node      1234  user

# Solution 1: Stop conflicting process
$ kill 1234

# Solution 2: Use different host port
ports:
  - "8081:8080"  # Use 8081 on host instead
```

### Issue 4: Can't Access Container from Host

```bash
# Problem
$ curl http://localhost:8080
curl: (7) Failed to connect to localhost port 8080

# Debug
$ docker ps
CONTAINER ID   PORTS
abc123         8080/tcp  # ⚠️ Port not published!

# Should be:
# 0.0.0.0:8080->8080/tcp

# Solution: Add port mapping
services:
  api:
    ports:
      - "8080:8080"  # Add this!
```

### Issue 5: Slow Inter-Container Communication

```bash
# Problem
API responses very slow (2-3 seconds per request)

# Debug: Check DNS resolution time
$ docker exec api time nslookup database
# If slow, DNS issue

# Solution 1: Use IP address (temporary test)
DATABASE_URL=postgres://172.18.0.3:5432/db

# Solution 2: Check Docker DNS
$ docker exec api cat /etc/resolv.conf
nameserver 127.0.0.11  # Should be Docker's DNS

# Solution 3: Restart Docker daemon
$ sudo systemctl restart docker
```

---

## Best Practices {#best-practices}

### 1. Network Naming Convention

```yaml
# ✅ GOOD: Clear, descriptive names
networks:
  frontend-network:      # Public-facing services
  backend-network:       # Internal services
  database-network:      # Database access
  cache-network:         # Cache access

# ❌ BAD: Generic names
networks:
  network1:
  network2:
  net:
```

### 2. Minimize Network Connections

```yaml
# ✅ GOOD: Services on only necessary networks
services:
  api:
    networks:
      - app-network      # Can call other services
      - db-network       # Can access database

  database:
    networks:
      - db-network       # ONLY accessible from services

# ❌ BAD: Everything on all networks
services:
  api:
    networks:
      - network1
      - network2
      - network3
```

### 3. Use Environment Variables for URLs

```yaml
# ✅ GOOD
services:
  order-service:
    environment:
      USER_SERVICE_URL: http://user-service:3001
      PRODUCT_SERVICE_URL: http://product-service:3002
```

```javascript
// In code
const userService = process.env.USER_SERVICE_URL;
```

### 4. Implement Circuit Breakers

```javascript
// Circuit breaker for resilient service calls
const CircuitBreaker = require('opossum');

const options = {
  timeout: 3000,        // If request takes > 3s, fail
  errorThresholdPercentage: 50,  // When 50% of requests fail
  resetTimeout: 30000   // Try again after 30s
};

const callUserService = async (userId) => {
  const response = await axios.get(`${USER_SERVICE}/users/${userId}`);
  return response.data;
};

const breaker = new CircuitBreaker(callUserService, options);

// Use circuit breaker
try {
  const user = await breaker.fire(userId);
} catch (error) {
  // Circuit is open, service is down
  console.log('User service unavailable');
}
```

### 5. Implement Retries with Backoff

```javascript
// Retry logic for network calls
const axios = require('axios');
const axiosRetry = require('axios-retry');

axiosRetry(axios, {
  retries: 3,
  retryDelay: axiosRetry.exponentialDelay,
  retryCondition: (error) => {
    // Retry on network errors or 5xx responses
    return axiosRetry.isNetworkOrIdempotentRequestError(error) ||
           (error.response && error.response.status >= 500);
  }
});

// Now axios automatically retries failed requests
const response = await axios.get(`${USER_SERVICE}/users/${userId}`);
```

### 6. Use Request Tracing

```javascript
// Add request ID for tracing across services
const { v4: uuidv4 } = require('uuid');

app.use((req, res, next) => {
  req.id = req.headers['x-request-id'] || uuidv4();
  res.setHeader('X-Request-ID', req.id);
  next();
});

// When calling other services
const response = await axios.get(`${USER_SERVICE}/users/${userId}`, {
  headers: {
    'X-Request-ID': req.id,
    'X-Service': 'order-service'
  }
});
```

### 7. Monitor Network Performance

```yaml
# Add monitoring stack
services:
  prometheus:
    image: prom/prometheus
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    networks:
      - monitoring-network

  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
    networks:
      - monitoring-network
```

---

## Quick Reference

### Common Network Commands

```bash
# Create network
docker network create mynetwork

# List networks
docker network ls

# Inspect network
docker network inspect mynetwork

# Connect container to network
docker network connect mynetwork container_name

# Disconnect container from network
docker network disconnect mynetwork container_name

# Remove network
docker network rm mynetwork

# Prune unused networks
docker network prune
```

### Testing Network Connectivity

```bash
# From inside container
docker exec container_name ping other_container
docker exec container_name nslookup other_container
docker exec container_name curl http://other_container:8080
docker exec container_name nc -zv other_container 8080
docker exec container_name traceroute other_container
```

### Network Troubleshooting Checklist

```
✓ Are containers on same network?
✓ Is DNS resolving correctly?
✓ Are ports exposed correctly?
✓ Is firewall blocking connections?
✓ Are containers actually running?
✓ Is network driver correct (bridge)?
✓ Are there any port conflicts?
✓ Is Docker daemon running?
```

---

That completes the Docker Networking guide! You now understand: ✅ How Docker networking works internally ✅ How containers communicate with each other ✅ How to set up microservices with proper network isolation ✅ DNS and service discovery ✅ Real-world production setups ✅ Advanced networking concepts ✅ Troubleshooting network issues ✅ Best practices for microservices

Ready to build networked microservices! 🚀