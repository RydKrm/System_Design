# Docker Compose Complete Guide - Part 2

## Commands, Real Examples, Best Practices & Troubleshooting

## Docker Compose Commands {#commands}

### Essential Commands

```bash
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# START & STOP
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Start all services
$ docker-compose up

# Start in detached mode (background)
$ docker-compose up -d

# Start specific services
$ docker-compose up frontend backend

# Stop all services (keeps containers)
$ docker-compose stop

# Stop and remove containers
$ docker-compose down

# Stop and remove everything (containers, networks, volumes)
$ docker-compose down -v

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# BUILD
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Build images
$ docker-compose build

# Build without cache
$ docker-compose build --no-cache

# Build specific service
$ docker-compose build backend

# Build and start
$ docker-compose up --build

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LOGS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# View logs
$ docker-compose logs

# Follow logs
$ docker-compose logs -f

# Logs for specific service
$ docker-compose logs backend

# Last 100 lines
$ docker-compose logs --tail=100

# Logs with timestamps
$ docker-compose logs -t

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# STATUS & INFO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# List running services
$ docker-compose ps

# List all services (including stopped)
$ docker-compose ps -a

# Show service configuration
$ docker-compose config

# Validate compose file
$ docker-compose config --quiet

# List images
$ docker-compose images

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXECUTE COMMANDS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Execute command in running service
$ docker-compose exec backend bash

# Execute as different user
$ docker-compose exec -u root backend bash

# Run one-off command (creates new container)
$ docker-compose run backend python manage.py migrate

# Run without dependencies
$ docker-compose run --no-deps backend pytest

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# RESTART & RELOAD
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Restart services
$ docker-compose restart

# Restart specific service
$ docker-compose restart backend

# Pause services
$ docker-compose pause

# Unpause services
$ docker-compose unpause

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SCALING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Scale service to N instances
$ docker-compose up --scale worker=3

# Scale multiple services
$ docker-compose up --scale api=2 --scale worker=4

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CLEANUP
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Remove stopped containers
$ docker-compose rm

# Remove without confirmation
$ docker-compose rm -f

# Stop and remove everything
$ docker-compose down

# Also remove volumes
$ docker-compose down -v

# Also remove images
$ docker-compose down --rmi all
```

### Command Comparison

```
DOCKER vs DOCKER-COMPOSE COMMANDS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

docker run                â†’ docker-compose up
docker build              â†’ docker-compose build
docker ps                 â†’ docker-compose ps
docker logs               â†’ docker-compose logs
docker exec               â†’ docker-compose exec
docker stop               â†’ docker-compose stop
docker rm                 â†’ docker-compose rm

Benefits of compose commands:
âœ“ Operate on all services at once
âœ“ Use service names (not container IDs)
âœ“ Follow compose file configuration
âœ“ Simpler syntax
```

---

## Real-World Examples {#real-examples}

### Example 1: MERN Stack (MongoDB, Express, React, Node)

```yaml
# docker-compose.yml
version: '3.8'

services:
  # Frontend - React
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: mern_frontend
    ports:
      - "3000:3000"
    volumes:
      - ./frontend/src:/app/src    # Hot reload in development
      - /app/node_modules            # Don't overwrite node_modules
    environment:
      - REACT_APP_API_URL=http://localhost:5000/api
    depends_on:
      - backend
    networks:
      - mern-network

  # Backend - Node.js + Express
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: mern_backend
    ports:
      - "5000:5000"
    volumes:
      - ./backend:/app
      - /app/node_modules
    environment:
      - NODE_ENV=development
      - MONGO_URI=mongodb://mongo:27017/merndb
      - JWT_SECRET=your_jwt_secret
    depends_on:
      - mongo
    networks:
      - mern-network
    command: npm run dev           # Development mode

  # Database - MongoDB
  mongo:
    image: mongo:6.0
    container_name: mern_mongo
    ports:
      - "27017:27017"
    volumes:
      - mongo_data:/data/db        # Persistent data
    environment:
      - MONGO_INITDB_ROOT_USERNAME=admin
      - MONGO_INITDB_ROOT_PASSWORD=password
    networks:
      - mern-network

  # MongoDB Admin UI
  mongo-express:
    image: mongo-express:latest
    container_name: mern_mongo_express
    ports:
      - "8081:8081"
    environment:
      - ME_CONFIG_MONGODB_SERVER=mongo
      - ME_CONFIG_MONGODB_PORT=27017
      - ME_CONFIG_MONGODB_ADMINUSERNAME=admin
      - ME_CONFIG_MONGODB_ADMINPASSWORD=password
    depends_on:
      - mongo
    networks:
      - mern-network

networks:
  mern-network:
    driver: bridge

volumes:
  mongo_data:
    driver: local
```

**Project Structure:**

```
mern-app/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ public/
â”‚   â””â”€â”€ src/
â”‚       â””â”€â”€ App.js
â””â”€â”€ backend/
    â”œâ”€â”€ Dockerfile
    â”œâ”€â”€ package.json
    â”œâ”€â”€ server.js
    â””â”€â”€ routes/
```

**Frontend Dockerfile:**

```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "start"]
```

**Backend Dockerfile:**

```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 5000
CMD ["npm", "run", "dev"]
```

**Usage:**

```bash
# Start everything
$ docker-compose up -d

# View logs
$ docker-compose logs -f backend

# Access:
# Frontend: http://localhost:3000
# Backend API: http://localhost:5000
# MongoDB Admin: http://localhost:8081

# Stop everything
$ docker-compose down

# Stop and remove volumes
$ docker-compose down -v
```

---

### Example 2: WordPress with MySQL

```yaml
# docker-compose.yml
version: '3.8'

services:
  # WordPress
  wordpress:
    image: wordpress:latest
    container_name: wordpress_app
    restart: always
    ports:
      - "8000:80"
    environment:
      WORDPRESS_DB_HOST: mysql:3306
      WORDPRESS_DB_USER: wordpress
      WORDPRESS_DB_PASSWORD: wordpress_pass
      WORDPRESS_DB_NAME: wordpress_db
    volumes:
      - wordpress_data:/var/www/html
    depends_on:
      mysql:
        condition: service_healthy
    networks:
      - wordpress-network

  # MySQL Database
  mysql:
    image: mysql:8.0
    container_name: wordpress_mysql
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: root_password
      MYSQL_DATABASE: wordpress_db
      MYSQL_USER: wordpress
      MYSQL_PASSWORD: wordpress_pass
    volumes:
      - mysql_data:/var/lib/mysql
    networks:
      - wordpress-network
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-proot_password"]
      interval: 10s
      timeout: 5s
      retries: 5

  # phpMyAdmin (Database Management)
  phpmyadmin:
    image: phpmyadmin:latest
    container_name: wordpress_phpmyadmin
    restart: always
    ports:
      - "8080:80"
    environment:
      PMA_HOST: mysql
      PMA_PORT: 3306
      PMA_USER: root
      PMA_PASSWORD: root_password
    depends_on:
      - mysql
    networks:
      - wordpress-network

networks:
  wordpress-network:
    driver: bridge

volumes:
  wordpress_data:
  mysql_data:
```

**Usage:**

```bash
$ docker-compose up -d

# Access:
# WordPress: http://localhost:8000
# phpMyAdmin: http://localhost:8080

# Backup database
$ docker-compose exec mysql mysqldump -u root -proot_password wordpress_db > backup.sql

# Restore database
$ cat backup.sql | docker-compose exec -T mysql mysql -u root -proot_password wordpress_db
```

---

### Example 3: Microservices with API Gateway

```yaml
# docker-compose.yml
version: '3.8'

services:
  # API Gateway (Nginx)
  gateway:
    image: nginx:alpine
    container_name: api_gateway
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - user-service
      - product-service
      - order-service
    networks:
      - microservices-network

  # User Service
  user-service:
    build: ./services/user-service
    container_name: user_service
    environment:
      - SERVICE_NAME=user-service
      - DATABASE_URL=postgres://postgres:password@postgres:5432/users
      - REDIS_URL=redis://cache:6379
    depends_on:
      - postgres
      - cache
    networks:
      - microservices-network
    deploy:
      replicas: 2               # Run 2 instances

  # Product Service
  product-service:
    build: ./services/product-service
    container_name: product_service
    environment:
      - SERVICE_NAME=product-service
      - DATABASE_URL=postgres://postgres:password@postgres:5432/products
      - REDIS_URL=redis://cache:6379
    depends_on:
      - postgres
      - cache
    networks:
      - microservices-network

  # Order Service
  order-service:
    build: ./services/order-service
    container_name: order_service
    environment:
      - SERVICE_NAME=order-service
      - DATABASE_URL=postgres://postgres:password@postgres:5432/orders
      - RABBITMQ_URL=amqp://guest:guest@rabbitmq:5672
    depends_on:
      - postgres
      - rabbitmq
    networks:
      - microservices-network

  # PostgreSQL Database
  postgres:
    image: postgres:14
    container_name: postgres_db
    environment:
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-db.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - microservices-network

  # Redis Cache
  cache:
    image: redis:alpine
    container_name: redis_cache
    ports:
      - "6379:6379"
    networks:
      - microservices-network

  # RabbitMQ Message Queue
  rabbitmq:
    image: rabbitmq:3-management
    container_name: rabbitmq_mq
    ports:
      - "5672:5672"
      - "15672:15672"           # Management UI
    networks:
      - microservices-network

networks:
  microservices-network:
    driver: bridge

volumes:
  postgres_data:
```

**nginx.conf:**

```nginx
events {
    worker_connections 1024;
}

http {
    upstream user_service {
        server user-service:3000;
    }
    
    upstream product_service {
        server product-service:3000;
    }
    
    upstream order_service {
        server order-service:3000;
    }

    server {
        listen 80;

        location /api/users {
            proxy_pass http://user_service;
        }

        location /api/products {
            proxy_pass http://product_service;
        }

        location /api/orders {
            proxy_pass http://order_service;
        }
    }
}
```

---

### Example 4: Development Environment with Hot Reload

```yaml
# docker-compose.dev.yml
version: '3.8'

services:
  # Next.js Frontend (Hot Reload)
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.dev
    volumes:
      - ./frontend:/app          # Mount entire directory
      - /app/node_modules         # Except node_modules
      - /app/.next                # Except .next build
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
      - CHOKIDAR_USEPOLLING=true  # Enable hot reload in Docker
    command: npm run dev

  # Node.js Backend (Hot Reload with Nodemon)
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.dev
    volumes:
      - ./backend:/app
      - /app/node_modules
    ports:
      - "5000:5000"
    environment:
      - NODE_ENV=development
    command: npm run dev          # Uses nodemon

  # PostgreSQL with development data
  database:
    image: postgres:14
    volumes:
      - ./dev-data.sql:/docker-entrypoint-initdb.d/init.sql
    environment:
      POSTGRES_PASSWORD: dev_password
```

**Dockerfile.dev (Frontend):**

```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
# Command specified in docker-compose
```

**package.json (Backend):**

```json
{
  "scripts": {
    "dev": "nodemon --watch src src/server.js"
  },
  "devDependencies": {
    "nodemon": "^3.0.0"
  }
}
```

---

## Best Practices {#best-practices}

### 1. Use .env Files for Configuration

```yaml
# âŒ BAD: Hardcoded values
services:
  app:
    environment:
      - DATABASE_URL=postgres://user:password@localhost:5432/db
      - API_KEY=abc123xyz
```

```yaml
# âœ… GOOD: Use environment variables
services:
  app:
    env_file: .env
```

```bash
# .env
DATABASE_URL=postgres://user:password@localhost:5432/db
API_KEY=abc123xyz
```

### 2. Don't Use 'latest' Tag

```yaml
# âŒ BAD: Unpredictable versions
services:
  app:
    image: node:latest

# âœ… GOOD: Specific versions
services:
  app:
    image: node:18.19-alpine
```

### 3. Use Named Volumes

```yaml
# âŒ BAD: Anonymous volumes
services:
  db:
    volumes:
      - /var/lib/mysql

# âœ… GOOD: Named volumes
services:
  db:
    volumes:
      - mysql_data:/var/lib/mysql

volumes:
  mysql_data:
```

### 4. Separate Development and Production

```bash
# Structure
docker-compose.yml           # Base configuration
docker-compose.dev.yml       # Development overrides
docker-compose.prod.yml      # Production overrides

# Usage
docker-compose -f docker-compose.yml -f docker-compose.dev.yml up
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up
```

### 5. Use Health Checks

```yaml
services:
  api:
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

### 6. Resource Limits

```yaml
services:
  app:
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 1G
        reservations:
          cpus: '1'
          memory: 512M
```

### 7. Use Multi-Stage Builds

```dockerfile
# Dockerfile
FROM node:18 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
CMD ["node", "dist/server.js"]
```

### 8. Proper Logging

```yaml
services:
  app:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
```

### 9. Use Restart Policies

```yaml
services:
  app:
    restart: unless-stopped    # Production
    
  dev:
    restart: "no"              # Development
```

### 10. .dockerignore File

```
# .dockerignore
node_modules
.git
.env
*.log
dist
coverage
.vscode
```

---

## Common Patterns {#patterns}

### Pattern 1: Wait-for-it Script

```yaml
# Problem: Service starts before database is ready
services:
  backend:
    depends_on:
      - database
    # Backend might fail if database not ready

# Solution: Wait script
services:
  backend:
    depends_on:
      - database
    command: ["./wait-for-it.sh", "database:5432", "--", "npm", "start"]
```

**wait-for-it.sh:**

```bash
#!/bin/sh
# wait-for-it.sh

set -e

host="$1"
shift
cmd="$@"

until nc -z "$host"; do
  >&2 echo "Waiting for $host..."
  sleep 1
done

>&2 echo "$host is available"
exec $cmd
```

### Pattern 2: Init Containers

```yaml
services:
  # Run migrations before app starts
  migrate:
    image: myapp
    command: npm run migrate
    depends_on:
      database:
        condition: service_healthy
    restart: "no"             # Run once and stop

  # Main application
  app:
    image: myapp
    depends_on:
      - migrate               # Wait for migrations
```

### Pattern 3: Shared Configuration

```yaml
# Define reusable configuration
x-logging: &default-logging
  driver: json-file
  options:
    max-size: "10m"
    max-file: "3"

x-healthcheck: &default-healthcheck
  interval: 30s
  timeout: 10s
  retries: 3

services:
  api:
    image: myapi
    logging: *default-logging
    healthcheck:
      <<: *default-healthcheck
      test: ["CMD", "curl", "-f", "http://localhost/health"]

  worker:
    image: myworker
    logging: *default-logging
    healthcheck:
      <<: *default-healthcheck
      test: ["CMD", "curl", "-f", "http://localhost/health"]
```

### Pattern 4: Service Discovery

```yaml
services:
  # Service 1
  api:
    image: myapi
    environment:
      - DATABASE_HOST=database   # Service name as hostname
      - CACHE_HOST=cache
      - QUEUE_HOST=queue

  # Services can find each other by name
  database:
    image: postgres
    
  cache:
    image: redis
    
  queue:
    image: rabbitmq
```

---

## Troubleshooting Compose Files {#troubleshooting}

### Issue 1: Services Can't Communicate

```bash
# Problem
$ docker-compose logs backend
Error: getaddrinfo ENOTFOUND database

# Debug
$ docker-compose ps
# Check if all services are running

$ docker-compose exec backend ping database
# Test network connectivity

# Solution 1: Check they're on same network
services:
  backend:
    networks:
      - app-network
  database:
    networks:
      - app-network

# Solution 2: Use correct service name
DATABASE_URL=postgres://database:5432  # Use service name, not localhost
```

### Issue 2: Port Already in Use

```bash
# Problem
Error: Bind for 0.0.0.0:3000 failed: port is already allocated

# Debug
$ lsof -i :3000
# Find what's using the port

# Solution 1: Use different port
ports:
  - "3001:3000"  # Map to different host port

# Solution 2: Stop conflicting service
$ docker stop $(docker ps -q --filter "publish=3000")
```

### Issue 3: Volume Permissions

```bash
# Problem
$ docker-compose logs app
Error: EACCES: permission denied, open '/app/data/file.txt'

# Debug
$ docker-compose exec app ls -la /app/data
drwxr-xr-x root root

$ docker-compose exec app whoami
appuser

# Solution: Fix ownership in Dockerfile
RUN chown -R appuser:appuser /app/data

# Or in compose file
services:
  app:
    user: "1001:1001"
    volumes:
      - app_data:/app/data
```

### Issue 4: Environment Variables Not Working

```bash
# Problem
$ docker-compose up
backend_1  | Error: DATABASE_URL is not defined

# Debug
$ docker-compose config
# View merged configuration

$ docker-compose exec backend env | grep DATABASE
# Check what's actually set

# Solution: Check .env file location
# Must be in same directory as docker-compose.yml

# Or explicitly specify
services:
  backend:
    env_file:
      - ./.env
```

### Issue 5: Build Context Issues

```bash
# Problem
$ docker-compose build
ERROR: Cannot locate specified Dockerfile: Dockerfile

# Solution: Check context path
services:
  app:
    build:
      context: ./backend     # Make sure path is correct
      dockerfile: Dockerfile
```

### Issue 6: depends_on Not Working

```bash
# Problem
Backend starts before database is ready

# Solution: Use health checks
services:
  backend:
    depends_on:
      database:
        condition: service_healthy

  database:
    healthcheck:
      test: ["CMD", "pg_isready"]
      interval: 5s
```

---

## Quick Reference Card

```yaml
# ESSENTIAL COMPOSE FILE TEMPLATE
version: '3.8'

services:
  # Service definition
  myservice:
    # Image
    image: nginx:alpine              # Use existing image
    # OR
    build: ./app                     # Build from Dockerfile
    
    # Name
    container_name: my_container
    
    # Ports
    ports:
      - "80:80"
    
    # Environment
    environment:
      - VAR=value
    env_file: .env
    
    # Volumes
    volumes:
      - ./local:/container
      - named_volume:/data
    
    # Networks
    networks:
      - mynetwork
    
    # Dependencies
    depends_on:
      - other_service
    
    # Restart
    restart: unless-stopped
    
    # Resources
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M

networks:
  mynetwork:

volumes:
  named_volume:
```

---

That completes the Docker Compose guide! You now know: âœ… Why you need Compose âœ… How it works internally âœ… How to write compose files âœ… All major features âœ… Real-world examples âœ… Best practices âœ… Common patterns âœ… Troubleshooting

Ready to master Docker Compose! ðŸš€