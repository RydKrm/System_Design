# Complete Docker Compose Guide

## Everything You Need to Know About Docker Compose Files

## Table of Contents

1. [Why Do We Need Docker Compose?](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#why-compose)
2. [How Docker Compose Works](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#how-it-works)
3. [Docker Compose File Structure](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#file-structure)
4. [Writing Your First Compose File](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#first-compose)
5. [Services Configuration](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#services)
6. [Networks in Compose](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#networks)
7. [Volumes in Compose](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#volumes)
8. [Environment Variables](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#environment)
9. [Dependencies and Startup Order](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#dependencies)
10. [Advanced Compose Features](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#advanced)
11. [Docker Compose Commands](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#commands)
12. [Real-World Examples](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#real-examples)
13. [Best Practices](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#best-practices)
14. [Common Patterns](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#patterns)
15. [Troubleshooting Compose Files](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#troubleshooting)

---

## Why Do We Need Docker Compose? {#why-compose}

### The Problem Without Compose

**Scenario: Running a Web Application Stack**

```
YOUR APPLICATION NEEDS:
â”œâ”€â”€ Frontend (React)
â”œâ”€â”€ Backend API (Node.js)
â”œâ”€â”€ Database (PostgreSQL)
â”œâ”€â”€ Cache (Redis)
â””â”€â”€ Message Queue (RabbitMQ)

WITHOUT DOCKER COMPOSE:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Step 1: Create network
$ docker network create myapp-network

# Step 2: Start database
$ docker run -d \
  --name postgres \
  --network myapp-network \
  -e POSTGRES_PASSWORD=secret \
  -e POSTGRES_DB=myapp \
  -v postgres-data:/var/lib/postgresql/data \
  -p 5432:5432 \
  postgres:14

# Step 3: Start Redis
$ docker run -d \
  --name redis \
  --network myapp-network \
  -p 6379:6379 \
  redis:alpine

# Step 4: Start RabbitMQ
$ docker run -d \
  --name rabbitmq \
  --network myapp-network \
  -e RABBITMQ_DEFAULT_USER=user \
  -e RABBITMQ_DEFAULT_PASS=password \
  -p 5672:5672 \
  rabbitmq:3-management

# Step 5: Start backend
$ docker run -d \
  --name backend \
  --network myapp-network \
  -e DATABASE_URL=postgres://postgres:secret@postgres:5432/myapp \
  -e REDIS_URL=redis://redis:6379 \
  -e RABBITMQ_URL=amqp://user:password@rabbitmq:5672 \
  -p 8080:8080 \
  mybackend:latest

# Step 6: Start frontend
$ docker run -d \
  --name frontend \
  --network myapp-network \
  -e API_URL=http://backend:8080 \
  -p 3000:80 \
  myfrontend:latest

PROBLEMS:
âŒ Too many commands to remember
âŒ Easy to make mistakes
âŒ Hard to share with team
âŒ Difficult to stop/start everything
âŒ No dependency management
âŒ Can't version control the setup
âŒ Takes 10 minutes to set up

WITH DOCKER COMPOSE:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# One file: docker-compose.yml
# One command:
$ docker-compose up

BENEFITS:
âœ“ Single file to define everything
âœ“ One command to start/stop all
âœ“ Easy to share (version control)
âœ“ Automatic network creation
âœ“ Dependency management
âœ“ Takes 10 seconds to set up
âœ“ Reproducible across environments
```

### Visual Comparison

```
MANUAL DOCKER COMMANDS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
$ docker network create...     
$ docker run database...       Takes 5 minutes
$ docker run cache...          to type all
$ docker run backend...        commands
$ docker run frontend...       

Hard to remember! ðŸ˜«

DOCKER COMPOSE:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
$ docker-compose up            

One command! ðŸŽ‰
Everything starts automatically!
```

---

## How Docker Compose Works {#how-it-works}

### The Architecture

```
DOCKER COMPOSE WORKFLOW:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Step 1: You Write
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ docker-compose.yml              â”‚
â”‚                                 â”‚
â”‚ services:                       â”‚
â”‚   frontend:                     â”‚
â”‚     image: nginx                â”‚
â”‚   backend:                      â”‚
â”‚     build: ./api                â”‚
â”‚   database:                     â”‚
â”‚     image: postgres             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 2: Docker Compose Reads
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Docker Compose Tool             â”‚
â”‚ Parses YAML file                â”‚
â”‚ Validates configuration         â”‚
â”‚ Plans execution order           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 3: Docker Compose Executes
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Creates:                        â”‚
â”‚ â”œâ”€ Networks                     â”‚
â”‚ â”œâ”€ Volumes                      â”‚
â”‚ â””â”€ Containers                   â”‚
â”‚                                 â”‚
â”‚ Starts in correct order         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 4: Result
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Project: myapp                         â”‚
â”‚                                         â”‚
â”‚  Network: myapp_default                 â”‚
â”‚  â”œâ”€ frontend    (myapp_frontend_1)     â”‚
â”‚  â”œâ”€ backend     (myapp_backend_1)      â”‚
â”‚  â””â”€ database    (myapp_database_1)     â”‚
â”‚                                         â”‚
â”‚  Volume: myapp_db_data                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### What Happens When You Run `docker-compose up`?

```
DETAILED EXECUTION FLOW:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

0. Parse YAML File
   â”œâ”€ Read docker-compose.yml
   â”œâ”€ Validate syntax
   â””â”€ Check for errors

1. Create Networks
   â”œâ”€ Default network: myapp_default
   â””â”€ Custom networks (if specified)

2. Create Volumes
   â”œâ”€ Named volumes
   â””â”€ Bind mounts preparation

3. Build Images (if needed)
   â”œâ”€ Check if 'build:' specified
   â”œâ”€ Run docker build
   â””â”€ Tag image

4. Pull Images (if needed)
   â”œâ”€ Check if image exists locally
   â””â”€ Pull from registry if not

5. Create Containers
   â”œâ”€ Create in dependency order
   â”œâ”€ Apply configuration
   â””â”€ Connect to networks

6. Start Containers
   â”œâ”€ Start in dependency order
   â”œâ”€ Wait for depends_on
   â””â”€ Run healthchecks

7. Display Logs
   â”œâ”€ Stream logs to terminal
   â””â”€ Color-coded by service

EXAMPLE EXECUTION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

$ docker-compose up

Creating network "myapp_default" with default driver
Creating volume "myapp_db_data" with default driver
Pulling database (postgres:14)...
Building backend
Step 1/5: FROM node:18
Step 2/5: COPY package.json .
...
Creating myapp_database_1 ... done
Creating myapp_redis_1    ... done
Creating myapp_backend_1  ... done
Creating myapp_frontend_1 ... done
Attaching to database_1, redis_1, backend_1, frontend_1
database_1  | PostgreSQL init process complete
backend_1   | Server listening on port 8080
frontend_1  | Server listening on port 80
```

### Project Naming

```
HOW COMPOSE NAMES THINGS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Project Directory: /home/user/myapp/
File: docker-compose.yml

Project Name: myapp (from directory name)

Created Resources:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Networks:                           â”‚
â”‚ â”œâ”€ myapp_default                    â”‚
â”‚ â””â”€ myapp_backend_network            â”‚
â”‚                                     â”‚
â”‚ Volumes:                            â”‚
â”‚ â”œâ”€ myapp_db_data                    â”‚
â”‚ â””â”€ myapp_redis_data                 â”‚
â”‚                                     â”‚
â”‚ Containers:                         â”‚
â”‚ â”œâ”€ myapp_frontend_1                 â”‚
â”‚ â”œâ”€ myapp_backend_1                  â”‚
â”‚ â””â”€ myapp_database_1                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Pattern: {project}_{service}_{number}

Override project name:
$ docker-compose -p myproject up
â†’ Creates myproject_frontend_1, etc.
```

---

## Docker Compose File Structure {#file-structure}

### Basic Structure

```yaml
# docker-compose.yml

# Version (optional in newer versions)
version: '3.8'

# Services (containers)
services:
  service1:
    # Service configuration
  service2:
    # Service configuration

# Networks (optional)
networks:
  network1:
    # Network configuration

# Volumes (optional)
volumes:
  volume1:
    # Volume configuration

# Configs (optional)
configs:
  config1:
    # Config configuration

# Secrets (optional)
secrets:
  secret1:
    # Secret configuration
```

### Complete Annotated Example

```yaml
# docker-compose.yml
# Complete example with all major sections

version: '3.8'  # Compose file format version

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SERVICES: Define your containers here
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
services:

  # Service 1: Database
  database:
    image: postgres:14           # Use this image
    container_name: myapp_db     # Custom container name
    restart: always              # Restart policy
    environment:                 # Environment variables
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: myapp
    volumes:                     # Mount volumes
      - db_data:/var/lib/postgresql/data
    networks:                    # Connect to networks
      - backend
    ports:                       # Expose ports
      - "5432:5432"
    healthcheck:                 # Health check
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Service 2: Backend API
  backend:
    build:                       # Build from Dockerfile
      context: ./backend
      dockerfile: Dockerfile
    depends_on:                  # Wait for these services
      - database
      - redis
    environment:
      DATABASE_URL: postgres://postgres:secret@database:5432/myapp
      REDIS_URL: redis://redis:6379
    networks:
      - backend
      - frontend
    ports:
      - "8080:8080"

  # Service 3: Frontend
  frontend:
    image: nginx:alpine
    depends_on:
      - backend
    volumes:
      - ./frontend/build:/usr/share/nginx/html
    networks:
      - frontend
    ports:
      - "80:80"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# NETWORKS: Define networks
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
networks:
  frontend:                      # Frontend network
    driver: bridge
  backend:                       # Backend network
    driver: bridge

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VOLUMES: Define named volumes
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
volumes:
  db_data:                       # Database persistent storage
    driver: local
```

---

## Writing Your First Compose File {#first-compose}

### Example 1: Simple Web Server

```yaml
# docker-compose.yml
# Simplest possible compose file

version: '3.8'

services:
  web:
    image: nginx:alpine
    ports:
      - "80:80"
```

**Usage:**

```bash
# Start
$ docker-compose up

# Stop
$ docker-compose down
```

**What This Does:**

```
1. Creates network: myapp_default
2. Pulls image: nginx:alpine (if not exists)
3. Creates container: myapp_web_1
4. Maps port 80 (host) to 80 (container)
5. Starts nginx

Access: http://localhost
```

### Example 2: Web App + Database

```yaml
# docker-compose.yml
# Simple web application with database

version: '3.8'

services:
  # Web application
  web:
    image: nginx:alpine
    ports:
      - "80:80"
    depends_on:
      - database

  # Database
  database:
    image: postgres:14
    environment:
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: webapp
    volumes:
      - db_data:/var/lib/postgresql/data

volumes:
  db_data:
```

**What This Does:**

```
1. Creates network: myapp_default
2. Creates volume: myapp_db_data
3. Starts database first (because of depends_on)
4. Then starts web server
5. Both containers can communicate via network

Database accessible from web container:
postgresql://postgres:secret@database:5432/webapp
```

### Example 3: Full Stack Application

```yaml
# docker-compose.yml
# Complete full-stack application

version: '3.8'

services:
  # Frontend (React)
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    environment:
      - REACT_APP_API_URL=http://localhost:8080
    depends_on:
      - backend

  # Backend (Node.js)
  backend:
    build: ./backend
    ports:
      - "8080:8080"
    environment:
      - DATABASE_URL=postgres://user:pass@database:5432/myapp
      - REDIS_URL=redis://cache:6379
    depends_on:
      - database
      - cache

  # Database (PostgreSQL)
  database:
    image: postgres:14
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
      POSTGRES_DB: myapp
    volumes:
      - db_data:/var/lib/postgresql/data

  # Cache (Redis)
  cache:
    image: redis:alpine
    ports:
      - "6379:6379"

volumes:
  db_data:
```

**Project Structure:**

```
myproject/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ package.json
â”‚   â””â”€â”€ src/
â””â”€â”€ backend/
    â”œâ”€â”€ Dockerfile
    â”œâ”€â”€ package.json
    â””â”€â”€ src/
```

---

## Services Configuration {#services}

### Using Images

```yaml
services:
  # Use official image
  database:
    image: postgres:14
    
  # Use specific version
  cache:
    image: redis:7.0.5-alpine
    
  # Use from different registry
  custom:
    image: myregistry.com/myapp:v1.0
```

### Building from Dockerfile

```yaml
services:
  # Simple build
  app:
    build: ./app
    
  # Build with context and dockerfile
  api:
    build:
      context: ./backend        # Build context directory
      dockerfile: Dockerfile    # Dockerfile name
      
  # Build with arguments
  web:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        - NODE_ENV=production
        - API_URL=https://api.example.com
        
  # Build with target (multi-stage)
  service:
    build:
      context: .
      target: production        # Build specific stage
```

### Container Configuration

```yaml
services:
  app:
    image: myapp
    
    # Container name (instead of auto-generated)
    container_name: my_custom_name
    
    # Hostname inside container
    hostname: myhost
    
    # Restart policy
    restart: always              # always, unless-stopped, on-failure, no
    
    # Command override
    command: python app.py --debug
    
    # Entrypoint override
    entrypoint: /custom-entrypoint.sh
    
    # Working directory
    working_dir: /app
    
    # User to run as
    user: "1001:1001"
    
    # TTY and interactive
    tty: true
    stdin_open: true
```

### Port Mapping

```yaml
services:
  web:
    image: nginx
    
    # Map ports
    ports:
      - "80:80"                 # host:container
      - "443:443"
      - "8080:80"               # Host 8080 â†’ Container 80
      - "127.0.0.1:8000:8000"   # Bind to specific IP
      - "3000-3005:3000-3005"   # Port range
    
    # Expose ports (only to other containers)
    expose:
      - "8080"
      - "9000"
```

**Port Mapping Explained:**

```
PORT MAPPING SYNTAX: "HOST:CONTAINER"

Example: "8080:80"
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Host Machine                         â”‚
â”‚ Browser: http://localhost:8080       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚ Port 8080
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Container                            â”‚
â”‚ Nginx listening on port 80           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Access from outside: localhost:8080
Nginx sees request on: port 80
```

### Resource Limits

```yaml
services:
  app:
    image: myapp
    
    # Memory limits
    mem_limit: 512m              # Hard limit
    mem_reservation: 256m        # Soft limit
    
    # CPU limits
    cpus: '1.5'                  # 1.5 CPU cores
    cpu_shares: 512              # Relative weight
    
    # Process limit
    pids_limit: 100
    
    # Alternative syntax (deploy section)
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 256M
```

### Health Checks

```yaml
services:
  web:
    image: nginx
    
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost"]
      interval: 30s              # Check every 30 seconds
      timeout: 10s               # Timeout after 10 seconds
      retries: 3                 # Retry 3 times before unhealthy
      start_period: 40s          # Don't check for first 40 seconds
    
  api:
    image: myapi
    
    healthcheck:
      test: ["CMD-SHELL", "wget --spider http://localhost:8080/health || exit 1"]
      interval: 1m
      timeout: 5s
      retries: 2
    
  database:
    image: postgres
    
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
```

---

## Networks in Compose {#networks}

### Default Network

```yaml
# When you don't specify networks
version: '3.8'

services:
  web:
    image: nginx
  api:
    image: myapi
  db:
    image: postgres

# Compose automatically creates:
# - Network: myapp_default (bridge)
# - All services connect to it
# - Services can reach each other by name
```

**How It Works:**

```
DEFAULT NETWORK:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Project: myapp
Creates: myapp_default

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Network: myapp_default                 â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚   web   â”‚  â”‚   api   â”‚  â”‚   db   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                         â”‚
â”‚  web can call:                          â”‚
â”‚  - http://api:8080                      â”‚
â”‚  - postgres://db:5432                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Custom Networks

```yaml
version: '3.8'

services:
  frontend:
    image: react-app
    networks:
      - frontend-net
      
  backend:
    image: node-api
    networks:
      - frontend-net
      - backend-net
      
  database:
    image: postgres
    networks:
      - backend-net

networks:
  frontend-net:
    driver: bridge
  backend-net:
    driver: bridge
```

**Network Isolation:**

```
NETWORK SEGMENTATION:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ frontend-net                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ frontend â”‚â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ backend  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ backend-net                â”‚          â”‚
â”‚                       â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”    â”‚
â”‚                       â”‚ backend  â”‚    â”‚
â”‚                       â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                            â”‚          â”‚
â”‚                       â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”    â”‚
â”‚                       â”‚ database â”‚    â”‚
â”‚                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

frontend can reach: backend âœ“
frontend cannot reach: database âœ— (different network)
backend can reach: both âœ“
```

### Network Configuration Options

```yaml
networks:
  # Basic bridge network
  app-network:
    driver: bridge
    
  # Bridge with custom subnet
  custom-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.28.0.0/16
          gateway: 172.28.0.1
    
  # External network (already exists)
  existing-network:
    external: true
    name: my-pre-existing-network
    
  # Host network (share host's network)
  host-network:
    driver: host
```

---

## Volumes in Compose {#volumes}

### Types of Volumes

```yaml
services:
  app:
    image: myapp
    volumes:
      # Named volume (managed by Docker)
      - db_data:/var/lib/postgresql/data
      
      # Bind mount (host directory)
      - ./app:/usr/src/app
      
      # Bind mount (absolute path)
      - /host/path:/container/path
      
      # Anonymous volume
      - /var/lib/data
      
      # Read-only mount
      - ./config:/etc/config:ro
      
      # Cached mount (performance)
      - ./code:/app:cached

volumes:
  db_data:    # Declare named volume
```

**Visual Explanation:**

```
VOLUME TYPES:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. NAMED VOLUME:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Docker-managed                       â”‚
â”‚ /var/lib/docker/volumes/myapp_db_dataâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ Volume
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Container: /var/lib/postgresql/data  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Use for: Persistent data

2. BIND MOUNT:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Host: /home/user/project/app         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ Bind mount
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Container: /usr/src/app              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Use for: Development (live code reload)

3. ANONYMOUS VOLUME:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Docker-managed (random name)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ Volume
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Container: /var/lib/data             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Use for: Temporary cache
```

### Volume Configuration

```yaml
volumes:
  # Simple volume
  data:
  
  # Volume with driver
  db_data:
    driver: local
    
  # Volume with options
  cache_data:
    driver: local
    driver_opts:
      type: tmpfs
      device: tmpfs
      o: size=100m,uid=1000
      
  # External volume (already exists)
  existing_data:
    external: true
    name: my-existing-volume
    
  # NFS volume
  nfs_data:
    driver: local
    driver_opts:
      type: nfs
      o: addr=192.168.1.100,rw
      device: ":/path/to/dir"
```

### Development vs Production Volumes

```yaml
# Development: docker-compose.yml
services:
  app:
    build: .
    volumes:
      - ./src:/app/src          # Live code reload
      - ./tests:/app/tests
      - node_modules:/app/node_modules  # Don't overwrite

# Production: docker-compose.prod.yml
services:
  app:
    image: myapp:latest
    volumes:
      - app_data:/app/data      # Only data, no source code
```

---

## Environment Variables {#environment}

### Setting Environment Variables

```yaml
services:
  app:
    image: myapp
    
    # Method 1: Inline
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgres://db:5432/myapp
      - API_KEY=abc123
    
    # Method 2: Key-value pairs
    environment:
      NODE_ENV: production
      DATABASE_URL: postgres://db:5432/myapp
      API_KEY: abc123
    
    # Method 3: From .env file
    env_file:
      - .env
      - .env.production
```

### Using .env File

```bash
# .env file (in same directory as docker-compose.yml)
NODE_ENV=production
DATABASE_PASSWORD=secret123
API_KEY=xyz789
POSTGRES_VERSION=14
```

```yaml
# docker-compose.yml
services:
  app:
    image: myapp
    env_file: .env              # Load all variables
    
  database:
    image: postgres:${POSTGRES_VERSION}  # Use in compose file
    environment:
      POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
```

**How It Works:**

```
ENVIRONMENT VARIABLE FLOW:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. .env file on host
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DATABASE_PASSWORD=secret123 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ env_file
               â–¼
2. Docker Compose reads
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Loads into environment      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
3. Container receives
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Container environment       â”‚
â”‚ DATABASE_PASSWORD=secret123 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
4. Application reads
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ process.env.DATABASE_PASSWORDâ”‚
â”‚ = "secret123"               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Variable Substitution

```yaml
# docker-compose.yml
services:
  web:
    image: nginx:${NGINX_VERSION:-latest}    # Default if not set
    ports:
      - "${HOST_PORT:-80}:80"                # Default to 80
    environment:
      - API_URL=${API_URL}                   # Required (fails if not set)
      - DEBUG=${DEBUG-false}                 # Default to false
```

```bash
# .env
NGINX_VERSION=1.23-alpine
HOST_PORT=8080
API_URL=https://api.example.com
```

---

## Dependencies and Startup Order {#dependencies}

### depends_on (Basic)

```yaml
services:
  # Start order: database â†’ backend â†’ frontend
  
  frontend:
    image: react-app
    depends_on:
      - backend                # Wait for backend to start
      
  backend:
    image: node-api
    depends_on:
      - database               # Wait for database to start
      
  database:
    image: postgres
```

**What depends_on Does:**

```
STARTUP ORDER:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Without depends_on:
All services start simultaneously
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ frontend â”‚  â”‚ backend  â”‚  â”‚ database â”‚
â”‚ (starts) â”‚  â”‚ (starts) â”‚  â”‚ (starts) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚             â”‚             â”‚
     â”‚        âŒ Error: Can't connect to database!
     â”‚
âŒ Error: Can't connect to backend!

With depends_on:
Services start in order
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ database â”‚
â”‚ (starts) â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
      â”‚ waits to start
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ backend  â”‚
â”‚ (starts) â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
      â”‚ waits to start
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ frontend â”‚
â”‚ (starts) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âœ“ All connections work!

âš ï¸ IMPORTANT:
depends_on waits for container to START
NOT for application to be READY!
```

### depends_on with Conditions (Long Format)

```yaml
services:
  frontend:
    image: react-app
    depends_on:
      backend:
        condition: service_healthy    # Wait until healthy!
        
  backend:
    image: node-api
    depends_on:
      database:
        condition: service_healthy
      cache:
        condition: service_started    # Just wait for start
    healthcheck:                      # Define health check
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 10s
      timeout: 5s
      retries: 3
      
  database:
    image: postgres
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      
  cache:
    image: redis
```

**Condition Types:**

```
service_started:  Container started (default)
service_healthy:  Container healthy (requires healthcheck)
service_completed_successfully: Container ran and exited 0
```

### Handling Startup Delays (Application Level)

```yaml
# docker-compose.yml
services:
  backend:
    image: node-api
    depends_on:
      - database
    # Even with depends_on, database might not be ready!
    
    # Solution: Retry logic in application
    environment:
      - DB_RETRY_ATTEMPTS=5
      - DB_RETRY_DELAY=3
```

```javascript
// app.js - Retry connection logic
const connectWithRetry = async (maxRetries = 5, delay = 3000) => {
  for (let i = 0; i < maxRetries; i++) {
    try {
      await database.connect();
      console.log('Connected to database');
      return;
    } catch (error) {
      console.log(`Connection attempt ${i + 1} failed, retrying in ${delay}ms...`);
      await sleep(delay);
    }
  }
  throw new Error('Could not connect to database');
};
```

---

## Advanced Compose Features {#advanced}

### Extending Services

```yaml
# docker-compose.yml (base)
services:
  web:
    image: nginx
    volumes:
      - ./html:/usr/share/nginx/html

# docker-compose.override.yml (automatically loaded)
services:
  web:
    ports:
      - "8080:80"              # Add ports
    environment:
      - DEBUG=true             # Add environment

# Result: Merged configuration
# nginx with volume + ports + environment
```

### Multiple Compose Files

```yaml
# docker-compose.yml (base)
services:
  app:
    build: .
    
# docker-compose.prod.yml (production overrides)
services:
  app:
    image: myapp:v1.0          # Use image instead of build
    restart: always
    environment:
      - NODE_ENV=production

# Usage:
$ docker-compose -f docker-compose.yml -f docker-compose.prod.yml up
```

### Profiles (Selective Service Start)

```yaml
services:
  # Core services (always start)
  web:
    image: nginx
    
  api:
    image: myapi
    
  # Optional services (only with profile)
  debug:
    image: debug-tools
    profiles: ["debug"]        # Only start with --profile debug
    
  test:
    image: test-runner
    profiles: ["test"]         # Only start with --profile test
```

```bash
# Start only core services
$ docker-compose up

# Start with debug tools
$ docker-compose --profile debug up

# Start with testing
$ docker-compose --profile test up
```

### Scaling Services

```yaml
services:
  worker:
    image: my-worker
    deploy:
      replicas: 3              # Start 3 instances
```

```bash
# Scale from command line
$ docker-compose up --scale worker=5

# Creates:
# - myapp_worker_1
# - myapp_worker_2
# - myapp_worker_3
# - myapp_worker_4
# - myapp_worker_5
```

---

(Continue to Part 2 with Docker Compose Commands, Real-World Examples, Best Practices, and Troubleshooting?)