	# Dockerfile - The Recipe for Containers! üìùüç≥

## What is a Dockerfile?

Think of a Dockerfile as a **recipe card** for cooking your container! üç≤

**Recipe Card (Dockerfile)** = Tells Docker exactly how to make your container dish
**Ingredients** = Base image, packages, files
**Instructions** = Commands to run
**Final Dish** = Your running container!

## Dockerfile Structure - Simple Example:

```dockerfile
# Start with a base image (like starting with pre-made dough)
FROM ubuntu:20.04

# Add ingredients (install packages)
RUN apt update && apt install -y python3

# Copy your files (add your special sauce)
COPY app.py /app/

# Set working directory (where to work in kitchen)
WORKDIR /app

# Tell what to run when container starts
CMD ["python3", "app.py"]
```

## Every Dockerfile Instruction Explained üéì

### 1. **FROM** - The Foundation üèóÔ∏è

**What it does:** Starts with a base image. Like saying "Start with Ubuntu" or "Start with Node.js"

```dockerfile
# Examples:
FROM ubuntu:20.04              # Start with Ubuntu 20.04
FROM node:16-alpine            # Start with Node.js 16 (alpine = small)
FROM python:3.9-slim           # Start with Python 3.9 (slim = smaller)
FROM nginx:latest              # Start with latest nginx
FROM scratch                   # Start from absolutely nothing!

# MUST be first instruction (except ARG before FROM)
```

**Real analogy:** Like choosing pre-made pizza crust before adding toppings!

### 2. **LABEL** - The Sticky Notes üè∑Ô∏è

**What it does:** Adds metadata to your image (like labels on a jar)

```dockerfile
# Examples:
LABEL maintainer="john@example.com"
LABEL version="1.0"
LABEL description="This is my awesome app"
LABEL org.opencontainers.image.authors="team@company.com"

# Multiple labels:
LABEL maintainer="dev@company.com" \
      version="2.3.1" \
      description="Web application"

# Check labels: docker image inspect <image-name>
```

**Real analogy:** Like putting "Made by Mom", "Best before 2024" labels on homemade jam!

### 3. **ARG** - The Recipe Variables üì¶

**What it does:** Defines variables that can be passed during build time

```dockerfile
# Define argument:
ARG VERSION=latest
ARG USERNAME=admin
ARG PORT=3000

# Use argument:
FROM ubuntu:${VERSION}
RUN useradd ${USERNAME}
EXPOSE ${PORT}

# Build with: docker build --build-arg VERSION=20.04 .
```

**Special ARG before FROM:**
```dockerfile
# ARG before FROM can be used in FROM
ARG PYTHON_VERSION=3.9
FROM python:${PYTHON_VERSION}
```

**Real analogy:** Like a recipe saying "Add sugar (amount: 1 cup)" where you can change 1 cup to 2 cups!

### 4. **ENV** - The Container Environment Variables üåç

**What it does:** Sets environment variables inside the container (available at runtime)

```dockerfile
# Set environment variables:
ENV NODE_ENV=production
ENV API_KEY=secret123
ENV PORT=8080
ENV DATABASE_URL=postgres://user:pass@localhost/db

# Multiple in one line:
ENV NODE_ENV=production \
    PORT=3000 \
    HOME=/home/app

# Use in commands:
RUN echo "Running in $NODE_ENV mode"

# These persist in running container!
# Check: docker run -it myimage env
```

**Real analogy:** Like setting room temperature before baking - affects everything!

### 5. **WORKDIR** - The Working Directory üìÇ

**What it does:** Sets the current working directory (like `cd` command)

```dockerfile
# Set working directory:
WORKDIR /app

# All subsequent commands run from /app
RUN pwd  # Output: /app
COPY . . # Copies to /app (not root)

# Can have multiple WORKDIR:
WORKDIR /app/src
RUN pwd  # Output: /app/src

WORKDIR /app/logs
RUN pwd  # Output: /app/logs
```

**Real analogy:** Like saying "Now work on the kitchen counter" instead of floor!

### 6. **COPY** - Copy Files from Host to Container üìã

**What it does:** Copies files/folders from your computer into the image

```dockerfile
# Copy single file:
COPY app.py /app/app.py

# Copy entire directory:
COPY src/ /app/src/

# Copy with wildcards:
COPY *.py /app/

# Copy multiple files:
COPY file1.txt file2.txt /app/

# Copy with relative paths (relative to WORKDIR):
WORKDIR /app
COPY . .  # Copies everything to /app

# COPY preserves file permissions
```

**Real analogy:** Like bringing your own recipe book to the kitchen!

### 7. **ADD** - Advanced Copy (with superpowers!) ‚ú®

**What it does:** Like COPY but with extra features

```dockerfile
# Everything COPY can do, plus:
ADD https://example.com/file.tar.gz /tmp/  # Download from URL!
ADD file.tar.gz /tmp/                      # Auto-extracts tar files!
ADD --chown=user:group file.txt /app/      # Set ownership!

# But be careful! Use COPY for simple file copying
# Use ADD only when you need its special powers
```

**Real analogy:** Like COPY, but can also order ingredients online (URL) and unpack them!

### 8. **RUN** - Run Commands During Build üõ†Ô∏è

**What it does:** Executes commands while building the image

```dockerfile
# Install packages:
RUN apt update && apt install -y python3 python3-pip

# Multiple commands (chained):
RUN apt update \
    && apt install -y python3 python3-pip \
    && pip3 install flask \
    && apt clean \
    && rm -rf /var/lib/apt/lists/*

# Create directory:
RUN mkdir -p /app/logs

# Set permissions:
RUN chmod +x /app/start.sh

# Each RUN creates a new layer (cacheable)
```

**Real analogy:** Like following cooking steps: "Chop onions", "Fry garlic", "Add tomatoes"!

### 9. **CMD** - Default Command to Run üöÄ

**What it does:** Defines the default command to run when container starts

```dockerfile
# Three forms:
CMD ["executable", "param1", "param2"]  # Exec form (recommended)
CMD ["python3", "app.py"]

CMD command param1 param2                # Shell form
CMD python3 app.py

CMD ["param1", "param2"]                # As default parameters to ENTRYPOINT

# Only ONE CMD - last one wins!
# Can be overridden: docker run myimage bash
```

**Real analogy:** Like the main dish you serve when guests arrive!

### 10. **ENTRYPOINT** - The Main Program üéØ

**What it does:** Configures container to run as an executable

```dockerfile
# Two forms:
ENTRYPOINT ["executable", "param1", "param2"]  # Exec form
ENTRYPOINT ["python3", "app.py"]

ENTRYPOINT command param1 param2               # Shell form
ENTRYPOINT python3 app.py

# CMD becomes default arguments to ENTRYPOINT:
ENTRYPOINT ["echo"]
CMD ["Hello World"]  # Default: echo "Hello World"
# Override: docker run myimage "Goodbye" ‚Üí echo "Goodbye"
```

**Real analogy:** Like deciding the kitchen will always make pizza (ENTRYPOINT), with default topping pepperoni (CMD)!

### 11. **EXPOSE** - Document Ports üì¢

**What it does:** Documents which ports the container listens on (informational only!)

```dockerfile
# Document ports:
EXPOSE 80       # HTTP
EXPOSE 443      # HTTPS
EXPOSE 3000     # Node.js app
EXPOSE 8080/tcp # With protocol (tcp/udp)
EXPOSE 5672/udp

# This doesn't publish ports! Just documents.
# To actually publish: docker run -p 80:80
```

**Real analogy:** Like putting "Emergency Exit Here" sign - doesn't open door, just shows where!

### 12. **USER** - Switch User üë§

**What it does:** Sets the user (and group) for subsequent commands

```dockerfile
# Create user first:
RUN groupadd -r appuser && useradd -r -g appuser appuser

# Switch to non-root user:
USER appuser

# Now all commands run as appuser (safer!)
WORKDIR /home/appuser
COPY --chown=appuser:appuser . .

# Can switch back:
USER root
RUN apt update
USER appuser
```

**Real analogy:** Like wearing different hats - "Now I'm the chef", "Now I'm the cleaner"!

### 13. **VOLUME** - Create Mount Point üíæ

**What it does:** Creates a mount point for external volumes

```dockerfile
# Create volume directories:
VOLUME /var/lib/mysql    # For database
VOLUME /app/data         # For application data
VOLUME /tmp              # For temporary files

# Multiple volumes:
VOLUME ["/data", "/config", "/logs"]

# These are automatically mounted as anonymous volumes
```

**Real analogy:** Like marking "Put leftovers here" in fridge - expects external container!

### 14. **HEALTHCHECK** - Container Health Monitor ‚ù§Ô∏è

**What it does:** Tells Docker how to test if container is healthy

```dockerfile
# Check every 30s, timeout after 3s, retry 3 times:
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost/health || exit 1

# Simple command:
HEALTHCHECK CMD pg_isready -U postgres || exit 1

# Disable inherited healthcheck:
HEALTHCHECK NONE
```

**Real analogy:** Like checking if oven is at right temperature before baking!

### 15. **ONBUILD** - Future Instructions üìÖ

**What it does:** Adds instructions to run when this image is used as base for another

```dockerfile
# In parent Dockerfile:
ONBUILD COPY . /app/src
ONBUILD RUN make /app/src

# When someone uses FROM your-image:
# Their build automatically runs your ONBUILD instructions
```

**Real analogy:** Like leaving notes for next chef: "When using my dough, remember to preheat oven!"

### 16. **STOPSIGNAL** - Stop Signal üîä

**What it does:** Sets the system call signal for stopping container

```dockerfile
# Change from default SIGTERM to SIGINT:
STOPSIGNAL SIGINT

# Use signal number:
STOPSIGNAL 9  # SIGKILL
```

**Real analogy:** Like choosing bell instead of whistle to signal dinner is ready!

### 17. **SHELL** - Change Default Shell üêö

**What it does:** Changes the default shell for shell form commands

```dockerfile
# Change to PowerShell (Windows):
SHELL ["powershell", "-Command"]

# Now RUN commands use PowerShell:
RUN Write-Host "Hello from PowerShell"

# Change back to bash:
SHELL ["/bin/bash", "-c"]
```

**Real analogy:** Like switching from English to French cooking instructions!

## Complete Real-World Examples üéØ

### Example 1: Simple Python Web App üêç

```dockerfile
# Python Web Application
FROM python:3.9-slim

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PORT=8000

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apt update \
    && apt install -y --no-install-recommends gcc \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first (for caching)
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create non-root user
RUN useradd -m -u 1000 appuser \
    && chown -R appuser:appuser /app
USER appuser

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s \
  CMD python healthcheck.py || exit 1

# Run application
CMD ["gunicorn", "--bind", "0.0.0.0:8000", "app:app"]
```

### Example 2: Node.js API with Nginx üöÄ

```dockerfile
# Multi-stage build: Build + Production
# Stage 1: Build
FROM node:16-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

# Stage 2: Production
FROM nginx:alpine

# Copy built files from builder stage
COPY --from=builder /app /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf

# Set labels
LABEL maintainer="dev@company.com" \
      version="1.0.0" \
      description="Node.js API with Nginx"

# Expose ports
EXPOSE 80 443

# Health check
HEALTHCHECK CMD wget --no-verbose --tries=1 --spider http://localhost/health || exit 1

# Start nginx
CMD ["nginx", "-g", "daemon off;"]
```

### Example 3: Java Spring Boot Application ‚òï

```dockerfile
# Java Application
FROM openjdk:11-jre-slim

# Arguments for build
ARG JAR_FILE=target/*.jar
ARG APP_VERSION=1.0.0

# Environment variables
ENV SPRING_PROFILES_ACTIVE=production \
    JAVA_OPTS="-Xmx512m -Xms256m"

# Create app user
RUN groupadd -r spring && useradd -r -g spring spring

# Copy jar file
COPY ${JAR_FILE} app.jar

# Create directory for logs
RUN mkdir -p /var/log/app && chown spring:spring /var/log/app

# Switch to non-root user
USER spring:spring

# Expose port
EXPOSE 8080

# Volume for external configuration
VOLUME /tmp

# Entrypoint with shell script for flexibility
ENTRYPOINT ["sh", "-c"]
CMD ["java ${JAVA_OPTS} -Djava.security.egd=file:/dev/./urandom -jar /app.jar"]
```

### Example 4: Database Container (PostgreSQL) üóÑÔ∏è

```dockerfile
# PostgreSQL Database
FROM postgres:13-alpine

# Environment variables for database
ENV POSTGRES_DB=mydb \
    POSTGRES_USER=admin \
    POSTGRES_PASSWORD=secret

# Copy initialization scripts
COPY init.sql /docker-entrypoint-initdb.d/
COPY setup.sh /docker-entrypoint-initdb.d/

# Copy custom configuration
COPY postgresql.conf /etc/postgresql/
COPY pg_hba.conf /etc/postgresql/

# Create directory for data
RUN mkdir -p /var/lib/postgresql/data \
    && chown -R postgres:postgres /var/lib/postgresql/data

# Volume for persistent data
VOLUME /var/lib/postgresql/data

# Health check
HEALTHCHECK --interval=10s --timeout=5s --retries=5 \
  CMD pg_isready -U ${POSTGRES_USER} || exit 1

# Use the default PostgreSQL entrypoint
# (inherited from parent image)
```

## Multi-Stage Builds - The Pro Technique! üèóÔ∏è

```dockerfile
# Stage 1: Build everything (tools, compilers, etc.)
FROM node:16 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Stage 2: Production (only what's needed)
FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]

# Result: Small final image! Builder tools not included!
```

**Why multi-stage?**
- Final image is smaller (no build tools)
- More secure (fewer packages)
- Faster builds (cached stages)

## Best Practices Checklist ‚úÖ

### 1. **Use Official Images**
```dockerfile
FROM node:16-alpine    # Good ‚úì
FROM ubuntu:20.04      # Good ‚úì
FROM some-random-repo  # Bad ‚úó
```

### 2. **Be Specific with Versions**
```dockerfile
FROM node:16-alpine    # Good ‚úì
FROM node:latest       # Bad ‚úó (might break tomorrow!)
```

### 3. **One Service Per Container**
```dockerfile
# Don't run database AND web server in same container
# Use separate containers connected via networking
```

### 4. **Minimize Layers**
```dockerfile
# Bad: Many layers
RUN apt update
RUN apt install -y package1
RUN apt install -y package2
RUN apt clean

# Good: One layer
RUN apt update \
    && apt install -y package1 package2 \
    && apt clean
```

### 5. **Order Matters for Caching**
```dockerfile
# Copy package files first (changes less often)
COPY package.json package-lock.json ./
RUN npm install

# Then copy source code (changes more often)
COPY . .

# This way, npm install is cached unless package.json changes!
```

### 6. **Use .dockerignore**
```dockerfile
# Create .dockerignore file:
node_modules/
.git/
*.log
.env
Dockerfile
README.md
```

### 7. **Non-Root User**
```dockerfile
RUN useradd -m appuser
USER appuser
```

### 8. **Clean Up in Same RUN**
```dockerfile
RUN apt update \
    && apt install -y package \
    && rm -rf /var/lib/apt/lists/*  # Clean up!
```

## Common Patterns and Templates üìã

### Pattern 1: Development with Hot Reload
```dockerfile
FROM node:16
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
CMD ["npm", "run", "dev"]  # Auto-reload on code changes
```

### Pattern 2: Production Web Server
```dockerfile
FROM nginx:alpine
COPY --chown=nginx:nginx dist/ /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf
EXPOSE 80
USER nginx
CMD ["nginx", "-g", "daemon off;"]
```

### Pattern 3: Cron Job Container
```dockerfile
FROM alpine:latest
RUN apk add --no-cache bash curl
COPY backup.sh /backup.sh
RUN chmod +x /backup.sh
# Run backup daily at 2 AM
CMD ["echo", "0 2 * * * /backup.sh >> /var/log/cron.log 2>&1"]
```

### Pattern 4: Data Processing Container
```dockerfile
FROM python:3.9
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY processor.py .
# Expects input/output volumes
VOLUME /input /output
ENTRYPOINT ["python", "processor.py"]
```

## Debugging Dockerfile Issues üêõ

### Common Problems:

1. **"No such file or directory"**
   ```dockerfile
   # Wrong:
   COPY app.py /app/  # But app.py doesn't exist in build context
   
   # Check: Is file in same directory as Dockerfile?
   ```

2. **Permission Denied**
   ```dockerfile
   # Solution: Set proper permissions
   RUN chmod +x /app/start.sh
   USER nonrootuser
   ```

3. **Build Cache Issues**
   ```bash
   # Force rebuild without cache:
   docker build --no-cache -t myapp .
   
   # Build specific stage:
   docker build --target builder -t myapp .
   ```

4. **Large Image Size**
   ```dockerfile
   # Clean up in same RUN command:
   RUN apt update \
       && apt install -y package \
       && apt clean \
       && rm -rf /var/lib/apt/lists/*
   ```

## Dockerfile vs docker-compose.yml

```dockerfile
# Dockerfile (Recipe):
# - How to BUILD the container
# - What goes INSIDE the container
# - Build instructions

# docker-compose.yml (Menu):
# - How to RUN multiple containers
# - How they CONNECT (networking)
# - Runtime configuration
```

## Quick Reference Cheat Sheet üìú

| Instruction | What It Does | Example |
|------------|-------------|---------|
| `FROM` | Base image | `FROM ubuntu:20.04` |
| `RUN` | Run command during build | `RUN apt update` |
| `COPY` | Copy files | `COPY . /app` |
| `ADD` | Copy + extract + URL | `ADD file.tar.gz /` |
| `CMD` | Default run command | `CMD ["npm", "start"]` |
| `ENTRYPOINT` | Main executable | `ENTRYPOINT ["python"]` |
| `ENV` | Set environment variable | `ENV PORT=3000` |
| `ARG` | Build-time variable | `ARG VERSION=1.0` |
| `WORKDIR` | Set working directory | `WORKDIR /app` |
| `EXPOSE` | Document port | `EXPOSE 80` |
| `USER` | Switch user | `USER appuser` |
| `VOLUME` | Create mount point | `VOLUME /data` |
| `LABEL` | Add metadata | `LABEL version="1.0"` |
| `HEALTHCHECK` | Health check command | `HEALTHCHECK CMD curl -f` |

## The Complete Process: Idea to Container üöÄ

```
1. Write Dockerfile (recipe)
2. Build: docker build -t myapp . (cook)
3. Run: docker run -p 3000:3000 myapp (serve)
4. Share: docker push myapp (share recipe)
5. Others: docker pull myapp (get your dish)
```

## Your First Dockerfile - Step by Step üë£

### Step 1: Create a simple app
```python
# app.py
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
    return "Hello Docker!"

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

### Step 2: Create requirements.txt
```
Flask==2.0.1
```

### Step 3: Write Dockerfile
```dockerfile
# Dockerfile
FROM python:3.9-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
EXPOSE 5000
CMD ["python", "app.py"]
```

### Step 4: Build and Run
```bash
# Build:
docker build -t my-python-app .

# Run:
docker run -p 5000:5000 my-python-app

# Visit: http://localhost:5000
# See: "Hello Docker!"
```

**Congratulations!** You just containerized your first app! üéâ

## Remember: Dockerfile is Like Cooking! üë©‚Äçüç≥

- **FROM** = Choose your base ingredient (flour for bread)
- **RUN** = Cooking steps (mix, knead, bake)
- **COPY** = Add your special ingredients
- **ENV** = Set cooking temperature
- **WORKDIR** = Choose your workspace
- **CMD** = Serve the dish
- **EXPOSE** = Tell guests where to sit

Every great container starts with a great Dockerfile! Happy container cooking! üê≥üç≥