# Complete Logic of Docker Image Building: Universal Workflow

## Table of Contents

1. [What is Docker Image Building?](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#what-is-building)
2. [The Universal Logic of Image Building](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#universal-logic)
3. [The Complete Build Workflow](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#build-workflow)
4. [Understanding Layers: The Core Concept](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#layers-concept)
5. [The Build Process Step-by-Step](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#build-process)
6. [How Docker Executes Each Instruction](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#instruction-execution)
7. [Universal Pattern for Any Programming Language](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#universal-pattern)
8. [Language-Specific Build Workflows](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#language-workflows)
9. [The Context and How Files Get Into Image](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#build-context)
10. [Caching Logic During Builds](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#caching-logic)
11. [From Dockerfile to Running Container](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#dockerfile-to-container)
12. [Complete Real Examples](https://claude.ai/chat/1aeaf5cc-96d4-4c4b-bd25-c56339a51961#complete-examples)

---

## What is Docker Image Building? {#what-is-building}

### The Simple Explanation

**Docker image building** is the process of creating a package that contains everything needed to run your application.

Think of it like this:

```
BUILDING AN IMAGE = Creating a Recipe + Shopping + Cooking

Recipe (Dockerfile):
"Here's how to make this dish"
├─ Start with base ingredients
├─ Add more ingredients
├─ Mix and cook
└─ Serve

Shopping (Build Context):
"Here are the ingredients I have"
├─ Your application code
├─ Configuration files
├─ Resources and assets

Cooking (Docker Build):
"Let me follow the recipe with these ingredients"
├─ Docker reads recipe (Dockerfile)
├─ Uses ingredients (Context files)
├─ Creates the dish (Image)

Result (Docker Image):
"A complete, ready-to-serve meal"
├─ Contains everything needed
├─ Can be served anywhere
├─ Same taste every time
```

### What is an Image?

```
DOCKER IMAGE = A Blueprint for Running Your Application

Image is like:
┌─────────────────────────────────────────────┐
│         A House Blueprint                   │
│                                             │
│ Contains:                                   │
│ ✓ Foundation (Operating System)             │
│ ✓ Walls (Runtime - Python, Node, Java)      │
│ ✓ Plumbing (Dependencies)                   │
│ ✓ Furniture (Your Application)              │
│ ✓ Instructions (How to start)               │
│                                             │
│ When you build from this blueprint:         │
│ You get an identical house every time!      │
└─────────────────────────────────────────────┘

Key Properties:
1. Read-only (can't be modified after creation)
2. Layered (built in steps)
3. Reusable (same image → many containers)
4. Portable (works on any Docker system)
```

---

## The Universal Logic of Image Building {#universal-logic}

This logic applies to **ANY** programming language or application:

### The Core Building Logic

```
UNIVERSAL IMAGE BUILDING LOGIC (5 STEPS):

Step 1: START WITH A BASE
        "What do I need to exist?"
        ├─ Operating System (Linux, Alpine, etc.)
        └─ Basic tools (package managers, libraries)

Step 2: INSTALL RUNTIME
        "What does my application need to run?"
        ├─ Python interpreter
        ├─ Node.js runtime
        ├─ Java JVM
        └─ Or other language runtime

Step 3: ADD DEPENDENCIES
        "What libraries does my app need?"
        ├─ Install packages (npm, pip, maven, etc.)
        ├─ Only what the application imports
        └─ These are external code your app uses

Step 4: ADD YOUR APPLICATION
        "What is the actual code I wrote?"
        ├─ Copy your source code
        ├─ Or copy compiled binaries
        └─ This is YOUR work

Step 5: DEFINE HOW TO RUN
        "How do I start this application?"
        ├─ What command to execute
        ├─ What port it listens on
        └─ What environment it needs

RESULT: A complete, runnable image
```

### Visual Logic Flow

```
The Universal Build Logic:

START
  │
  ▼
┌────────────────────────────────────┐
│ FROM some-base-image               │  Step 1: Foundation
│ (Get base OS + basic tools)        │
└────────────┬───────────────────────┘
             │
             ▼
┌────────────────────────────────────┐
│ RUN install-runtime                │  Step 2: Add Runtime
│ (Install Python, Node, Java, etc.) │
└────────────┬───────────────────────┘
             │
             ▼
┌────────────────────────────────────┐
│ COPY dependency-files              │  Step 3a: Copy dependency list
│ RUN install-dependencies           │  Step 3b: Install dependencies
└────────────┬───────────────────────┘
             │
             ▼
┌────────────────────────────────────┐
│ COPY application-code              │  Step 4: Add your app
└────────────┬───────────────────────┘
             │
             ▼
┌────────────────────────────────────┐
│ CMD ["run", "application"]         │  Step 5: Define start command
└────────────┬───────────────────────┘
             │
             ▼
          IMAGE READY
      (Can create containers)
```

---

## The Complete Build Workflow {#build-workflow}

Let's understand the COMPLETE workflow from start to finish:

### The Big Picture Workflow

```
COMPLETE DOCKER IMAGE BUILD WORKFLOW:

Phase 1: PREPARATION (You do this)
═══════════════════════════════════════════════════════════
┌─────────────────────────────────────────────────────────┐
│ 1. Write Your Application                               │
│    ├─ Create source code files                          │
│    ├─ Write configurations                              │
│    └─ Test locally                                      │
│                                                         │
│ 2. Create Dockerfile                                    │
│    ├─ Choose base image                                 │
│    ├─ Define build steps                                │
│    └─ Set runtime command                               │
│                                                         │
│ 3. Organize Project Structure                           │
│    ├─ Put files in folders                              │
│    ├─ Create .dockerignore                              │
│    └─ Prepare build context                             │
└─────────────────────────────────────────────────────────┘

Phase 2: BUILD (Docker does this)
═══════════════════════════════════════════════════════════
┌─────────────────────────────────────────────────────────┐
│ 1. Read Dockerfile                                      │
│    └─ Parse instructions top to bottom                  │
│                                                         │
│ 2. Prepare Build Context                                │
│    └─ Send all files to Docker daemon                   │
│                                                         │
│ 3. Execute Instructions                                 │
│    ├─ FROM: Load base image                             │
│    ├─ RUN: Execute commands                             │
│    ├─ COPY: Add files                                   │
│    ├─ ENV: Set variables                                │
│    └─ CMD: Set startup command                          │
│                                                         │
│ 4. Create Layers                                        │
│    └─ Each instruction = One layer                      │
│                                                         │
│ 5. Save Final Image                                     │
│    └─ Store all layers as one image                     │
└─────────────────────────────────────────────────────────┘

Phase 3: USAGE (You do this)
═══════════════════════════════════════════════════════════
┌─────────────────────────────────────────────────────────┐
│ 1. Run Container from Image                             │
│    └─ docker run myimage                                │
│                                                         │
│ 2. Container Starts                                     │
│    └─ Executes CMD from Dockerfile                      │
│                                                         │
│ 3. Application Runs                                     │
│    └─ Your app is now running inside container          │
└─────────────────────────────────────────────────────────┘
```

### The Detailed Workflow Diagram

```
USER WORKFLOW:
┌──────────────────────────────────────────────────────────┐
│                                                          │
│  Developer's Computer                                    │
│  ├─ Write application code                              │
│  ├─ Write Dockerfile                                    │
│  ├─ Organize files                                      │
│  │                                                       │
│  └─ Run: docker build -t myapp .                         │
│            │                                             │
└────────────┼─────────────────────────────────────────────┘
             │
             │ Send build request
             ▼
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  Docker Daemon                                          │
│  │                                                      │
│  ├─ Receive build request                               │
│  ├─ Read Dockerfile                                     │
│  ├─ Collect build context (all files)                   │
│  │                                                      │
│  ├─ Execute each instruction:                           │
│  │  ├─ FROM → Load base image                           │
│  │  ├─ RUN → Execute commands                           │
│  │  ├─ COPY → Add files                                 │
│  │  └─ CMD → Set startup                                │
│  │                                                      │
│  ├─ Create layer for each instruction                   │
│  ├─ Stack all layers                                    │
│  └─ Save as image                                       │
│            │                                            │
└────────────┼────────────────────────────────────────────┘
             │
             │ Image saved
             ▼
┌──────────────────────────────────────────────────────────┐
│                                                          │
│  Image Storage                                           │
│  └─ myapp:latest (stored on disk)                        │
│                                                          │
└──────────────────────────────────────────────────────────┘
             │
             │ docker run myapp
             ▼
┌──────────────────────────────────────────────────────────┐
│                                                          │
│  Running Container                                       │
│  └─ Application executing                                │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

---

## Understanding Layers: The Core Concept {#layers-concept}

Layers are THE fundamental concept in Docker image building.

### What is a Layer?

```
A LAYER = A Snapshot of Changes

Think of it like taking photos of a building being constructed:

Photo 1 (Layer 1): Empty lot
┌─────────────────────────┐
│                         │
│     (empty ground)      │
│                         │
└─────────────────────────┘

Photo 2 (Layer 2): Foundation added
┌─────────────────────────┐
│                         │
│    ▓▓▓▓▓▓▓▓▓▓▓▓▓        │
└─────────────────────────┘

Photo 3 (Layer 3): Walls added
┌─────────────────────────┐
│    │         │          │
│    │         │          │
│    ▓▓▓▓▓▓▓▓▓▓▓▓▓        │
└─────────────────────────┘

Photo 4 (Layer 4): Roof added
┌─────────────────────────┐
│       /────\            │
│    │ /      \ │         │
│    │/        \│         │
│    ▓▓▓▓▓▓▓▓▓▓▓▓▓        │
└─────────────────────────┘

Each photo shows ONLY what changed since the last photo.
Stack all photos together = Complete building!

Docker layers work the SAME WAY!
```

### How Instructions Create Layers

```
DOCKERFILE INSTRUCTIONS → LAYERS

Only these instructions create layers:
┌──────────────────────────────────────┐
│ FROM   → Creates layer (base image)  │
│ RUN    → Creates layer (changes)     │
│ COPY   → Creates layer (adds files)  │
│ ADD    → Creates layer (adds files)  │
└──────────────────────────────────────┘

These DON'T create layers (just metadata):
┌──────────────────────────────────────┐
│ ENV    → Just sets variable          │
│ EXPOSE → Just documents port          │
│ CMD    → Just sets command            │
│ LABEL  → Just adds metadata           │
│ WORKDIR → Just changes directory      │
└──────────────────────────────────────┘

Example:
FROM ubuntu            → Layer 1 (50 MB)
RUN apt-get install    → Layer 2 (100 MB)
COPY app.py .          → Layer 3 (1 MB)
ENV PORT=8080          → No layer (metadata)
CMD ["python", "app"]  → No layer (metadata)

Final image: 3 layers (151 MB total)
```

### Layer Stacking Logic

```
LAYERS STACK LIKE TRANSPARENT SHEETS:

Imagine transparent sheets stacked on top of each other:

Sheet 1 (Layer 1):
┌─────────────────────────┐
│ ubuntu/                 │
│  ├─ bin/                │
│  ├─ usr/                │
│  └─ lib/                │
└─────────────────────────┘

Sheet 2 (Layer 2) placed on top:
┌─────────────────────────┐
│ usr/                    │
│  └─ lib/                │
│      └─ python/         │
└─────────────────────────┘

Sheet 3 (Layer 3) placed on top:
┌─────────────────────────┐
│ app/                    │
│  └─ app.py              │
└─────────────────────────┘

When you look through all sheets:
┌─────────────────────────┐
│ ubuntu/                 │
│  ├─ bin/                │
│  ├─ usr/                │
│  │   └─ lib/            │
│  │       └─ python/     │
│  └─ lib/                │
│ app/                    │
│  └─ app.py              │
└─────────────────────────┘

This is what you see in a running container!
```

---

## The Build Process Step-by-Step {#build-process}

Let's follow the EXACT process Docker uses to build an image:

### Step 1: You Run Docker Build

```
YOU TYPE:
$ docker build -t myapp:latest .
              │              │
              │              └─ Build context (current directory)
              └─ Tag name for the image

WHAT THIS DOES:
1. Tells Docker to build an image
2. Tag it as "myapp:latest"
3. Use current directory (.) as build context
```

### Step 2: Docker Reads Dockerfile

```
DOCKER'S LOGIC:

1. Look for file named "Dockerfile" in build context
   └─ If not found, error: "unable to locate Dockerfile"

2. Read entire file into memory
   └─ Parse all instructions
   └─ Validate syntax

3. Plan the build
   └─ Count instructions
   └─ Determine which create layers
   └─ Check if any cached layers can be reused

Example Dockerfile:
FROM python:3.11          ← Instruction 1
WORKDIR /app              ← Instruction 2
COPY requirements.txt .   ← Instruction 3
RUN pip install -r req... ← Instruction 4
COPY . .                  ← Instruction 5
CMD ["python", "app.py"]  ← Instruction 6

Docker's Plan:
"I need to execute 6 instructions
 Instructions 1, 3, 4, 5 will create layers
 Total expected layers: 4"
```

### Step 3: Docker Prepares Build Context

```
BUILD CONTEXT = All files Docker can access during build

YOUR PROJECT DIRECTORY:
myproject/
├── Dockerfile
├── app.py
├── requirements.txt
├── config.json
├── node_modules/        (1 GB!)
├── .git/                (500 MB!)
└── tests/

DOCKER'S LOGIC:
1. Find all files in build context directory (.)
2. Exclude files in .dockerignore (if exists)
3. Package all remaining files
4. Send to Docker daemon

WITHOUT .dockerignore:
Sends: 1.5 GB (everything!)

WITH .dockerignore:
.dockerignore contents:
node_modules
.git
tests

Sends: 50 MB (only needed files!)

The build context is UPLOADED to Docker daemon.
If it's large, this takes time!
```

### Step 4: Docker Executes Instructions One by One

```
INSTRUCTION EXECUTION LOGIC:

Docker executes instructions in STRICT ORDER (top to bottom).
Each instruction is a step in the build process.

For EACH instruction:
┌────────────────────────────────────────────────┐
│ 1. Check if cached layer exists                │
│    └─ Yes? Use cached layer (fast!)            │
│    └─ No? Execute instruction (create layer)   │
│                                                │
│ 2. If executing:                               │
│    a. Start with previous layer's filesystem   │
│    b. Execute the instruction                  │
│    c. Capture all changes                      │
│    d. Save changes as new layer                │
│    e. Layer gets a unique hash (ID)            │
│                                                │
│ 3. Move to next instruction                    │
│    └─ Current layer becomes "previous layer"   │
└────────────────────────────────────────────────┘

Example Execution:

Instruction 1: FROM python:3.11
  Check: Do I have python:3.11 locally?
  Yes → Use cached image as Layer 1
  No → Pull from Docker Hub

Instruction 2: WORKDIR /app
  Action: Create /app directory, set as working dir
  Note: No layer created (just metadata)

Instruction 3: COPY requirements.txt .
  Check: Has requirements.txt changed? (checksum)
  Changed → Execute: Copy file from context
  Create: Layer 2 (contains requirements.txt)

Instruction 4: RUN pip install -r requirements.txt
  Check: Is Layer 2 + this command cached?
  Not cached → Execute: Run pip install
  Create: Layer 3 (contains installed packages)

Instruction 5: COPY . .
  Check: Have source files changed?
  Changed → Execute: Copy all files
  Create: Layer 4 (contains app code)

Instruction 6: CMD ["python", "app.py"]
  Action: Set startup command
  Note: No layer created (just metadata)

BUILD COMPLETE!
Final image: 4 layers + metadata
```

### Step 5: Docker Creates the Final Image

```
FINAL IMAGE CREATION LOGIC:

1. Combine all layers
   ┌─────────────────────────┐
   │ Layer 4: App code       │
   ├─────────────────────────┤
   │ Layer 3: Dependencies   │
   ├─────────────────────────┤
   │ Layer 2: requirements   │
   ├─────────────────────────┤
   │ Layer 1: Python base    │
   └─────────────────────────┘

2. Add metadata
   ├─ Image name: myapp:latest
   ├─ Creation date: 2024-12-19
   ├─ CMD: ["python", "app.py"]
   ├─ ENV variables
   └─ EXPOSE ports

3. Calculate image ID
   └─ SHA256 hash of all layers + metadata
   └─ Example: sha256:abc123def456...

4. Save to local storage
   └─ Location: /var/lib/docker/overlay2/
   └─ Each layer stored separately
   └─ Metadata in separate file

5. Tag the image
   └─ Create tag: myapp:latest
   └─ Points to image ID: sha256:abc123...

RESULT: Image ready to use!
$ docker images
REPOSITORY   TAG      IMAGE ID       SIZE
myapp        latest   abc123def456   300MB
```

---

## How Docker Executes Each Instruction {#instruction-execution}

Let's understand the logic of EACH instruction type:

### FROM Instruction

```
FROM ubuntu:20.04

DOCKER'S LOGIC:
┌────────────────────────────────────────┐
│ 1. Parse instruction                   │
│    └─ Image: ubuntu                    │
│    └─ Tag: 20.04                       │
│                                        │
│ 2. Check local storage                 │
│    └─ Do I have ubuntu:20.04?          │
│                                        │
│ 3a. If YES (found locally):            │
│     └─ Load from local storage         │
│     └─ Use as base layer               │
│                                        │
│ 3b. If NO (not found):                 │
│     └─ Connect to Docker Hub           │
│     └─ Pull ubuntu:20.04               │
│     └─ Download all layers             │
│     └─ Save to local storage           │
│     └─ Use as base layer               │
│                                        │
│ 4. Set as Layer 0 (foundation)         │
│    └─ All future layers build on this │
└────────────────────────────────────────┘

RESULT:
Base filesystem loaded into build
```

### RUN Instruction

```
RUN apt-get update && apt-get install -y python3

DOCKER'S LOGIC:
┌────────────────────────────────────────┐
│ 1. Check cache                         │
│    └─ Is "parent layer + this command" │
│       cached?                          │
│                                        │
│ 2a. If CACHED:                         │
│     └─ Use cached layer                │
│     └─ Skip execution (fast!)          │
│                                        │
│ 2b. If NOT CACHED:                     │
│     └─ Create temporary container      │
│     └─ Execute command inside          │
│     └─ Capture all filesystem changes  │
│     └─ Delete temporary container      │
│     └─ Save changes as new layer       │
│                                        │
│ 3. Create new layer                    │
│    └─ Contains: All files added/changed│
│    └─ Size: Size of changes            │
└────────────────────────────────────────┘

EXECUTION DETAILS:
├─ Start with previous layer's filesystem
├─ Create container from it
├─ Run: apt-get update && apt-get install -y python3
│  ├─ Downloads package lists
│  ├─ Downloads python3 packages
│  ├─ Installs to /usr/bin/python3
│  └─ Creates dependencies
├─ Capture all new/modified files
├─ Save as layer
└─ Remove temporary container

RESULT:
New layer with Python installed (100 MB)
```

### COPY Instruction

```
COPY app.py /app/

DOCKER'S LOGIC:
┌────────────────────────────────────────┐
│ 1. Locate source file                  │
│    └─ Find app.py in build context     │
│                                        │
│ 2. Calculate checksum                  │
│    └─ SHA256 of app.py content         │
│                                        │
│ 3. Check cache                         │
│    └─ Do I have "parent layer +        │
│       app.py with this checksum"?      │
│                                        │
│ 4a. If CACHED:                         │
│     └─ Use cached layer                │
│                                        │
│ 4b. If NOT CACHED:                     │
│     └─ Copy file from context          │
│     └─ Place in /app/ in container     │
│     └─ Set permissions                 │
│     └─ Save as new layer               │
│                                        │
│ 5. Create new layer                    │
│    └─ Contains: The copied file        │
│    └─ Size: Size of file               │
└────────────────────────────────────────┘

EXECUTION DETAILS:
├─ Read app.py from build context (host)
├─ Copy to /app/ in image filesystem
├─ Preserve or set ownership (--chown)
├─ Preserve or set permissions
└─ Save as new layer

RESULT:
New layer with app.py (5 KB)
```

### WORKDIR Instruction

```
WORKDIR /app

DOCKER'S LOGIC:
┌────────────────────────────────────────┐
│ 1. Check if directory exists           │
│    └─ Does /app exist in current layer?│
│                                        │
│ 2a. If NO:                             │
│     └─ Create /app directory           │
│                                        │
│ 2b. If YES:                            │
│     └─ Use existing directory          │
│                                        │
│ 3. Set as working directory            │
│    └─ All future instructions use this │
│                                        │
│ 4. Save as metadata (no layer)         │
└────────────────────────────────────────┘

RESULT:
Working directory set (no size increase)
```

### ENV Instruction

```
ENV PORT=8080

DOCKER'S LOGIC:
┌────────────────────────────────────────┐
│ 1. Parse variable                      │
│    └─ Name: PORT                       │
│    └─ Value: 8080                      │
│                                        │
│ 2. Store in image metadata             │
│    └─ Available during build           │
│    └─ Available in containers          │
│                                        │
│ 3. No layer created                    │
│    └─ Just metadata                    │
└────────────────────────────────────────┘

RESULT:
Environment variable set (no size increase)
```

### CMD Instruction

```
CMD ["python", "app.py"]

DOCKER'S LOGIC:
┌────────────────────────────────────────┐
│ 1. Parse command                       │
│    └─ Executable: python               │
│    └─ Arguments: ["app.py"]            │
│                                        │
│ 2. Store in image metadata             │
│    └─ Will be executed when container  │
│       starts                           │
│                                        │
│ 3. No layer created                    │
│    └─ Just metadata                    │
└────────────────────────────────────────┘

RESULT:
Startup command set (no size increase)
```

---

## Universal Pattern for Any Programming Language {#universal-pattern}

Here's the UNIVERSAL pattern that works for ANY language:

### The Universal Dockerfile Pattern

```dockerfile
# ════════════════════════════════════════════════════════
# UNIVERSAL DOCKERFILE PATTERN (Works for any language!)
# ════════════════════════════════════════════════════════

# ─────────────────────────────────────────────────────────
# STEP 1: Choose Base Image
# ─────────────────────────────────────────────────────────
# Logic: Start with OS + Runtime for your language
FROM <language>:<version>
# Examples:
# FROM python:3.11
# FROM node:18
# FROM golang:1.21
# FROM openjdk:17
# FROM ruby:3.2

# ─────────────────────────────────────────────────────────
# STEP 2: Set Working Directory
# ─────────────────────────────────────────────────────────
# Logic: Create a clean workspace for your app
WORKDIR /app

# ─────────────────────────────────────────────────────────
# STEP 3: Copy Dependency Manifest
# ─────────────────────────────────────────────────────────
# Logic: Copy ONLY dependency list first (for caching)
COPY <dependency-file> .
# Examples:
# Python: requirements.txt, Pipfile
# Node.js: package.json, package-lock.json
# Go: go.mod, go.sum
# Java: pom.xml, build.gradle
# Ruby: Gemfile, Gemfile.lock

# ─────────────────────────────────────────────────────────
# STEP 4: Install Dependencies
# ─────────────────────────────────────────────────────────
# Logic: Install all libraries your app needs
RUN <install-command>
# Examples:
# Python: pip install -r requirements.txt
# Node.js: npm install or npm ci
# Go: go mod download
# Java: mvn dependency:go-offline
# Ruby: bundle install

# ─────────────────────────────────────────────────────────
# STEP 5: Copy Application Code
# ─────────────────────────────────────────────────────────
# Logic: Now copy your actual source code
COPY . .

# ─────────────────────────────────────────────────────────
# STEP 6: Build/Compile (if needed)
# ─────────────────────────────────────────────────────────
# Logic: Compile code if using compiled language
RUN <build-command>
# Examples:
# TypeScript: npm run build
# Java: mvn package
# Go: go build
# (Skip for interpreted languages like Python)

# ─────────────────────────────────────────────────────────
# STEP 7: Expose Port
# ─────────────────────────────────────────────────────────
# Logic: Document which port your app uses
EXPOSE <port-number>

# ─────────────────────────────────────────────────────────
# STEP 8: Define Startup Command
# ─────────────────────────────────────────────────────────
# Logic: Tell Docker how to start your app
CMD ["<runtime>", "<entry-point>"]
# Examples:
# Python: ["python", "app.py"]
# Node.js: ["node", "index.js"]
# Go: ["./app"]
# Java: ["java", "-jar", "app.jar"]
```

### Why This Order?

```
THE LOGIC OF THIS ORDER:

Step 1 (Base Image):
  └─ Need OS + runtime before anything else
     Can't install packages without package manager!

Step 2 (Working Directory):
  └─ Need a place to put files
     Organizes everything in one place

Step 3 (Copy Dependencies FIRST):
  └─ CRITICAL FOR CACHING!
     If dependencies don't change, entire install is cached
     If you copy code first, ANY code change invalidates cache

Step 4 (Install Dependencies):
  └─ Now we have the dependency list
     Install while code is not yet copied
     This layer gets cached!

Step 5 (Copy Code):
  └─ Code changes frequently
     By copying last, only this layer rebuilds on code changes
     Dependency layer stays cached ✓

Step 6 (Build):
  └─ Compile after all code is present
     Creates final executable

Step 7-8 (Runtime Config):
  └─ Finally, define how to run
     These don't create layers, just metadata
```

### Visual: Why Dependency-First Matters

```
❌ BAD ORDER (Copy code before dependencies):
┌────────────────────────────────────────────┐
│ FROM python:3.11                           │ ← Layer 1: Cached ✓
│ COPY . .                 (20 MB)           │ ← Layer 2: Changed! Rebuild ✗
│ RUN pip install          (500 MB)          │ ← Layer 3: Must rebuild ✗ (5 min)
│ CMD ["python", "app.py"]                   │
└────────────────────────────────────────────┘

One line of code changes:
→ Layer 2 invalidated
→ Layer 3 must rebuild (5 minutes wasted!)

✅ GOOD ORDER (Dependencies before code):
┌────────────────────────────────────────────┐
│ FROM python:3.11                           │ ← Layer 1: Cached ✓
│ COPY requirements.txt .  (2 KB)            │ ← Layer 2: Unchanged, Cached ✓
│ RUN pip install          (500 MB)          │ ← Layer 3: Cached ✓ (instant!)
│ COPY . .                 (20 MB)           │ ← Layer 4: Changed, Rebuild ✗ (1 sec)
│ CMD ["python", "app.py"]                   │
└────────────────────────────────────────────┘

One line of code changes:
→ Layers 1-3 cached (instant!)
→ Only Layer 4 rebuilds (1 second)
→ Saved 5 minutes!
```

---

## Language-Specific Build Workflows {#language-workflows}

Let's see how the universal pattern applies to specific languages:

### Python Workflow

```dockerfile
# ════════════════════════════════════════════════════════
# PYTHON BUILD WORKFLOW
# ════════════════════════════════════════════════════════

FROM python:3.11-slim

WORKDIR /app

# Copy dependency manifest
COPY requirements.txt .

# Install dependencies
# --no-cache-dir: Don't cache pip downloads (saves space)
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Python is interpreted, no build step needed

EXPOSE 8000

CMD ["python", "app.py"]
```

**Build Logic Flow**:

```
1. Start with Python 3.11 + minimal OS (150 MB)
2. Create /app workspace
3. Copy requirements.txt (2 KB)
   └─ Layer created (2 KB)
4. pip install reads requirements.txt
   └─ Downloads packages from PyPI
   └─ Installs to /usr/local/lib/python3.11/
   └─ Layer created (200 MB)
5. Copy all Python files
   └─ app.py, models.py, etc.
   └─ Layer created (5 MB)
6. Set startup: python app.py

Final image: 355 MB (150 + 2 + 200 + 5)
```

### Node.js Workflow

```dockerfile
# ════════════════════════════════════════════════════════
# NODE.JS BUILD WORKFLOW
# ════════════════════════════════════════════════════════

FROM node:18-alpine

WORKDIR /app

# Copy dependency manifests
COPY package.json package-lock.json ./

# Install dependencies
# npm ci: Clean install (uses lock file exactly)
# --only=production: Skip devDependencies
RUN npm ci --only=production && \
    npm cache clean --force

# Copy application code
COPY . .

# If TypeScript, build it
RUN npm run build

EXPOSE 3000

CMD ["node", "dist/index.js"]
```

**Build Logic Flow**:

```
1. Start with Node.js 18 + Alpine (50 MB)
2. Create /app workspace
3. Copy package.json + package-lock.json (50 KB)
   └─ Layer created (50 KB)
4. npm ci reads lock file
   └─ Downloads exact versions from npm registry
   └─ Installs to /app/node_modules/
   └─ Cleans cache
   └─ Layer created (150 MB)
5. Copy all source files
   └─ src/, public/, config/
   └─ Layer created (10 MB)
6. npm run build compiles TypeScript
   └─ Creates dist/ folder
   └─ Layer created (5 MB)
7. Set startup: node dist/index.js

Final image: 215 MB (50 + 0.05 + 150 + 10 + 5)
```

### Go Workflow

```dockerfile
# ════════════════════════════════════════════════════════
# GO BUILD WORKFLOW
# ════════════════════════════════════════════════════════

# Build stage
FROM golang:1.21-alpine AS builder

WORKDIR /build

# Copy go module files
COPY go.mod go.sum ./

# Download dependencies
RUN go mod download

# Copy source code
COPY . .

# Build binary
RUN CGO_ENABLED=0 GOOS=linux go build -o app .

# Production stage
FROM alpine:3.18

WORKDIR /app

# Copy only the binary from builder
COPY --from=builder /build/app .

EXPOSE 8080

CMD ["./app"]
```

**Build Logic Flow**:

```
BUILDER STAGE:
1. Start with Go 1.21 + Alpine (300 MB)
2. Create /build workspace
3. Copy go.mod + go.sum (10 KB)
   └─ Layer created (10 KB)
4. go mod download fetches dependencies
   └─ Downloads to $GOPATH/pkg/mod/
   └─ Layer created (50 MB)
5. Copy all .go files
   └─ Layer created (500 KB)
6. go build compiles everything
   └─ Creates static binary 'app'
   └─ Layer created (8 MB)

Builder stage total: 358 MB (deleted after build!)

PRODUCTION STAGE:
1. Start with Alpine only (7 MB)
2. Create /app workspace
3. Copy binary from builder (8 MB)
   └─ Layer created (8 MB)
4. Set startup: ./app

Final image: 15 MB (7 + 8)
(96% smaller than builder!)
```

### Java Workflow

```dockerfile
# ════════════════════════════════════════════════════════
# JAVA BUILD WORKFLOW
# ════════════════════════════════════════════════════════

# Build stage
FROM maven:3.9-eclipse-temurin-17 AS builder

WORKDIR /build

# Copy POM file
COPY pom.xml .

# Download dependencies (cached layer)
RUN mvn dependency:go-offline

# Copy source code
COPY src ./src

# Build JAR
RUN mvn package -DskipTests

# Production stage
FROM eclipse-temurin:17-jre-alpine

WORKDIR /app

# Copy JAR from builder
COPY --from=builder /build/target/*.jar app.jar

EXPOSE 8080

CMD ["java", "-jar", "app.jar"]
```

**Build Logic Flow**:

```
BUILDER STAGE:
1. Start with Maven + JDK 17 (600 MB)
2. Create /build workspace
3. Copy pom.xml (5 KB)
   └─ Layer created (5 KB)
4. mvn dependency:go-offline
   └─ Downloads all dependencies from Maven Central
   └─ Stores in /root/.m2/repository/
   └─ Layer created (200 MB)
5. Copy src/ directory
   └─ All .java files
   └─ Layer created (1 MB)
6. mvn package compiles and packages
   └─ Compiles .java to .class
   └─ Creates JAR file
   └─ Layer created (50 MB)

Builder stage total: 851 MB (deleted after build!)

PRODUCTION STAGE:
1. Start with JRE 17 + Alpine (180 MB)
   (JRE only, no compiler/Maven)
2. Create /app workspace
3. Copy app.jar from builder (50 MB)
   └─ Layer created (50 MB)
4. Set startup: java -jar app.jar

Final image: 230 MB (180 + 50)
(73% smaller than builder!)
```

---

## The Context and How Files Get Into Image {#build-context}

Understanding the build context is CRUCIAL:

### What is Build Context?

```
BUILD CONTEXT = All files Docker can access during build

When you run:
$ docker build -t myapp .
                        ^
                        └─ This dot (.) is the context path

Docker's Logic:
┌────────────────────────────────────────┐
│ 1. "Context path is current directory" │
│                                        │
│ 2. Find all files in that directory    │
│    (recursively, including subdirs)    │
│                                        │
│ 3. Exclude files in .dockerignore      │
│                                        │
│ 4. Package all remaining files         │
│                                        │
│ 5. Send package to Docker daemon       │
│                                        │
│ 6. Daemon can now access these files   │
│    (and only these files!)             │
└────────────────────────────────────────┘
```

### Build Context Visual

```
YOUR PROJECT DIRECTORY:
/home/user/myproject/
├── Dockerfile              ✓ Part of context
├── .dockerignore           ✓ Part of context
├── app.py                  ✓ Part of context
├── requirements.txt        ✓ Part of context
├── config/                 ✓ Part of context
│   ├── dev.json            ✓
│   └── prod.json           ✓
├── node_modules/           ⚠️ Should be ignored!
│   └── [5000 packages]
├── .git/                   ⚠️ Should be ignored!
│   └── [history]
└── tests/                  ⚠️ Maybe ignore?
    └── test_app.py

Run: docker build -t myapp .
                           ^
                           Current directory

WHAT GETS SENT TO DOCKER:
┌────────────────────────────────────────┐
│ WITHOUT .dockerignore:                 │
│ ALL files sent (2 GB!)                 │
│ ├─ Dockerfile                          │
│ ├─ app.py                              │
│ ├─ requirements.txt                    │
│ ├─ config/                             │
│ ├─ node_modules/ (1.5 GB) ⚠️           │
│ ├─ .git/ (500 MB) ⚠️                   │
│ └─ tests/                              │
│                                        │
│ Upload time: 5 minutes!                │
└────────────────────────────────────────┘

┌────────────────────────────────────────┐
│ WITH .dockerignore:                    │
│ node_modules                           │
│ .git                                   │
│ tests                                  │
│                                        │
│ Only needed files sent (50 MB)         │
│ ├─ Dockerfile                          │
│ ├─ app.py                              │
│ ├─ requirements.txt                    │
│ └─ config/                             │
│                                        │
│ Upload time: 2 seconds!                │
└────────────────────────────────────────┘
```

### How COPY Works with Context

```
COPY IN DOCKERFILE:

COPY <source-in-context> <destination-in-image>

Important Rules:
1. Source MUST be in build context
2. Source path is RELATIVE to context root
3. Cannot copy files outside context

Example Project:
/home/user/myproject/        ← Context root
├── Dockerfile
├── app/
│   └── main.py
└── ../otherproject/         ← Outside context!
    └── helper.py

Dockerfile:
FROM python:3.11

# ✅ WORKS - app/ is in context
COPY app/main.py /app/

# ❌ FAILS - ../otherproject/ is outside context
COPY ../otherproject/helper.py /app/
# Error: Forbidden path outside context

# ✅ WORKS - relative to context root
COPY app/ /app/

# ✅ WORKS - copy everything from context
COPY . /app/
```

### Build Context Size Matters

```
WHY CONTEXT SIZE IS IMPORTANT:

Small Context (50 MB):
  Upload to daemon: 2 seconds
  Build starts: Immediately
  Developer happy: ✓

Large Context (2 GB):
  Upload to daemon: 5 minutes
  Build starts: After 5 minutes waiting
  Developer frustrated: ✗

The build can't start until context is uploaded!

Solution: Use .dockerignore
┌────────────────────────────────────────┐
│ .dockerignore                          │
│                                        │
│ # Don't send these to Docker           │
│ node_modules                           │
│ .git                                   │
│ dist                                   │
│ build                                  │
│ *.log                                  │
│ .env                                   │
│ tests                                  │
│ docs                                   │
│ *.md                                   │
└────────────────────────────────────────┘
```

---

## Caching Logic During Builds {#caching-logic}

Docker's caching is what makes rebuilds fast. Understanding it is key:

### How Caching Works

```
DOCKER'S CACHING DECISION LOGIC:

For EACH instruction, Docker asks:
┌────────────────────────────────────────┐
│ "Can I use a cached layer for this?"   │
│                                        │
│ To answer, Docker checks:              │
│ 1. Is parent layer the same?           │
│ 2. Is instruction string identical?    │
│ 3. (For COPY) Are files identical?     │
│                                        │
│ All YES? → Use cached layer ✓          │
│ Any NO?  → Rebuild from here ✗         │
└────────────────────────────────────────┘

Example:
Previous Build    Current Build      Decision
─────────────────────────────────────────────────────
FROM ubuntu       FROM ubuntu        ✓ Same → Cache
RUN apt install   RUN apt install    ✓ Same → Cache
COPY app.py .     COPY app.py .      ? Check file...
                                     ✓ Same → Cache
RUN build         RUN build          ✓ Same → Cache

Result: All cached, build in 2 seconds!

Change ONE LINE in app.py:
─────────────────────────────────────────────────────
FROM ubuntu       FROM ubuntu        ✓ Same → Cache
RUN apt install   RUN apt install    ✓ Same → Cache
COPY app.py .     COPY app.py .      ✗ File changed!
                                     ✗ REBUILD
RUN build         RUN build          ✗ REBUILD
                                     (dependency)

Result: Partial cache, build in 30 seconds
```

### Cache Invalidation Chain

```
CACHE INVALIDATION = Once one layer rebuilds, ALL subsequent layers rebuild

Visual Example:
┌─────────────────────────────────────────────┐
│ Layer 1: FROM ubuntu        [CACHED] ✓      │
├─────────────────────────────────────────────┤
│ Layer 2: RUN apt install    [CACHED] ✓      │
├─────────────────────────────────────────────┤
│ Layer 3: COPY app.py        [CHANGED] ✗     │ ← Cache break!
├─────────────────────────────────────────────┤
│ Layer 4: RUN build          [REBUILD] ✗     │ ← Must rebuild
├─────────────────────────────────────────────┤
│ Layer 5: COPY config        [REBUILD] ✗     │ ← Must rebuild
└─────────────────────────────────────────────┘

Once Layer 3 breaks cache, ALL layers after it rebuild,
even if their instructions haven't changed!

This is WHY order matters:
Put changing things LAST!
```

### COPY Caching Logic

```
FOR COPY INSTRUCTIONS:

Docker creates a checksum (hash) of file contents:

File: app.py
Content: "print('hello')"
Checksum: sha256:abc123...

If content changes:
Content: "print('world')"
Checksum: sha256:def456...  ← Different!

Cache decision:
Previous checksum: abc123
Current checksum:  def456
Result: NOT EQUAL → Cache miss → Rebuild

Example:
# First build
COPY app.py .
  ├─ Checksum: abc123
  ├─ Create layer with app.py
  └─ Layer ID: layer-xyz

# Second build (no changes)
COPY app.py .
  ├─ Checksum: abc123
  ├─ Same as layer-xyz!
  └─ Use cached layer-xyz ✓

# Third build (app.py changed)
COPY app.py .
  ├─ Checksum: def456  ← Changed!
  ├─ Different from layer-xyz
  └─ Create new layer ✗
```

---

## From Dockerfile to Running Container {#dockerfile-to-container}

Let's see the COMPLETE journey:

### The Complete Journey

```
PHASE 1: WRITING
════════════════════════════════════════════════════════════
You write:
├─ Application code (app.py, index.js, etc.)
├─ Dockerfile (build instructions)
└─ .dockerignore (files to exclude)

PHASE 2: BUILDING
════════════════════════════════════════════════════════════
$ docker build -t myapp .

Docker does:
├─ Read Dockerfile
├─ Collect build context
├─ Execute instructions
├─ Create layers
└─ Save as image

Result: myapp:latest (image file on disk)

PHASE 3: STORING
════════════════════════════════════════════════════════════
Image saved to:
/var/lib/docker/overlay2/
├─ layer-1/
├─ layer-2/
├─ layer-3/
└─ metadata.json

PHASE 4: RUNNING
════════════════════════════════════════════════════════════
$ docker run -p 8080:8080 myapp

Docker does:
├─ Load image from disk
├─ Create writable layer
├─ Stack all layers
├─ Start container
└─ Execute CMD

Result: Application running!

PHASE 5: EXECUTION
════════════════════════════════════════════════════════════
Container runtime:
├─ App receives requests
├─ Processes data
├─ Returns responses
└─ Writes logs

You interact:
├─ curl http://localhost:8080
├─ docker logs myapp
└─ docker exec -it myapp sh
```

### Visual: The Complete Flow

```
┌──────────────────────────────────────────────────────────┐
│                  YOUR COMPUTER                           │
│                                                          │
│  Developer writes:                                       │
│  ├─ app.py                                               │
│  ├─ Dockerfile                                           │
│  └─ .dockerignore                                        │
│            │                                             │
│            ▼                                             │
│  $ docker build -t myapp .                               │
└────────────┬─────────────────────────────────────────────┘
             │
             │ Build request + context
             ▼
┌──────────────────────────────────────────────────────────┐
│                 DOCKER DAEMON                            │
│                                                          │
│  Build Process:                                          │
│  ├─ Read Dockerfile                                      │
│  ├─ FROM ubuntu                    → Layer 1             │
│  ├─ RUN apt-get install            → Layer 2             │
│  ├─ COPY app.py                    → Layer 3             │
│  └─ CMD ["python", "app.py"]       → Metadata            │
│            │                                             │
│            ▼                                             │
│  Create image: myapp:latest                              │
│            │                                             │
│            ▼                                             │
│  Save to disk                                            │
└────────────┬─────────────────────────────────────────────┘
             │
             │ Image saved
             ▼
┌──────────────────────────────────────────────────────────┐
│                IMAGE STORAGE                             │
│                                                          │
│  /var/lib/docker/overlay2/                               │
│  ├─ layer-abc123/   (Layer 1)                            │
│  ├─ layer-def456/   (Layer 2)                            │
│  ├─ layer-ghi789/   (Layer 3)                            │
│  └─ metadata.json   (CMD, ENV, etc.)                     │
└────────────┬─────────────────────────────────────────────┘
             │
             │ docker run myapp
             ▼
┌──────────────────────────────────────────────────────────┐
│              RUNNING CONTAINER                           │
│                                                          │
│  Container ID: abc123                                    │
│                                                          │
│  Filesystem (stacked layers):                            │
│  ┌──────────────────────────────────┐                    │
│  │ Writable layer (new)             │                    │
│  ├──────────────────────────────────┤                    │
│  │ Layer 3: app.py                  │                    │
│  ├──────────────────────────────────┤                    │
│  │ Layer 2: Python installed        │                    │
│  ├──────────────────────────────────┤                    │
│  │ Layer 1: Ubuntu base             │                    │
│  └──────────────────────────────────┘                    │
│                                                          │
│  Process: python app.py (running)                        │
│  Listening on: 0.0.0.0:8080                              │
└──────────────────────────────────────────────────────────┘
             │
             │ Application serves requests
             ▼
┌─────────────────────────────────────────────────────────┐
│                    USERS                                │
│                                                         │
│  $ curl http://localhost:8080                           │
│  → Request goes to container                            │
│  → App processes request                                │
│  → Response returned                                    │
└─────────────────────────────────────────────────────────┘
```

---

## Complete Real Examples {#complete-examples}

Let's see COMPLETE examples with every step explained:

### Example 1: Simple Python Flask App

**Project Structure**:

```
flask-app/
├── Dockerfile
├── .dockerignore
├── app.py
├── requirements.txt
└── templates/
    └── index.html
```

**app.py**:

```python
from flask import Flask, render_template

app = Flask(__name__)

@app.route('/')
def home():
    return render_template('index.html')

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

**requirements.txt**:

```
Flask==2.3.0
```

**.dockerignore**:

```
__pycache__
*.pyc
.git
.env
```

**Dockerfile**:

```dockerfile
# Start with Python 3.11 on minimal Debian
FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Copy requirements file first (for caching)
COPY requirements.txt .

# Install dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Expose Flask's default port
EXPOSE 5000

# Start Flask application
CMD ["python", "app.py"]
```

**Build Process Logic**:

```
$ docker build -t flask-app .

Step 1/7: FROM python:3.11-slim
 └─ Pulling python:3.11-slim from Docker Hub
 └─ Downloaded: 150 MB
 └─ Layer 1 created: 150 MB

Step 2/7: WORKDIR /app
 └─ Creating /app directory in image
 └─ Setting as working directory
 └─ No layer created (metadata only)

Step 3/7: COPY requirements.txt .
 └─ Finding requirements.txt in build context
 └─ Checksum: sha256:abc123...
 └─ Copying to /app/requirements.txt
 └─ Layer 2 created: 50 bytes

Step 4/7: RUN pip install --no-cache-dir -r requirements.txt
 └─ Executing: pip install Flask==2.3.0
 └─ Downloading Flask from PyPI
 └─ Installing Flask + dependencies
 └─ Installed: Flask, Werkzeug, Jinja2, click, etc.
 └─ Layer 3 created: 25 MB

Step 5/7: COPY . .
 └─ Copying all files from context
 └─ Files copied:
    ├─ app.py
    ├─ requirements.txt (already there)
    └─ templates/index.html
 └─ Layer 4 created: 10 KB

Step 6/7: EXPOSE 5000
 └─ Documenting port 5000
 └─ No layer created (metadata only)

Step 7/7: CMD ["python", "app.py"]
 └─ Setting startup command
 └─ No layer created (metadata only)

Successfully built flask-app
Final image size: 175 MB (150 + 0 + 25 + 0.01)
```

**Running the Container**:

```
$ docker run -p 5000:5000 flask-app

Docker's Actions:
1. Load image: flask-app
2. Create writable layer on top
3. Create container from image
4. Execute CMD: python app.py
5. Flask starts listening on 0.0.0.0:5000
6. Map container port 5000 to host port 5000

Result:
Application running at http://localhost:5000
```

### Example 2: Node.js Express API with TypeScript

**Project Structure**:

```
express-api/
├── Dockerfile
├── .dockerignore
├── package.json
├── package-lock.json
├── tsconfig.json
└── src/
    ├── index.ts
    ├── routes/
    └── controllers/
```

**package.json**:

```json
{
  "name": "express-api",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js"
  },
  "dependencies": {
    "express": "^4.18.0"
  },
  "devDependencies": {
    "@types/express": "^4.17.0",
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0"
  }
}
```

**.dockerignore**:

```
node_modules
dist
.git
*.log
.env
```

**Dockerfile (Multi-Stage)**:

```dockerfile
# ════════════════════════════════════════════════════════
# Build Stage
# ════════════════════════════════════════════════════════
FROM node:18 AS builder

WORKDIR /build

# Copy package files
COPY package*.json ./

# Install all dependencies (including dev)
RUN npm install

# Copy source code
COPY tsconfig.json ./
COPY src ./src

# Compile TypeScript
RUN npm run build

# ════════════════════════════════════════════════════════
# Production Stage
# ════════════════════════════════════════════════════════
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install ONLY production dependencies
RUN npm ci --only=production && \
    npm cache clean --force

# Copy compiled JavaScript from builder
COPY --from=builder /build/dist ./dist

EXPOSE 3000

CMD ["node", "dist/index.js"]
```

**Build Process Logic**:

```
$ docker build -t express-api .

BUILDER STAGE:
══════════════════════════════════════════════════════════
Step 1: FROM node:18 AS builder
 └─ Load node:18 (900 MB)
 └─ Label as "builder"

Step 2: WORKDIR /build
 └─ Create /build directory

Step 3: COPY package*.json ./
 └─ Copy package.json and package-lock.json
 └─ Layer created: 100 KB

Step 4: RUN npm install
 └─ Installing ALL dependencies
 └─ node_modules/:
    ├─ express (prod)
    ├─ @types/express (dev)
    ├─ typescript (dev)
    └─ ... all sub-dependencies
 └─ Layer created: 500 MB

Step 5: COPY tsconfig.json + src/
 └─ Copy TypeScript config
 └─ Copy all .ts files
 └─ Layer created: 50 KB

Step 6: RUN npm run build
 └─ Executing: tsc
 └─ TypeScript compiles src/ → dist/
 └─ dist/ contains .js files
 └─ Layer created: 100 KB

Builder stage total: 1,400 MB

PRODUCTION STAGE:
══════════════════════════════════════════════════════════
Step 7: FROM node:18-alpine
 └─ NEW stage, fresh start
 └─ Load node:18-alpine (50 MB)

Step 8: WORKDIR /app
 └─ Create /app directory

Step 9: COPY package*.json ./
 └─ Copy package files
 └─ Layer created: 100 KB

Step 10: RUN npm ci --only=production && npm cache clean
 └─ Installing ONLY production dependencies
 └─ node_modules/:
    └─ express (no dev packages!)
 └─ Cleaning npm cache
 └─ Layer created: 50 MB

Step 11: COPY --from=builder /build/dist ./dist
 └─ Copy compiled JavaScript from builder
 └─ ONLY dist/ copied (not src/, not dev deps!)
 └─ Layer created: 100 KB

Step 12: EXPOSE 3000
 └─ Document port

Step 13: CMD ["node", "dist/index.js"]
 └─ Set startup command

Production stage total: 100 MB

BUILD COMPLETE:
══════════════════════════════════════════════════════════
Builder stage: DELETED (1,400 MB freed)
Final image: 100 MB (93% smaller!)

Image layers:
├─ Layer 1: node:18-alpine base (50 MB)
├─ Layer 2: package files (100 KB)
├─ Layer 3: production node_modules (50 MB)
└─ Layer 4: dist/ from builder (100 KB)
```

### Example 3: Go Microservice (Smallest Possible)

**Project Structure**:

```
go-service/
├── Dockerfile
├── .dockerignore
├── go.mod
├── go.sum
└── main.go
```

**main.go**:

```go
package main

import (
    "fmt"
    "net/http"
)

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello from Go!")
}

func main() {
    http.HandleFunc("/", handler)
    http.ListenAndServe(":8080", nil)
}
```

**.dockerignore**:

```
.git
*.md
```

**Dockerfile**:

```dockerfile
# ════════════════════════════════════════════════════════
# Build Stage
# ════════════════════════════════════════════════════════
FROM golang:1.21-alpine AS builder

WORKDIR /build

# Copy go module files
COPY go.mod go.sum ./

# Download dependencies
RUN go mod download

# Copy source code
COPY . .

# Build static binary
RUN CGO_ENABLED=0 GOOS=linux go build -ldflags="-w -s" -o app .

# ════════════════════════════════════════════════════════
# Production Stage (Minimal)
# ════════════════════════════════════════════════════════
FROM scratch

# Copy SSL certificates (needed for HTTPS)
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

# Copy the binary
COPY --from=builder /build/app /app

EXPOSE 8080

ENTRYPOINT ["/app"]
```

**Build Process Logic**:

```
$ docker build -t go-service .

BUILDER STAGE:
══════════════════════════════════════════════════════════
Step 1: FROM golang:1.21-alpine AS builder
 └─ Load golang:1.21-alpine (300 MB)

Step 2: WORKDIR /build
 └─ Create /build directory

Step 3: COPY go.mod go.sum ./
 └─ Copy dependency manifests
 └─ Layer created: 5 KB

Step 4: RUN go mod download
 └─ Download all dependencies
 └─ Store in $GOPATH/pkg/mod/
 └─ Layer created: 10 MB

Step 5: COPY . .
 └─ Copy main.go
 └─ Layer created: 2 KB

Step 6: RUN go build
 └─ Compile Go code to binary
 └─ Create static executable 'app'
 └─ Flags: -ldflags="-w -s" (strip debug info)
 └─ Layer created: 7 MB

Builder stage total: 317 MB

PRODUCTION STAGE:
══════════════════════════════════════════════════════════
Step 7: FROM scratch
 └─ EMPTY image (0 MB!)
 └─ No OS, no shell, nothing!

Step 8: COPY --from=builder /etc/ssl/certs/...
 └─ Copy SSL certificates
 └─ Layer created: 200 KB

Step 9: COPY --from=builder /build/app /app
 └─ Copy ONLY the binary
 └─ Layer created: 7 MB

Step 10: EXPOSE 8080
 └─ Document port

Step 11: ENTRYPOINT ["/app"]
 └─ Set startup command

Production stage total: 7.2 MB

BUILD COMPLETE:
══════════════════════════════════════════════════════════
Builder stage: DELETED (317 MB freed)
Final image: 7.2 MB (98% smaller!)

This is THE SMALLEST possible image!
```

---

## Summary: The Complete Building Logic

```
DOCKER IMAGE BUILDING = Following a Recipe to Create a Package

THE UNIVERSAL WORKFLOW:
═══════════════════════════════════════════════════════════
1. Write Dockerfile (the recipe)
2. Organize files (the ingredients)
3. Run docker build (start cooking)
4. Docker reads instructions (follows recipe)
5. Each instruction creates a layer (step-by-step)
6. Layers stack to form image (final dish)
7. Image saved to disk (package ready)
8. Run container from image (serve the dish)

THE UNIVERSAL PATTERN (any language):
═══════════════════════════════════════════════════════════
FROM base-image         Step 1: Foundation
WORKDIR /app            Step 2: Workspace
COPY deps-file .        Step 3: Dependency list
RUN install-deps        Step 4: Install libraries
COPY code .             Step 5: Add your code
RUN build               Step 6: Compile (if needed)
EXPOSE port             Step 7: Document port
CMD ["run", "app"]      Step 8: Define startup

THE KEY CONCEPTS:
═══════════════════════════════════════════════════════════
✓ Layers = Snapshots of changes
✓ Caching = Reusing unchanged layers
✓ Context = Files Docker can access
✓ Order matters = Put changing things last
✓ Multi-stage = Build big, ship small

RESULT:
═══════════════════════════════════════════════════════════
A portable, reproducible, efficient package containing
everything your application needs to run anywhere!
```

This is the complete logic of Docker image building! 🎉