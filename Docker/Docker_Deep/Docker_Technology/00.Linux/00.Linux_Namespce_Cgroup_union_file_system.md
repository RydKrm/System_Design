# Deep Dive into Linux Namespaces, Cgroups, and Union File Systems
---

## 1. Linux Namespaces

### What are Namespaces?

Imagine you're living in an apartment building. Each apartment has its own space, its own door number, and residents can't see what's happening in other apartments. Linux namespaces work similarly - they create isolated "apartments" for processes, where each process thinks it has the entire system to itself.

**Why did we need Namespaces?**

Before namespaces, all processes on a Linux system could see each other. If you ran a program, it could see all other running programs, all network connections, all files, and all users. This created several problems:

1. **Security risks**: One application could interfere with another
2. **Resource conflicts**: Programs might use the same ports or file paths
3. **No isolation**: Testing or running multiple versions of software was difficult
4. **Multi-tenancy issues**: Hosting multiple users on one machine was risky

### Types of Namespaces

Linux provides seven types of namespaces:

```
┌─────────────────────────────────────────────────────────────┐
│                    LINUX NAMESPACES                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐     │
│  │   PID    │  │   NET    │  │   MNT    │  │   UTS    │     │
│  │ Process  │  │ Network  │  │  Mount   │  │ Hostname │     │
│  │    IDs   │  │  Stack   │  │  Points  │  │          │     │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘     │
│                                                             │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐                   │
│  │   IPC    │  │   USER   │  │  CGROUP  │                   │
│  │Inter-Proc│  │   User   │  │  Control │                   │
│  │   Comm   │  │   & GID  │  │  Groups  │                   │
│  └──────────┘  └──────────┘  └──────────┘                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

Let me explain each namespace in detail:

#### 1. PID Namespace (Process ID)

**What it does**: Creates an isolated view of process IDs.

Think of it like this: In your apartment (namespace), you might label your rooms as Room 1, Room 2, etc. In another apartment, they also have Room 1, Room 2. The numbers are the same, but they refer to completely different rooms.

**How it works**:

- When you create a PID namespace, the first process inside it becomes PID 1 (like the "init" process)
- Processes inside can only see other processes in the same namespace
- Processes outside can still see processes inside, but with different PID numbers

```
Host System View                Container View
┌─────────────────┐            ┌──────────────┐
│ PID 1: systemd  │            │ PID 1: bash  │
│ PID 2: kernel   │            │ PID 2: nginx │
│ PID 534: docker │            │ PID 3: app   │
│ PID 1024: bash  │◄───────────┤              │
│ PID 1025: nginx │   (Same    │   Isolated   │
│ PID 1026: app   │  processes,│     View     │
└─────────────────┘  different └──────────────┘
                      PIDs!)
```

#### 2. Network Namespace (NET)

**What it does**: Provides isolated network stack.

Imagine each apartment has its own mailbox, doorbell, and phone line. They don't share these communication channels.

**How it works**:

- Each namespace gets its own network interfaces (like eth0, lo)
- Its own IP addresses
- Its own routing tables
- Its own firewall rules
- Its own ports (so two containers can both use port 80)

```
┌────────────────────────────────────────────────────────┐
│                    Physical Network                    │
└────────────────────────────────────────────────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
┌───────▼──────┐  ┌────────▼──────┐  ┌───────▼──────┐
│  Namespace 1 │  │  Namespace 2  │  │  Namespace 3 │
│              │  │               │  │              │
│ eth0:        │  │ eth0:         │  │ eth0:        │
│ 172.17.0.2   │  │ 172.17.0.3    │  │ 172.17.0.4   │
│ Port 80      │  │ Port 80       │  │ Port 3306    │
│              │  │               │  │              │
└──────────────┘  └───────────────┘  └──────────────┘
   Container 1       Container 2       Container 3
```

#### 3. Mount Namespace (MNT)

**What it does**: Provides isolated filesystem mount points.

Like each apartment having its own storage areas. One apartment might have a bookshelf mounted on the north wall, another on the south wall, and they're completely independent.

**How it works**:

- Each namespace sees a different set of mounted filesystems
- Changes to mounts in one namespace don't affect others
- You can mount a filesystem in a container without affecting the host

```
Host Filesystem                Container Filesystem
┌─────────────────┐           ┌──────────────────┐
│ /               │           │ /                │
│ ├── bin         │           │ ├── bin          │
│ ├── home        │           │ ├── etc          │
│ ├── var         │           │ ├── app          │
│ └── usr         │           │ └── tmp          │
│                 │           │                  │
│ Container sees  │           │ Only sees its    │
│ everything      │           │ own tree!        │
└─────────────────┘           └──────────────────┘
```

#### 4. UTS Namespace (Unix Timesharing System)

**What it does**: Isolates hostname and domain name.

Each apartment can have its own nameplate on the door, independent of others.

**How it works**:

- Each namespace can have its own hostname
- Useful for identifying containers
- Applications inside see their custom hostname

```
┌──────────────────────────────────────────┐
│           Host: server.example.com       │
├──────────────────────────────────────────┤
│                                          │
│  ┌────────────────┐  ┌────────────────┐  │
│  │ Container 1    │  │ Container 2    │  │
│  │ Host: web-app  │  │ Host: db-server│  │
│  └────────────────┘  └────────────────┘  │
└──────────────────────────────────────────┘
```

#### 5. IPC Namespace (Inter-Process Communication)

**What it does**: Isolates inter-process communication resources.

Like each apartment having its own intercom system. Messages sent on one intercom don't reach other apartments.

**How it works**:

- Isolates System V IPC objects (message queues, semaphores, shared memory)
- POSIX message queues
- Processes can only communicate with others in the same namespace

```
┌─────────────────────────────────────────────┐
│              Host System                    │
├─────────────────────────────────────────────┤
│                                             │
│  ┌──────────────┐      ┌──────────────┐     │
│  │ Namespace A  │      │ Namespace B  │     │
│  │              │      │              │     │
│  │  Process 1   │      │  Process 3   │     │
│  │     │        │      │     │        │     │
│  │     ▼ IPC    │      │     ▼ IPC    │     │
│  │  Process 2   │      │  Process 4   │     │
│  │              │      │              │     │
│  │  ✓ Can talk  │      │  ✓ Can talk  │     │
│  └──────────────┘      └──────────────┘     │
│         │                      │            │
│         └──────────X───────────┘            │
│              Cannot communicate!            │
└─────────────────────────────────────────────┘
```

#### 6. User Namespace (USER)

**What it does**: Isolates user and group IDs.

This is powerful - imagine a person who is just a regular resident in an apartment (no special privileges) but inside their apartment, they're the "owner" with full control.

**How it works**:

- Maps user IDs inside namespace to different IDs outside
- A process can be root (UID 0) inside namespace but unprivileged outside
- Greatly improves security

```
┌──────────────────────────────────────────────┐
│            Outside Namespace                 │
│                                              │
│         User: john (UID 1000)                │
│              No special privileges           │
└──────────────────────────────────────────────┘
                      │
                      │ Enters container
                      ▼
┌──────────────────────────────────────────────┐
│            Inside Namespace                  │
│                                              │
│         User: root (UID 0)                   │
│              Full control inside!            │
│                                              │
│  But attacks can't escape because outside    │
│  this user is still just UID 1000            │
└──────────────────────────────────────────────┘
```

#### 7. Cgroup Namespace

**What it does**: Virtualizes the view of cgroups (we'll cover cgroups next).

Like showing each apartment resident a different floor plan - they think they're seeing the whole building, but they're only seeing their portion.

---

## 2. Control Groups (cgroups)

### What are Cgroups?

If namespaces answer "what can you see?", cgroups answer "how much can you use?"

Think of cgroups like a power management system in apartments. The building manager says: "Apartment A can use maximum 1000 watts, Apartment B can use 500 watts." This prevents one apartment from using all the electricity.

**Why did we need Cgroups?**

Before cgroups:

1. One process could consume all CPU, starving others
2. A program could eat all RAM, crashing the system
3. No way to fairly distribute resources
4. Hard to track resource usage by groups of processes
5. No resource guarantees for important applications

```
Without Cgroups                    With Cgroups
┌─────────────────┐               ┌─────────────────┐
│   CPU: 4 cores  │               │   CPU: 4 cores  │
│                 │               │                 │
│  App A: 95%     │               │  App A: ≤50%    │
│  App B: 3%      │               │  App B: ≤30%    │
│  App C: 2%      │               │  App C: ≤20%    │
│                 │               │                 │
│  App A is       │               │  Fair resource  │
│  hogging!       │               │  distribution!  │
└─────────────────┘               └─────────────────┘
```

### How Cgroups Work

Cgroups organize processes into hierarchical groups and apply resource limits to those groups. They control:

1. **CPU**: How much processor time
2. **Memory**: How much RAM
3. **Block I/O**: Disk read/write speed
4. **Network**: Bandwidth limits
5. **Devices**: Access to hardware devices

```
┌──────────────────────────────────────────────────┐
│              Cgroup Hierarchy                    │
├──────────────────────────────────────────────────┤
│                                                  │
│                    Root (/)                      │
│                       │                          │
│         ┌─────────────┼─────────────┐            │
│         │             │             │            │
│    System       Containers    User Apps          │
│         │             │             │            │
│    ┌────┴────┐   ┌────┴────┐   ┌───┴───┐         │
│    │         │   │         │   │       │         │
│  Docker  Systemd Web  Database Game  Audio       │
│                                                  │
│  Each node has resource limits:                  │
│  • CPU shares                                    │
│  • Memory limit                                  │
│  • I/O bandwidth                                 │
└──────────────────────────────────────────────────┘
```

### Cgroup Controllers (Subsystems)

Each controller manages a specific resource type:

#### CPU Controller

```
Container A              Container B
┌──────────┐            ┌──────────┐
│ CPU:     │            │ CPU:     │
│ 2 cores  │            │ 1 core   │
│ 70% max  │            │ 30% max  │
└──────────┘            └──────────┘
      │                       │
      └───────────┬───────────┘
                  ▼
        ┌──────────────────┐
        │  Physical CPUs   │
        │   (4 cores)      │
        └──────────────────┘
```

**How it works**:

- **cpu.shares**: Relative CPU time (weights, not hard limits)
- **cpu.cfs_period_us** and **cpu.cfs_quota_us**: Hard CPU limits
- Example: 50000us quota / 100000us period = 50% of one CPU

#### Memory Controller

```
┌─────────────────────────────────────┐
│     Physical RAM: 8GB               │
├─────────────────────────────────────┤
│                                     │
│  Container 1: Max 2GB               │
│  ┌──────────────────┐               │
│  │ Used: 1.5GB      │               │
│  └──────────────────┘               │
│                                     │
│  Container 2: Max 1GB               │
│  ┌──────────┐                       │
│  │Used:800MB│                       │
│  └──────────┘                       │
│                                     │
│  Container 3: Max 3GB               │
│  ┌───────────────────-─────────┐    │
│  │ Used: 2.9GB (Close to limit)│    │
│  └────────────────────-────────┘    │
└─────────────────────────────────────┘
```

**How it works**:

- **memory.limit_in_bytes**: Hard memory limit
- **memory.soft_limit_in_bytes**: Soft limit (reclaimed under pressure)
- When limit exceeded, processes are killed (OOM - Out of Memory)

#### Block I/O Controller

```
       Disk Access
           │
    ┌──────┴──────┐
    │             │
Container A   Container B
  (Fast)       (Slow)
    │             │
 500 MB/s      100 MB/s
    │             │
    └──────┬──────┘
           ▼
    Physical Disk
     (SSD/HDD)
```

**How it works**:

- **blkio.weight**: I/O priority (100-1000)
- **blkio.throttle.read_bps_device**: Read bytes per second limit
- **blkio.throttle.write_bps_device**: Write bytes per second limit

---

## 3. Union File Systems (UnionFS)

### What is a Union File System?

Imagine you have a stack of transparent sheets. The bottom sheet has a base drawing, each sheet on top adds something new, and when you look from above, you see the complete combined picture. That's how union filesystems work!

**Why did we need Union File Systems?**

Traditional filesystems had problems for containers:

1. **Disk space waste**: Each container copying entire OS = gigabytes wasted
2. **Slow startup**: Copying files takes time
3. **No sharing**: Can't share common files between containers
4. **Difficult updates**: Changing base OS means rebuilding everything

Union filesystems solved this by allowing multiple directories to be "layered" and appear as one.

### How Union File Systems Work

```
┌────────────────────────────────────────────────┐
│           What You See (Merged View)           │
│                                                │
│  /app/code.py       (from Layer 3)             │
│  /app/config.json   (from Layer 2)             │
│  /bin/bash          (from Layer 1)             │
│  /lib/libc.so       (from Layer 0)             │
└────────────────────────────────────────────────┘
                       ▲
                       │ Merged
                       │
┌────────────────────────────────────────────────┐
│  Layer 3 (Writable)     Your Application       │
│  ┌──────────────┐                              │
│  │ /app/code.py │      [Read-Write]            │
│  └──────────────┘                              │
├────────────────────────────────────────────────┤
│  Layer 2               Application Config      │
│  ┌────────────────────┐                        │
│  │ /app/config.json   │  [Read-Only]           │
│  └────────────────────┘                        │
├────────────────────────────────────────────────┤
│  Layer 1               Programming Language    │
│  ┌──────────────────┐                          │
│  │ /usr/bin/python  │    [Read-Only]           │
│  └──────────────────┘                          │
├────────────────────────────────────────────────┤
│  Layer 0               Base OS (Ubuntu)        │
│  ┌──────────────────┐                          │
│  │ /bin/bash        │    [Read-Only]           │
│  │ /lib/libc.so     │                          │
│  └──────────────────┘                          │
└────────────────────────────────────────────────┘
```

**The magic of layers**:

Each layer is read-only except the top one. When you:

- **Read a file**: The system looks from top to bottom, returns first match
- **Modify a file**: Copy file from lower layer to top layer (Copy-on-Write), modify the copy
- **Delete a file**: Create a "whiteout" marker in top layer hiding the file below

### Copy-on-Write (CoW) Mechanism

This is the clever trick that makes union filesystems efficient:

```
Initial State:
┌─────────────────────────┐
│   Writable Layer        │
│   (Empty)               │
└─────────────────────────┘
┌─────────────────────────┐
│   Read-Only Layer       │
│   ┌─────────────┐       │
│   │  file.txt   │       │
│   │  "Hello"    │       │
│   └─────────────┘       │
└─────────────────────────┘

After Modifying file.txt:
┌─────────────────────────┐
│   Writable Layer        │
│   ┌─────────────┐       │
│   │  file.txt   │◄──────┼─ Modified copy
│   │  "Hello     │       │
│   │   World"    │       │
│   └─────────────┘       │
└─────────────────────────┘
┌─────────────────────────┐
│   Read-Only Layer       │
│   ┌─────────────┐       │
│   │  file.txt   │◄──────┼─ Original unchanged
│   │  "Hello"    │       │   (still used by
│   └─────────────┘       │    other containers)
└─────────────────────────┘
```

### Popular Union Filesystem Implementations

**1. OverlayFS** (most common in modern Docker):

- Fast and efficient
- Built into Linux kernel
- Two layers: "lower" (read-only) and "upper" (read-write)

**2. AUFS** (older Docker versions):

- Advanced multi-layered union filesystem
- More complex but very flexible

**3. Btrfs and ZFS**:

- Full filesystems with snapshot capabilities
- Can act like union filesystems

---

## 4. How Docker Uses All Three Technologies

Now let's see how Docker orchestrates namespaces, cgroups, and union filesystems together to create containers!

### Docker Container Architecture

```
┌───────────────────────────────────────────────────────────┐
│                      Docker Container                     │
├───────────────────────────────────────────────────────────┤
│                                                           │
│  ┌──────────────────────────────────────────────────────┐ │
│  │              Namespaces (Isolation)                  │ │
│  │  ┌────────┬────────┬────────┬────────┬────────────┐  │ │
│  │  │  PID   │  NET   │  MNT   │  UTS   │  IPC/USER  │  │ │
│  │  └────────┴────────┴────────┴────────┴────────────┘  │ │
│  │           "What can the container see?"              │ │
│  └──────────────────────────────────────────────────────┘ │
│                           │                               │
│  ┌──────────────────────────────────────────────────────┐ │
│  │              Cgroups (Resource Limits)               │ │
│  │  ┌────────┬────────┬────────┬────────────────────┐   │ │
│  │  │  CPU   │ Memory │ Block  │    Network         │   │ │
│  │  │ 50%    │  1GB   │  I/O   │   Bandwidth        │   │ │
│  │  └────────┴────────┴────────┴────────────────────┘   │ │
│  │           "How much can it use?"                     │ │
│  └──────────────────────────────────────────────────────┘ │
│                           │                               │
│  ┌──────────────────────────────────────────────────────┐ │
│  │         Union FS (Layered Filesystem)                │ │
│  │                                                      │ │
│  │  Container Layer (R/W)                               │ │
│  │  ├── Image Layer 3 (R/O)                             │ │
│  │  ├── Image Layer 2 (R/O)                             │ │
│  │  ├── Image Layer 1 (R/O)                             │ │
│  │  └── Base Layer (R/O)                                │ │
│  │           "What files does it have?"                 │ │
│  └──────────────────────────────────────────────────────┘ │
│                                                           │
└───────────────────────────────────────────────────────────┘
```

### Step-by-Step: Creating a Docker Container

Let's walk through what happens when you run `docker run -m 512m --cpus=0.5 nginx`:

**Step 1: Image Layers Setup (Union FS)**

```
Docker pulls nginx image (if not present):

Layer 4: nginx configuration  [10 MB]
   ↓
Layer 3: nginx binary         [50 MB]
   ↓
Layer 2: dependencies         [100 MB]
   ↓
Layer 1: Ubuntu base          [200 MB]
   ↓
Total image: 360 MB (shared among all nginx containers!)

Creates writable layer on top:
Layer 5: Container changes    [Initially 0 MB]
```

**Step 2: Namespace Creation**

```
Docker creates new namespaces:

┌─────────────────────────────────────┐
│  PID Namespace                      │
│  • Container's nginx = PID 1        │
│  • Isolated process tree            │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│  Network Namespace                  │
│  • Virtual ethernet: veth0          │
│  • IP: 172.17.0.2                   │
│  • Connected to docker0 bridge      │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│  Mount Namespace                    │
│  • Sees layered filesystem          │
│  • Has its own /proc, /sys          │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│  UTS Namespace                      │
│  • Hostname: container-id-abc123    │
└─────────────────────────────────────┘
```

**Step 3: Cgroup Configuration**

```
Docker creates cgroup hierarchy:

/sys/fs/cgroup/
├── memory/
│   └── docker/
│       └── container-abc123/
│           ├── memory.limit_in_bytes = 536870912  (512 MB)
│           └── memory.oom_control
│
├── cpu/
│   └── docker/
│       └── container-abc123/
│           ├── cpu.cfs_period_us = 100000
│           └── cpu.cfs_quota_us = 50000  (0.5 CPU)
│
└── blkio/
    └── docker/
        └── container-abc123/
            └── blkio.weight = 500
```

**Step 4: Process Execution Flow**

```
┌────────────────────────────────────────────────────────┐
│  1. Docker Engine receives: docker run nginx           │
└───────────────────┬────────────────────────────────────┘
                    ▼
┌────────────────────────────────────────────────────────┐
│  2. containerd prepares container runtime              │
└───────────────────┬────────────────────────────────────┘
                    ▼
┌────────────────────────────────────────────────────────┐
│  3. runc creates namespaces and cgroups                │
└───────────────────┬────────────────────────────────────┘
                    ▼
┌────────────────────────────────────────────────────────┐
│  4. Mount union filesystem layers                      │
└───────────────────┬────────────────────────────────────┘
                    ▼
┌────────────────────────────────────────────────────────┐
│  5. Execute nginx process in isolated environment      │
└────────────────────────────────────────────────────────┘
```

### Real-World Example: Running Two Nginx Containers

```
Host System:
┌──────────────────────────────────────────────────────────┐
│  OS: Ubuntu 22.04                                        │
│  RAM: 8GB                                                │
│  CPU: 4 cores                                            │
└──────────────────────────────────────────────────────────┘
           │
           ├─────────────────────┬──────────────────────
           ▼                     ▼
┌──────────────────────┐  ┌──────────────────────┐
│  Container 1         │  │  Container 2         │
├──────────────────────┤  ├──────────────────────┤
│ Namespaces:          │  │ Namespaces:          │
│  PID: nginx=PID 1    │  │  PID: nginx=PID 1    │
│  NET: 172.17.0.2:80  │  │  NET: 172.17.0.3:80  │
│  MNT: own /var/www   │  │  MNT: own /var/www   │
│                      │  │                      │
│ Cgroups:             │  │ Cgroups:             │
│  Memory: 512MB       │  │  Memory: 512MB       │
│  CPU: 1 core         │  │  CPU: 1 core         │
│                      │  │                      │
│ Filesystem:          │  │ Filesystem:          │
│  Container Layer (R/W│  │  Container Layer (R/W│
│  ├─ Nginx Layers ────┼──┼─► Shared! (R/O)      │
│  └─ Ubuntu Base ─────┼──┼─► Shared! (R/O)      │
└──────────────────────┘  └──────────────────────┘

Both containers:
✓ Think they're PID 1 (PID namespace)
✓ Both use port 80 internally (Network namespace)
✓ Share same nginx image layers (Union FS)
✓ Have separate file changes (Top writable layer)
✓ Limited to 512MB each (Cgroups)
✓ Can't see each other's processes (PID namespace)
```

### Benefits of This Architecture

**1. Efficiency:**

```
Traditional VMs          Docker Containers
┌─────────────┐         ┌──────────────┐
│   VM 1      │         │ Container 1  │
│ Guest OS    │         │ (Share OS)   │
│ 1GB RAM     │         │ 50MB RAM     │
│ Full kernel │         │ No kernel    │
└─────────────┘         └──────────────┘
┌─────────────┐         ┌──────────────┐
│   VM 2      │         │ Container 2  │
│ Guest OS    │         │ (Share OS)   │
│ 1GB RAM     │         │ 50MB RAM     │
│ Full kernel │         │ No kernel    │
└─────────────┘         └──────────────┘

Total: 2GB+ RAM         Total: 100MB RAM
Startup: 30-60s         Startup: <1s
```

**2. Security:**

- Namespaces provide isolation
- Processes can't escape to host
- Limited resource access via cgroups
- Read-only image layers prevent tampering

**3. Portability:**

- Same image runs anywhere
- All dependencies in layers
- Reproducible environments

**4. Resource Management:**

- Fair CPU distribution
- Memory limits prevent one container crashing system
- I/O throttling prevents disk hogging

---

## Complete Workflow Diagram

```
┌────────────────────────────────────────────────────────────────┐
│                    Docker Run Command                          │
│         docker run --memory=1g --cpus=2 myapp                  │
└────────────────────┬───────────────────────────────────────────┘
                     ▼
┌────────────────────────────────────────────────────────────────┐
│               Docker Engine Processing                         │
│  1. Check if image exists locally                              │
│  2. Pull layers if needed                                      │
│  3. Prepare container configuration                            │
└────────────────────┬───────────────────────────────────────────┘
                     ▼
        ┌────────────┴────────────┐
        ▼                         ▼
┌───────────────┐         ┌──────────────────┐
│  Union FS     │         │   containerd     │
│  Setup        │         │   (Container     │
│               │         │    Runtime)      │
│  • Mount base │         └────────┬─────────┘
│    layers     │                  ▼
│  • Create     │         ┌──────────────────┐
│    writable   │         │      runc        │
│    layer      │         │  (Low-level      │
│               │         │   Runtime)       │
└───────┬───────┘         └────────┬─────────┘
        │                          │
        │    ┌─────────────────────┘
        ▼    ▼
┌────────────────────────────────────────────────────────────────┐
│                  Linux Kernel Operations                       │
│                                                                │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐  │
│  │  Create      │  │   Create     │  │   Mount Filesystem   │  │
│  │  Namespaces  │  │   Cgroups    │  │   with Union FS      │  │ 
│  │              │  │              │  │                      │  │
│  │ • PID        │  │ • Set memory │  │ • Overlay/AUFS       │  │
│  │ • NET        │  │   limit: 1GB │  │ • Read-only base     │  │
│  │ • MNT        │  │ • Set CPU    │  │ • Writable top       │  │
│  │ • UTS        │  │   limit: 2   │  │                      │  │
│  │ • IPC        │  │   cores      │  │                      │  │
│  │ • USER       │  │ • Set I/O    │  │                      │  │
│  └──────────────┘  │   weights    │  └──────────────────────┘  │
│                    └──────────────┘                            │
└─────────────────────────┬──────────────────────────────────────┘
                          ▼
┌────────────────────────────────────────────────────────────────┐
│                  Container Running                             │
│                                                                │
│    Process sees:           Process limited to:                 │
│    • Own PID tree         • 1GB RAM                            │
│    • Own network          • 2 CPU cores                        │
│    • Own filesystem       • Controlled I/O                     │
│    • Own hostname         • Specific devices                   │
│                                                                │
│    Isolated and resource-controlled!                           │
└────────────────────────────────────────────────────────────────┘

```

## Summary

These three technologies work together perfectly:

1. **Namespaces** = **Isolation** ("You can only see your stuff")
2. **Cgroups** = **Resource Limits** ("You can only use this much")
3. **Union FS** = **Efficient Storage** ("Share what's common, separate what's unique")

Docker orchestrates all three to create lightweight, isolated, efficient containers that:
- Start in seconds (not minutes like VMs)
- Use minimal resources (MBs not GBs)
- Are portable (run anywhere)
- Are secure (isolated from host and each other)
- Are efficient (share common layers)

This is why containers have revolutionized software deployment - they provide isolation and resource management without the overhead of full virtualization!
```
```