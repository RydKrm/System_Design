
# Docker Internal Architecture - The Ultimate Deep Dive

## Introduction

This comprehensive guide explores every aspect of Docker's internal architecture, from the Linux kernel primitives to high-level orchestration. You'll learn exactly how Docker works under the hood, how components communicate, and how a simple `docker run` command transforms into a running container.

---

## Part 1: The Foundation - Linux Kernel Features

### Namespaces: Creating Isolation

Docker containers achieve isolation through Linux namespaces. Think of namespaces as creating separate "universes" where processes live independently.

**The Seven Namespace Types:**

1. **PID Namespace** - Process isolation
2. **Network Namespace** - Network stack isolation
3. **Mount Namespace** - Filesystem isolation
4. **UTS Namespace** - Hostname isolation
5. **IPC Namespace** - Inter-process communication isolation
6. **User Namespace** - User ID isolation
7. **Cgroup Namespace** - Control group isolation

**Visual Example:**

```
Host View                  Container View
═══════════               ═══════════════
PID 1: systemd            PID 1: nginx
PID 500: dockerd          PID 2: worker
PID 1000: nginx           (Can't see host processes)
```

### Control Groups (cgroups): Resource Management

Cgroups limit and monitor resource usage. They're like resource police ensuring no container uses more than its allocation.

**Key Controllers:**

- CPU: Limits processing power
- Memory: Limits RAM usage
- Block I/O: Limits disk read/write
- Network: Limits bandwidth

**Example Hierarchy:**

```
/sys/fs/cgroup/
  ├── memory/
  │   └── docker/
  │       └── container_id/
  │           ├── memory.limit_in_bytes
  │           └── cgroup.procs
  └── cpu/
      └── docker/
          └── container_id/
              ├── cpu.shares
              └── cgroup.procs
```

### Union Filesystems: Layer Technology

Union filesystems allow stacking multiple directories (layers) to appear as one unified filesystem.

```
Container View (Merged):
├── /app/myapp.py
├── /usr/lib/python3.9/
└── /bin/bash

Actual Structure:
Layer 3 (R/W): /app/myapp.py
Layer 2 (R/O): /usr/lib/python3.9/
Layer 1 (R/O): /bin/bash
```

---

## Part 2: runc - The Low-Level Runtime

### What is runc?

runc is the component that actually creates containers. It implements the OCI (Open Container Initiative) Runtime Specification and directly interacts with the Linux kernel.

**runc's Job:**

1. Parse OCI runtime specification
2. Create Linux namespaces
3. Set up cgroups
4. Prepare root filesystem
5. Execute container process

**Example OCI Spec (config.json):**

```json
{
  "ociVersion": "1.0.0",
  "process": {
    "args": ["/bin/sh"],
    "env": ["PATH=/usr/bin"],
    "cwd": "/"
  },
  "root": {
    "path": "rootfs"
  },
  "linux": {
    "namespaces": [
      {"type": "pid"},
      {"type": "network"}
    ],
    "resources": {
      "memory": {"limit": 536870912}
    }
  }
}
```

### Container Creation Process

**Step-by-Step:**

1. **Clone System Call**
    
    ```c
    clone(CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET)
    ```
    
    Creates new process with isolated namespaces
    
2. **Cgroup Setup**
    
    ```bash
    echo $PID > /sys/fs/cgroup/memory/docker/abc123/cgroup.procs
    echo 536870912 > /sys/fs/cgroup/memory/docker/abc123/memory.limit_in_bytes
    ```
    
3. **Filesystem Preparation**
    
    ```bash
    mount -t overlay overlay \
      -o lowerdir=/layer1:/layer2,upperdir=/upper,workdir=/work \
      /merged
    ```
    
4. **Execute Process**
    
    ```c
    execve("/bin/sh", ["/bin/sh"], env)
    ```
    

---

## Part 3: containerd - The High-Level Runtime

### Architecture Overview

containerd manages the complete container lifecycle and provides a stable API for clients like Docker.

```
┌─────────────────────────────────┐
│        containerd               │
├─────────────────────────────────┤
│  gRPC API Server                │
│    ↓                            │
│  Content Store (images)         │
│  Snapshot Service (filesystems) │
│  Metadata Database (state)      │
│  Task Service (containers)      │
│    ↓                            │
│  containerd-shim (per container)│
│    ↓                            │
│  runc                           │
└─────────────────────────────────┘
```

### Key Components

**1. Content Store** Stores image content addressable by digest:

```
/var/lib/containerd/content/blobs/sha256/
  ├── abc123... (image layer)
  ├── def456... (config)
  └── ghi789... (manifest)
```

**2. Snapshot Service** Manages container filesystems:

```
base (read-only)
  └─> layer1 (read-only)
      └─> layer2 (read-only)
          └─> container (read-write)
```

**3. containerd-shim** Critical daemon that:

- Keeps container's STDIO open
- Reports container exit status
- Acts as parent process
- Allows daemon upgrades without killing containers

**Process Tree:**

```
systemd
  └─> containerd
       ├─> shim-1 -> container-1
       └─> shim-2 -> container-2
```

If containerd restarts, shims keep containers running!

---

## Part 4: Docker Engine - The Complete Platform

### Docker Daemon (dockerd)

The Docker daemon is the central management service.

**Responsibilities:**

```
┌────────────────────────────────┐
│       Docker Daemon            │
├────────────────────────────────┤
│ • REST API Server              │
│ • Image Management             │
│ • Volume Management            │
│ • Network Management           │
│ • Build System (BuildKit)      │
│ • Swarm Mode                   │
└────────────────────────────────┘
```

**Configuration** (`/etc/docker/daemon.json`):

```json
{
  "storage-driver": "overlay2",
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  },
  "default-address-pools": [
    {"base": "172.18.0.0/16", "size": 24}
  ],
  "features": {
    "buildkit": true
  }
}
```

### Docker API

**Communication Methods:**

1. **Unix Socket** (default): `/var/run/docker.sock`
2. **TCP Socket**: `tcp://host:2376` (with TLS)
3. **SSH**: `ssh://user@host`

**API Structure:**

```
/v1.41/
  ├── containers/
  │   ├── create
  │   ├── {id}/start
  │   ├── {id}/stop
  │   └── {id}/logs
  ├── images/
  │   ├── create (pull)
  │   ├── build
  │   └── {id}/json
  ├── networks/
  └── volumes/
```

**Example API Call:**

```bash
curl --unix-socket /var/run/docker.sock \
  -X POST \
  -H "Content-Type: application/json" \
  -d '{"Image":"nginx"}' \
  http://localhost/v1.41/containers/create
```

---

## Part 5: Image Management
### **What is it?**
Docker image management is like **organizing and storing cooking recipes with all their ingredients pre-packaged**. 

Think of a Docker image as a **ready-to-use recipe box** that contains:
- All ingredients (your app code)
- Cooking instructions (settings/configurations)
- List of utensils needed (software dependencies)

### **How it Works (The Simple Version):**

1. **Images are Templates**
   - Like a cookie cutter or a mold
   - You can make many identical cookies (containers) from one cutter (image)

2. **Layers Like a Sandwich**
   - Images are built in **layers** (like a sandwich)
   - Base layer = bread (operating system)
   - Middle layers = fillings (libraries, dependencies)
   - Top layer = your app (the final touch)
   - If you change just your app, only that top layer needs updating!

3. **Registry = Library of Recipes**
   - **Docker Hub** is like a public library of recipes
   - You can **pull** (borrow) common recipes (nginx, mysql, python)
   - You can **push** (donate) your own recipes

4. **Version Control Like Book Editions**
   - Images have **tags** (like v1.0, latest, stable)
   - You can always go back to v1.0 if v2.0 doesn't work

### **Key Operations (What You Actually Do):**

- **`docker pull`** → Download a ready-made image from the library
- **`docker build`** → Create your own custom image
- **`docker push`** → Share your image with others
- **`docker images`** → See all images on your computer
- **`docker rmi`** → Delete images you don't need

### **Real-Life Example:**
Imagine you want to run a WordPress website:

1. You **pull** WordPress and MySQL images (like getting pre-made cake mixes)
2. You **run** them to create containers (like baking the cakes)
3. If it works perfectly, you **tag** it as "production-ready"
4. Share with your team so they get **exactly the same setup**

### **The Big Benefit:**
**"It works on my machine" problem disappears!** The image contains everything needed, so it runs the same way on any computer with Docker.

**In one sentence:** Docker image management is creating, sharing, and using **portable application packages** that run consistently anywhere.

**1. Manifest** - Points to config and layers **2. Config** - Image metadata (CMD, ENV, etc.) **3. Layers** - Filesystem changes

**Example Manifest:**

```json
{
  "schemaVersion": 2,
  "config": {
    "digest": "sha256:abc123...",
    "size": 7023
  },
  "layers": [
    {"digest": "sha256:layer1..."},
    {"digest": "sha256:layer2..."}
  ]
}
```

### Pull Image Flow

```
1. docker pull nginx
     ↓
2. Resolve to registry.hub.docker.com
     ↓
3. Authenticate (if required)
     ↓
4. GET /v2/library/nginx/manifests/latest
     ↓
5. Parse manifest, get layer digests
     ↓
6. For each layer:
     GET /v2/library/nginx/blobs/{digest}
     ↓
7. Extract to /var/lib/docker/overlay2/
     ↓
8. Verify checksums
     ↓
9. Update metadata
     ↓
10. Image ready!
```

---

## Part 6: Volume Management
A Docker volume is a designated storage space that exists outside the container's filesystem but can be accessed by one or more containers. Think of it as an external hard drive that you can plug into different computers. The computer (container) can read and write to this drive, but the drive's data persists even when the computer is turned off or replaced.
### Volume Types

```
┌────────────────────────────────────┐
│         Volume Types               │
├────────────────────────────────────┤
│ 1. Named Volumes (Docker-managed)  │
│    /var/lib/docker/volumes/        │
│                                    │
│ 2. Bind Mounts (Host directories)  │
│    /any/host/path                  │
│                                    │
│ 3. tmpfs (Memory)                  │
│    RAM-based temporary storage     │
└────────────────────────────────────┘
```

### Volume Architecture

```
Host System                Container
┌──────────────────┐      ┌──────────────────┐
│ /var/lib/docker/ │      │ /data/           │
│  volumes/        │◄────►│  ├── file1.txt   │
│   myvolume/      │      │  └── file2.txt   │
│    _data/        │      └──────────────────┘
│     ├── file1.txt│
│     └── file2.txt│
└──────────────────┘
```

### Mount Process

```
1. docker run -v myvolume:/data nginx
     ↓
2. Check if 'myvolume' exists
     No → Create: /var/lib/docker/volumes/myvolume
     Yes → Use existing
     ↓
3. containerd prepares mount
     Source: /var/lib/docker/volumes/myvolume/_data
     Target: /data (in container)
     ↓
4. runc performs mount
     mount --bind /var/lib/docker/volumes/myvolume/_data \
           /data
     ↓
5. Container sees /data directory
```

---

## Part 7: Network Management

### Network Drivers

```
┌──────────────────────────────────────┐
│      Network Drivers                 │
├──────────────────────────────────────┤
│ bridge    Default, single-host       │
│ host      Uses host network directly │
│ overlay   Multi-host (Swarm)         │
│ macvlan   Assign MAC to container    │
│ none      No networking              │
└──────────────────────────────────────┘
```

### Bridge Network Architecture

```
┌─────────────────────────────────────────┐
│              Host Machine               │
│                                         │
│  ┌────────────────────────────────────┐ │
│  │         docker0 Bridge             │ │
│  │         172.17.0.1/16              │ │
│  │                                    │ │
│  │  ┌────────────┐    ┌────────────┐  │ │
│  │  │Container 1 │    │Container 2 │  │ │
│  │  │172.17.0.2  │    │172.17.0.3  │  │ │
│  │  └─────┬──────┘    └─────┬──────┘  │ │
│  │        │                 │         │ │
│  │        └────────┬────────┘         │ │
│  │                 │                  │ │
│  │         ┌───────▼───────┐          │ │
│  │         │ docker0       │          │ │
│  │         │ (bridge)      │          │ │
│  │         └───────┬───────┘          │ │
│  └─────────────────┼──────────────────┘ │
│                    │                    │
│           ┌────────▼────────┐           │
│           │   iptables      │           │
│           │   (NAT/Filter)  │           │
│           └────────┬────────┘           │
│                    │                    │
│           ┌────────▼────────┐           │
│           │   eth0 (NIC)    │           │
│           │   192.168.1.100 │           │
│           └─────────────────┘           │
└─────────────────────────────────────────┘
```

### Virtual Ethernet (veth) Pairs

```
Container Namespace         Host Namespace
┌───────────────┐          ┌───────────────┐
│   eth0        │◄────────►│   vethXXX     │
│  172.17.0.2   │ veth pair│  (no IP)      │
└───────────────┘          └───────┬───────┘
                                   │
                            ┌──────▼──────┐
                            │   docker0   │
                            │   (bridge)  │
                            └─────────────┘
```

### Port Publishing

When you use `-p 8080:80`:

```
External Request Flow:
──────────────────────

1. Client connects to 192.168.1.100:8080
     ↓
2. Packet arrives at host eth0
     ↓
3. iptables NAT (PREROUTING):
   -A DOCKER -p tcp --dport 8080
   -j DNAT --to-destination 172.17.0.2:80
     ↓
4. Packet destination changed to 172.17.0.2:80
     ↓
5. Routed through docker0 bridge
     ↓
6. Forwarded via veth pair
     ↓
7. Arrives at container eth0:80
     ↓
8. Application (nginx) receives request
```

### DNS Resolution

Docker provides automatic DNS at 127.0.0.11:

```
Container 1: "ping container2"
     ↓
Query 127.0.0.11 for "container2"
     ↓
Docker embedded DNS resolves:
"container2" → 172.17.0.3
     ↓
Connection established
```

---

## Part 8: How Everything Works Together

### Complete System Integration

```
                    User Interface
                          │
                  ┌───────┴────-────┐
                  │   Docker CLI    │
                  └───────┬─────────┘
                          │ HTTP/Unix Socket
                  ┌───────▼──────────┐
                  │  Docker Daemon   │
                  │   (dockerd)      │
                  │                  │
                  │ • API Server     │
                  │ • Image Mgmt     │
                  │ • Volume Mgmt    │
                  │ • Network Mgmt   │
                  └───────┬──────────┘
                          │ gRPC
                  ┌───────▼──────────┐
                  │   containerd     │
                  │                  │
                  │ • Lifecycle      │
                  │ • Images         │
                  │ • Snapshots      │
                  └───────┬──────────┘
                          │
              ┌───────────┴───────────┐
              │                       │
       ┌──────▼─────┐          ┌─────▼──────┐
       │   shim-1   │          │   shim-2   │
       └──────┬─────┘          └─────┬──────┘
              │                      │
       ┌──────▼─────┐          ┌─────▼──────┐
       │   runc-1   │          │   runc-2   │
       └──────┬─────┘          └─────┬──────┘
              │                      │
       ┌──────▼─────┐          ┌─────▼──────┐
       │Container 1 │          │Container 2 │
       └────────────┘          └────────────┘
              │                      │
              └──────────┬───────────┘
                         │
                  ┌──────▼──────┐
                  │Linux Kernel │
                  │             │
                  │• Namespaces │
                  │• Cgroups    │
                  │• OverlayFS  │
                  └─────────────┘
```

---
## Key Takeaways

### Component Responsibilities

```
┌────────────┬────────────────────────────────┐
│ Component  │ Primary Responsibility         │
├────────────┼────────────────────────────────┤
│ Docker CLI │ User interface, commands       │
│ dockerd    │ API, orchestration, features   │
│ containerd │ Container lifecycle, images    │
│ shim       │ Daemonless, STDIO handling     │
│ runc       │ Container creation, kernel API │
│ Kernel     │ Namespaces, cgroups, overlayfs │
└────────────┴────────────────────────────────┘
```

### Communication Flow

```
User Command
     ↓ Unix Socket/HTTP
Docker Daemon
     ↓ gRPC
containerd
     ↓ Fork/Exec
containerd-shim
     ↓ Binary Execution
runc
     ↓ System Calls
Linux Kernel
     ↓
Running Container
```

### Why This Architecture?

1. **Modularity** - Each component is independent
2. **Stability** - Daemon can restart without killing containers
3. **Standards** - Follows OCI specifications
4. **Flexibility** - Components can be swapped
5. **Security** - Layered security boundaries
6. **Performance** - Efficient resource usage

---

## Conclusion

Docker's architecture is a masterpiece of software engineering. By understanding how each component works and interacts, you can:

- **Debug effectively** - Know where to look when issues arise
- **Optimize performance** - Understand resource usage
- **Secure deployments** - Apply security at the right layers
- **Make informed decisions** - Choose the right tools and approaches

From a simple `docker run` to complex multi-host orchestration, every action flows through this carefully designed architecture, transforming high-level commands into low-level kernel operations that create the isolated, portable environments we call containers.

The journey from Linux kernel primitives to production-grade container platforms demonstrates the power of layered abstractions, where each layer adds value while maintaining clear boundaries and responsibilities.

---

**End of Docker Internal Architecture Deep Dive**