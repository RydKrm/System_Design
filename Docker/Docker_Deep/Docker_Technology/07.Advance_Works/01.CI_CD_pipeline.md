# Complete CI/CD Pipeline Guide for Docker Multi-Project Deployment

## Table of Contents

1. [Understanding CI/CD Pipeline](https://claude.ai/chat/aefcc9c9-f1e1-41de-9883-ed6b27dff2da#understanding)
2. [CI/CD Architecture Overview](https://claude.ai/chat/aefcc9c9-f1e1-41de-9883-ed6b27dff2da#architecture)
3. [Prerequisites Setup](https://claude.ai/chat/aefcc9c9-f1e1-41de-9883-ed6b27dff2da#prerequisites)
4. [GitHub Actions Workflow for Project 1](https://claude.ai/chat/aefcc9c9-f1e1-41de-9883-ed6b27dff2da#project1-workflow)
5. [GitHub Actions Workflow for Project 2](https://claude.ai/chat/aefcc9c9-f1e1-41de-9883-ed6b27dff2da#project2-workflow)
6. [Server Setup for Automated Deployment](https://claude.ai/chat/aefcc9c9-f1e1-41de-9883-ed6b27dff2da#server-setup)
7. [Docker Registry Configuration](https://claude.ai/chat/aefcc9c9-f1e1-41de-9883-ed6b27dff2da#docker-registry)
8. [Environment Variables and Secrets](https://claude.ai/chat/aefcc9c9-f1e1-41de-9883-ed6b27dff2da#secrets)
9. [Testing Strategy](https://claude.ai/chat/aefcc9c9-f1e1-41de-9883-ed6b27dff2da#testing)
10. [Deployment Strategies](https://claude.ai/chat/aefcc9c9-f1e1-41de-9883-ed6b27dff2da#deployment-strategies)
11. [Rollback Procedures](https://claude.ai/chat/aefcc9c9-f1e1-41de-9883-ed6b27dff2da#rollback)
12. [Monitoring and Notifications](https://claude.ai/chat/aefcc9c9-f1e1-41de-9883-ed6b27dff2da#monitoring)
13. [Complete Working Examples](https://claude.ai/chat/aefcc9c9-f1e1-41de-9883-ed6b27dff2da#examples)

---

## 1. Understanding CI/CD Pipeline {#understanding}

CI/CD stands for Continuous Integration and Continuous Deployment. It's an automated process that runs every time you push code to your repository. Let's break down what happens:

### What is Continuous Integration (CI)?

Continuous Integration is the practice of automatically testing your code whenever changes are made. Instead of manually running tests before deployment, the CI system does it for you.

**Traditional Development (Without CI)**:

```
Developer writes code → Manually run tests → Hope nothing breaks → Deploy
                         (often skipped)        (surprises happen)
```

**With CI**:

```
Developer writes code → Push to GitHub → Automatic tests run → Build passes/fails
                                         Tests catch bugs        Clear status
```

### What is Continuous Deployment (CD)?

Continuous Deployment automatically deploys your code to production if all tests pass. No manual intervention needed.

**The Complete CI/CD Flow**:

```
┌─────────────────────────────────────────────────────────────────────┐
│                         Developer Workflow                          │
└─────────────────────────────────────────────────────────────────────┘

Developer writes code on local machine
    │
    ├─ git add .
    ├─ git commit -m "Add new feature"
    ├─ git push origin feature-branch
    │
    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                              GitHub                                  │
│                                                                      │
│  Feature Branch ─────── Pull Request ──────── Code Review           │
│                                                    │                 │
│                                                    │ Approved        │
│                                                    ▼                 │
│                                            Merge to Production       │
│                                                    │                 │
└────────────────────────────────────────────────────┼─────────────────┘
                                                     │
                                                     │ Triggers
                                                     ▼
┌─────────────────────────────────────────────────────────────────────┐
│                       GitHub Actions Runner                          │
│                     (Automated CI/CD Pipeline)                       │
│                                                                      │
│  Step 1: Checkout Code                                              │
│    └─ Download latest code from production branch                   │
│                                                                      │
│  Step 2: Run Tests                                                   │
│    ├─ Install dependencies                                           │
│    ├─ Run unit tests                                                 │
│    ├─ Run integration tests                                          │
│    └─ Run linting/code quality checks                                │
│         │                                                            │
│         ├─ If tests FAIL ─────────────────┐                         │
│         │                                  │                         │
│         │                                  ▼                         │
│         │                          ❌ Pipeline stops                 │
│         │                          Notification sent                 │
│         │                          "Build failed"                    │
│         │                                                            │
│         └─ If tests PASS ─────────────────┐                         │
│                                            │                         │
│  Step 3: Build Docker Images              │                         │
│    ├─ Build frontend image                │                         │
│    ├─ Build backend image                 │                         │
│    └─ Tag images with version             │                         │
│                                            │                         │
│  Step 4: Push to Docker Registry           │                         │
│    └─ Upload images to DockerHub/GHCR     │                         │
│                                            │                         │
│  Step 5: Deploy to Production Server       │                         │
│    ├─ SSH into production server          │                         │
│    ├─ Pull latest images                  │                         │
│    ├─ Stop old containers                 │                         │
│    ├─ Start new containers                │                         │
│    └─ Run health checks                   │                         │
│         │                                  │                         │
│         └─ Success ────────────────────────┘                         │
│                                            │                         │
└────────────────────────────────────────────┼─────────────────────────┘
                                             │
                                             ▼
                                    ✅ Deployment Complete
                                    Notification sent
                                    "Successfully deployed"
                                             │
                                             ▼
┌─────────────────────────────────────────────────────────────────────┐
│                       Production Server                              │
│                                                                      │
│  ┌─────────────┐  ┌─────────────┐  ┌──────────────┐               │
│  │   New       │  │   New       │  │  Databases   │               │
│  │  Frontend   │  │  Backend    │  │  (unchanged) │               │
│  │  Container  │  │  Container  │  │              │               │
│  └─────────────┘  └─────────────┘  └──────────────┘               │
│                                                                      │
│  Users see the new version immediately                              │
└─────────────────────────────────────────────────────────────────────┘
```

### Why Use CI/CD?

**Without CI/CD (Manual Deployment)**:

1. Developer finishes coding
2. Manually runs tests (maybe skips them)
3. Manually SSHs into server
4. Manually pulls code
5. Manually builds Docker images
6. Manually restarts containers
7. Manually checks if everything works
8. If it breaks, manually fixes and repeats

**With CI/CD (Automated)**:

1. Developer merges to production branch
2. Everything else happens automatically
3. Get notified if it worked or failed
4. Coffee time ☕

**Benefits**:

- **Consistency**: Same process every time, no human errors
- **Speed**: Deploys in minutes instead of hours
- **Safety**: Tests catch bugs before production
- **Confidence**: Know immediately if something breaks
- **Documentation**: Pipeline serves as deployment documentation
- **Rollback**: Easy to revert to previous version

---

## 2. CI/CD Architecture Overview {#architecture}

Here's how the entire CI/CD system fits together:

```
┌────────────────────────────────────────────────────────────────────────┐
│                          GitHub Repository                             │
│                                                                        │
│  ┌──────────────┐                                                      │
│  │ Source Code  │                                                      │
│  │              │                                                      │
│  │ ├─ frontend/ │                                                      │
│  │ ├─ backend/  │                                                      │
│  │ └─ .github/  │                                                      │
│  │    └─workflows/                                                     │
│  │       └─ deploy.yml  ◄──── This file defines CI/CD pipeline         │
│  └──────────────┘                                                      │
│                                                                        │
│  When code is merged to 'production' branch:                           │
│  Triggers GitHub Actions workflow                                      │
└────────────────┬───────────────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────────────┐
│                      GitHub Actions Runner                             │
│                   (Free tier: 2000 minutes/month)                      │
│                                                                        │
│  Virtual machine that executes your pipeline:                          │
│                                                                        │
│  ┌──────────────────────────────────────────────────────────────┐      │
│  │ Job 1: Test                                                  │      │
│  │   - Checkout code                                            │      │
│  │   - Install dependencies (npm install / go mod download)     │      │
│  │   - Run tests (npm test / go test)                           │      │
│  │   - Run linting (eslint / golint)                            │      │
│  └──────────────────────────────────────────────────────────────┘      │
│                            │                                           │
│                            │ If tests pass                             │
│                            ▼                                           │
│  ┌──────────────────────────────────────────────────────────────┐      │
│  │ Job 2: Build                                                 │      │
│  │   - Build Docker images                                      │      │
│  │   - Tag with version (commit SHA + timestamp)                │      │
│  │   - Push to Docker registry (DockerHub/GHCR)                 │      │
│  └──────────────────────────────────────────────────────────────┘      │
│                            │                                           │
│                            │ If build succeeds                         │
│                            ▼                                           │
│  ┌──────────────────────────────────────────────────────────────┐      │
│  │ Job 3: Deploy                                                │      │
│  │   - SSH into production server                               │      │
│  │   - Pull new Docker images                                   │      │ 
│  │   - Run deployment script                                    │      │
│  │   - Perform health checks                                    │      │
│  └──────────────────────────────────────────────────────────────┘      │
│                            │                                           │
└────────────────────────────┼───────────────────────────────────────────┘
                             │
                             ▼
┌────────────────────────────────────────────────────────────────────────┐
│                         Docker Registry                                │
│                  (DockerHub or GitHub Container Registry)              │
│                                                                        │
│  Stores Docker images:                                                 │
│  ├─ myuser/project1-frontend:v1.2.3                                    │
│  ├─ myuser/project1-backend:v1.2.3                                     │
│  ├─ myuser/project2-frontend:v2.0.1                                    │
│  └─ myuser/project2-backend:v2.0.1                                     │
│                                                                        │
└────────────────────────────┬───────────────────────────────────────────┘
                             │
                             │ Images pulled from here
                             ▼
┌───────────────────────────────────────────────────────────────────┐
│                      Production Server                            │
│                                                                   │
│  Deployment script runs:                                          │
│  1. docker-compose pull    ◄── Downloads new images               │
│  2. docker-compose down    ◄── Stops old containers               │
│  3. docker-compose up -d   ◄── Starts new containers              │
│  4. health check           ◄── Verifies deployment succeeded      │
│                                                                   │
│  ┌───────────────────────────────────────────────────────────┐    │
│  │              Running Containers (New Version)             │    │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │    │
│  │  │Frontend 1│  │Backend 1 │  │Frontend 2│  │Backend 2 │   │    │
│  │  │ v1.2.3   │  │ v1.2.3   │  │ v2.0.1   │  │ v2.0.1   │   │    │
│  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘   │    │
│  └───────────────────────────────────────────────────────────┘    │
│                                                                   │
└───────────────────────────────────────────────────────────────────┘
```

### Key Components

**1. GitHub Repository**: Where your code lives and where the CI/CD pipeline is defined

**2. GitHub Actions Runner**: Free virtual machine provided by GitHub that executes your pipeline

**3. Docker Registry**: Storage for Docker images (like npm for packages, but for containers)

**4. Production Server**: Your VPS/server where applications run

**5. Deployment Script**: Shell script on the server that handles the actual deployment

---

## 3. Prerequisites Setup {#prerequisites}

Before setting up CI/CD, you need to prepare your server and GitHub repository.

### Server Preparation

**1. Create a deployment user (non-root):**

```bash
# SSH into your production server
ssh root@your-server-ip

# Create deployment user
sudo useradd -m -s /bin/bash deploy
sudo usermod -aG docker deploy

# Create SSH directory for deploy user
sudo mkdir -p /home/deploy/.ssh
sudo chown deploy:deploy /home/deploy/.ssh
sudo chmod 700 /home/deploy/.ssh
```

**2. Generate SSH key for GitHub Actions:**

```bash
# On your production server (as deploy user)
sudo su - deploy

# Generate SSH key (press Enter for all prompts)
ssh-keygen -t ed25519 -C "github-actions-deploy" -f ~/.ssh/github_actions

# This creates two files:
# ~/.ssh/github_actions      (private key - keep secret!)
# ~/.ssh/github_actions.pub  (public key - can be shared)

# Add public key to authorized_keys
cat ~/.ssh/github_actions.pub >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys

# Display private key (you'll add this to GitHub secrets)
cat ~/.ssh/github_actions
```

**3. Create deployment directory:**

```bash
# As deploy user
mkdir -p /home/deploy/projects
cd /home/deploy/projects

# Clone your repositories here
git clone https://github.com/yourusername/project1.git
git clone https://github.com/yourusername/project2.git
```

**4. Create deployment script:**

```bash
# /home/deploy/scripts/deploy-project1.sh
cat > /home/deploy/scripts/deploy-project1.sh << 'EOF'
#!/bin/bash
set -e  # Exit on error

PROJECT_DIR="/home/deploy/projects/project1"
LOG_FILE="/home/deploy/logs/deploy-project1.log"
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

# Logging function
log() {
    echo "[$TIMESTAMP] $1" | tee -a "$LOG_FILE"
}

log "=== Starting Project 1 Deployment ==="

# Navigate to project directory
cd "$PROJECT_DIR" || exit 1

# Pull latest code
log "Pulling latest code..."
git fetch origin
git reset --hard origin/production

# Pull latest Docker images
log "Pulling Docker images..."
docker-compose pull

# Stop old containers
log "Stopping old containers..."
docker-compose down

# Start new containers
log "Starting new containers..."
docker-compose up -d --build

# Wait for containers to be healthy
log "Waiting for services to be healthy..."
sleep 10

# Health check
log "Performing health checks..."
if curl -f http://localhost:3001/health > /dev/null 2>&1; then
    log "✓ Frontend health check passed"
else
    log "✗ Frontend health check failed"
    exit 1
fi

if curl -f http://localhost:5001/health > /dev/null 2>&1; then
    log "✓ Backend health check passed"
else
    log "✗ Backend health check failed"
    exit 1
fi

# Clean up old images
log "Cleaning up old Docker images..."
docker image prune -af --filter "until=24h"

log "=== Deployment Completed Successfully ==="
EOF

chmod +x /home/deploy/scripts/deploy-project1.sh
```

Create similar script for Project 2:

```bash
# /home/deploy/scripts/deploy-project2.sh
cat > /home/deploy/scripts/deploy-project2.sh << 'EOF'
#!/bin/bash
set -e

PROJECT_DIR="/home/deploy/projects/project2"
LOG_FILE="/home/deploy/logs/deploy-project2.log"
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

log() {
    echo "[$TIMESTAMP] $1" | tee -a "$LOG_FILE"
}

log "=== Starting Project 2 Deployment ==="

cd "$PROJECT_DIR" || exit 1

log "Pulling latest code..."
git fetch origin
git reset --hard origin/production

log "Pulling Docker images..."
docker-compose pull

log "Stopping old containers..."
docker-compose down

log "Starting new containers..."
docker-compose up -d --build

log "Waiting for services to be healthy..."
sleep 10

log "Performing health checks..."
if curl -f http://localhost:3002/health > /dev/null 2>&1; then
    log "✓ Frontend health check passed"
else
    log "✗ Frontend health check failed"
    exit 1
fi

if curl -f http://localhost:8002/health > /dev/null 2>&1; then
    log "✓ Backend health check passed"
else
    log "✗ Backend health check failed"
    exit 1
fi

log "Cleaning up old Docker images..."
docker image prune -af --filter "until=24h"

log "=== Deployment Completed Successfully ==="
EOF

chmod +x /home/deploy/scripts/deploy-project2.sh
```

**5. Create log directory:**

```bash
mkdir -p /home/deploy/logs
```

### GitHub Repository Setup

**1. Repository Structure:**

Your repository should look like this:

```
project1/
├── .github/
│   └── workflows/
│       └── deploy.yml          ◄── CI/CD workflow
├── frontend/
│   ├── Dockerfile
│   ├── package.json
│   ├── src/
│   └── __tests__/             ◄── Frontend tests
├── backend/
│   ├── Dockerfile
│   ├── package.json
│   ├── src/
│   └── __tests__/             ◄── Backend tests
├── docker-compose.yml
├── docker-compose.prod.yml    ◄── Production overrides
└── README.md
```

**2. Create production branch:**

```bash
# On your local machine
cd project1

# Create and push production branch
git checkout -b production
git push -u origin production

# Set production as protected branch on GitHub:
# Go to: Settings → Branches → Add rule
# Branch name pattern: production
# ✓ Require pull request reviews before merging
# ✓ Require status checks to pass before merging
```

---

## 4. GitHub Actions Workflow for Project 1 {#project1-workflow}

Now let's create the actual CI/CD pipeline for Project 1 (React + Node.js + PostgreSQL + Redis).

### Complete Workflow File

```yaml
# .github/workflows/deploy.yml
name: Deploy Project 1 to Production

# Trigger on push to production branch
on:
  push:
    branches:
      - production

# Environment variables used across all jobs
env:
  DOCKER_REGISTRY: docker.io
  IMAGE_PREFIX: yourdockerhubusername/project1

jobs:
  # Job 1: Run tests
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        component: [frontend, backend]
    
    steps:
      # Step 1: Checkout code from repository
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Step 2: Setup Node.js environment
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: ${{ matrix.component }}/package-lock.json
      
      # Step 3: Install dependencies
      - name: Install dependencies
        working-directory: ./${{ matrix.component }}
        run: npm ci
      
      # Step 4: Run linting
      - name: Run linting
        working-directory: ./${{ matrix.component }}
        run: npm run lint
        continue-on-error: false
      
      # Step 5: Run unit tests
      - name: Run tests
        working-directory: ./${{ matrix.component }}
        run: npm test -- --coverage
        env:
          CI: true
      
      # Step 6: Upload test coverage
      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          file: ./${{ matrix.component }}/coverage/coverage-final.json
          flags: ${{ matrix.component }}
          name: ${{ matrix.component }}-coverage

  # Job 2: Build and push Docker images
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: test  # Only run if tests pass
    
    outputs:
      frontend-tag: ${{ steps.meta-frontend.outputs.tags }}
      backend-tag: ${{ steps.meta-backend.outputs.tags }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Step 1: Set up Docker Buildx (for faster builds)
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      # Step 2: Login to Docker Hub
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      # Step 3: Generate image metadata (tags, labels)
      - name: Docker metadata for Frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_PREFIX }}-frontend
          tags: |
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value={{date 'YYYYMMDD-HHmmss'}}
      
      - name: Docker metadata for Backend
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_PREFIX }}-backend
          tags: |
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value={{date 'YYYYMMDD-HHmmss'}}
      
      # Step 4: Build and push Frontend image
      - name: Build and push Frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            REACT_APP_API_URL=https://api.project01.com
      
      # Step 5: Build and push Backend image
      - name: Build and push Backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job 3: Deploy to production server
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build  # Only run if build succeeds
    environment:
      name: production
      url: https://project01.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Step 1: Deploy via SSH
      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: ${{ secrets.SERVER_PORT || 22 }}
          script: |
            # Navigate to project directory
            cd /home/deploy/projects/project1
            
            # Pull latest code
            git fetch origin
            git reset --hard origin/production
            
            # Update docker-compose to use new images
            export IMAGE_TAG=production-${{ github.sha }}
            
            # Run deployment script
            bash /home/deploy/scripts/deploy-project1.sh
      
      # Step 2: Health check
      - name: Health check
        run: |
          echo "Waiting for deployment to stabilize..."
          sleep 30
          
          # Check frontend
          if curl -f https://project01.com/health; then
            echo "✓ Frontend is healthy"
          else
            echo "✗ Frontend health check failed"
            exit 1
          fi
          
          # Check backend
          if curl -f https://api.project01.com/health; then
            echo "✓ Backend is healthy"
          else
            echo "✗ Backend health check failed"
            exit 1
          fi
      
      # Step 3: Notify on success
      - name: Deployment success notification
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              text: "✅ Project 1 deployed successfully to production",
              attachments: [{
                color: 'good',
                text: `Commit: ${{ github.sha }}\nAuthor: ${{ github.actor }}\nMessage: ${{ github.event.head_commit.message }}`
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      
      # Step 4: Notify on failure
      - name: Deployment failure notification
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              text: "❌ Project 1 deployment FAILED",
              attachments: [{
                color: 'danger',
                text: `Commit: ${{ github.sha }}\nAuthor: ${{ github.actor }}\nCheck logs: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}`
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
```

### Understanding the Workflow

**Workflow Structure**:

The workflow has three main jobs that run sequentially:

```
test → build → deploy
 ↓       ↓       ↓
Pass   Pass   Execute
 ↓       ↓
Fail   Fail → Stop (don't deploy broken code)
```

**Job 1: Test**

This job runs tests for both frontend and backend using a matrix strategy, which means it runs them in parallel:

```yaml
strategy:
  matrix:
    component: [frontend, backend]
```

This creates two parallel jobs:

- One for `frontend` where `matrix.component` = `frontend`
- One for `backend` where `matrix.component` = `backend`

For each component, it:

1. Checks out code
2. Sets up Node.js
3. Installs dependencies (`npm ci` is faster and more reliable than `npm install`)
4. Runs linting to catch code style issues
5. Runs unit tests with coverage
6. Uploads coverage reports

**Job 2: Build**

This job builds Docker images and pushes them to Docker Hub:

1. Sets up Docker Buildx (enables advanced build features and caching)
2. Logs into Docker Hub using secrets
3. Generates metadata (tags and labels) for images
4. Builds frontend image and pushes it
5. Builds backend image and pushes it

**Image Tagging Strategy**:

Each image gets multiple tags:

- `production-abc123def` (commit SHA - unique identifier)
- `latest` (always points to the most recent production deploy)
- `20241222-143022` (timestamp - useful for tracking)

**Job 3: Deploy**

This job connects to your production server via SSH and runs the deployment:

1. SSHs into server using stored credentials
2. Pulls latest code
3. Runs the deployment script
4. Performs health checks
5. Sends notifications (Slack, Discord, email, etc.)

---

## 5. GitHub Actions Workflow for Project 2 {#project2-workflow}

Project 2 uses Next.js and Golang, so the workflow is slightly different.

### Complete Workflow File for Project 2

```yaml
# .github/workflows/deploy.yml
name: Deploy Project 2 to Production

on:
  push:
    branches:
      - production

env:
  DOCKER_REGISTRY: docker.io
  IMAGE_PREFIX: yourdockerhubusername/project2

jobs:
  # Job 1: Test Frontend (Next.js)
  test-frontend:
    name: Test Next.js Frontend
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci
      
      - name: Run linting
        working-directory: ./frontend
        run: npm run lint
      
      - name: Run type checking
        working-directory: ./frontend
        run: npm run type-check
      
      - name: Run tests
        working-directory: ./frontend
        run: npm test -- --passWithNoTests
        env:
          CI: true
      
      - name: Build Next.js (test production build)
        working-directory: ./frontend
        run: npm run build
        env:
          NEXT_PUBLIC_API_URL: https://api.project02.com

  # Job 2: Test Backend (Golang)
  test-backend:
    name: Test Golang Backend
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'
          cache-dependency-path: backend/go.sum
      
      - name: Install dependencies
        working-directory: ./backend
        run: go mod download
      
      - name: Run go vet
        working-directory: ./backend
        run: go vet ./...
      
      - name: Run tests
        working-directory: ./backend
        run: go test -v -race -coverprofile=coverage.out ./...
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./backend/coverage.out
          flags: backend
      
      - name: Build binary (test compilation)
        working-directory: ./backend
        run: go build -v -o /tmp/api

  # Job 3: Build Docker images
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [test-frontend, test-backend]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      - name: Docker metadata for Frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_PREFIX }}-frontend
          tags: |
            type=sha,prefix=production-
            type=raw,value=latest
      
      - name: Docker metadata for Backend
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_PREFIX }}-backend
          tags: |
            type=sha,prefix=production-
            type=raw,value=latest
      
      - name: Build and push Frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NEXT_PUBLIC_API_URL=https://api.project02.com
      
      - name: Build and push Backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job 4: Deploy
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: production
      url: https://project02.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: 22
          script: |
            cd /home/deploy/projects/project2
            git fetch origin
            git reset --hard origin/production
            bash /home/deploy/scripts/deploy-project2.sh
      
      - name: Health check
        run: |
          sleep 30
          curl -f https://project02.com/ || exit 1
          curl -f https://api.project02.com/health || exit 1
          echo "✅ Deployment successful!"
```

### Key Differences from Project 1

**1. Separate test jobs**: Frontend and Backend tests run as separate jobs (instead of using matrix) because they use different tools (Node.js vs Go)

**2. Go-specific setup**: Uses `actions/setup-go` instead of `actions/setup-node` for the backend

**3. Go testing**: Runs `go test` with race detection and coverage

**4. Next.js build test**: Runs `npm run build` during testing to catch build errors before deployment

---

## 6. Server Setup for Automated Deployment {#server-setup}

### Production Docker Compose Configuration

Your production `docker-compose.yml` should be modified to use images from the registry instead of building locally.

**Project 1 Production Compose:**

```yaml
# /home/deploy/projects/project1/docker-compose.prod.yml
version: '3.8'

services:
  frontend:
    image: yourdockerhubusername/project1-frontend:latest
    container_name: project1_frontend
    restart: unless-stopped
    networks:
      - project1_internal
      - proxy_network
    environment:
      - NODE_ENV=production

  backend:
    image: yourdockerhubusername/project1-backend:latest
    container_name: project1_backend
    restart: unless-stopped
    depends_on:
      - postgres
      - redis
    networks:
      - project1_internal
      - proxy_network
    environment:
      - NODE_ENV=production
      - PORT=5000
      - DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=${JWT_SECRET}
    env_file:
      - .env

  postgres:
    image: postgres:15-alpine
    container_name: project1_postgres
    restart: unless-stopped
    networks:
      - project1_internal
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: project1_redis
    restart: unless-stopped
    command: redis-server --requirepass ${REDIS_PASSWORD}
    networks:
      - project1_internal
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5

volumes:
  postgres_data:
    name: project1_postgres_data
  redis_data:
    name: project1_redis_data

networks:
  project1_internal:
    name: project1_network
    driver: bridge
  proxy_network:
    external: true
```

**Key Changes for Production**:

1. `image:` instead of `build:` - pulls pre-built images from registry
2. Tag uses `:latest` which is always the most recent production deploy
3. All sensitive data comes from `.env` file (never commit this!)

### Enhanced Deployment Script with Rollback

```bash
#!/bin/bash
# /home/deploy/scripts/deploy-project1.sh

set -e

PROJECT_DIR="/home/deploy/projects/project1"
LOG_FILE="/home/deploy/logs/deploy-project1.log"
BACKUP_DIR="/home/deploy/backups/project1"
TIMESTAMP=$(date '+%Y-%m-%d_%H-%M-%S')

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log() {
    echo -e "${GREEN}[$TIMESTAMP]${NC} $1" | tee -a "$LOG_FILE"
}

error() {
    echo -e "${RED}[$TIMESTAMP] ERROR:${NC} $1" | tee -a "$LOG_FILE"
}

warn() {
    echo -e "${YELLOW}[$TIMESTAMP] WARNING:${NC} $1" | tee -a "$LOG_FILE"
}

# Create backup directory
mkdir -p "$BACKUP_DIR"

log "=== Starting Project 1 Deployment ==="

# Navigate to project directory
cd "$PROJECT_DIR" || exit 1

# Backup current docker-compose state
log "Creating backup of current state..."
docker-compose config > "$BACKUP_DIR/docker-compose-backup-$TIMESTAMP.yml"

# Store current image tags for rollback
docker images --format "{{.Repository}}:{{.Tag}}" | grep project1 > "$BACKUP_DIR/image-tags-$TIMESTAMP.txt"

# Pull latest code
log "Pulling latest code..."
git fetch origin
PREV_COMMIT=$(git rev-parse HEAD)
git reset --hard origin/production
CURR_COMMIT=$(git rev-parse HEAD)

log "Previous commit: $PREV_COMMIT"
log "Current commit: $CURR_COMMIT"

# Pull latest Docker images
log "Pulling latest Docker images..."
docker-compose -f docker-compose.prod.yml pull

# Backup database before deployment
log "Backing up database..."
docker exec project1_postgres pg_dump -U ${POSTGRES_USER} ${POSTGRES_DB} | gzip > "$BACKUP_DIR/db-backup-$TIMESTAMP.sql.gz"

# Stop old containers (but don't remove volumes)
log "Stopping old containers..."
docker-compose -f docker-compose.prod.yml down

# Start new containers
log "Starting new containers..."
docker-compose -f docker-compose.prod.yml up -d

# Wait for services to start
log "Waiting for services to initialize..."
sleep 15

# Detailed health checks
log "Performing health checks..."

# Check frontend
if curl -f -s http://localhost:3001/health > /dev/null; then
    log "✓ Frontend health check passed"
else
    error "✗ Frontend health check FAILED"
    log "Rolling back..."
    rollback
    exit 1
fi

# Check backend
if curl -f -s http://localhost:5001/health > /dev/null; then
    log "✓ Backend health check passed"
else
    error "✗ Backend health check FAILED"
    log "Rolling back..."
    rollback
    exit 1
fi

# Check database connectivity
if docker exec project1_postgres pg_isready -U ${POSTGRES_USER} > /dev/null; then
    log "✓ Database health check passed"
else
    error "✗ Database health check FAILED"
    log "Rolling back..."
    rollback
    exit 1
fi

# Check Redis connectivity
if docker exec project1_redis redis-cli ping > /dev/null; then
    log "✓ Redis health check passed"
else
    error "✗ Redis health check FAILED"
    log "Rolling back..."
    rollback
    exit 1
fi

# Clean up old images (keep last 3)
log "Cleaning up old Docker images..."
docker image prune -af --filter "until=72h"

# Clean up old backups (keep last 10)
log "Cleaning up old backups..."
cd "$BACKUP_DIR"
ls -t db-backup-*.sql.gz | tail -n +11 | xargs -r rm

log "=== Deployment Completed Successfully ==="
log "Deployed commit: $CURR_COMMIT"

exit 0

# Rollback function
rollback() {
    error "=== INITIATING ROLLBACK ==="
    
    # Stop failed containers
    docker-compose -f docker-compose.prod.yml down
    
    # Restore previous commit
    git reset --hard $PREV_COMMIT
    
    # Pull previous images (tagged with previous commit)
    docker-compose -f docker-compose.prod.yml pull
    
    # Start containers
    docker-compose -f docker-compose.prod.yml up -d
    
    # Restore database if needed
    # gunzip < "$BACKUP_DIR/db-backup-$TIMESTAMP.sql.gz" | docker exec -i project1_postgres psql -U ${POSTGRES_USER} ${POSTGRES_DB}
    
    error "=== ROLLBACK COMPLETED ==="
}
```

This enhanced script:

- Creates backups before deployment
- Performs comprehensive health checks
- Automatically rolls back if health checks fail
- Cleans up old images and backups
- Logs everything for debugging

---

## 7. Docker Registry Configuration {#docker-registry}

You need somewhere to store your Docker images. We'll use Docker Hub (free for public images).

### Option 1: Docker Hub (Recommended for beginners)

**Setup:**

1. Create account at https://hub.docker.com
    
2. Create repositories:
    
    - `yourusername/project1-frontend`
    - `yourusername/project1-backend`
    - `yourusername/project2-frontend`
    - `yourusername/project2-backend`
3. Generate access token:
    
    - Go to Account Settings → Security
    - Click "New Access Token"
    - Name: "GitHub Actions"
    - Permissions: Read & Write
    - Copy the token (you'll add this to GitHub secrets)

### Option 2: GitHub Container Registry (GHCR)

GHCR is integrated with GitHub and is free for public repos.

**Setup:**

1. Create Personal Access Token:
    
    - GitHub → Settings → Developer settings → Personal access tokens → Tokens (classic)
    - Generate new token
    - Select scopes: `write:packages`, `read:packages`, `delete:packages`
    - Copy token
2. Modify workflow to use GHCR:
    

```yaml
# In your workflow file
env:
  DOCKER_REGISTRY: ghcr.io
  IMAGE_PREFIX: ghcr.io/${{ github.repository_owner }}/project1

# Update login step:
- name: Login to GitHub Container Registry
  uses: docker/login-action@v3
  with:
    registry: ghcr.io
    username: ${{ github.actor }}
    password: ${{ secrets.GITHUB_TOKEN }}
```

### Option 3: Self-hosted Registry

For complete control, host your own registry:

```yaml
# docker-registry/docker-compose.yml
version: '3.8'

services:
  registry:
    image: registry:2
    container_name: docker_registry
    restart: unless-stopped
    ports:
      - "5000:5000"
    environment:
      REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY: /data
      REGISTRY_AUTH: htpasswd
      REGISTRY_AUTH_HTPASSWD_PATH: /auth/htpasswd
      REGISTRY_AUTH_HTPASSWD_REALM: Registry Realm
    volumes:
      - registry_data:/data
      - ./auth:/auth

volumes:
  registry_data:
```

Create authentication:

```bash
# Install htpasswd
sudo apt-get install apache2-utils

# Create password file
mkdir auth
htpasswd -Bc auth/htpasswd yourusername

# Start registry
docker-compose up -d
```

---

## 8. Environment Variables and Secrets {#secrets}

### GitHub Repository Secrets

Add these secrets to your GitHub repository:

**Go to: Repository → Settings → Secrets and variables → Actions → New repository secret**

**Required Secrets:**

```
SECRET_NAME             | VALUE                          | DESCRIPTION
------------------------|--------------------------------|-------------------------
DOCKER_USERNAME         | yourdockerhubusername          | Docker Hub username
DOCKER_PASSWORD         | dckr_pat_xxxxxxxxxxxxx         | Docker Hub access token
SERVER_HOST             | 123.45.67.89                   | Production server IP
SERVER_USERNAME         | deploy                         | SSH username
SERVER_SSH_KEY          | -----BEGIN OPENSSH PRIVATE KEY | Private SSH key
SERVER_PORT             | 22                             | SSH port (optional)
SLACK_WEBHOOK_URL       | https://hooks.slack.com/...    | Slack notifications
```

**How to add the SSH key:**

```bash
# On your production server (as deploy user)
cat ~/.ssh/github_actions

# Copy the ENTIRE output including:
# -----BEGIN OPENSSH PRIVATE KEY-----
# [key content]
# -----END OPENSSH PRIVATE KEY-----

# Paste into GitHub secret SERVER_SSH_KEY
```

### Environment Variables on Server

Create `.env` files on your production server:

```bash
# /home/deploy/projects/project1/.env
COMPOSE_PROJECT_NAME=project1

# PostgreSQL
POSTGRES_USER=project1_user
POSTGRES_PASSWORD=super_secure_production_password_12345
POSTGRES_DB=project1_database

# Redis
REDIS_PASSWORD=super_secure_redis_password_67890

# Application
JWT_SECRET=production_jwt_secret_must_be_32_chars_min
NODE_ENV=production
```

**Security Best Practices:**

1. Never commit `.env` files to Git
2. Use different passwords for each environment
3. Rotate secrets regularly
4. Use strong, randomly generated passwords
5. Limit secret access to only who needs it

```bash
# Generate secure passwords
openssl rand -base64 32

# Or use a password generator
pwgen -s 32 1
```

---

## 9. Testing Strategy {#testing}

Your CI/CD pipeline should run comprehensive tests before deployment.

### Frontend Tests (React/Next.js)

**Create test files:**

```javascript
// frontend/src/__tests__/App.test.js
import { render, screen } from '@testing-library/react';
import App from '../App';

describe('App Component', () => {
  test('renders application', () => {
    render(<App />);
    const element = screen.getByText(/welcome/i);
    expect(element).toBeInTheDocument();
  });

  test('handles API calls', async () => {
    // Mock API
    global.fetch = jest.fn(() =>
      Promise.resolve({
        json: () => Promise.resolve({ data: 'test' }),
      })
    );

    render(<App />);
    // Add assertions
  });
});
```

**Package.json scripts:**

```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "lint": "eslint src/**/*.{js,jsx}",
    "lint:fix": "eslint src/**/*.{js,jsx} --fix"
  }
}
```

### Backend Tests (Node.js)

```javascript
// backend/src/__tests__/api.test.js
const request = require('supertest');
const app = require('../server');

describe('API Endpoints', () => {
  test('GET /health should return 200', async () => {
    const response = await request(app).get('/health');
    expect(response.statusCode).toBe(200);
    expect(response.body.status).toBe('healthy');
  });

  test('GET /api/users should return users', async () => {
    const response = await request(app)
      .get('/api/users')
      .set('Authorization', 'Bearer test-token');
    
    expect(response.statusCode).toBe(200);
    expect(Array.isArray(response.body)).toBe(true);
  });
});
```

### Backend Tests (Golang)

```go
// backend/handlers/health_test.go
package handlers

import (
    "net/http"
    "net/http/httptest"
    "testing"
)

func TestHealthHandler(t *testing.T) {
    req, err := http.NewRequest("GET", "/health", nil)
    if err != nil {
        t.Fatal(err)
    }

    rr := httptest.NewRecorder()
    handler := http.HandlerFunc(HealthHandler)
    handler.ServeHTTP(rr, req)

    if status := rr.Code; status != http.StatusOK {
        t.Errorf("handler returned wrong status code: got %v want %v",
            status, http.StatusOK)
    }

    expected := `{"status":"healthy"}`
    if rr.Body.String() != expected {
        t.Errorf("handler returned unexpected body: got %v want %v",
            rr.Body.String(), expected)
    }
}
```

**Run tests:**

```bash
# Node.js
npm test

# Go
go test ./... -v
go test ./... -cover
go test ./... -race
```

### Integration Tests

Test the entire stack together:

```yaml
# .github/workflows/integration-tests.yml
name: Integration Tests

on:
  pull_request:
    branches: [production]

jobs:
  integration:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Install backend dependencies
        working-directory: ./backend
        run: npm ci
      
      - name: Run database migrations
        working-directory: ./backend
        run: npm run migrate
        env:
          DATABASE_URL: postgresql://postgres:testpass@localhost:5432/testdb
      
      - name: Start backend
        working-directory: ./backend
        run: |
          npm start &
          sleep 5
        env:
          DATABASE_URL: postgresql://postgres:testpass@localhost:5432/testdb
          REDIS_URL: redis://localhost:6379
          PORT: 5000
      
      - name: Run integration tests
        run: |
          curl -f http://localhost:5000/health
          curl -f http://localhost:5000/api/users
```

---

## 10. Deployment Strategies {#deployment-strategies}

### Strategy 1: Blue-Green Deployment

Run two identical production environments (blue and green). Deploy to the inactive one, test it, then switch traffic.

**Implementation:**

```yaml
# docker-compose.blue.yml
services:
  frontend-blue:
    image: project1-frontend:latest
    container_name: project1_frontend_blue
    networks:
      - proxy_network

# docker-compose.green.yml
services:
  frontend-green:
    image: project1-frontend:latest
    container_name: project1_frontend_green
    networks:
      - proxy_network
```

**Nginx configuration:**

```nginx
upstream frontend_active {
    server project1_frontend_blue:80;  # Active environment
}

upstream frontend_inactive {
    server project1_frontend_green:80;  # Inactive environment
}

server {
    listen 443 ssl;
    server_name project01.com;
    
    location / {
        proxy_pass http://frontend_active;
    }
}
```

**Deployment script:**

```bash
#!/bin/bash
# Deploy to inactive environment
docker-compose -f docker-compose.green.yml up -d

# Test green environment
curl -f http://localhost:3002/health

# If healthy, update Nginx to point to green
# Edit nginx config: frontend_active → project1_frontend_green
docker exec nginx_proxy nginx -s reload

# Green is now active, blue becomes inactive
```

### Strategy 2: Rolling Deployment

Update containers one at a time to avoid downtime.

```bash
#!/bin/bash
# For scaled services (multiple instances)
docker-compose up -d --scale frontend=3 --no-recreate

# Update one instance at a time
for i in {1..3}; do
    docker-compose up -d --scale frontend=$((3-i)) --no-recreate
    docker-compose pull frontend
    docker-compose up -d --scale frontend=$((3-i+1)) --no-recreate
    sleep 30  # Wait for health check
done
```

### Strategy 3: Canary Deployment

Deploy to a small percentage of users first, gradually increase if stable.

```nginx
upstream frontend {
    server frontend_stable:80 weight=9;   # 90% traffic
    server frontend_canary:80 weight=1;   # 10% traffic
}
```

---

## 11. Rollback Procedures {#rollback}

### Automatic Rollback

The deployment script already includes rollback on health check failure. For manual rollback:

### Manual Rollback Script

```bash
#!/bin/bash
# /home/deploy/scripts/rollback-project1.sh

set -e

PROJECT_DIR="/home/deploy/projects/project1"
BACKUP_DIR="/home/deploy/backups/project1"

# List available backups
echo "Available backups:"
ls -lt "$BACKUP_DIR"/docker-compose-backup-*.yml | head -10

# Prompt for backup to restore
read -p "Enter backup timestamp (YYYY-MM-DD_HH-MM-SS): " TIMESTAMP

BACKUP_FILE="$BACKUP_DIR/docker-compose-backup-$TIMESTAMP.yml"

if [ ! -f "$BACKUP_FILE" ]; then
    echo "Backup file not found!"
    exit 1
fi

echo "Rolling back to $TIMESTAMP..."

cd "$PROJECT_DIR"

# Get commit from backup metadata
PREV_COMMIT=$(grep "# Commit:" "$BACKUP_FILE" | cut -d' ' -f3)

# Reset to previous commit
git reset --hard $PREV_COMMIT

# Stop current containers
docker-compose down

# Start containers with backup configuration
docker-compose -f "$BACKUP_FILE" up -d

# Restore database (optional)
read -p "Restore database backup? (y/n): " RESTORE_DB
if [ "$RESTORE_DB" = "y" ]; then
    DB_BACKUP="$BACKUP_DIR/db-backup-$TIMESTAMP.sql.gz"
    if [ -f "$DB_BACKUP" ]; then
        echo "Restoring database..."
        gunzip < "$DB_BACKUP" | docker exec -i project1_postgres psql -U project1_user project1_database
        echo "Database restored"
    fi
fi

echo "Rollback complete!"
```

### Using Git Tags for Rollback

Tag each successful deployment:

```bash
# In deployment script, after successful deployment
git tag -a "deploy-$(date +%Y%m%d-%H%M%S)" -m "Deployment on $(date)"
git push origin --tags
```

To rollback to a specific tag:

```bash
git checkout tags/deploy-20241222-143000
docker-compose pull
docker-compose up -d
```

---

## 12. Monitoring and Notifications {#monitoring}

### Slack Notifications

**Setup Slack Webhook:**

1. Go to https://api.slack.com/apps
2. Create New App
3. Add "Incoming Webhooks" feature
4. Create webhook for your channel
5. Copy webhook URL
6. Add to GitHub secrets as `SLACK_WEBHOOK_URL`

The workflow already includes Slack notifications (see Project 1 workflow).

### Discord Notifications

```yaml
- name: Discord notification
  if: always()
  uses: sarisia/actions-status-discord@v1
  with:
    webhook: ${{ secrets.DISCORD_WEBHOOK }}
    status: ${{ job.status }}
    title: "Project 1 Deployment"
    description: "Deployment to production"
    color: 0x00ff00
    username: GitHub Actions
```

### Email Notifications

```yaml
- name: Send email
  if: failure()
  uses: dawidd6/action-send-mail@v3
  with:
    server_address: smtp.gmail.com
    server_port: 465
    username: ${{ secrets.EMAIL_USERNAME }}
    password: ${{ secrets.EMAIL_PASSWORD }}
    subject: "Deployment Failed - Project 1"
    body: "Deployment to production failed. Check logs at ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
    to: team@example.com
    from: deployments@example.com
```

### Monitoring Dashboard

Use Uptime Kuma for monitoring:

```yaml
# monitoring/docker-compose.yml
version: '3.8'

services:
  uptime-kuma:
    image: louislam/uptime-kuma:1
    container_name: uptime-kuma
    volumes:
      - uptime_data:/app/data
    ports:
      - "3001:3001"
    restart: unless-stopped

volumes:
  uptime_data:
```

Configure monitors for:

- https://project01.com/health
- https://api.project01.com/health
- https://project02.com
- https://api.project02.com/health

---

## 13. Complete Working Examples {#examples}

### Full Project Structure

```
project1/
├── .github/
│   └── workflows/
│       ├── deploy.yml                 # Main deployment workflow
│       ├── test.yml                   # Run tests on PRs
│       └── lint.yml                   # Code quality checks
├── frontend/
│   ├── src/
│   │   ├── __tests__/
│   │   │   ├── App.test.js
│   │   │   └── components.test.js
│   │   ├── App.js
│   │   └── index.js
│   ├── public/
│   ├── Dockerfile
│   ├── nginx.conf
│   ├── package.json
│   ├── .eslintrc.js
│   └── jest.config.js
├── backend/
│   ├── src/
│   │   ├── __tests__/
│   │   │   ├── api.test.js
│   │   │   └── db.test.js
│   │   ├── server.js
│   │   ├── routes/
│   │   └── models/
│   ├── Dockerfile
│   ├── package.json
│   ├── .eslintrc.js
│   └── jest.config.js
├── docker-compose.yml                  # Development
├── docker-compose.prod.yml             # Production
├── .env.example
├── .gitignore
└── README.md
```

### Complete Deployment Workflow

Here's the complete end-to-end process:

**1. Developer makes changes:**

```bash
# Create feature branch
git checkout -b feature/new-api-endpoint

# Make changes
# ... edit code ...

# Commit changes
git add .
git commit -m "Add new API endpoint"

# Push to GitHub
git push origin feature/new-api-endpoint
```

**2. Create Pull Request:**

```
GitHub UI:
1. Go to repository
2. Click "New Pull Request"
3. Select: feature/new-api-endpoint → production
4. Add description
5. Request review
6. CI checks run automatically (tests, linting)
```

**3. Code Review:**

```
Reviewer:
- Reviews code
- Checks test results
- Approves or requests changes
```

**4. Merge to Production:**

```
GitHub UI:
1. Click "Merge Pull Request"
2. Confirm merge
3. Delete feature branch

This triggers the deployment workflow!
```

**5. Automatic Deployment:**

```
GitHub Actions:
✓ Run tests
✓ Build Docker images
✓ Push to registry
✓ Deploy to server
✓ Health checks
✓ Send success notification
```

**6. Verify Deployment:**

```bash
# Check website
curl https://project01.com

# Check API
curl https://api.project01.com/health

# Check logs
ssh deploy@your-server
tail -f /home/deploy/logs/deploy-project1.log
```

### Testing the Pipeline

**Test without deploying:**

```yaml
# Add to workflow for dry-run testing
- name: Dry run deployment
  if: github.event_name == 'pull_request'
  run: |
    echo "Would deploy commit: ${{ github.sha }}"
    echo "Would deploy to: ${{ secrets.SERVER_HOST }}"
    echo "Skipping actual deployment for PR"
```

**Test SSH connection:**

```bash
# Test SSH key works
ssh -i ~/.ssh/github_actions deploy@your-server "echo Connection successful"
```

**Test Docker build locally:**

```bash
# Build images locally
docker build -t test-frontend ./frontend
docker build -t test-backend ./backend

# Test they run
docker run --rm -p 3000:80 test-frontend
docker run --rm -p 5000:5000 test-backend
```

### Troubleshooting Common Issues

**Issue: "Permission denied (publickey)"**

```bash
# Fix: Check SSH key is correctly added
# On server:
cat ~/.ssh/authorized_keys

# Should contain the PUBLIC key
# In GitHub secrets, you added the PRIVATE key
```

**Issue: "Tests failed"**

```bash
# Run tests locally first
cd frontend && npm test
cd backend && npm test

# Fix failing tests before pushing
```

**Issue: "Docker build failed"**

```bash
# Test build locally
docker build -t test ./frontend

# Check Dockerfile syntax
# Verify all COPY paths exist
```

**Issue: "Health check failed after deployment"**

```bash
# SSH into server
ssh deploy@your-server

# Check container logs
docker logs project1_backend --tail 100

# Check container is running
docker ps

# Check if services can reach each other
docker exec project1_backend ping postgres
```

---

## Summary

You now have a complete CI/CD pipeline that:

✅ **Automatically tests** code on every push ✅ **Builds Docker images** when tests pass  
✅ **Deploys to production** when merged to production branch ✅ **Performs health checks** to verify deployment ✅ **Automatically rolls back** if health checks fail ✅ **Sends notifications** on success or failure ✅ **Creates backups** before each deployment ✅ **Supports multiple projects** independently

### Workflow Summary

```
Code Push → Tests → Build → Deploy → Health Check → Notify
    │         │       │        │         │           │
    └─────────┴───────┴────────┴─────────┴───────────┘
           Any failure stops the pipeline
```

### Next Steps

1. Test the pipeline with a simple change
2. Monitor first few deployments closely
3. Add more comprehensive tests as you go
4. Set up monitoring and alerting
5. Document any project-specific quirks

The beauty of CI/CD is that once set up, deployments become boring—and that's exactly what you want! 🚀