# The Complete Guide to Rust Modules, Crates, and Backend Development

## Table of Contents

1. Understanding the Module System
2. Privacy and Visibility Rules
3. Creating Your Own Libraries
4. Workspace Organization
5. Real-World Backend Development Patterns
6. Best Practices and Production Examples

---

## Chapter 1: Understanding the Module System

### The Philosophy Behind Rust's Module System

Rust's module system is designed with three core principles in mind: **organization**, **encapsulation**, and **reusability**. Unlike some languages where every file is automatically accessible, Rust requires you to explicitly declare how your code is structured. This might seem verbose at first, but it provides powerful benefits: you always know where code comes from, you can't accidentally expose internal implementation details, and your project structure becomes self-documenting.

The module system creates a hierarchical tree structure. At the root of this tree is your **crate** - the compilation unit. A crate can be either a binary (an executable program) or a library (reusable code). Within a crate, you organize code into **modules**, which can contain functions, structs, enums, constants, traits, and even other modules.

### Understanding Crates: The Top Level

A crate is the smallest amount of code that the Rust compiler considers at a time. When you run `cargo build`, you're compiling a crate. There are two types of crates:

**Binary crates** are programs you can run. They must have a `main` function that serves as the entry point. When you create a new project with `cargo new my_project`, you get a binary crate by default.

**Library crates** don't have a `main` function and don't compile to an executable. Instead, they define functionality intended to be shared with multiple projects. You create a library crate with `cargo new --lib my_library`.

The distinction is crucial: binary crates are endpoints (applications), while library crates are building blocks (reusable code).

### The Crate Root: Where Everything Begins

Every crate has a root file that the Rust compiler starts from:

- For binary crates: `src/main.rs`
- For library crates: `src/lib.rs`

The crate root forms the root of your module tree. All other modules in your project branch off from this root.

### Modules: Organizing Code Within Crates

Modules let you organize code within a crate into groups for readability and reusability. They also control the **privacy** of items - whether code can be used from outside the module (public) or only within the module and its children (private).

Let me show you a practical example. Imagine we're building a restaurant management system:

```rust
// src/lib.rs - This is our crate root for a library

// Define a module inline using curly braces
mod front_of_house {
    // Modules can contain other modules
    mod hosting {
        fn add_to_waitlist() {
            println!("Adding customer to waitlist");
        }

        fn seat_at_table() {
            println!("Seating customer");
        }
    }

    mod serving {
        fn take_order() {
            println!("Taking order");
        }

        fn serve_order() {
            println!("Serving order");
        }

        fn take_payment() {
            println!("Processing payment");
        }
    }
}
```

**Explanation of the above code:**

We've defined a module called `front_of_house` that contains two nested modules: `hosting` and `serving`. This creates a module tree:

```
crate (lib.rs)
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
```

Each function lives within its logical grouping. However, there's a critical issue with this code: **everything is private by default**. If you try to call these functions from outside their modules, the compiler will reject it.

---

## Chapter 2: Privacy and Visibility Rules

### The Default-Private Philosophy

Rust follows the principle of **privacy by default**. This means that all items (functions, methods, structs, enums, modules, and constants) are private to their parent module by default. This is the opposite of languages like Java or C++, where items are often public by default.

Why this design? It follows the principle of **encapsulation** and **least privilege**. You explicitly choose what to expose, making it harder to accidentally create dependencies on internal implementation details. This makes refactoring easier and safer.

### The `pub` Keyword: Making Things Public

To make an item public, you use the `pub` keyword. But making a module public doesn't automatically make its contents public. Let's fix our restaurant example:

```rust
// src/lib.rs

mod front_of_house {
    // Making the hosting module public
    pub mod hosting {
        // Making this function public
        pub fn add_to_waitlist() {
            println!("Adding customer to waitlist");
        }

        // This function remains private (no pub keyword)
        fn seat_at_table() {
            println!("Seating customer");
        }
    }

    // The serving module is still private
    mod serving {
        fn take_order() {
            println!("Taking order");
        }
    }
}

// A public function in the crate root
pub fn eat_at_restaurant() {
    // We can call this because:
    // 1. front_of_house is defined in the same module (siblings)
    // 2. hosting is public
    // 3. add_to_waitlist is public
    front_of_house::hosting::add_to_waitlist();
}
```

**Explanation of visibility rules:**

1. **Siblings can see each other**: The `eat_at_restaurant` function can access `front_of_house` because they're defined in the same module (both are children of the crate root).

2. **Public chain required**: To access `add_to_waitlist` from outside `front_of_house`, both the `hosting` module AND the `add_to_waitlist` function must be public.

3. **Private by default**: `seat_at_table` and the entire `serving` module remain private implementation details.

### Relative vs Absolute Paths

When referring to items in the module tree, you can use either absolute or relative paths.

**Absolute paths** start from the crate root using the `crate` keyword:

```rust
pub fn eat_at_restaurant() {
    // Absolute path - starts from crate root
    crate::front_of_house::hosting::add_to_waitlist();
}
```

**Relative paths** start from the current module using `self` or `super`, or by directly naming a module:

```rust
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,  // Private field
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }

    fn fix_incorrect_order() {
        cook_order();
        // super refers to the parent module (crate root in this case)
        super::front_of_house::hosting::add_to_waitlist();
    }

    fn cook_order() {
        println!("Cooking order");
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast with Rye toast
    let mut meal = back_of_house::Breakfast::summer("Rye");

    // We can change the toast because it's public
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // This won't compile - seasonal_fruit is private
    // meal.seasonal_fruit = String::from("blueberries");
}
```

**Explanation of struct privacy:**

1. **Struct fields are private by default**: Even though `Breakfast` is public, `seasonal_fruit` is private.

2. **Per-field visibility**: You can make individual struct fields public with `pub`.

3. **Constructor pattern**: Because `seasonal_fruit` is private, users can't create a `Breakfast` directly. The `summer` function serves as a constructor, ensuring the struct is always created with valid data.

4. **The `super` keyword**: In `fix_incorrect_order`, we use `super` to go up one level in the module hierarchy, then navigate to the sibling module.

### Privacy Rules for Enums vs Structs

There's an important difference between structs and enums regarding privacy:

```rust
mod back_of_house {
    // If an enum is public, all its variants are public
    pub enum Appetizer {
        Soup,
        Salad,
    }

    // But struct fields are private by default
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }
}

pub fn eat_at_restaurant() {
    // We can use all enum variants
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;

    // But we can't directly construct Breakfast due to private field
    // This won't compile:
    // let breakfast = back_of_house::Breakfast {
    //     toast: String::from("Wheat"),
    //     seasonal_fruit: String::from("apples"),
    // };
}
```

**Why this difference?** Enums are typically used in pattern matching, and it would be impractical if some variants were inaccessible. Structs, however, often have complex invariants that need to be maintained, so field-level privacy makes sense.

### The `use` Keyword: Bringing Paths into Scope

Writing long paths repeatedly is tedious. The `use` keyword creates shortcuts:

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

// Bring the hosting module into scope
use crate::front_of_house::hosting;

// Or bring the function directly
// use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    // Now we can use the short path
    hosting::add_to_waitlist();

    // Or if we used the second form:
    // add_to_waitlist();
}
```

**Best practice for `use`**: For functions, it's idiomatic to bring the parent module into scope (not the function itself), so it's clear the function isn't locally defined. For structs, enums, and other items, bringing the item directly is idiomatic.

```rust
// Idiomatic
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}

// Less idiomatic for structs
use std::collections;

fn main() {
    let mut map = collections::HashMap::new();
}
```

### Re-exporting with `pub use`

Sometimes you want to bring an item into scope and also make it available for others to bring into their scope. This is called **re-exporting**:

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

// Re-export hosting so external code can use it
pub use crate::front_of_house::hosting;

// Now external code can do:
// use restaurant::hosting;
// instead of:
// use restaurant::front_of_house::hosting;
```

**Why re-export?** It lets you structure your internal code one way while presenting a different public API. This is crucial for library design - you can change internal organization without breaking external code.

---

## Chapter 3: Separating Modules into Files

### The File System as Module Hierarchy

As your project grows, keeping all modules in one file becomes unwieldy. Rust lets you split modules into separate files, and the file system structure mirrors the module hierarchy.

Let's reorganize our restaurant example. Here's how the file structure works:

**Rules for file-based modules:**

1. To declare a module named `front_of_house` that lives in another file, you write `mod front_of_house;` (note the semicolon instead of curly braces).

2. Rust will look for the module's contents in either:

   - `src/front_of_house.rs`
   - `src/front_of_house/mod.rs` (older style, still supported)

3. For submodules, if you have a module `front_of_house::hosting`, the file goes in:
   - `src/front_of_house/hosting.rs`

Let's see this in practice:

```rust
// src/lib.rs (the crate root)

// Declare the front_of_house module
// Rust will look for its contents in src/front_of_house.rs
mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```

```rust
// src/front_of_house.rs

// Declare the hosting submodule
// Rust will look for its contents in src/front_of_house/hosting.rs
pub mod hosting;

pub mod serving;
```

```rust
// src/front_of_house/hosting.rs

pub fn add_to_waitlist() {
    println!("Adding customer to waitlist");
}

fn seat_at_table() {
    println!("Seating customer");
}
```

```rust
// src/front_of_house/serving.rs

pub fn take_order() {
    println!("Taking order");
}

pub fn serve_order() {
    println!("Serving order");
}

fn take_payment() {
    println!("Processing payment");
}
```

**Explanation of the file structure:**

The module tree remains exactly the same as when everything was in one file:

```
crate (lib.rs)
 └── front_of_house (front_of_house.rs)
     ├── hosting (front_of_house/hosting.rs)
     └── serving (front_of_house/serving.rs)
```

The key insight: `mod front_of_house;` doesn't just declare a module, it tells the compiler to include the contents of that module from another file. The semicolon after the module name is the signal that the module's contents are in a separate file.

---

## Chapter 4: Creating Your Own Library Crate

### Designing a Library from Scratch

Let's create a real-world library for handling user authentication in a backend system. This will demonstrate proper library design, visibility control, and API surface management.

We'll create a library called `auth_lib` that handles user registration, login, and token management.

**Project structure:**

```
auth_lib/
├── Cargo.toml
└── src/
    ├── lib.rs
    ├── models.rs
    ├── token.rs
    ├── validation.rs
    └── error.rs
```

Let's start with the Cargo.toml:

```toml
# Cargo.toml

[package]
name = "auth_lib"
version = "0.1.0"
edition = "2021"

[dependencies]
# Dependencies we'll use in our examples
serde = { version = "1.0", features = ["derive"] }
chrono = "0.4"
```

Now, let's build the library from the ground up:

````rust
// src/lib.rs (the public API surface)

// Private modules - implementation details
mod validation;
mod token;

// Public modules - part of the public API
pub mod models;
pub mod error;

// Re-export commonly used types for convenience
pub use error::{AuthError, AuthResult};
pub use models::{User, UserCredentials};

/// The main authentication service
pub struct AuthService {
    // Private field - users can't access this directly
    token_secret: String,
}

impl AuthService {
    /// Creates a new authentication service with the given secret
    ///
    /// # Examples
    ///
    /// ```
    /// use auth_lib::AuthService;
    ///
    /// let service = AuthService::new("my-secret-key");
    /// ```
    pub fn new(secret: &str) -> Self {
        Self {
            token_secret: secret.to_string(),
        }
    }

    /// Registers a new user
    ///
    /// # Errors
    ///
    /// Returns `AuthError::ValidationError` if the email or password is invalid
    pub fn register(&self, email: &str, password: &str) -> AuthResult<User> {
        // Use private validation module
        validation::validate_email(email)?;
        validation::validate_password(password)?;

        // In a real app, you'd hash the password and save to database
        let user = User {
            id: 1, // Would come from database
            email: email.to_string(),
            created_at: chrono::Utc::now(),
        };

        Ok(user)
    }

    /// Authenticates a user and returns a token
    ///
    /// # Errors
    ///
    /// Returns `AuthError::InvalidCredentials` if authentication fails
    pub fn login(&self, credentials: UserCredentials) -> AuthResult<String> {
        // In a real app, verify against database
        validation::validate_email(&credentials.email)?;

        // Generate token using private token module
        let token = token::generate_token(
            credentials.email,
            &self.token_secret
        )?;

        Ok(token)
    }

    /// Validates a token
    ///
    /// # Errors
    ///
    /// Returns `AuthError::InvalidToken` if the token is invalid or expired
    pub fn validate_token(&self, token: &str) -> AuthResult<String> {
        token::validate_token(token, &self.token_secret)
    }
}
````

**Explanation of the library design:**

1. **Public vs Private modules**: `models` and `error` are public because users of our library need to work with these types. But `validation` and `token` are private - they're implementation details.

2. **Re-exports**: We re-export commonly used types (`AuthError`, `User`, etc.) at the crate root. This means users can write `use auth_lib::AuthError;` instead of `use auth_lib::error::AuthError;`.

3. **Privacy boundaries**: The `token_secret` field is private. Users can't access or modify it directly, ensuring security.

4. **Public API**: Only `new`, `register`, `login`, and `validate_token` are public. These are the only operations users need.

Now let's implement the supporting modules:

```rust
// src/error.rs

use std::fmt;

/// All possible errors in the authentication system
#[derive(Debug)]
pub enum AuthError {
    ValidationError(String),
    InvalidCredentials,
    InvalidToken,
    TokenExpired,
    InternalError(String),
}

// Implement Display for good error messages
impl fmt::Display for AuthError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AuthError::ValidationError(msg) => write!(f, "Validation error: {}", msg),
            AuthError::InvalidCredentials => write!(f, "Invalid email or password"),
            AuthError::InvalidToken => write!(f, "Invalid or malformed token"),
            AuthError::TokenExpired => write!(f, "Token has expired"),
            AuthError::InternalError(msg) => write!(f, "Internal error: {}", msg),
        }
    }
}

// Implement std::error::Error for interoperability
impl std::error::Error for AuthError {}

/// Convenient result type for authentication operations
pub type AuthResult<T> = Result<T, AuthError>;
```

**Explanation of error design:**

1. **Custom error type**: We define `AuthError` to represent all possible errors in our library. This is much better than using strings or generic errors.

2. **Type alias**: `AuthResult<T>` is shorthand for `Result<T, AuthError>`. This makes function signatures cleaner.

3. **Public error type**: The error type is public because users need to handle these errors. But the variants are carefully chosen to not leak implementation details.

```rust
// src/models.rs

use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};

/// Represents a user in the system
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub id: i64,
    pub email: String,
    pub created_at: DateTime<Utc>,
}

/// Credentials provided during login
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserCredentials {
    pub email: String,
    pub password: String,
}

/// Information contained in an authentication token
#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) struct TokenClaims {
    pub(crate) email: String,
    pub(crate) exp: i64, // Expiration timestamp
}
```

**Explanation of model design:**

1. **Public fields**: For `User` and `UserCredentials`, all fields are public. These are data transfer objects (DTOs) - pure data containers.

2. **`pub(crate)`**: `TokenClaims` uses `pub(crate)`, meaning it's public within our crate but private to external users. We need to share it between modules internally, but users don't need to see it.

3. **Derive macros**: We derive `Serialize` and `Deserialize` for easy JSON conversion, common in web applications.

```rust
// src/validation.rs
// This entire module is private (no pub on mod)

use crate::error::{AuthError, AuthResult};

/// Validates an email address
pub(crate) fn validate_email(email: &str) -> AuthResult<()> {
    if email.is_empty() {
        return Err(AuthError::ValidationError(
            "Email cannot be empty".to_string()
        ));
    }

    if !email.contains('@') {
        return Err(AuthError::ValidationError(
            "Invalid email format".to_string()
        ));
    }

    // In a real app, use a proper email validation library
    Ok(())
}

/// Validates a password
pub(crate) fn validate_password(password: &str) -> AuthResult<()> {
    if password.len() < 8 {
        return Err(AuthError::ValidationError(
            "Password must be at least 8 characters".to_string()
        ));
    }

    if !password.chars().any(|c| c.is_numeric()) {
        return Err(AuthError::ValidationError(
            "Password must contain at least one number".to_string()
        ));
    }

    Ok(())
}
```

**Explanation of private module design:**

1. **`pub(crate)` functions**: These functions are visible within our crate but not to users. We need them in `lib.rs`, but users don't call them directly.

2. **Implementation details**: The validation rules might change. By keeping this module private, we can refactor it without breaking external code.

```rust
// src/token.rs

use crate::error::{AuthError, AuthResult};
use crate::models::TokenClaims;
use chrono::{Utc, Duration};

/// Generates a JWT-like token (simplified for demonstration)
pub(crate) fn generate_token(email: String, secret: &str) -> AuthResult<String> {
    let expiration = Utc::now() + Duration::hours(24);

    let claims = TokenClaims {
        email: email.clone(),
        exp: expiration.timestamp(),
    };

    // In a real app, use a proper JWT library like jsonwebtoken
    // This is a simplified version for demonstration
    let token = format!(
        "{}:{}:{}",
        email,
        claims.exp,
        simple_hash(&format!("{}{}{}", email, claims.exp, secret))
    );

    Ok(token)
}

/// Validates a token
pub(crate) fn validate_token(token: &str, secret: &str) -> AuthResult<String> {
    let parts: Vec<&str> = token.split(':').collect();

    if parts.len() != 3 {
        return Err(AuthError::InvalidToken);
    }

    let email = parts[0];
    let exp: i64 = parts[1]
        .parse()
        .map_err(|_| AuthError::InvalidToken)?;
    let hash = parts[2];

    // Check expiration
    let now = Utc::now().timestamp();
    if exp < now {
        return Err(AuthError::TokenExpired);
    }

    // Verify hash
    let expected_hash = simple_hash(&format!("{}{}{}", email, exp, secret));
    if hash != expected_hash {
        return Err(AuthError::InvalidToken);
    }

    Ok(email.to_string())
}

// Private helper function - not even visible in the crate
fn simple_hash(input: &str) -> String {
    // In production, use a proper cryptographic hash
    format!("{:x}", input.len() * 31)
}
```

**Explanation of token module:**

1. **Fully private implementation**: The entire token generation mechanism is hidden. Users only interact with it through `AuthService`.

2. **Private helper**: `simple_hash` doesn't even have `pub(crate)` - it's private to this module only.

### Using the Library

Now let's see how someone would use our library:

```rust
// In another project's src/main.rs

use auth_lib::{AuthService, UserCredentials, AuthError};

fn main() {
    // Create the auth service
    let auth_service = AuthService::new("super-secret-key");

    // Register a user
    match auth_service.register("user@example.com", "password123") {
        Ok(user) => println!("User registered: {:?}", user),
        Err(AuthError::ValidationError(msg)) => {
            println!("Validation failed: {}", msg);
            return;
        }
        Err(e) => {
            println!("Registration failed: {}", e);
            return;
        }
    }

    // Login
    let credentials = UserCredentials {
        email: "user@example.com".to_string(),
        password: "password123".to_string(),
    };

    let token = match auth_service.login(credentials) {
        Ok(t) => t,
        Err(e) => {
            println!("Login failed: {}", e);
            return;
        }
    };

    println!("Login successful! Token: {}", token);

    // Validate token
    match auth_service.validate_token(&token) {
        Ok(email) => println!("Token valid for user: {}", email),
        Err(AuthError::TokenExpired) => println!("Token has expired"),
        Err(AuthError::InvalidToken) => println!("Token is invalid"),
        Err(e) => println!("Validation error: {}", e),
    }

    // This won't compile - validation module is private:
    // auth_lib::validation::validate_email("test@example.com");

    // This won't compile - token_secret is private:
    // let secret = auth_service.token_secret;
}
```

**What the user can and cannot do:**

✅ **Can do:**

- Create an `AuthService`
- Call public methods (`register`, `login`, `validate_token`)
- Handle `AuthError` variants
- Create `User` and `UserCredentials` instances

❌ **Cannot do:**

- Access `validation` or `token` modules (they're private)
- Access `token_secret` field (it's private)
- Call internal functions like `generate_token` directly
- Modify internal implementation details

This is exactly what we want - a clean, safe public API with all implementation details hidden.

---

## Chapter 5: Workspace Organization

### What is a Cargo Workspace?

As projects grow, you often want to split them into multiple related crates. Maybe you have a backend API, a CLI tool, and a shared library. A **workspace** is a set of packages that share the same `Cargo.lock` and output directory.

Workspaces provide several benefits:

1. **Shared dependencies**: All crates in the workspace use the same versions of dependencies, ensuring consistency.

2. **Unified build**: You can build all crates with a single command.

3. **Code sharing**: Crates within a workspace can easily depend on each other.

4. **Monorepo structure**: You can organize a large project as multiple interconnected crates while keeping them in one repository.

### Creating a Workspace

Let's create a real-world workspace for a backend web service. We'll have:

- `common`: Shared types and utilities
- `api`: The REST API server
- `cli`: A command-line admin tool
- `worker`: Background job processor

**Workspace structure:**

```
backend_project/
├── Cargo.toml (workspace root)
├── Cargo.lock (shared by all members)
├── common/
│   ├── Cargo.toml
│   └── src/
│       └── lib.rs
├── api/
│   ├── Cargo.toml
│   └── src/
│       └── main.rs
├── cli/
│   ├── Cargo.toml
│   └── src/
│       └── main.rs
└── worker/
    ├── Cargo.toml
    └── src/
        └── main.rs
```

The root `Cargo.toml` defines the workspace:

```toml
# Cargo.toml (workspace root)

[workspace]
members = [
    "common",
    "api",
    "cli",
    "worker",
]

# Optional: define dependencies that can be inherited by members
[workspace.dependencies]
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
chrono = "0.4"

# Workspace-wide settings
[workspace.package]
edition = "2021"
authors = ["Your Name <you@example.com>"]
license = "MIT"
```

**Explanation of workspace configuration:**

1. **`members`**: Lists all crates in the workspace. Cargo will manage them as a unit.

2. **`workspace.dependencies`**: Define dependencies once, then inherit them in member crates. This ensures version consistency.

3. **`workspace.package`**: Common metadata that can be inherited by all members.

### The Common Library Crate

This crate contains shared code used by all other crates:

```toml
# common/Cargo.toml

[package]
name = "common"
version.workspace = true
edition.workspace = true

[dependencies]
serde.workspace = true
serde_json.workspace = true
chrono.workspace = true
```

Note the `.workspace = true` syntax - this inherits values from the workspace root.

```rust
// common/src/lib.rs

use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};

/// Common user model used across all services
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub id: i64,
    pub email: String,
    pub name: String,
    pub created_at: DateTime<Utc>,
}

/// Common configuration structure
#[derive(Debug, Clone, Deserialize)]
pub struct Config {
    pub database_url: String,
    pub redis_url: String,
    pub jwt_secret: String,
    pub api_port: u16,
}

impl Config {
    /// Loads configuration from environment variables
    pub fn from_env() -> Result<Self, Box<dyn std::error::Error>> {
        Ok(Config {
            database_url: std::env::var("DATABASE_URL")?,
            redis_url: std::env::var("REDIS_URL")?,
            jwt_secret: std::env::var("JWT_SECRET")?,
            api_port: std::env::var("API_PORT")?.parse()?,
        })
    }
}

/// Common error type used across services
#[derive(Debug)]
pub enum AppError {
    DatabaseError(String),
    ValidationError(String),
    NotFound,
    Unauthorized,
}

impl std::fmt::Display for AppError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            AppError::DatabaseError(msg) => write!(f, "Database error: {}", msg),
            AppError::ValidationError(msg) => write!(f, "Validation error: {}", msg),
            AppError::NotFound => write!(f, "Resource not found"),
            AppError::Unauthorized => write!(f, "Unauthorized access"),
        }
    }
}

impl std::error::Error for AppError {}

pub type AppResult<T> = Result<T, AppError>;
```

**Why a common crate?** This prevents code duplication. The same `User` type, `Config`, and error handling is used consistently across API, CLI, and worker crates. When you update the `User` model, all services automatically use the new version.

### The API Server Crate

Now let's build the REST API server that depends on our common library:

```toml
# api/Cargo.toml

[package]
name = "api"
version.workspace = true
edition.workspace = true

[dependencies]
# Reference the common library within the workspace
common = { path = "../common" }

# Inherit workspace dependencies
tokio.workspace = true
serde.workspace = true
serde_json.workspace = true

# API-specific dependencies
axum = "0.7"
tower = "0.4"
tower-http = { version = "0.5", features = ["cors"] }
```

**Explanation of dependencies:**

1. **`common = { path = "../common" }`**: This creates a dependency on our workspace member. Cargo understands this is a local crate.

2. **Workspace dependencies**: We inherit `tokio`, `serde`, etc. from the workspace root, ensuring version consistency.

3. **Crate-specific dependencies**: `axum` is only needed for the API server, so it's defined here, not in the workspace root.

```rust
// api/src/main.rs

use axum::{
    routing::{get, post},
    Router,
    Json,
    http::StatusCode,
    response::IntoResponse,
};
use std::net::SocketAddr;

// Import from our common library
use common::{User, Config, AppError, AppResult};

/// The main entry point for the API server
#[tokio::main]
async fn main() {
    // Load shared configuration
    let config = Config::from_env()
        .expect("Failed to load configuration");

    println!("Starting API server on port {}", config.api_port);

    // Build the router with routes
    let app = Router::new()
        .route("/", get(health_check))
        .route("/users/:id", get(get_user))
        .route("/users", post(create_user));

    // Start the server
    let addr = SocketAddr::from(([0, 0, 0, 0], config.api_port));
    let listener = tokio::net::TcpListener::bind(addr)
        .await
        .expect("Failed to bind to port");

    println!("API server listening on {}", addr);

    axum::serve(listener, app)
        .await
        .expect("Server failed");
}

/// Health check endpoint
async fn health_check() -> &'static str {
    "OK"
}

/// Get a user by ID
async fn get_user(
    axum::extract::Path(id): axum::extract::Path<i64>,
) -> Result<Json<User>, AppError> {
    // In a real app, fetch from database
    // Using our shared User type from common
    let user = User {
        id,
        email: format!("user{}@example.com", id),
        name: format!("User {}", id),
        created_at: chrono::Utc::now(),
    };

    Ok(Json(user))
}

/// Create a new user
async fn create_user(
    Json(payload): Json<CreateUserRequest>,
) -> Result<(StatusCode, Json<User>), AppError> {
    // Validate using common error types
    if payload.email.is_empty() {
        return Err(AppError::ValidationError(
            "Email cannot be empty".to_string()
        ));
    }

    // In a real app, save to database
    let user = User {
        id: 1,
        email: payload.email,
        name: payload.name,
        created_at: chrono::Utc::now(),
    };

    Ok((StatusCode::CREATED, Json(user)))
}

/// Request body for creating a user
#[derive(serde::Deserialize)]
struct CreateUserRequest {
    email: String,
    name: String,
}

/// Implement error conversion for Axum
impl IntoResponse for AppError {
    fn into_response(self) -> axum::response::Response {
        let (status, message) = match self {
            AppError::NotFound => (StatusCode::NOT_FOUND, self.to_string()),
            AppError::Unauthorized => (StatusCode::UNAUTHORIZED, self.to_string()),
            AppError::ValidationError(_) => (StatusCode::BAD_REQUEST, self.to_string()),
            AppError::DatabaseError(_) => {
                (StatusCode::INTERNAL_SERVER_ERROR, "Internal server error".to_string())
            }
        };

        (status, message).into_response()
    }
}
```

**Key points about the API crate:**

1. **Uses common types**: We import `User`, `Config`, and `AppError` from our common library. There's a single source of truth.

2. **Binary crate**: This has a `main` function - it compiles to an executable.

3. **Workspace coordination**: When we run `cargo build` from the workspace root, Cargo builds both `common` and `api`, understanding their dependency relationship.

### The CLI Tool Crate

The command-line administration tool also uses the common library:

```toml
# cli/Cargo.toml

[package]
name = "cli"
version.workspace = true
edition.workspace = true

[dependencies]
common = { path = "../common" }
tokio.workspace = true
serde_json.workspace = true

# CLI-specific dependencies
clap = { version = "4.0", features = ["derive"] }
```

```rust
// cli/src/main.rs

use clap::{Parser, Subcommand};
use common::{User, Config, AppResult};

/// Backend administration CLI tool
#[derive(Parser)]
#[command(name = "admin-cli")]
#[command(about = "Administration tool for backend services", long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// List all users
    ListUsers,

    /// Get user by ID
    GetUser {
        /// User ID
        id: i64,
    },

    /// Create a new user
    CreateUser {
        /// User email
        #[arg(short, long)]
        email: String,

        /// User name
        #[arg(short, long)]
        name: String,
    },
}

#[tokio::main]
async fn main() -> AppResult<()> {
    // Load the same configuration as other services
    let config = Config::from_env()
        .expect("Failed to load configuration");

    let cli = Cli::parse();

    match cli.command {
        Commands::ListUsers => {
            println!("Listing users from database: {}", config.database_url);
            // In a real app, query database
            let users = vec![
                User {
                    id: 1,
                    email: "user1@example.com".to_string(),
                    name: "User One".to_string(),
                    created_at: chrono::Utc::now(),
                },
            ];

            for user in users {
                println!("{}: {} ({})", user.id, user.name, user.email);
            }
        }

        Commands::GetUser { id } => {
            println!("Fetching user {}", id);
            // In a real app, query database using common types
            let user = User {
                id,
                email: format!("user{}@example.com", id),
                name: format!("User {}", id),
                created_at: chrono::Utc::now(),
            };

            println!("{:#?}", user);
        }

        Commands::CreateUser { email, name } => {
            println!("Creating user: {} ({})", name, email);

            // Use the same User type as the API
            let user = User {
                id: 123, // Would come from database
                email,
                name,
                created_at: chrono::Utc::now(),
            };

            println!("Created user: {:#?}", user);
        }
    }

    Ok(())
}
```

**Why separate CLI and API crates?**

1. **Different dependencies**: The CLI needs `clap`, the API needs `axum`. They're built independently.

2. **Separate binaries**: You can deploy just the API server without including CLI code.

3. **Shared logic**: Both use the exact same `User` type and `Config` from the common crate.

### The Worker Crate

Background job processor that handles async tasks:

```toml
# worker/Cargo.toml

[package]
name = "worker"
version.workspace = true
edition.workspace = true

[dependencies]
common = { path = "../common" }
tokio.workspace = true
serde_json.workspace = true
```

```rust
// worker/src/main.rs

use tokio::time::{interval, Duration};
use common::{Config, User, AppResult};

#[tokio::main]
async fn main() -> AppResult<()> {
    let config = Config::from_env()
        .expect("Failed to load configuration");

    println!("Starting background worker");
    println!("Connected to database: {}", config.database_url);
    println!("Connected to Redis: {}", config.redis_url);

    // Run background tasks
    let mut tick = interval(Duration::from_secs(10));

    loop {
        tick.tick().await;

        // Process pending jobs
        process_pending_jobs(&config).await?;
    }
}

async fn process_pending_jobs(config: &Config) -> AppResult<()> {
    println!("Processing pending jobs...");

    // In a real app, fetch jobs from Redis or database
    // Uses the same User type as other services
    let user = User {
        id: 1,
        email: "user@example.com".to_string(),
        name: "User One".to_string(),
        created_at: chrono::Utc::now(),
    };

    // Process some job for this user
    println!("Processed job for user: {}", user.email);

    Ok(())
}
```

### Building and Running the Workspace

From the workspace root, you can:

```bash
# Build all crates
cargo build

# Build a specific crate
cargo build -p api
cargo build -p cli

# Run a specific binary
cargo run -p api
cargo run -p cli -- list-users
cargo run -p worker

# Test all crates
cargo test

# Check all crates (faster than build)
cargo check
```

**Explanation of workspace commands:**

1. **`cargo build`**: Builds all workspace members. Cargo is smart - it builds `common` first since other crates depend on it.

2. **`-p` flag**: Specifies a package. `cargo build -p api` builds only the API crate (and its dependencies).

3. **`--` separator**: Passes arguments to the binary. `cargo run -p cli -- list-users` runs the CLI with the `list-users` subcommand.

### Workspace Benefits Demonstrated

Let's say you need to add a `role` field to the `User` model:

```rust
// common/src/lib.rs

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub id: i64,
    pub email: String,
    pub name: String,
    pub role: UserRole,  // New field
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum UserRole {
    Admin,
    User,
    Guest,
}
```

**What happens:**

1. You change the `User` struct once in `common/src/lib.rs`
2. Run `cargo build` from the workspace root
3. The compiler shows you every place in `api`, `cli`, and `worker` that needs to be updated
4. All services use the new `User` model with the `role` field
5. No risk of services getting out of sync

This is the power of workspaces - **shared code, unified dependencies, consistent updates**.

---

## Chapter 6: Real-World Backend Development

### A Complete Backend Service Architecture

Let's build a production-ready REST API with proper module organization, showing how everything we've learned applies to real backend development.

We'll create a **Task Management API** with:

- User authentication
- Task CRUD operations
- Database layer
- Proper error handling
- Middleware for logging and auth
- Configuration management

**Project structure:**

```
task_api/
├── Cargo.toml
└── src/
    ├── main.rs
    ├── config.rs
    ├── db/
    │   ├── mod.rs
    │   └── models.rs
    ├── handlers/
    │   ├── mod.rs
    │   ├── auth.rs
    │   └── tasks.rs
    ├── middleware/
    │   ├── mod.rs
    │   ├── auth.rs
    │   └── logging.rs
    ├── services/
    │   ├── mod.rs
    │   ├── auth_service.rs
    │   └── task_service.rs
    └── error.rs
```

**Cargo.toml:**

```toml
[package]
name = "task_api"
version = "0.1.0"
edition = "2021"

[dependencies]
# Web framework
axum = "0.7"
tokio = { version = "1.0", features = ["full"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["trace", "cors"] }

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Database (using PostgreSQL)
sqlx = { version = "0.7", features = ["runtime-tokio-native-tls", "postgres", "chrono", "uuid"] }

# Time
chrono = { version = "0.4", features = ["serde"] }

# UUID
uuid = { version = "1.0", features = ["serde", "v4"] }

# Password hashing
argon2 = "0.5"

# JWT
jsonwebtoken = "9.0"

# Environment variables
dotenvy = "0.15"

# Logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
```

### Error Handling Module

Let's start with comprehensive error handling - the foundation of any backend:

```rust
// src/error.rs

use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde_json::json;

/// All possible errors in our application
#[derive(Debug)]
pub enum AppError {
    // Database errors
    DatabaseError(sqlx::Error),
    DatabaseConnectionError(String),

    // Authentication/Authorization errors
    Unauthorized,
    InvalidToken,
    TokenExpired,
    InvalidCredentials,

    // Validation errors
    ValidationError(String),

    // Resource errors
    NotFound(String),
    AlreadyExists(String),

    // Internal errors
    InternalError(String),
    ConfigError(String),
}

impl std::fmt::Display for AppError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AppError::DatabaseError(e) => write!(f, "Database error: {}", e),
            AppError::DatabaseConnectionError(msg) => write!(f, "Database connection error: {}", msg),
            AppError::Unauthorized => write!(f, "Unauthorized access"),
            AppError::InvalidToken => write!(f, "Invalid authentication token"),
            AppError::TokenExpired => write!(f, "Authentication token has expired"),
            AppError::InvalidCredentials => write!(f, "Invalid email or password"),
            AppError::ValidationError(msg) => write!(f, "Validation error: {}", msg),
            AppError::NotFound(resource) => write!(f, "{} not found", resource),
            AppError::AlreadyExists(resource) => write!(f, "{} already exists", resource),
            AppError::InternalError(msg) => write!(f, "Internal error: {}", msg),
            AppError::ConfigError(msg) => write!(f, "Configuration error: {}", msg),
        }
    }
}

impl std::error::Error for AppError {}

/// Convert database errors to AppError
impl From<sqlx::Error> for AppError {
    fn from(err: sqlx::Error) -> Self {
        match err {
            sqlx::Error::RowNotFound => AppError::NotFound("Resource".to_string()),
            _ => AppError::DatabaseError(err),
        }
    }
}

/// Convert AppError to HTTP responses
impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, error_message) = match self {
            AppError::DatabaseError(_) => {
                // Don't expose internal database errors to clients
                tracing::error!("Database error: {}", self);
                (StatusCode::INTERNAL_SERVER_ERROR, "Internal server error".to_string())
            }
            AppError::DatabaseConnectionError(_) => {
                tracing::error!("Database connection error: {}", self);
                (StatusCode::SERVICE_UNAVAILABLE, "Service temporarily unavailable".to_string())
            }
            AppError::Unauthorized | AppError::InvalidToken | AppError::TokenExpired => {
                (StatusCode::UNAUTHORIZED, self.to_string())
            }
            AppError::InvalidCredentials => {
                (StatusCode::UNAUTHORIZED, self.to_string())
            }
            AppError::ValidationError(_) => {
                (StatusCode::BAD_REQUEST, self.to_string())
            }
            AppError::NotFound(_) => {
                (StatusCode::NOT_FOUND, self.to_string())
            }
            AppError::AlreadyExists(_) => {
                (StatusCode::CONFLICT, self.to_string())
            }
            AppError::InternalError(_) => {
                tracing::error!("Internal error: {}", self);
                (StatusCode::INTERNAL_SERVER_ERROR, "Internal server error".to_string())
            }
            AppError::ConfigError(_) => {
                tracing::error!("Configuration error: {}", self);
                (StatusCode::INTERNAL_SERVER_ERROR, "Service configuration error".to_string())
            }
        };

        let body = Json(json!({
            "error": error_message,
        }));

        (status, body).into_response()
    }
}

/// Convenient result type
pub type AppResult<T> = Result<T, AppError>;
```

**Explanation of error handling strategy:**

1. **Comprehensive error types**: We define specific error variants for every failure scenario. This makes error handling explicit and type-safe.

2. **Error conversion**: The `From<sqlx::Error>` implementation automatically converts database errors to our `AppError` type. This means we can use the `?` operator with database operations.

3. **HTTP response mapping**: `IntoResponse` converts errors to appropriate HTTP status codes and JSON responses. This is crucial for REST APIs.

4. **Security consideration**: We don't expose internal database errors to clients (see `DatabaseError` case). We log them server-side but return a generic message.

5. **Logging integration**: We use `tracing::error!` to log serious errors for debugging while sending safe messages to clients.

### Configuration Module

```rust
// src/config.rs

use crate::error::{AppError, AppResult};

#[derive(Debug, Clone)]
pub struct Config {
    pub database_url: String,
    pub jwt_secret: String,
    pub jwt_expiration_hours: i64,
    pub server_host: String,
    pub server_port: u16,
}

impl Config {
    /// Load configuration from environment variables
    pub fn from_env() -> AppResult<Self> {
        // Load .env file if it exists
        dotenvy::dotenv().ok();

        Ok(Config {
            database_url: std::env::var("DATABASE_URL")
                .map_err(|_| AppError::ConfigError(
                    "DATABASE_URL must be set".to_string()
                ))?,

            jwt_secret: std::env::var("JWT_SECRET")
                .map_err(|_| AppError::ConfigError(
                    "JWT_SECRET must be set".to_string()
                ))?,

            jwt_expiration_hours: std::env::var("JWT_EXPIRATION_HOURS")
                .unwrap_or_else(|_| "24".to_string())
                .parse()
                .map_err(|_| AppError::ConfigError(
                    "JWT_EXPIRATION_HOURS must be a valid number".to_string()
                ))?,

            server_host: std::env::var("SERVER_HOST")
                .unwrap_or_else(|_| "0.0.0.0".to_string()),

            server_port: std::env::var("SERVER_PORT")
                .unwrap_or_else(|_| "3000".to_string())
                .parse()
                .map_err(|_| AppError::ConfigError(
                    "SERVER_PORT must be a valid port number".to_string()
                ))?,
        })
    }

    /// Validate configuration values
    pub fn validate(&self) -> AppResult<()> {
        if self.jwt_secret.len() < 32 {
            return Err(AppError::ConfigError(
                "JWT_SECRET must be at least 32 characters".to_string()
            ));
        }

        if self.jwt_expiration_hours < 1 {
            return Err(AppError::ConfigError(
                "JWT_EXPIRATION_HOURS must be at least 1".to_string()
            ));
        }

        Ok(())
    }
}
```

**Configuration design principles:**

1. **Environment-based**: Configuration comes from environment variables, following 12-factor app principles.

2. **Validation**: The `validate()` method checks configuration values at startup, failing fast if something is wrong.

3. **Defaults**: Some values have sensible defaults (like server host and port).

4. **Type safety**: We parse strings into appropriate types (integers, ports) with proper error handling.

### Database Models

```rust
// src/db/models.rs

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sqlx::FromRow;
use uuid::Uuid;

/// User model matching the database schema
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct User {
    pub id: Uuid,
    pub email: String,
    pub name: String,
    #[serde(skip_serializing)]  // Never send password hash to clients
    pub password_hash: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Task model matching the database schema
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct Task {
    pub id: Uuid,
    pub user_id: Uuid,
    pub title: String,
    pub description: Option<String>,
    pub completed: bool,
    pub due_date: Option<DateTime<Utc>>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// DTO for creating a new user
#[derive(Debug, Deserialize)]
pub struct CreateUser {
    pub email: String,
    pub name: String,
    pub password: String,
}

/// DTO for user login
#[derive(Debug, Deserialize)]
pub struct LoginRequest {
    pub email: String,
    pub password: String,
}

/// DTO for creating a task
#[derive(Debug, Deserialize)]
pub struct CreateTask {
    pub title: String,
    pub description: Option<String>,
    pub due_date: Option<DateTime<Utc>>,
}

/// DTO for updating a task
#[derive(Debug, Deserialize)]
pub struct UpdateTask {
    pub title: Option<String>,
    pub description: Option<String>,
    pub completed: Option<bool>,
    pub due_date: Option<DateTime<Utc>>,
}

/// JWT claims
#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,  // Subject (user ID)
    pub email: String,
    pub exp: i64,     // Expiration time
}
```

**Model design patterns:**

1. **Database models**: `User` and `Task` match the database schema exactly. The `FromRow` derive macro allows SQLx to automatically map database rows to these structs.

2. **Security**: `#[serde(skip_serializing)]` on `password_hash` ensures it's never included in JSON responses.

3. **DTOs (Data Transfer Objects)**: `CreateUser`, `LoginRequest`, etc. are separate from database models. They represent API request/response formats, which often differ from database structure.

4. **Type safety**: Using `Uuid` instead of strings, `DateTime<Utc>` instead of generic timestamps ensures type safety.

### Database Layer

```rust
// src/db/mod.rs

pub mod models;

use sqlx::{PgPool, postgres::PgPoolOptions};
use crate::error::{AppError, AppResult};

/// Create a database connection pool
pub async fn create_pool(database_url: &str) -> AppResult<PgPool> {
    PgPoolOptions::new()
        .max_connections(5)
        .connect(database_url)
        .await
        .map_err(|e| AppError::DatabaseConnectionError(e.to_string()))
}

/// Run database migrations
pub async fn run_migrations(pool: &PgPool) -> AppResult<()> {
    sqlx::migrate!("./migrations")
        .run(pool)
        .await
        .map_err(|e| AppError::DatabaseError(sqlx::Error::Migrate(Box::new(e))))?;

    Ok(())
}
```

**Database layer responsibilities:**

1. **Connection pooling**: We create a pool of database connections for efficiency. Multiple requests can use connections from the pool concurrently.

2. **Migration management**: `sqlx::migrate!` runs SQL migrations from the `migrations/` directory, keeping the database schema in sync with code.

3. **Error conversion**: Database connection errors are wrapped in our `AppError` type.

### Authentication Service

````rust
// src/services/auth_service.rs

use argon2::{
    password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString},
    Argon2,
};
use chrono::{Duration, Utc};
use jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header, Validation};
use sqlx::PgPool;
use uuid::Uuid;

use crate::{
    db::models::{Claims, CreateUser, LoginRequest, User},
    error::{AppError, AppResult},
};

pub struct AuthService {
    pool: PgPool,
    jwt_secret: String,
    jwt_expiration_hours: i64,
}

impl AuthService {
    pub fn new(pool: PgPool, jwt_secret: String, jwt_expiration_hours: i64) -> Self {
        Self {
            pool,
            jwt_secret,
            jwt_expiration_hours,
        }
    }

    /// Register a new user
    pub async fn register(&self, create_user: CreateUser) -> AppResult<User> {
        // Validate input
        self.validate_email(&create_user.email)?;
        self.validate_password(&create_user.password)?;

        // Check if user already exists
        let existing = sqlx::query_as::<_, User>(
            "SELECT * FROM users WHERE email = $1"
        )
        .bind(&create_user.email)
        .fetch_optional(&self.pool)
        .await?;

        if existing.is_some() {
            return Err(AppError::AlreadyExists("User with this email".to_string()));
        }

        // Hash password
        let password_hash = self.hash_password(&create_user.password)?;

        // Insert user
        let user = sqlx::query_as::<_, User>(
            "INSERT INTO users (id, email, name, password_hash, created_at, updated_at)
             VALUES ($1, $2, $3, $4, $5, $6)
             RETURNING *"
        )
        .bind(Uuid::new_v4())
        .bind(&create_user.email)
        .bind(&create_user.name)
        .bind(&password_hash)
        .bind(Utc::now())
        .bind(Utc::now())
        .fetch_one(&self.pool)
        .await?;

        Ok(user)
    }

    /// Authenticate user and return JWT token
    pub async fn login(&self, login_req: LoginRequest) -> AppResult<String> {
        // Fetch user by email
        let user = sqlx::query_as::<_, User>(
            "SELECT * FROM users WHERE email = $1"
        )
        .bind(&login_req.email)
        .fetch_optional(&self.pool)
        .await?
        .ok_or(AppError::InvalidCredentials)?;

        // Verify password
        self.verify_password(&login_req.password, &user.password_hash)?;

        // Generate JWT
        let token = self.generate_token(&user)?;

        Ok(token)
    }

    /// Validate JWT token and return claims
    pub fn validate_token(&self, token: &str) -> AppResult<Claims> {
        let token_data = decode::<Claims>(
            token,
            &DecodingKey::from_secret(self.jwt_secret.as_bytes()),
            &Validation::default(),
        )
        .map_err(|_| AppError::InvalidToken)?;

        // Check if token is expired
        let now = Utc::now().timestamp();
        if token_data.claims.exp < now {
            return Err(AppError::TokenExpired);
        }

        Ok(token_data.claims)
    }

    /// Get user by ID
    pub async fn get_user_by_id(&self, user_id: Uuid) -> AppResult<User> {
        let user = sqlx::query_as::<_, User>(
            "SELECT * FROM users WHERE id = $1"
        )
        .bind(user_id)
        .fetch_optional(&self.pool)
        .await?
        .ok_or_else(|| AppError::NotFound("User".to_string()))?;

        Ok(user)
    }

    // Private helper methods

    fn hash_password(&self, password: &str) -> AppResult<String> {
        let salt = SaltString::generate(&mut OsRng);
        let argon2 = Argon2::default();

        let password_hash = argon2
            .hash_password(password.as_bytes(), &salt)
            .map_err(|e| AppError::InternalError(format!("Password hashing failed: {}", e)))?
            .to_string();

        Ok(password_hash)
    }

    fn verify_password(&self, password: &str, hash: &str) -> AppResult<()> {
        let parsed_hash = PasswordHash::new(hash)
            .map_err(|e| AppError::InternalError(format!("Invalid password hash: {}", e)))?;

        Argon2::default()
            .verify_password(password.as_bytes(), &parsed_hash)
            .map_err(|_| AppError::InvalidCredentials)?;

        Ok(())
    }

    fn generate_token(&self, user: &User) -> AppResult<String> {
        let expiration = Utc::now() + Duration::hours(self.jwt_expiration_hours);

        let claims = Claims {
            sub: user.id.to_string(),
            email: user.email.clone(),
            exp: expiration.timestamp(),
        };

        let token = encode(
            &Header::default(),
            &claims,
            &EncodingKey::from_secret(self.jwt_secret.as_bytes()),
        )
        .map_err(|e| AppError::InternalError(format!("Token generation failed: {}", e)))?;

        Ok(token)
    }

    fn validate_email(&self, email: &str) -> AppResult<()> {
        if email.is_empty() || !email.contains('@') {
            return Err(AppError::ValidationError("Invalid email format".to_string()));
        }
        Ok(())
    }

    fn validate_password(&self, ```

**Explanation of `thiserror` benefits:**

1. **Automatic `Display` implementation**: The `#[error("...")]` attribute generates the `Display` trait automatically

2. **Automatic conversions**: The `#[from]` attribute generates `From` implementations, so you can use `?` to convert between error types

3. **Less boilerplate**: Instead of manually implementing `Display`, `Error`, and `From`, you get it all with derive macros

4. **Clear error messages**: Error messages are defined right next to the variants

### Best Practice #7: Dependency Injection Pattern

```rust
// Define traits for dependencies to enable testing and flexibility

use async_trait::async_trait;

/// Trait for user repository operations
#[async_trait]
pub trait UserRepository: Send + Sync {
    async fn find_by_email(&self, email: &str) -> Result<Option<User>, DatabaseError>;
    async fn create(&self, user: CreateUser) -> Result<User, DatabaseError>;
    async fn update(&self, id: Uuid, user: UpdateUser) -> Result<User, DatabaseError>;
}

/// Postgres implementation
pub struct PostgresUserRepository {
    pool: PgPool,
}

#[async_trait]
impl UserRepository for PostgresUserRepository {
    async fn find_by_email(&self, email: &str) -> Result<Option<User>, DatabaseError> {
        sqlx::query_as::<_, User>("SELECT * FROM users WHERE email = $1")
            .bind(email)
            .fetch_optional(&self.pool)
            .await
            .map_err(DatabaseError::from)
    }

    async fn create(&self, user: CreateUser) -> Result<User, DatabaseError> {
        // Implementation...
        unimplemented!()
    }

    async fn update(&self, id: Uuid, user: UpdateUser) -> Result<User, DatabaseError> {
        // Implementation...
        unimplemented!()
    }
}

/// Service that depends on the repository trait, not concrete implementation
pub struct UserService<R: UserRepository> {
    repository: R,
}

impl<R: UserRepository> UserService<R> {
    pub fn new(repository: R) -> Self {
        Self { repository }
    }

    pub async fn get_user_by_email(&self, email: &str) -> Result<Option<User>, DatabaseError> {
        self.repository.find_by_email(email).await
    }
}

// For testing, create a mock implementation:
pub struct MockUserRepository {
    users: std::sync::Mutex<Vec<User>>,
}

#[async_trait]
impl UserRepository for MockUserRepository {
    async fn find_by_email(&self, email: &str) -> Result<Option<User>, DatabaseError> {
        let users = self.users.lock().unwrap();
        Ok(users.iter().find(|u| u.email == email).cloned())
    }

    async fn create(&self, user: CreateUser) -> Result<User, DatabaseError> {
        let mut users = self.users.lock().unwrap();
        let new_user = User {
            id: Uuid::new_v4(),
            email: user.email,
            name: user.name,
            password_hash: "hashed".to_string(),
            created_at: chrono::Utc::now(),
            updated_at: chrono::Utc::now(),
        };
        users.push(new_user.clone());
        Ok(new_user)
    }

    async fn update(&self, id: Uuid, user: UpdateUser) -> Result<User, DatabaseError> {
        // Mock implementation...
        unimplemented!()
    }
}

// Usage in tests:
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_get_user_by_email() {
        let mock_repo = MockUserRepository {
            users: std::sync::Mutex::new(vec![
                User {
                    id: Uuid::new_v4(),
                    email: "test@example.com".to_string(),
                    name: "Test User".to_string(),
                    password_hash: "hash".to_string(),
                    created_at: chrono::Utc::now(),
                    updated_at: chrono::Utc::now(),
                }
            ]),
        };

        let service = UserService::new(mock_repo);
        let user = service.get_user_by_email("test@example.com").await.unwrap();

        assert!(user.is_some());
        assert_eq!(user.unwrap().email, "test@example.com");
    }
}
````

**Why dependency injection?**

1. **Testability**: You can inject mock implementations for testing without touching the database

2. **Flexibility**: Easy to swap implementations (Postgres → MongoDB, for example)

3. **Separation of concerns**: Business logic doesn't depend on specific infrastructure

### Best Practice #8: Configuration with Environment-Specific Defaults

```rust
use serde::Deserialize;
use std::env;

#[derive(Debug, Clone, Deserialize)]
pub struct AppConfig {
    #[serde(default = "default_environment")]
    pub environment: Environment,

    pub database: DatabaseConfig,
    pub server: ServerConfig,
    pub auth: AuthConfig,

    #[serde(default)]
    pub features: FeatureFlags,
}

#[derive(Debug, Clone, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum Environment {
    Development,
    Staging,
    Production,
}

fn default_environment() -> Environment {
    Environment::Development
}

#[derive(Debug, Clone, Deserialize)]
pub struct DatabaseConfig {
    pub url: String,

    #[serde(default = "default_max_connections")]
    pub max_connections: u32,

    #[serde(default = "default_connection_timeout")]
    pub connection_timeout_seconds: u64,
}

fn default_max_connections() -> u32 {
    match env::var("ENVIRONMENT").as_deref() {
        Ok("production") => 20,
        Ok("staging") => 10,
        _ => 5,
    }
}

fn default_connection_timeout() -> u64 {
    30
}

#[derive(Debug, Clone, Deserialize)]
pub struct ServerConfig {
    #[serde(default = "default_host")]
    pub host: String,

    #[serde(default = "default_port")]
    pub port: u16,

    #[serde(default = "default_request_timeout")]
    pub request_timeout_seconds: u64,
}

fn default_host() -> String {
    "0.0.0.0".to_string()
}

fn default_port() -> u16 {
    match env::var("ENVIRONMENT").as_deref() {
        Ok("production") => 8080,
        _ => 3000,
    }
}

fn default_request_timeout() -> u64 {
    30
}

#[derive(Debug, Clone, Deserialize)]
pub struct AuthConfig {
    pub jwt_secret: String,

    #[serde(default = "default_jwt_expiration")]
    pub jwt_expiration_hours: i64,

    #[serde(default = "default_bcrypt_cost")]
    pub bcrypt_cost: u32,
}

fn default_jwt_expiration() -> i64 {
    24
}

fn default_bcrypt_cost() -> u32 {
    match env::var("ENVIRONMENT").as_deref() {
        Ok("production") => 12,
        _ => 8, // Lower cost for faster tests in dev
    }
}

#[derive(Debug, Clone, Deserialize, Default)]
pub struct FeatureFlags {
    #[serde(default)]
    pub enable_registration: bool,

    #[serde(default)]
    pub enable_password_reset: bool,

    #[serde(default)]
    pub enable_rate_limiting: bool,
}

impl AppConfig {
    /// Load configuration from environment variables or config file
    pub fn load() -> Result<Self, config::ConfigError> {
        let environment = env::var("ENVIRONMENT")
            .unwrap_or_else(|_| "development".to_string());

        let config = config::Config::builder()
            // Start with default values
            .set_default("environment", environment.clone())?

            // Load environment-specific config file if it exists
            .add_source(
                config::File::with_name(&format!("config/{}", environment))
                    .required(false)
            )

            // Override with environment variables prefixed with APP_
            // Example: APP_DATABASE__URL becomes database.url
            .add_source(
                config::Environment::with_prefix("APP")
                    .separator("__")
            )
            .build()?;

        config.try_deserialize()
    }

    /// Validate configuration
    pub fn validate(&self) -> Result<(), String> {
        // Validate JWT secret length
        if self.auth.jwt_secret.len() < 32 {
            return Err("JWT secret must be at least 32 characters".to_string());
        }

        // Validate database URL format
        if !self.database.url.starts_with("postgres://") &&
           !self.database.url.starts_with("postgresql://") {
            return Err("Database URL must be a PostgreSQL connection string".to_string());
        }

        // Production-specific validations
        if self.environment == Environment::Production {
            if self.auth.bcrypt_cost < 10 {
                return Err("Bcrypt cost must be at least 10 in production".to_string());
            }

            if !self.features.enable_rate_limiting {
                return Err("Rate limiting must be enabled in production".to_string());
            }
        }

        Ok(())
    }
}
```

**Configuration management strategy:**

1. **Layered configuration**: Defaults → config files → environment variables (in that priority)

2. **Environment-aware defaults**: Different defaults for development vs production

3. **Validation**: Explicit validation with environment-specific rules

4. **Feature flags**: Enable/disable features without code changes

5. **Type safety**: All configuration is strongly typed

### Best Practice #9: Structured Logging with Context

```rust
use tracing::{info, warn, error, instrument};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

/// Initialize logging with appropriate settings
pub fn init_logging(environment: &str) {
    let log_level = match environment {
        "production" => "info",
        "staging" => "debug",
        _ => "debug",
    };

    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| log_level.into())
        )
        .with(tracing_subscriber::fmt::layer().json())
        .init();
}

/// Example service with instrumented methods
pub struct OrderService {
    repository: Box<dyn OrderRepository>,
}

impl OrderService {
    /// The #[instrument] macro automatically logs function entry/exit
    /// and includes parameters in the log context
    #[instrument(skip(self), fields(user_id = %user_id))]
    pub async fn create_order(
        &self,
        user_id: Uuid,
        items: Vec<OrderItem>,
    ) -> Result<Order, OrderError> {
        info!(item_count = items.len(), "Creating order");

        // Validate items
        if items.is_empty() {
            warn!("Attempted to create order with no items");
            return Err(OrderError::EmptyOrder);
        }

        // Calculate total
        let total: f64 = items.iter().map(|item| item.price * item.quantity as f64).sum();
        info!(total = %total, "Order total calculated");

        // Create order
        match self.repository.create(user_id, items).await {
            Ok(order) => {
                info!(order_id = %order.id, "Order created successfully");
                Ok(order)
            }
            Err(e) => {
                error!(error = %e, "Failed to create order");
                Err(OrderError::DatabaseError(e))
            }
        }
    }

    #[instrument(skip(self))]
    pub async fn process_payment(
        &self,
        order_id: Uuid,
        payment_method: PaymentMethod,
    ) -> Result<Payment, PaymentError> {
        info!("Processing payment");

        // Add payment method to log context
        let _span = tracing::info_span!("payment_processing",
            method = ?payment_method
        ).entered();

        // Simulate payment processing
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

        info!("Payment processed successfully");

        Ok(Payment {
            id: Uuid::new_v4(),
            order_id,
            amount: 99.99,
            status: PaymentStatus::Completed,
        })
    }
}
```

**Structured logging benefits:**

1. **Automatic context**: `#[instrument]` adds function parameters to logs

2. **Searchable logs**: JSON format makes logs easily searchable in log aggregation systems

3. **Performance**: Logs are only formatted if they're actually emitted (based on log level)

4. **Correlation**: Request IDs and user IDs in context help trace requests through the system

### Best Practice #10: Graceful Shutdown

```rust
use tokio::signal;
use std::sync::Arc;
use tokio::sync::Notify;

/// Graceful shutdown handler
pub async fn shutdown_signal(notify: Arc<Notify>) {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("Failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        signal::unix::signal(signal::unix::SignalKind::terminate())
            .expect("Failed to install SIGTERM handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => {
            tracing::info!("Received Ctrl+C signal");
        }
        _ = terminate => {
            tracing::info!("Received SIGTERM signal");
        }
    }

    // Notify all tasks to shutdown
    notify.notify_waiters();
}

/// Main application with graceful shutdown
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    init_logging("production");

    let config = AppConfig::load()?;
    let pool = create_database_pool(&config.database.url).await?;

    // Shared shutdown notifier
    let shutdown_notify = Arc::new(Notify::new());

    // Spawn background tasks
    let worker_handle = tokio::spawn(run_background_worker(
        pool.clone(),
        shutdown_notify.clone(),
    ));

    // Setup HTTP server
    let app = create_router(pool.clone());
    let addr = SocketAddr::from(([0, 0, 0, 0], config.server.port));
    let listener = tokio::net::TcpListener::bind(addr).await?;

    tracing::info!("Server starting on {}", addr);

    // Run server with graceful shutdown
    axum::serve(listener, app)
        .with_graceful_shutdown(shutdown_signal(shutdown_notify.clone()))
        .await?;

    tracing::info!("HTTP server stopped, waiting for background tasks");

    // Wait for background tasks to complete
    worker_handle.await?;

    // Close database connections
    pool.close().await;

    tracing::info!("Application shutdown complete");

    Ok(())
}

/// Background worker that respects shutdown signal
async fn run_background_worker(
    pool: PgPool,
    shutdown: Arc<Notify>,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(10));

    loop {
        tokio::select! {
            _ = interval.tick() => {
                // Process background tasks
                match process_pending_jobs(&pool).await {
                    Ok(count) => tracing::debug!(jobs_processed = count, "Background processing complete"),
                    Err(e) => tracing::error!(error = %e, "Background processing failed"),
                }
            }
            _ = shutdown.notified() => {
                tracing::info!("Background worker received shutdown signal");
                break;
            }
        }
    }

    tracing::info!("Background worker stopped");
    Ok(())
}

async fn process_pending_jobs(pool: &PgPool) -> Result<usize, sqlx::Error> {
    // Process jobs...
    Ok(0)
}
```

**Graceful shutdown strategy:**

1. **Signal handling**: Listen for Ctrl+C and SIGTERM

2. **HTTP server**: Stop accepting new connections but finish processing existing requests

3. **Background tasks**: Notify background workers to stop after completing current work

4. **Resource cleanup**: Close database connections and other resources

5. **Ordered shutdown**: Ensures no data loss or corrupted state

---

## Chapter 8: Real-World Production Patterns

### Pattern #1: Repository Pattern with Transactions

```rust
use sqlx::{PgPool, Postgres, Transaction};

/// Repository trait that supports both pooled connections and transactions
#[async_trait]
pub trait TaskRepository: Send + Sync {
    async fn create(&self, task: CreateTask) -> Result<Task, DatabaseError>;
    async fn find_by_id(&self, id: Uuid) -> Result<Option<Task>, DatabaseError>;
    async fn update(&self, id: Uuid, task: UpdateTask) -> Result<Task, DatabaseError>;
    async fn delete(&self, id: Uuid) -> Result<(), DatabaseError>;
}

/// Implementation that works with connection pool
pub struct PgTaskRepository {
    pool: PgPool,
}

impl PgTaskRepository {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }

    /// Begin a transaction for complex operations
    pub async fn begin_transaction(&self) -> Result<Transaction<'_, Postgres>, sqlx::Error> {
        self.pool.begin().await
    }
}

#[async_trait]
impl TaskRepository for PgTaskRepository {
    async fn create(&self, task: CreateTask) -> Result<Task, DatabaseError> {
        create_task_internal(&self.pool, task).await
    }

    async fn find_by_id(&self, id: Uuid) -> Result<Option<Task>, DatabaseError> {
        find_task_by_id_internal(&self.pool, id).await
    }

    async fn update(&self, id: Uuid, task: UpdateTask) -> Result<Task, DatabaseError> {
        update_task_internal(&self.pool, id, task).await
    }

    async fn delete(&self, id: Uuid) -> Result<(), DatabaseError> {
        delete_task_internal(&self.pool, id).await
    }
}

/// Internal functions that work with any executor (pool or transaction)
async fn create_task_internal<'e, E>(
    executor: E,
    task: CreateTask,
) -> Result<Task, DatabaseError>
where
    E: sqlx::Executor<'e, Database = Postgres>,
{
    sqlx::query_as::<_, Task>(
        "INSERT INTO tasks (id, user_id, title, description, completed, due_date, created_at, updated_at)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
         RETURNING *"
    )
    .bind(Uuid::new_v4())
    .bind(task.user_id)
    .bind(task.title)
    .bind(task.description)
    .bind(false)
    .bind(task.due_date)
    .bind(chrono::Utc::now())
    .bind(chrono::Utc::now())
    .fetch_one(executor)
    .await
    .map_err(DatabaseError::from)
}

async fn find_task_by_id_internal<'e, E>(
    executor: E,
    id: Uuid,
) -> Result<Option<Task>, DatabaseError>
where
    E: sqlx::Executor<'e, Database = Postgres>,
{
    sqlx::query_as::<_, Task>("SELECT * FROM tasks WHERE id = $1")
        .bind(id)
        .fetch_optional(executor)
        .await
        .map_err(DatabaseError::from)
}

// Similar implementations for update and delete...

async fn update_task_internal<'e, E>(
    executor: E,
    id: Uuid,
    task: UpdateTask,
) -> Result<Task, DatabaseError>
where
    E: sqlx::Executor<'e, Database = Postgres>,
{
    // Implementation...
    unimplemented!()
}

async fn delete_task_internal<'e, E>(
    executor: E,
    id: Uuid,
) -> Result<(), DatabaseError>
where
    E: sqlx::Executor<'e, Database = Postgres>,
{
    // Implementation...
    unimplemented!()
}

/// Service that uses transactions for complex operations
pub struct TaskService {
    repository: PgTaskRepository,
}

impl TaskService {
    /// Create a task and automatically assign it to a project
    /// Both operations happen in a transaction
    pub async fn create_task_in_project(
        &self,
        project_id: Uuid,
        task: CreateTask,
    ) -> Result<Task, ServiceError> {
        // Start transaction
        let mut tx = self.repository.begin_transaction().await?;

        // Create the task
        let created_task = create_task_internal(&mut *tx, task).await?;

        // Assign to project (using the same transaction)
        sqlx::query(
            "INSERT INTO project_tasks (project_id, task_id) VALUES ($1, $2)"
        )
        .bind(project_id)
        .bind(created_task.id)
        .execute(&mut *tx)
        .await?;

        // Commit transaction
        tx.commit().await?;

        Ok(created_task)
    }
}
```

**Transaction pattern benefits:**

1. **Atomicity**: Multiple operations succeed or fail together

2. **Consistency**: Database constraints are enforced across operations

3. **Flexibility**: Same repository functions work with pool or transaction

4. **Type safety**: `sqlx::Executor` trait allows generic implementation

### Pattern #2: Rate Limiting Middleware

```rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use std::time::{Duration, Instant};

/// Rate limiter state
#[derive(Clone)]
struct RateLimiterState {
    requests: HashMap<String, Vec<Instant>>,
}

/// Rate limiter with in-memory storage (use Redis in production)
#[derive(Clone)]
pub struct RateLimiter {
    state: Arc<RwLock<RateLimiterState>>,
    max_requests: usize,
    window: Duration,
}

impl RateLimiter {
    pub fn new(max_requests: usize, window: Duration) -> Self {
        Self {
            state: Arc::new(RwLock::new(RateLimiterState {
                requests: HashMap::new(),
            })),
            max_requests,
            window,
        }
    }

    /// Check if a request is allowed
    pub async fn check_rate_limit(&self, key: &str) -> bool {
        let now = Instant::now();
        let mut state = self.state.write().await;

        // Get or create request history for this key
        let requests = state.requests.entry(key.to_string()).or_insert_with(Vec::new);

        // Remove expired requests
        requests.retain(|&time| now.duration_since(time) < self.window);

        // Check if limit exceeded
        if requests.len() >= self.max_requests {
            return false;
        }

        // Record this request
        requests.push(now);
        true
    }
}

/// Rate limiting middleware
pub async fn rate_limit_middleware(
    State(rate_limiter): State<RateLimiter>,
    request: Request,
    next: Next,
) -> Result<Response, AppError> {
    // Extract identifier (IP address, user ID, API key, etc.)
    let identifier = extract_identifier(&request)?;

    // Check rate limit
    if !rate_limiter.check_rate_limit(&identifier).await {
        return Err(AppError::RateLimitExceeded);
    }

    Ok(next.run(request).await)
}

fn extract_identifier(request: &Request) -> Result<String, AppError> {
    // Try to get user ID from auth extension
    if let Some(auth_user) = request.extensions().get::<AuthUser>() {
        return Ok(auth_user.user_id.to_string());
    }

    // Fall back to IP address
    if let Some(ip) = request
        .headers()
        .get("X-Forwarded-For")
        .and_then(|h| h.to_str().ok())
    {
        return Ok(ip.to_string());
    }

    // Last resort: use a generic key
    Ok("anonymous".to_string())
}
```

### Pattern #3: Circuit Breaker for External Services

```rust
use std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};
use std::sync::Arc;
use std::time::{Duration, Instant};

/// Circuit breaker states
#[derive(Debug, Clone, Copy, PartialEq)]
enum CircuitState {
    Closed,      // Normal operation
    Open,        // Failing, reject requests
    HalfOpen,    // Testing if service recovered
}

/// Circuit breaker for protecting against cascading failures
pub struct CircuitBreaker {
    state: Arc<tokio::sync::RwLock<CircuitState>>,
    failure_count: Arc<AtomicUsize>,
    last_failure_time: Arc<tokio::sync::RwLock<Option<Instant>>>,
    failure_threshold: usize,
    timeout: Duration,
    half_open_timeout: Duration,
}

impl CircuitBreaker {
    pub fn new(failure_threshold: usize, timeout: Duration) -> Self {
        Self {
            state: Arc::new(tokio::sync::RwLock::new(CircuitState::Closed)),
            failure_count: Arc::new(AtomicUsize::new(0)),
            last_failure_time: Arc::new(tokio::sync::RwLock::new(None)),
            failure_threshold,
            timeout,
            half_open_timeout: Duration::from_secs(30),
        }
    }

    /// Execute a function with circuit breaker protection
    pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    where
        F: std::future::Future<Output = Result<T, E>>,
    {
        // Check current state
        let state = *self.state.read().await;

        match state {
            CircuitState::Open => {
                // Check if we should try half-open
                if let Some(last_failure) = *self.last_failure_time.read().await {
                    if last_failure.elapsed() >= self.half_open_timeout {
                        // Transition to half-open
                        *self.state.write().await = CircuitState::HalfOpen;
                        tracing::info!("Circuit breaker transitioning to half-open");
                    } else {
                        return Err(CircuitBreakerError::Open);
                    }
                }
            }
            CircuitState::HalfOpen => {
                tracing::debug!("Circuit breaker in half-open state, testing service");
            }
            CircuitState::Closed => {
                // Normal operation
            }
        }

        // Execute the function
        match f.await {
            Ok(result) => {
                // Success - reset failure count
                self.on_success().await;
                Ok(result)
            }
            Err(e) => {
                // Failure - increment count
                self.on_failure().await;
                Err(CircuitBreakerError::RequestFailed(e))
            }
        }
    }

    async fn on_success(&self) {
        let state = *self.state.read().await;

        if state == CircuitState::HalfOpen {
            // Service recovered, close circuit
            *self.state.write().await = CircuitState::Closed;
            self.failure_count.store(0, Ordering::SeqCst);
            tracing::info!("Circuit breaker closed - service recovered");
        } else if state == CircuitState::Closed {
            // Reset failure count on success
            self.failure_count.store(0, Ordering::SeqCst);
        }
    }

    async fn on_failure(&self) {
        let failures = self.failure_count.fetch_add(1, Ordering::SeqCst) + 1;

        if failures >= self.failure_threshold {
            *self.state.write().await = CircuitState::Open;
            *self.last_failure_time.write().await = Some(Instant::now());
            tracing::warn!(
                failures = failures,
                "Circuit breaker opened - too many failures"
            );
        }
    }
}

#[derive(Debug)]
pub enum CircuitBreakerError<E> {
    Open,
    RequestFailed(E),
}

/// Example: HTTP client with circuit breaker
pub struct ResilientHttpClient {
    client: reqwest::Client,
    circuit_breaker: CircuitBreaker,
}

impl ResilientHttpClient {
    pub fn new() -> Self {
        Self {
            client: reqwest::Client::new(),
            circuit_breaker: CircuitBreaker::new(5, Duration::from_secs(60)),
        }
    }

    pub async fn get(&self, url: &str) -> Result<String, CircuitBreakerError<reqwest::Error>> {
        self.circuit_breaker
            .call(async {
                self.client
                    .get(url)
                    .timeout(Duration::from_secs(5))
                    .send()
                    .await?
                    .text()
                    .await
            })
            .await
    }
}
```

**Circuit breaker benefits:**

1. **Prevents cascading failures**: When a service fails, stop calling it

2. **Automatic recovery**: Periodically tests if the service recovered

3. **Fast failures**: Don't wait for timeouts when service is known to be down

4. **System stability**: Prevents overwhelming failing services

---

## Summary

We've covered the complete Rust module and crate system:

1. **Module basics**: Organization, privacy, paths
2. **Crate types**: Libraries vs binaries
3. **File organization**: Splitting modules across files
4. **Library design**: Public APIs and private implementation
5. **Workspaces**: Multi-crate projects
6. **Backend patterns**: Real-world production code
7. **Best practices**: Testing, error handling, configuration
8. **Production patterns**: Transactions, rate limiting, circuit breakers

The key principles:

- **Privacy by default**: Explicit about what's public
- **Separation of concerns**: Modules organize by domain
- **Type safety**: Use the type system to prevent bugs
- **Testability**: Design for dependency injection
- **Error handling**: Comprehensive, typed errors
- **Production-ready**: Graceful shutdown, logging, monitoring

This architecture scales from small projects to large production systems!
