# Rust Error Handling: A Comprehensive Guide

## Chapter 1: The Philosophy of Rust Error Handling

Rust takes a fundamentally different approach to error handling compared to many other programming languages. Instead of using exceptions like Java, Python, or JavaScript, Rust embraces **explicit error handling** through its type system. This design philosophy stems from Rust's core principle: making errors visible, predictable, and impossible to ignore accidentally.

### Why Rust Chose This Path

In languages with exceptions, errors can propagate invisibly through your program. A function might throw an exception, but there's no way to know this from its signature. You might forget to catch it, leading to crashes in production. Rust's creators wanted to eliminate this entire class of problems.

Rust's solution is elegant: **errors are values**. When a function can fail, it returns a special type that forces you to acknowledge that failure is possible. You cannot accidentally ignore an error because the type system won't let you compile your code until you've handled it.

### The Two Categories of Errors

Rust distinguishes between two fundamental types of problems:

**1. Recoverable Errors**: These are problems your program can potentially handle and continue running. Examples include:

- A file not being found
- Network connection failures
- Invalid user input
- Database query failures

**2. Unrecoverable Errors**: These are bugs in your program that indicate something fundamentally wrong. Examples include:

- Array index out of bounds
- Assertion failures
- Situations that should "never happen"

For recoverable errors, Rust uses the `Result<T, E>` type. For unrecoverable errors, Rust uses the `panic!` macro, which stops program execution immediately.

## Chapter 2: The Result Type - Foundation of Error Handling

### Understanding Result<T, E>

The `Result` type is an enum defined in Rust's standard library. Let's understand its structure deeply before seeing it in action:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

This definition tells us several important things:

- `Result` is a generic type with two type parameters
- `T` represents the type of the value returned on success
- `E` represents the type of the error returned on failure
- `Ok` variant wraps a successful value
- `Err` variant wraps an error value

The beauty of this design is that a function returning `Result<String, io::Error>` explicitly declares: "I will either give you a String, or I will give you an io::Error explaining what went wrong." There's no ambiguity, no hidden behavior.

### Basic Result Usage

Let's start with a simple example that demonstrates the fundamental pattern. Imagine we're building a system that needs to read configuration values:

```rust
use std::num::ParseIntError;

// This function attempts to parse a string into a number
// It returns Result because parsing can fail
fn parse_port(port_str: &str) -> Result<u16, ParseIntError> {
    // The parse() method itself returns a Result
    // We simply return that Result to our caller
    port_str.parse::<u16>()
}

fn main() {
    // Example 1: Successful parsing
    let valid_port = "8080";
    let result = parse_port(valid_port);

    // We must handle both possibilities
    match result {
        Ok(port) => println!("Successfully parsed port: {}", port),
        Err(e) => println!("Failed to parse port: {}", e),
    }

    // Example 2: Failed parsing
    let invalid_port = "not_a_number";
    match parse_port(invalid_port) {
        Ok(port) => println!("Port: {}", port),
        Err(e) => println!("Error: {} is not a valid port number", e),
    }
}
```

**Explanation**: In this example, `parse_port` wraps the standard library's `parse()` method. The `parse()` method returns `Result<u16, ParseIntError>` because parsing a string into a number can fail in multiple ways (invalid characters, number too large, empty string, etc.). The `ParseIntError` type contains detailed information about what went wrong.

### Manual Error Creation

Sometimes you need to create your own error conditions. Here's how to construct `Result` values manually:

```rust
fn divide(numerator: f64, denominator: f64) -> Result<f64, String> {
    if denominator == 0.0 {
        // We create an Err variant with our error message
        Err(String::from("Cannot divide by zero"))
    } else {
        // We create an Ok variant with the successful result
        Ok(numerator / denominator)
    }
}

fn main() {
    // Test valid division
    match divide(10.0, 2.0) {
        Ok(result) => println!("10 / 2 = {}", result),
        Err(e) => println!("Error: {}", e),
    }

    // Test division by zero
    match divide(10.0, 0.0) {
        Ok(result) => println!("Result: {}", result),
        Err(e) => println!("Error: {}", e),
    }
}
```

**Explanation**: Here we manually construct `Result` values. When the denominator is zero, we return `Err(String::from("Cannot divide by zero"))`. The `String::from()` creates a heap-allocated string containing our error message. For valid operations, we return `Ok(numerator / denominator)`, wrapping the successful computation.

## Chapter 3: Pattern Matching for Error Handling

### The Match Expression

Pattern matching is the most fundamental way to handle `Result` values. It forces you to consider both success and failure cases explicitly:

```rust
use std::fs::File;
use std::io::Read;

fn read_username_from_file(filename: &str) -> Result<String, std::io::Error> {
    // Attempt to open the file
    let file_result = File::open(filename);

    // Handle the result of opening the file
    let mut file = match file_result {
        Ok(file) => file,
        Err(e) => return Err(e), // If opening fails, return the error immediately
    };

    // If we got here, the file opened successfully
    let mut username = String::new();

    // Attempt to read the file contents
    match file.read_to_string(&mut username) {
        Ok(_) => Ok(username), // Success: return the username
        Err(e) => Err(e),      // Failure: return the error
    }
}

fn main() {
    match read_username_from_file("username.txt") {
        Ok(username) => println!("Username: {}", username),
        Err(e) => println!("Failed to read username: {}", e),
    }
}
```

**Explanation**: This example demonstrates nested error handling. First, we attempt to open a file using `File::open()`, which returns `Result<File, std::io::Error>`. We use a `match` expression to handle this. If opening succeeds, we extract the `File` and continue. If it fails, we immediately return that error to our caller using `return Err(e)`.

Then, we attempt to read the file contents. Again, we use `match` to handle success or failure. This pattern is explicit but verbose, which is why Rust provides more convenient operators.

### The if-let Pattern

When you only care about the success case and want to ignore errors (or handle them simply), `if let` provides a more concise syntax:

```rust
fn try_parse_config(config_str: &str) -> Option<i32> {
    // if let extracts the value only if parsing succeeds
    if let Ok(value) = config_str.parse::<i32>() {
        // This block only executes on success
        println!("Parsed configuration value: {}", value);
        Some(value)
    } else {
        // This block handles all failure cases
        println!("Failed to parse configuration, using default");
        None
    }
}

fn main() {
    try_parse_config("42");
    try_parse_config("invalid");
}
```

**Explanation**: The `if let Ok(value) = ...` pattern attempts to match the `Ok` variant. If the match succeeds, it extracts the inner value into the `value` variable and executes the if block. If the result is `Err`, the match fails and the else block executes. This is more readable when you don't need to handle the specific error, just detect failure.

## Chapter 4: The Question Mark Operator (?)

### Understanding the ? Operator

The question mark operator `?` is Rust's most powerful error handling feature. It provides a concise way to propagate errors up the call stack. Let's understand what it does:

When you append `?` to a `Result` value:

1. If the value is `Ok(v)`, it extracts `v` and continues execution
2. If the value is `Err(e)`, it immediately returns `Err(e)` from the current function

This might sound simple, but it's transformative. Let's rewrite our earlier file-reading example:

```rust
use std::fs::File;
use std::io::{self, Read};

// Without ? operator (verbose version)
fn read_username_verbose(filename: &str) -> Result<String, io::Error> {
    let file_result = File::open(filename);
    let mut file = match file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut username = String::new();
    match file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}

// With ? operator (concise version)
fn read_username_concise(filename: &str) -> Result<String, io::Error> {
    let mut file = File::open(filename)?;  // ? handles the error
    let mut username = String::new();
    file.read_to_string(&mut username)?;   // ? handles the error again
    Ok(username)
}

fn main() {
    match read_username_concise("username.txt") {
        Ok(name) => println!("Username: {}", name),
        Err(e) => println!("Error: {}", e),
    }
}
```

**Explanation**: In `read_username_verbose`, we manually check each operation with `match` and return errors explicitly. In `read_username_concise`, the `?` operator does this automatically. When we write `File::open(filename)?`, if the open operation fails, the function immediately returns that error. If it succeeds, the `File` is extracted and assigned to `file`.

### Chaining with the ? Operator

The real power of `?` becomes apparent when chaining multiple fallible operations:

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_and_process_file(filename: &str) -> Result<String, io::Error> {
    // Each ? propagates errors automatically
    let mut file = File::open(filename)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;

    // We can continue with more operations
    let processed = contents.to_uppercase();
    Ok(processed)
}

// We can even chain operations more elegantly
fn read_and_process_elegant(filename: &str) -> Result<String, io::Error> {
    let mut contents = String::new();
    File::open(filename)?.read_to_string(&mut contents)?;
    Ok(contents.to_uppercase())
}

fn main() {
    match read_and_process_elegant("data.txt") {
        Ok(data) => println!("Processed data: {}", data),
        Err(e) => println!("Error processing file: {}", e),
    }
}
```

**Explanation**: Notice how we chain operations in `read_and_process_elegant`. The expression `File::open(filename)?` returns a `File` if successful, and we immediately call `.read_to_string()` on it, then apply `?` again. This creates a clean, linear flow while maintaining robust error handling.

## Chapter 5: The Option Type and Error Handling

### Understanding Option<T>

While `Result` handles operations that can fail with an error, `Option` handles situations where a value might simply be absent:

```rust
enum Option<T> {
    Some(T),
    None,
}
```

**Explanation**: `Option<T>` is used when something might not exist, but there's no specific error to report. For example, finding an item in a list might yield `Some(item)` if found or `None` if not found. There's no error here—the item simply doesn't exist.

### Option in Practice

Let's see how `Option` differs from `Result` in real scenarios:

```rust
struct User {
    name: String,
    email: String,
    age: Option<u32>,  // Age is optional
    phone: Option<String>,  // Phone is optional
}

fn find_user_by_email(users: &[User], email: &str) -> Option<&User> {
    // Searching returns Option because the user might not exist
    for user in users {
        if user.email == email {
            return Some(user);
        }
    }
    None  // User not found
}

fn get_user_age(user: &User) -> Option<u32> {
    // Simply return the optional age field
    user.age
}

fn main() {
    let users = vec![
        User {
            name: String::from("Alice"),
            email: String::from("alice@example.com"),
            age: Some(30),
            phone: None,
        },
        User {
            name: String::from("Bob"),
            email: String::from("bob@example.com"),
            age: None,
            phone: Some(String::from("555-1234")),
        },
    ];

    // Using match with Option
    match find_user_by_email(&users, "alice@example.com") {
        Some(user) => {
            println!("Found user: {}", user.name);

            // Nested Option handling
            match user.age {
                Some(age) => println!("Age: {}", age),
                None => println!("Age not provided"),
            }
        }
        None => println!("User not found"),
    }
}
```

**Explanation**: In this example, `age` and `phone` are `Option` fields because not all users might provide this information. The `find_user_by_email` function returns `Option<&User>` because the search might not find a matching user. This is different from an error—the absence of a user is a valid state, not an exceptional condition.

### Converting Between Option and Result

Rust provides methods to convert between `Option` and `Result`, which is useful when you need to add error context:

```rust
fn parse_config_value(key: &str, config: &std::collections::HashMap<String, String>)
    -> Result<i32, String> {
    // Step 1: Get the value (returns Option)
    let value = config.get(key);

    // Step 2: Convert None to an error with ok_or
    let value_str = value.ok_or(format!("Missing configuration key: {}", key))?;

    // Step 3: Parse the value
    value_str.parse::<i32>()
        .map_err(|e| format!("Invalid number for {}: {}", key, e))
}

fn main() {
    let mut config = std::collections::HashMap::new();
    config.insert(String::from("port"), String::from("8080"));
    config.insert(String::from("timeout"), String::from("not_a_number"));

    // Successful case
    match parse_config_value("port", &config) {
        Ok(port) => println!("Port: {}", port),
        Err(e) => println!("Error: {}", e),
    }

    // Missing key case
    match parse_config_value("missing", &config) {
        Ok(val) => println!("Value: {}", val),
        Err(e) => println!("Error: {}", e),
    }

    // Parse error case
    match parse_config_value("timeout", &config) {
        Ok(val) => println!("Timeout: {}", val),
        Err(e) => println!("Error: {}", e),
    }
}
```

**Explanation**: The `ok_or` method converts `Option<T>` into `Result<T, E>`. If the Option is `Some(value)`, it becomes `Ok(value)`. If it's `None`, it becomes `Err(e)` with the error you provide. This is extremely useful because `HashMap::get()` returns `Option`, but we want to return `Result` with a meaningful error message.

The `map_err` method transforms the error type. When parsing fails, we get a `ParseIntError`, but we convert it into a `String` with additional context about which configuration key failed.

## Chapter 6: Custom Error Types

### Why Custom Error Types Matter

As your application grows, using `String` for errors becomes limiting. You need structured error types that can:

- Provide specific error information
- Allow programmatic error handling
- Support error conversion and composition
- Include helpful debugging information

### Creating Simple Custom Errors

Let's build a custom error type for a user registration system:

```rust
use std::fmt;

// Define our custom error type
#[derive(Debug)]
enum RegistrationError {
    UsernameTooShort,
    UsernameTooLong,
    InvalidEmail,
    PasswordTooWeak,
    UsernameAlreadyExists,
}

// Implement Display trait for user-friendly error messages
impl fmt::Display for RegistrationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            RegistrationError::UsernameTooShort =>
                write!(f, "Username must be at least 3 characters"),
            RegistrationError::UsernameTooLong =>
                write!(f, "Username must be at most 20 characters"),
            RegistrationError::InvalidEmail =>
                write!(f, "Email address is not valid"),
            RegistrationError::PasswordTooWeak =>
                write!(f, "Password must be at least 8 characters with numbers and letters"),
            RegistrationError::UsernameAlreadyExists =>
                write!(f, "This username is already taken"),
        }
    }
}

// Implement the Error trait
impl std::error::Error for RegistrationError {}

// Our registration function using the custom error
fn validate_username(username: &str) -> Result<(), RegistrationError> {
    if username.len() < 3 {
        return Err(RegistrationError::UsernameTooShort);
    }
    if username.len() > 20 {
        return Err(RegistrationError::UsernameTooLong);
    }
    Ok(())
}

fn validate_email(email: &str) -> Result<(), RegistrationError> {
    if !email.contains('@') || !email.contains('.') {
        return Err(RegistrationError::InvalidEmail);
    }
    Ok(())
}

fn validate_password(password: &str) -> Result<(), RegistrationError> {
    if password.len() < 8 {
        return Err(RegistrationError::PasswordTooWeak);
    }
    if !password.chars().any(|c| c.is_numeric()) {
        return Err(RegistrationError::PasswordTooWeak);
    }
    Ok(())
}

fn register_user(username: &str, email: &str, password: &str)
    -> Result<String, RegistrationError> {
    // Validate each field using ?
    validate_username(username)?;
    validate_email(email)?;
    validate_password(password)?;

    // If all validations pass, create the user
    Ok(format!("User {} registered successfully", username))
}

fn main() {
    // Test various registration attempts
    let test_cases = vec![
        ("ab", "test@example.com", "password123"),
        ("validuser", "invalid-email", "password123"),
        ("validuser", "test@example.com", "short"),
        ("validuser", "test@example.com", "validpass123"),
    ];

    for (username, email, password) in test_cases {
        match register_user(username, email, password) {
            Ok(msg) => println!("✓ {}", msg),
            Err(e) => println!("✗ Registration failed: {}", e),
        }
    }
}
```

**Explanation**: We define `RegistrationError` as an enum with variants for each possible validation failure. By implementing `Display`, we provide user-friendly error messages. Implementing `std::error::Error` makes our type compatible with Rust's error handling ecosystem.

The `validate_*` functions return `Result<(), RegistrationError>`. The `()` (unit type) indicates success with no return value—we only care about whether validation passed or failed. In `register_user`, we use `?` to propagate any validation error immediately.

### Errors with Data

Sometimes errors need to carry additional information:

```rust
use std::fmt;

#[derive(Debug)]
enum PaymentError {
    InsufficientFunds {
        required: f64,
        available: f64
    },
    InvalidAmount {
        amount: f64,
        reason: String
    },
    CardDeclined {
        card_last_four: String,
        decline_code: String
    },
    NetworkError {
        attempt: u32,
        max_attempts: u32
    },
}

impl fmt::Display for PaymentError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            PaymentError::InsufficientFunds { required, available } => {
                write!(f, "Insufficient funds: need ${:.2}, have ${:.2}",
                       required, available)
            }
            PaymentError::InvalidAmount { amount, reason } => {
                write!(f, "Invalid amount ${:.2}: {}", amount, reason)
            }
            PaymentError::CardDeclined { card_last_four, decline_code } => {
                write!(f, "Card ending in {} declined: code {}",
                       card_last_four, decline_code)
            }
            PaymentError::NetworkError { attempt, max_attempts } => {
                write!(f, "Network error (attempt {}/{})", attempt, max_attempts)
            }
        }
    }
}

impl std::error::Error for PaymentError {}

struct Account {
    balance: f64,
}

fn process_payment(account: &mut Account, amount: f64) -> Result<String, PaymentError> {
    // Validate amount is positive
    if amount <= 0.0 {
        return Err(PaymentError::InvalidAmount {
            amount,
            reason: String::from("Amount must be positive"),
        });
    }

    // Check if amount is suspiciously large
    if amount > 10000.0 {
        return Err(PaymentError::InvalidAmount {
            amount,
            reason: String::from("Amount exceeds single transaction limit"),
        });
    }

    // Check sufficient funds
    if account.balance < amount {
        return Err(PaymentError::InsufficientFunds {
            required: amount,
            available: account.balance,
        });
    }

    // Process the payment
    account.balance -= amount;
    Ok(format!("Payment of ${:.2} processed successfully. New balance: ${:.2}",
               amount, account.balance))
}

fn main() {
    let mut account = Account { balance: 500.0 };

    // Test various payment scenarios
    println!("Initial balance: ${:.2}", account.balance);

    match process_payment(&mut account, 200.0) {
        Ok(msg) => println!("✓ {}", msg),
        Err(e) => println!("✗ {}", e),
    }

    match process_payment(&mut account, 400.0) {
        Ok(msg) => println!("✓ {}", msg),
        Err(e) => println!("✗ {}", e),
    }

    match process_payment(&mut account, -50.0) {
        Ok(msg) => println!("✓ {}", msg),
        Err(e) => println!("✗ {}", e),
    }
}
```

**Explanation**: This example shows enum variants carrying structured data. `InsufficientFunds` stores both the required and available amounts, allowing the caller to programmatically handle the error (perhaps offering to charge a different card for the difference). The error messages automatically include the relevant data, making debugging easier.

## Chapter 7: Error Composition and the From Trait

### The Problem of Multiple Error Types

Real applications deal with errors from multiple sources: file I/O, network operations, parsing, database queries, etc. Each library defines its own error types. How do you handle them all together?

### The From Trait for Error Conversion

Rust's `From` trait enables automatic error conversion. When you use `?`, Rust automatically converts errors using `From` implementations:

```rust
use std::fs::File;
use std::io::{self, Read};
use std::num::ParseIntError;
use std::fmt;

// Our application-specific error type
#[derive(Debug)]
enum AppError {
    Io(io::Error),
    Parse(ParseIntError),
    Custom(String),
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::Io(err) => write!(f, "IO error: {}", err),
            AppError::Parse(err) => write!(f, "Parse error: {}", err),
            AppError::Custom(msg) => write!(f, "Application error: {}", msg),
        }
    }
}

impl std::error::Error for AppError {}

// Implement From to convert io::Error into AppError
impl From<io::Error> for AppError {
    fn from(error: io::Error) -> Self {
        AppError::Io(error)
    }
}

// Implement From to convert ParseIntError into AppError
impl From<ParseIntError> for AppError {
    fn from(error: ParseIntError) -> Self {
        AppError::Parse(error)
    }
}

// Now we can use ? with different error types seamlessly
fn read_number_from_file(filename: &str) -> Result<i32, AppError> {
    let mut file = File::open(filename)?;  // io::Error automatically converts to AppError
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;   // io::Error automatically converts to AppError

    let number = contents.trim().parse::<i32>()?;  // ParseIntError automatically converts

    if number < 0 {
        // We can also create custom errors
        return Err(AppError::Custom(String::from("Number must be positive")));
    }

    Ok(number)
}

fn main() {
    match read_number_from_file("number.txt") {
        Ok(num) => println!("Read number: {}", num),
        Err(e) => println!("Error: {}", e),
    }
}
```

**Explanation**: The `From<io::Error>` and `From<ParseIntError>` implementations tell Rust how to convert these errors into `AppError`. When we use `?` on an operation that returns `io::Error`, Rust automatically calls `From::from(io_error)` to convert it into `AppError`. This allows `read_number_from_file` to use `?` with multiple error types while returning a single unified error type.

### Using the thiserror Crate

Manually implementing error types is tedious. The `thiserror` crate automates this:

```rust
use thiserror::Error;
use std::io;
use std::num::ParseIntError;

#[derive(Error, Debug)]
enum DataError {
    #[error("IO error: {0}")]
    Io(#[from] io::Error),

    #[error("Parse error: {0}")]
    Parse(#[from] ParseIntError),

    #[error("Invalid data: {0}")]
    Validation(String),

    #[error("Data not found: {key}")]
    NotFound { key: String },

    #[error("Configuration error: {source}")]
    Config {
        source: ConfigError,
        #[source]
        backtrace: std::backtrace::Backtrace,
    },
}

#[derive(Error, Debug)]
#[error("Invalid configuration: {message}")]
struct ConfigError {
    message: String,
}

fn process_data_file(filename: &str) -> Result<Vec<i32>, DataError> {
    let content = std::fs::read_to_string(filename)?;  // Auto-converts io::Error

    let mut numbers = Vec::new();
    for line in content.lines() {
        if line.is_empty() {
            continue;
        }

        let number = line.trim().parse::<i32>()?;  // Auto-converts ParseIntError

        if number < 0 || number > 1000 {
            return Err(DataError::Validation(
                format!("Number {} out of valid range 0-1000", number)
            ));
        }

        numbers.push(number);
    }

    if numbers.is_empty() {
        return Err(DataError::NotFound {
            key: filename.to_string(),
        });
    }

    Ok(numbers)
}

fn main() {
    match process_data_file("data.txt") {
        Ok(numbers) => println!("Processed {} numbers", numbers.len()),
        Err(e) => {
            println!("Error: {}", e);
            // We can also inspect the error programmatically
            match e {
                DataError::Validation(msg) => println!("Validation failed: {}", msg),
                DataError::NotFound { key } => println!("File not found: {}", key),
                _ => println!("Other error occurred"),
            }
        }
    }
}
```

**Explanation**: The `#[derive(Error)]` macro automatically implements `Display` and `std::error::Error`. The `#[error("...")]` attribute defines the display message. The `#[from]` attribute automatically implements `From` for error conversion. This dramatically reduces boilerplate while providing rich error types.

## Chapter 8: Advanced Error Handling Patterns

### The unwrap and expect Methods

For cases where you're absolutely certain an operation won't fail, or during prototyping, Rust provides `unwrap` and `expect`:

```rust
fn main() {
    // unwrap: panics with a generic message if Result is Err
    let config = "42";
    let number = config.parse::<i32>().unwrap();  // Will panic if parsing fails
    println!("Number: {}", number);

    // expect: panics with your custom message if Result is Err
    let important_config = "100";
    let value = important_config.parse::<i32>()
        .expect("Critical: Failed to parse configuration value");
    println!("Value: {}", value);

    // DANGER: This will crash your program
    // let bad = "not_a_number".parse::<i32>().unwrap();
}
```

**Explanation**: `unwrap()` is useful when you're prototyping or when a failure represents a bug in your code. However, it should be used sparingly in production code. `expect()` is slightly better because it lets you provide context about why you expected the operation to succeed. Both methods will panic if the `Result` is `Err`, terminating your program.

**When to use unwrap/expect**:

- During initial development and prototyping
- In tests where failure is acceptable
- When dealing with operations that provably can't fail (like parsing a hardcoded valid string)
- Never in production code where error recovery is possible

### The unwrap_or and unwrap_or_else Methods

These methods provide fallback values instead of panicking:

```rust
use std::env;

fn get_config_with_default() {
    // unwrap_or: provides a default value if Result is Err
    let port = env::var("PORT")
        .unwrap_or(String::from("8080"));
    println!("Server will run on port: {}", port);

    // unwrap_or_else: computes default value lazily using a closure
    let timeout = env::var("TIMEOUT")
        .unwrap_or_else(|_| {
            println!("TIMEOUT not set, using default");
            String::from("30")
        });
    println!("Timeout: {} seconds", timeout);

    // Combining with parsing
    let max_connections = env::var("MAX_CONNECTIONS")
        .unwrap_or_else(|_| String::from("100"))
        .parse::<i32>()
        .unwrap_or(100);  // Fallback if parsing fails too
    println!("Max connections: {}", max_connections);
}

fn main() {
    get_config_with_default();
}
```

**Explanation**: `unwrap_or()` is perfect when you have a simple default value. If the `Result` is `Ok(value)`, it returns `value`. If it's `Err`, it returns your default. `unwrap_or_else()` takes a closure that's only executed if the `Result` is an `Err`, which is more efficient when computing the default is expensive.

In the last example, we chain error handling. First, we try to get the environment variable (which might fail). If that succeeds, we parse it (which might also fail). Each step has its own fallback strategy.

### The and_then Method for Chaining Operations

When you have a sequence of operations where each depends on the previous one's success, `and_then` provides elegant chaining:

```rust
use std::fs;
use std::path::Path;

fn read_and_validate_config(filename: &str) -> Result<i32, String> {
    // Read the file
    fs::read_to_string(filename)
        .map_err(|e| format!("Failed to read file: {}", e))
        // If successful, parse the contents
        .and_then(|contents| {
            contents.trim().parse::<i32>()
                .map_err(|e| format!("Failed to parse config: {}", e))
        })
        // If successful, validate the value
        .and_then(|value| {
            if value >= 1 && value <= 65535 {
                Ok(value)
            } else {
                Err(format!("Port {} out of valid range 1-65535", value))
            }
        })
}

fn process_user_input(input: &str) -> Result<String, String> {
    // Trim the input
    let trimmed = input.trim();

    // Check not empty
    if trimmed.is_empty() {
        return Err(String::from("Input cannot be empty"));
    }

    // Check length
    if trimmed.len() > 100 {
        return Err(String::from("Input too long (max 100 characters)"));
    }

    // Convert to uppercase
    Ok(trimmed.to_uppercase())
}

fn main() {
    // Test config reading
    match read_and_validate_config("port.txt") {
        Ok(port) => println!("Valid port: {}", port),
        Err(e) => println!("Config error: {}", e),
    }

    // Test chaining with and_then
    let result = process_user_input("  hello world  ")
        .and_then(|processed| {
            // Further processing based on the result
            if processed.len() > 5 {
                Ok(format!("Long input: {}", processed))
            } else {
                Ok(format!("Short input: {}", processed))
            }
        });

    match result {
        Ok(msg) => println!("✓ {}", msg),
        Err(e) => println!("✗ {}", e),
    }
}
```

**Explanation**: `and_then` is like `map`, but for when your transformation function also returns a `Result`. In `read_and_validate_config`, we create a pipeline: read file → parse contents → validate value. Each step only executes if the previous step succeeded. If any step fails, the error propagates and subsequent steps are skipped.

The `map_err` method transforms error types, which is useful when you want to add context or convert between error types in a chain.

### Collecting Results

When working with iterators and collections, you often need to process multiple items that can each fail:

```rust
fn parse_numbers(strings: Vec<&str>) -> Result<Vec<i32>, String> {
    // collect() can gather Results into a Result<Vec<_>>
    strings.into_iter()
        .map(|s| s.parse::<i32>().map_err(|e| format!("Failed to parse '{}': {}", s, e)))
        .collect()  // Converts Iterator<Result<i32, String>> to Result<Vec<i32>, String>
}

fn validate_all_emails(emails: Vec<&str>) -> Result<Vec<String>, String> {
    emails.into_iter()
        .map(|email| {
            if email.contains('@') && email.contains('.') {
                Ok(email.to_lowercase())
            } else {
                Err(format!("Invalid email: {}", email))
            }
        })
        .collect()  // Stops at first error
}

fn process_files(filenames: Vec<&str>) -> Result<Vec<String>, std::io::Error> {
    // If any file read fails, the entire operation fails
    filenames.into_iter()
        .map(|filename| std::fs::read_to_string(filename))
        .collect()
}

fn main() {
    // Example 1: All succeed
    let valid_numbers = vec!["1", "2", "3", "4", "5"];
    match parse_numbers(valid_numbers) {
        Ok(numbers) => println!("Parsed numbers: {:?}", numbers),
        Err(e) => println!("Error: {}", e),
    }

    // Example 2: One fails
    let mixed_numbers = vec!["1", "2", "invalid", "4"];
    match parse_numbers(mixed_numbers) {
        Ok(numbers) => println!("Parsed numbers: {:?}", numbers),
        Err(e) => println!("Error: {}", e),  // Stops at first error
    }

    // Example 3: Email validation
    let emails = vec!["alice@example.com", "bob@test.org", "invalid-email"];
    match validate_all_emails(emails) {
        Ok(emails) => println!("Valid emails: {:?}", emails),
        Err(e) => println!("Error: {}", e),
    }
}
```

**Explanation**: The magic happens in `collect()`. When you have an `Iterator<Item = Result<T, E>>`, calling `collect::<Result<Vec<T>, E>>()` performs a transformation: if all Results are `Ok`, you get `Ok(Vec<T>)` containing all the values. If any Result is `Err`, you get `Err` with the first error encountered, and processing stops immediately.

This is extremely powerful for validation scenarios where you want "all or nothing" semantics—either all operations succeed and you get all results, or one fails and you get that error.

### Partition for Separating Success and Failure

Sometimes you want to process all items and separate successes from failures:

```rust
fn process_with_partition(inputs: Vec<&str>) -> (Vec<i32>, Vec<String>) {
    let results: Vec<Result<i32, String>> = inputs.into_iter()
        .map(|s| {
            s.parse::<i32>()
                .map_err(|_| format!("Could not parse: {}", s))
        })
        .collect();

    // Separate successful parses from failures
    let (successes, failures): (Vec<_>, Vec<_>) = results.into_iter()
        .partition(Result::is_ok);

    let numbers: Vec<i32> = successes.into_iter()
        .map(Result::unwrap)  // Safe because we know they're Ok
        .collect();

    let errors: Vec<String> = failures.into_iter()
        .map(Result::unwrap_err)  // Safe because we know they're Err
        .collect();

    (numbers, errors)
}

fn main() {
    let mixed_input = vec!["42", "not_a_number", "100", "invalid", "256"];
    let (numbers, errors) = process_with_partition(mixed_input);

    println!("Successfully parsed {} numbers: {:?}", numbers.len(), numbers);
    println!("Failed to parse {} items:", errors.len());
    for error in errors {
        println!("  - {}", error);
    }
}
```

**Explanation**: Unlike `collect()` which stops at the first error, `partition()` processes all items and separates them based on a condition. Here we use `Result::is_ok` as the condition. This gives us both successful results and all errors, which is useful for batch processing where you want to report all problems rather than just the first one.

## Chapter 9: Error Handling Best Practices

### Best Practice 1: Use Result for Recoverable Errors

Never use panic for situations your program should handle gracefully:

```rust
// ❌ BAD: Using panic for expected error conditions
fn get_user_age_bad(age_str: &str) -> i32 {
    age_str.parse::<i32>().unwrap()  // Will crash on invalid input!
}

// ✅ GOOD: Returning Result for expected failures
fn get_user_age_good(age_str: &str) -> Result<i32, String> {
    age_str.parse::<i32>()
        .map_err(|_| String::from("Please enter a valid age"))
        .and_then(|age| {
            if age >= 0 && age <= 150 {
                Ok(age)
            } else {
                Err(String::from("Age must be between 0 and 150"))
            }
        })
}

fn main() {
    // The bad version would crash here
    // get_user_age_bad("not_a_number");  // CRASH!

    // The good version handles errors gracefully
    match get_user_age_good("not_a_number") {
        Ok(age) => println!("Age: {}", age),
        Err(e) => println!("Error: {}", e),
    }

    match get_user_age_good("200") {
        Ok(age) => println!("Age: {}", age),
        Err(e) => println!("Error: {}", e),
    }

    match get_user_age_good("25") {
        Ok(age) => println!("Age: {}", age),
        Err(e) => println!("Error: {}", e),
    }
}
```

**Explanation**: The key principle is: if a user could trigger the error through normal interaction, use `Result`. Panics should only be used for programmer errors (bugs) or truly unrecoverable situations. Invalid user input is not a reason to crash—it's an opportunity to provide helpful feedback.

### Best Practice 2: Provide Context in Errors

Error messages should help users understand what went wrong and how to fix it:

```rust
use std::fs;
use std::io;
use std::path::Path;

// ❌ BAD: Generic error messages
fn read_config_bad(filename: &str) -> Result<String, io::Error> {
    fs::read_to_string(filename)  // Error message won't mention config or filename
}

// ✅ GOOD: Adding context to errors
fn read_config_good(filename: &str) -> Result<String, String> {
    fs::read_to_string(filename)
        .map_err(|e| format!(
            "Failed to read configuration file '{}': {}. \
             Please ensure the file exists and you have read permissions.",
            filename, e
        ))
}

// ✅ EVEN BETTER: Structured errors with context
#[derive(Debug)]
struct ConfigError {
    filename: String,
    operation: String,
    source: io::Error,
}

impl std::fmt::Display for ConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "Failed to {} config file '{}': {}",
               self.operation, self.filename, self.source)
    }
}

impl std::error::Error for ConfigError {}

fn read_config_best(filename: &str) -> Result<String, ConfigError> {
    fs::read_to_string(filename)
        .map_err(|e| ConfigError {
            filename: filename.to_string(),
            operation: String::from("read"),
            source: e,
        })
}

fn main() {
    match read_config_good("nonexistent.toml") {
        Ok(config) => println!("Config: {}", config),
        Err(e) => eprintln!("Error: {}", e),
    }

    match read_config_best("missing.toml") {
        Ok(config) => println!("Config: {}", config),
        Err(e) => {
            eprintln!("Error: {}", e);
            eprintln!("  File: {}", e.filename);
            eprintln!("  Operation: {}", e.operation);
            eprintln!("  Cause: {}", e.source);
        }
    }
}
```

**Explanation**: The first version just returns the raw `io::Error`, which might say "No such file or directory" but won't mention which file or why we were trying to read it. The second version adds context explaining this was a configuration file and what file was involved. The third version uses a structured error type that preserves both the context and the original error, enabling programmatic error handling while also providing great error messages.

### Best Practice 3: Use the ? Operator Liberally

The `?` operator makes error handling code cleaner and more maintainable:

```rust
use std::fs;
use std::io;

// ❌ BAD: Manual error propagation is verbose and error-prone
fn process_file_bad(filename: &str) -> Result<String, io::Error> {
    let contents = match fs::read_to_string(filename) {
        Ok(c) => c,
        Err(e) => return Err(e),
    };

    let trimmed = contents.trim();

    let uppercase = trimmed.to_uppercase();

    Ok(uppercase)
}

// ✅ GOOD: Using ? operator for clean error propagation
fn process_file_good(filename: &str) -> Result<String, io::Error> {
    let contents = fs::read_to_string(filename)?;
    let trimmed = contents.trim();
    let uppercase = trimmed.to_uppercase();
    Ok(uppercase)
}

// ✅ EVEN BETTER: Chaining operations
fn process_file_best(filename: &str) -> Result<String, io::Error> {
    Ok(fs::read_to_string(filename)?
        .trim()
        .to_uppercase())
}

fn main() {
    match process_file_best("test.txt") {
        Ok(result) => println!("Processed: {}", result),
        Err(e) => eprintln!("Error: {}", e),
    }
}
```

**Explanation**: The manual error propagation in the first version is repetitive and obscures the happy path logic. The `?` operator eliminates this boilerplate, making the code's intent crystal clear. The third version goes further by chaining operations together. Always prefer `?` over manual `match` when simply propagating errors.

### Best Practice 4: Create Domain-Specific Error Types

As your application grows, create error types that match your domain:

```rust
use std::fmt;

// Domain: E-commerce order processing
#[derive(Debug)]
enum OrderError {
    InvalidQuantity { product_id: String, quantity: i32 },
    OutOfStock { product_id: String, requested: i32, available: i32 },
    InvalidPrice { product_id: String, price: f64 },
    PaymentFailed { reason: String },
    ShippingAddressInvalid { field: String, value: String },
    CustomerNotFound { customer_id: String },
}

impl fmt::Display for OrderError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            OrderError::InvalidQuantity { product_id, quantity } =>
                write!(f, "Invalid quantity {} for product {}", quantity, product_id),
            OrderError::OutOfStock { product_id, requested, available } =>
                write!(f, "Product {} out of stock: requested {}, available {}",
                       product_id, requested, available),
            OrderError::InvalidPrice { product_id, price } =>
                write!(f, "Invalid price ${:.2} for product {}", price, product_id),
            OrderError::PaymentFailed { reason } =>
                write!(f, "Payment failed: {}", reason),
            OrderError::ShippingAddressInvalid { field, value } =>
                write!(f, "Invalid shipping address: {} = '{}'", field, value),
            OrderError::CustomerNotFound { customer_id } =>
                write!(f, "Customer not found: {}", customer_id),
        }
    }
}

impl std::error::Error for OrderError {}

struct Order {
    customer_id: String,
    product_id: String,
    quantity: i32,
    price: f64,
}

struct Inventory {
    available_stock: i32,
}

fn validate_order(order: &Order, inventory: &Inventory) -> Result<(), OrderError> {
    // Validate quantity
    if order.quantity <= 0 {
        return Err(OrderError::InvalidQuantity {
            product_id: order.product_id.clone(),
            quantity: order.quantity,
        });
    }

    // Check stock availability
    if order.quantity > inventory.available_stock {
        return Err(OrderError::OutOfStock {
            product_id: order.product_id.clone(),
            requested: order.quantity,
            available: inventory.available_stock,
        });
    }

    // Validate price
    if order.price < 0.0 {
        return Err(OrderError::InvalidPrice {
            product_id: order.product_id.clone(),
            price: order.price,
        });
    }

    Ok(())
}

fn process_order(order: Order, inventory: &Inventory) -> Result<String, OrderError> {
    validate_order(&order, inventory)?;

    // Simulate payment processing
    let payment_success = order.price > 0.0;
    if !payment_success {
        return Err(OrderError::PaymentFailed {
            reason: String::from("Payment gateway timeout"),
        });
    }

    Ok(format!("Order processed: {} units of product {}",
               order.quantity, order.product_id))
}

fn main() {
    let inventory = Inventory { available_stock: 10 };

    // Test valid order
    let valid_order = Order {
        customer_id: String::from("CUST123"),
        product_id: String::from("PROD456"),
        quantity: 5,
        price: 99.99,
    };

    match process_order(valid_order, &inventory) {
        Ok(msg) => println!("✓ {}", msg),
        Err(e) => eprintln!("✗ {}", e),
    }

    // Test out of stock
    let oversized_order = Order {
        customer_id: String::from("CUST123"),
        product_id: String::from("PROD456"),
        quantity: 15,
        price: 99.99,
    };

    match process_order(oversized_order, &inventory) {
        Ok(msg) => println!("✓ {}", msg),
        Err(e) => {
            eprintln!("✗ {}", e);
            // We can handle specific errors programmatically
            if let OrderError::OutOfStock { product_id, requested, available } = e {
                eprintln!("  Suggestion: Try ordering {} units instead", available);
            }
        }
    }
}
```

**Explanation**: Domain-specific errors make your code self-documenting. Instead of generic error messages, `OrderError` variants clearly describe what can go wrong in the order processing domain. Each variant carries the exact data needed to understand and potentially recover from the error. This also enables sophisticated error handling where different errors trigger different recovery strategies.

### Best Practice 5: Log Errors Appropriately

Different errors require different logging levels:

```rust
// Note: This is a conceptual example showing logging patterns
// In real code, you'd use the `log` crate with a logging implementation

enum LogLevel {
    Debug,
    Info,
    Warning,
    Error,
}

fn log(level: LogLevel, message: &str) {
    let prefix = match level {
        LogLevel::Debug => "DEBUG",
        LogLevel::Info => "INFO",
        LogLevel::Warning => "WARN",
        LogLevel::Error => "ERROR",
    };
    eprintln!("[{}] {}", prefix, message);
}

#[derive(Debug)]
enum ApiError {
    DatabaseConnection(String),
    RecordNotFound(String),
    ValidationFailed(String),
    InternalError(String),
}

fn handle_api_request(user_id: &str) -> Result<String, ApiError> {
    // Simulate database connection issue (severe - should be logged as ERROR)
    if user_id == "trigger_db_error" {
        let err = ApiError::DatabaseConnection(String::from("Connection pool exhausted"));
        log(LogLevel::Error, &format!("Critical: {:?}", err));
        return Err(err);
    }

    // User not found (expected - log as INFO or DEBUG)
    if user_id == "nonexistent" {
        let err = ApiError::RecordNotFound(format!("User {} not found", user_id));
        log(LogLevel::Info, &format!("{:?}", err));
        return Err(err);
    }

    // Validation error (user error - log as WARNING)
    if user_id.len() < 5 {
        let err = ApiError::ValidationFailed(format!("User ID {} too short", user_id));
        log(LogLevel::Warning, &format!("{:?}", err));
        return Err(err);
    }

    Ok(format!("User data for {}", user_id))
}

fn main() {
    let test_cases = vec!["valid_user_12345", "trigger_db_error", "nonexistent", "short"];

    for user_id in test_cases {
        match handle_api_request(user_id) {
            Ok(data) => println!("Success: {}", data),
            Err(e) => println!("Request failed: {:?}", e),
        }
        println!();
    }
}
```

**Explanation**: Not all errors are equally important. Database connection failures are critical and should be logged as errors because they indicate system problems. User not found is an expected condition in normal operation, so it warrants only informational logging. Validation failures are user errors, not system problems, so they're logged as warnings. This distinction helps operations teams quickly identify real issues versus normal user behavior.

## Chapter 10: Real-World Backend Development

### Example 1: RESTful API Error Handling

In a real backend API, error handling must convert internal errors into appropriate HTTP responses:

```rust
use std::fmt;

// HTTP status codes
#[derive(Debug, Clone, Copy)]
enum StatusCode {
    Ok = 200,
    BadRequest = 400,
    NotFound = 404,
    InternalServerError = 500,
}

// Application-level errors
#[derive(Debug)]
enum ApiError {
    ValidationError { field: String, message: String },
    NotFound { resource: String, id: String },
    DatabaseError { operation: String, details: String },
    AuthenticationError { reason: String },
    InternalError { message: String },
}

impl fmt::Display for ApiError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ApiError::ValidationError { field, message } =>
                write!(f, "Validation error on field '{}': {}", field, message),
            ApiError::NotFound { resource, id } =>
                write!(f, "{} with id '{}' not found", resource, id),
            ApiError::DatabaseError { operation, details } =>
                write!(f, "Database error during {}: {}", operation, details),
            ApiError::AuthenticationError { reason } =>
                write!(f, "Authentication failed: {}", reason),
            ApiError::InternalError { message } =>
                write!(f, "Internal server error: {}", message),
        }
    }
}

impl std::error::Error for ApiError {}

// Convert ApiError to HTTP response
struct HttpResponse {
    status_code: StatusCode,
    body: String,
}

impl From<ApiError> for HttpResponse {
    fn from(error: ApiError) -> Self {
        let (status_code, body) = match error {
            ApiError::ValidationError { field, message } => {
                (StatusCode::BadRequest, format!("{{\"error\": \"validation_error\", \"field\": \"{}\", \"message\": \"{}\"}}", field, message))
            }
            ApiError::NotFound { resource, id } => {
                (StatusCode::NotFound, format!("{{\"error\": \"not_found\", \"resource\": \"{}\", \"id\": \"{}\"}}", resource, id))
            }
            ApiError::AuthenticationError { reason } => {
                (StatusCode::BadRequest, format!("{{\"error\": \"authentication_failed\", \"reason\": \"{}\"}}", reason))
            }
            ApiError::DatabaseError { .. } | ApiError::InternalError { .. } => {
                // Don't leak internal details to clients
                (StatusCode::InternalServerError, String::from("{\"error\": \"internal_server_error\", \"message\": \"An internal error occurred\"}"))
            }
        };

        HttpResponse { status_code, body }
    }
}

// Simulated database
struct Database;

impl Database {
    fn find_user(&self, user_id: &str) -> Result<User, ApiError> {
        // Simulate database lookup
        if user_id == "123" {
            Ok(User {
                id: user_id.to_string(),
                email: String::from("user@example.com"),
                name: String::from("John Doe"),
            })
        } else {
            Err(ApiError::NotFound {
                resource: String::from("User"),
                id: user_id.to_string(),
            })
        }
    }

    fn update_user(&self, user: &User) -> Result<(), ApiError> {
        // Simulate validation
        if user.email.is_empty() {
            return Err(ApiError::ValidationError {
                field: String::from("email"),
                message: String::from("Email cannot be empty"),
            });
        }

        if !user.email.contains('@') {
            return Err(ApiError::ValidationError {
                field: String::from("email"),
                message: String::from("Invalid email format"),
            });
        }

        // Simulate successful update
        Ok(())
    }
}

struct User {
    id: String,
    email: String,
    name: String,
}

// API endpoint handler
fn get_user_endpoint(user_id: &str, db: &Database) -> HttpResponse {
    match db.find_user(user_id) {
        Ok(user) => HttpResponse {
            status_code: StatusCode::Ok,
            body: format!("{{\"id\": \"{}\", \"email\": \"{}\", \"name\": \"{}\"}}",
                         user.id, user.email, user.name),
        },
        Err(e) => e.into(),  // Convert ApiError to HttpResponse
    }
}

fn update_user_endpoint(user_id: &str, new_email: &str, db: &Database) -> HttpResponse {
    // Chain of operations, each can fail
    let result = db.find_user(user_id)
        .and_then(|mut user| {
            user.email = new_email.to_string();
            db.update_user(&user)?;
            Ok(user)
        });

    match result {
        Ok(user) => HttpResponse {
            status_code: StatusCode::Ok,
            body: format!("{{\"message\": \"User updated\", \"email\": \"{}\"}}", user.email),
        },
        Err(e) => {
            // Log the error internally
            eprintln!("Error in update_user_endpoint: {}", e);
            e.into()  // Convert to HTTP response
        }
    }
}

fn main() {
    let db = Database;

    println!("=== GET /users/123 ===");
    let response = get_user_endpoint("123", &db);
    println!("Status: {:?}", response.status_code);
    println!("Body: {}\n", response.body);

    println!("=== GET /users/999 (not found) ===");
    let response = get_user_endpoint("999", &db);
    println!("Status: {:?}", response.status_code);
    println!("Body: {}\n", response.body);

    println!("=== PUT /users/123 (valid email) ===");
    let response = update_user_endpoint("123", "newemail@example.com", &db);
    println!("Status: {:?}", response.status_code);
    println!("Body: {}\n", response.body);

    println!("=== PUT /users/123 (invalid email) ===");
    let response = update_user_endpoint("123", "invalid-email", &db);
    println!("Status: {:?}", response.status_code);
    println!("Body: {}\n", response.body);
}
```

**Explanation**: This example demonstrates a complete error handling strategy for a REST API. We define application-level errors (`ApiError`) that represent business logic problems. Then we implement `From<ApiError> for HttpResponse` to convert these internal errors into appropriate HTTP responses with correct status codes and JSON bodies.

Notice how we don't expose internal error details (like database errors) to clients—we convert them to generic internal server errors. This prevents information leakage while still providing useful feedback for validation and not-found errors.

### Example 2: Database Layer with Connection Pooling

Real applications need robust database error handling:

````rust
use std::fmt;
use std::time::Duration;

#[derive(Debug)]
enum DatabaseError {
    ConnectionFailed { attempt: u32, reason: String },
    QueryFailed { query: String, error: String },
    Timeout { operation: String, duration: Duration },
    DeadlockDetected { retry_count: u32 },
    ConstraintViolation { constraint: String, details: String },
}

impl fmt::Display for DatabaseError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            DatabaseError::ConnectionFailed { attempt, reason } =>
                write!(f, "Database connection failed (attempt {}): {}", attempt, reason),
            DatabaseError::QueryFailed { query, error } =>
                write!(f, "Query failed: {} - Error: {}", query, error),
            DatabaseError::Timeout { operation, duration } =>
                write!(f, "Operation '{}' timed out after {:?}", operation, duration),
            DatabaseError::DeadlockDetected { retry_count } =>
                write!(f, "Deadlock detected (retry {})", retry_count),
            DatabaseError::ConstraintViolation { constraint, details } =>
                write!(f, "Constraint '{}' violated: {}", constraint, details),
        }
    }
}

impl std::error::Error for DatabaseError {}

// Simulated database connection
struct DbConnection {
    id: u32,
}

struct ConnectionPool {
    max_connections: u32,
    current_connections: u32,
}

impl ConnectionPool {
    fn new(max_connections: u32) -> Self {
        ConnectionPool {
            max_connections,
            current_connections: 0,
        }
    }

    fn get_connection(&mut self) -> Result<DbConnection, DatabaseError> {
        if self.current_connections >= self.max_connections {
            return Err(DatabaseError::ConnectionFailed {
                attempt: 1,
                reason: format!("Pool exhausted ({}/{})",
                               self.current_connections, self.max_connections),
            });
        }

        self.current_connections += 1;
        Ok(DbConnection { id: self.current_connections })
    }

    fn release_connection(&mut self, _conn: DbConnection) {
        self.current_connections -= 1;
    }
}
```rust
// Repository pattern with error handling
struct UserRepository {
    pool: ConnectionPool,
}

impl UserRepository {
    fn new(pool: ConnectionPool) -> Self {
        UserRepository { pool }
    }

    fn create_user(&mut self, email: &str, name: &str) -> Result<i32, DatabaseError> {
        // Get connection from pool
        let conn = self.pool.get_connection()?;

        // Simulate constraint validation
        if email.is_empty() {
            return Err(DatabaseError::ConstraintViolation {
                constraint: String::from("email_not_null"),
                details: String::from("Email cannot be empty"),
            });
        }

        // Simulate unique constraint check
        if email == "duplicate@example.com" {
            return Err(DatabaseError::ConstraintViolation {
                constraint: String::from("email_unique"),
                details: format!("Email '{}' already exists", email),
            });
        }

        // Simulate query execution
        println!("Executing: INSERT INTO users (email, name) VALUES ('{}', '{}')", email, name);

        // Release connection back to pool
        self.pool.release_connection(conn);

        // Return generated user ID
        Ok(42)
    }

    fn find_user_by_id(&mut self, user_id: i32) -> Result<Option<UserData>, DatabaseError> {
        let conn = self.pool.get_connection()?;

        // Simulate timeout on specific queries
        if user_id == 999 {
            return Err(DatabaseError::Timeout {
                operation: String::from("SELECT * FROM users WHERE id = 999"),
                duration: Duration::from_secs(30),
            });
        }

        // Simulate query execution
        let result = if user_id == 42 {
            Some(UserData {
                id: user_id,
                email: String::from("user@example.com"),
                name: String::from("John Doe"),
            })
        } else {
            None
        };

        self.pool.release_connection(conn);
        Ok(result)
    }

    fn update_user_with_retry(&mut self, user_id: i32, email: &str)
        -> Result<(), DatabaseError> {
        const MAX_RETRIES: u32 = 3;

        for retry_count in 0..MAX_RETRIES {
            let conn = match self.pool.get_connection() {
                Ok(c) => c,
                Err(e) => {
                    if retry_count < MAX_RETRIES - 1 {
                        eprintln!("Connection failed, retrying... (attempt {})", retry_count + 1);
                        std::thread::sleep(Duration::from_millis(100));
                        continue;
                    } else {
                        return Err(e);
                    }
                }
            };

            // Simulate deadlock detection
            if user_id == 100 && retry_count < 2 {
                self.pool.release_connection(conn);
                eprintln!("Deadlock detected, retrying... (attempt {})", retry_count + 1);
                std::thread::sleep(Duration::from_millis(50));
                continue;
            }

            // Execute update
            println!("Executing: UPDATE users SET email = '{}' WHERE id = {}", email, user_id);
            self.pool.release_connection(conn);
            return Ok(());
        }

        Err(DatabaseError::DeadlockDetected { retry_count: MAX_RETRIES })
    }
}

struct UserData {
    id: i32,
    email: String,
    name: String,
}

fn main() {
    let pool = ConnectionPool::new(5);
    let mut repo = UserRepository::new(pool);

    println!("=== Test 1: Create user successfully ===");
    match repo.create_user("alice@example.com", "Alice") {
        Ok(id) => println!("✓ User created with ID: {}\n", id),
        Err(e) => eprintln!("✗ Error: {}\n", e),
    }

    println!("=== Test 2: Constraint violation (duplicate email) ===");
    match repo.create_user("duplicate@example.com", "Bob") {
        Ok(id) => println!("✓ User created with ID: {}\n", id),
        Err(e) => eprintln!("✗ Error: {}\n", e),
    }

    println!("=== Test 3: Find existing user ===");
    match repo.find_user_by_id(42) {
        Ok(Some(user)) => println!("✓ Found user: {} ({})\n", user.name, user.email),
        Ok(None) => println!("User not found\n"),
        Err(e) => eprintln!("✗ Error: {}\n", e),
    }

    println!("=== Test 4: Query timeout ===");
    match repo.find_user_by_id(999) {
        Ok(Some(user)) => println!("✓ Found user: {}\n", user.name),
        Ok(None) => println!("User not found\n"),
        Err(e) => eprintln!("✗ Error: {}\n", e),
    }

    println!("=== Test 5: Update with deadlock retry ===");
    match repo.update_user_with_retry(100, "newemail@example.com") {
        Ok(()) => println!("✓ User updated successfully\n"),
        Err(e) => eprintln!("✗ Error: {}\n", e),
    }
}
````

**Explanation**: This example demonstrates enterprise-grade database error handling. The `ConnectionPool` manages database connections and handles pool exhaustion. The `UserRepository` uses the repository pattern to encapsulate database operations.

Key patterns shown:

- **Connection management**: Getting and releasing connections with error handling
- **Constraint violations**: Detecting and reporting database constraint errors
- **Retry logic**: Automatically retrying operations that fail due to transient issues like deadlocks
- **Timeout handling**: Detecting and reporting operations that take too long
- **Resource cleanup**: Always releasing connections back to the pool, even when errors occur

The `update_user_with_retry` method demonstrates a sophisticated retry strategy. It attempts the operation up to 3 times, sleeping between attempts to avoid overwhelming the database. This handles transient failures gracefully while still failing fast if the problem persists.

### Example 3: Microservice Communication with Error Propagation

In microservice architectures, errors need to propagate across service boundaries:

```rust
use std::fmt;
use std::time::Duration;

// Service A's errors
#[derive(Debug)]
enum ServiceAError {
    InvalidRequest(String),
    InternalError(String),
}

impl fmt::Display for ServiceAError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ServiceAError::InvalidRequest(msg) => write!(f, "Invalid request: {}", msg),
            ServiceAError::InternalError(msg) => write!(f, "Internal error: {}", msg),
        }
    }
}

impl std::error::Error for ServiceAError {}

// Service B's errors
#[derive(Debug)]
enum ServiceBError {
    NotFound(String),
    Timeout(Duration),
    ServiceUnavailable,
}

impl fmt::Display for ServiceBError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ServiceBError::NotFound(id) => write!(f, "Resource not found: {}", id),
            ServiceBError::Timeout(duration) => write!(f, "Request timed out after {:?}", duration),
            ServiceBError::ServiceUnavailable => write!(f, "Service temporarily unavailable"),
        }
    }
}

impl std::error::Error for ServiceBError {}

// Unified error type for the gateway/orchestrator
#[derive(Debug)]
enum GatewayError {
    ServiceA(ServiceAError),
    ServiceB(ServiceBError),
    MultipleServiceFailures(Vec<String>),
    CircuitBreakerOpen { service: String, failures: u32 },
}

impl fmt::Display for GatewayError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            GatewayError::ServiceA(e) => write!(f, "Service A error: {}", e),
            GatewayError::ServiceB(e) => write!(f, "Service B error: {}", e),
            GatewayError::MultipleServiceFailures(errors) => {
                write!(f, "Multiple services failed: {}", errors.join(", "))
            }
            GatewayError::CircuitBreakerOpen { service, failures } => {
                write!(f, "Circuit breaker open for {}: {} consecutive failures", service, failures)
            }
        }
    }
}

impl std::error::Error for GatewayError {}

// Convert service-specific errors to gateway errors
impl From<ServiceAError> for GatewayError {
    fn from(error: ServiceAError) -> Self {
        GatewayError::ServiceA(error)
    }
}

impl From<ServiceBError> for GatewayError {
    fn from(error: ServiceBError) -> Self {
        GatewayError::ServiceB(error)
    }
}

// Circuit breaker pattern
struct CircuitBreaker {
    failure_threshold: u32,
    failure_count: u32,
    state: CircuitState,
}

#[derive(Debug, PartialEq)]
enum CircuitState {
    Closed,  // Normal operation
    Open,    // Failing, reject requests
    HalfOpen, // Testing if service recovered
}

impl CircuitBreaker {
    fn new(failure_threshold: u32) -> Self {
        CircuitBreaker {
            failure_threshold,
            failure_count: 0,
            state: CircuitState::Closed,
        }
    }

    fn call<F, T, E>(&mut self, f: F) -> Result<T, GatewayError>
    where
        F: FnOnce() -> Result<T, E>,
        E: Into<GatewayError>,
    {
        if self.state == CircuitState::Open {
            return Err(GatewayError::CircuitBreakerOpen {
                service: String::from("downstream"),
                failures: self.failure_count,
            });
        }

        match f() {
            Ok(result) => {
                // Success - reset failure count
                self.failure_count = 0;
                self.state = CircuitState::Closed;
                Ok(result)
            }
            Err(e) => {
                // Failure - increment count and check threshold
                self.failure_count += 1;
                if self.failure_count >= self.failure_threshold {
                    self.state = CircuitState::Open;
                    eprintln!("Circuit breaker opened after {} failures", self.failure_count);
                }
                Err(e.into())
            }
        }
    }
}

// Service implementations
struct ServiceA;
struct ServiceB;

impl ServiceA {
    fn process_order(&self, order_id: &str) -> Result<String, ServiceAError> {
        if order_id.is_empty() {
            return Err(ServiceAError::InvalidRequest(
                String::from("Order ID cannot be empty")
            ));
        }

        if order_id == "error" {
            return Err(ServiceAError::InternalError(
                String::from("Failed to process order")
            ));
        }

        Ok(format!("Order {} processed", order_id))
    }
}

impl ServiceB {
    fn get_inventory(&self, product_id: &str) -> Result<i32, ServiceBError> {
        if product_id == "timeout" {
            return Err(ServiceBError::Timeout(Duration::from_secs(5)));
        }

        if product_id == "unavailable" {
            return Err(ServiceBError::ServiceUnavailable);
        }

        if product_id == "999" {
            return Err(ServiceBError::NotFound(product_id.to_string()));
        }

        Ok(100) // Available inventory
    }
}

// Gateway orchestrator
struct Gateway {
    service_a: ServiceA,
    service_b: ServiceB,
    circuit_breaker: CircuitBreaker,
}

impl Gateway {
    fn new() -> Self {
        Gateway {
            service_a: ServiceA,
            service_b: ServiceB,
            circuit_breaker: CircuitBreaker::new(3),
        }
    }

    fn create_order(&mut self, order_id: &str, product_id: &str)
        -> Result<String, GatewayError> {
        // Step 1: Check inventory (with circuit breaker)
        let inventory = self.circuit_breaker.call(|| {
            self.service_b.get_inventory(product_id)
        })?;

        println!("Inventory check passed: {} units available", inventory);

        // Step 2: Process order
        let result = self.service_a.process_order(order_id)?;

        Ok(format!("{}, Inventory: {}", result, inventory))
    }

    fn batch_create_orders(&mut self, orders: Vec<(&str, &str)>)
        -> Result<Vec<String>, GatewayError> {
        let mut results = Vec::new();
        let mut errors = Vec::new();

        for (order_id, product_id) in orders {
            match self.create_order(order_id, product_id) {
                Ok(result) => results.push(result),
                Err(e) => {
                    eprintln!("Order {} failed: {}", order_id, e);
                    errors.push(format!("Order {}: {}", order_id, e));
                }
            }
        }

        if errors.is_empty() {
            Ok(results)
        } else if results.is_empty() {
            // All failed
            Err(GatewayError::MultipleServiceFailures(errors))
        } else {
            // Partial success - in real app, might return both successes and failures
            Err(GatewayError::MultipleServiceFailures(errors))
        }
    }
}

fn main() {
    let mut gateway = Gateway::new();

    println!("=== Test 1: Successful order ===");
    match gateway.create_order("ORDER123", "PROD456") {
        Ok(result) => println!("✓ {}\n", result),
        Err(e) => eprintln!("✗ Error: {}\n", e),
    }

    println!("=== Test 2: Service A error (invalid request) ===");
    match gateway.create_order("", "PROD456") {
        Ok(result) => println!("✓ {}\n", result),
        Err(e) => eprintln!("✗ Error: {}\n", e),
    }

    println!("=== Test 3: Service B error (not found) ===");
    match gateway.create_order("ORDER124", "999") {
        Ok(result) => println!("✓ {}\n", result),
        Err(e) => eprintln!("✗ Error: {}\n", e),
    }

    println!("=== Test 4: Circuit breaker - multiple failures ===");
    for i in 1..=5 {
        println!("Attempt {}:", i);
        match gateway.create_order(&format!("ORDER{}", i), "unavailable") {
            Ok(result) => println!("✓ {}", result),
            Err(e) => eprintln!("✗ Error: {}", e),
        }
    }
    println!();

    println!("=== Test 5: Batch processing with partial failures ===");
    let orders = vec![
        ("ORDER201", "PROD1"),
        ("", "PROD2"),           // Will fail validation
        ("ORDER203", "999"),      // Will fail - not found
        ("ORDER204", "PROD4"),
    ];

    match gateway.batch_create_orders(orders) {
        Ok(results) => {
            println!("✓ All orders succeeded:");
            for result in results {
                println!("  - {}", result);
            }
        }
        Err(GatewayError::MultipleServiceFailures(errors)) => {
            eprintln!("✗ Some orders failed:");
            for error in errors {
                eprintln!("  - {}", error);
            }
        }
        Err(e) => eprintln!("✗ Error: {}", e),
    }
}
```

**Explanation**: This example shows error handling in a microservice architecture. The gateway service coordinates calls to multiple downstream services, each with their own error types.

Key patterns demonstrated:

- **Error conversion**: Using `From` trait to convert service-specific errors into a unified gateway error type
- **Circuit breaker**: Protecting against cascading failures by "opening the circuit" after repeated failures
- **Graceful degradation**: Continuing to process successful orders even when some fail
- **Error aggregation**: Collecting multiple errors from batch operations

The circuit breaker is crucial for resilience. After 3 consecutive failures, it stops sending requests to the failing service, giving it time to recover and preventing resource exhaustion. This pattern is essential in distributed systems.

### Example 4: Background Job Processing with Error Recovery

Background job systems need sophisticated error handling for retry logic and dead letter queues:

```rust
use std::fmt;
use std::time::{Duration, SystemTime};

#[derive(Debug, Clone)]
enum JobError {
    Transient { reason: String, retry_after: Duration },
    Permanent { reason: String },
    RateLimited { retry_after: Duration },
}

impl fmt::Display for JobError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            JobError::Transient { reason, retry_after } =>
                write!(f, "Transient error (retry after {:?}): {}", retry_after, reason),
            JobError::Permanent { reason } =>
                write!(f, "Permanent error: {}", reason),
            JobError::RateLimited { retry_after } =>
                write!(f, "Rate limited, retry after {:?}", retry_after),
        }
    }
}

impl std::error::Error for JobError {}

#[derive(Debug, Clone)]
struct Job {
    id: String,
    job_type: String,
    payload: String,
    attempts: u32,
    max_attempts: u32,
    created_at: SystemTime,
}

#[derive(Debug)]
enum JobStatus {
    Success,
    RetryScheduled { retry_at: SystemTime },
    Failed { reason: String },
    MovedToDeadLetter,
}

struct JobProcessor {
    retry_delays: Vec<Duration>,
}

impl JobProcessor {
    fn new() -> Self {
        JobProcessor {
            // Exponential backoff: 1s, 5s, 25s, 2min, 10min
            retry_delays: vec![
                Duration::from_secs(1),
                Duration::from_secs(5),
                Duration::from_secs(25),
                Duration::from_secs(120),
                Duration::from_secs(600),
            ],
        }
    }

    fn process_job(&self, job: &Job) -> Result<String, JobError> {
        println!("Processing job {} (attempt {}/{})", job.id, job.attempts + 1, job.max_attempts);

        // Simulate different job types and their potential failures
        match job.job_type.as_str() {
            "send_email" => self.send_email(&job.payload),
            "process_payment" => self.process_payment(&job.payload),
            "generate_report" => self.generate_report(&job.payload),
            _ => Err(JobError::Permanent {
                reason: format!("Unknown job type: {}", job.job_type),
            }),
        }
    }

    fn send_email(&self, payload: &str) -> Result<String, JobError> {
        if payload == "invalid_email" {
            // Permanent error - bad data
            return Err(JobError::Permanent {
                reason: String::from("Invalid email address format"),
            });
        }

        if payload == "smtp_down" {
            // Transient error - service temporarily unavailable
            return Err(JobError::Transient {
                reason: String::from("SMTP server unavailable"),
                retry_after: Duration::from_secs(60),
            });
        }

        if payload == "rate_limited" {
            return Err(JobError::RateLimited {
                retry_after: Duration::from_secs(300),
            });
        }

        Ok(format!("Email sent to: {}", payload))
    }

    fn process_payment(&self, payload: &str) -> Result<String, JobError> {
        if payload == "insufficient_funds" {
            // Permanent error - user needs to add funds
            return Err(JobError::Permanent {
                reason: String::from("Insufficient funds"),
            });
        }

        if payload == "gateway_timeout" {
            return Err(JobError::Transient {
                reason: String::from("Payment gateway timeout"),
                retry_after: Duration::from_secs(30),
            });
        }

        Ok(format!("Payment processed: {}", payload))
    }

    fn generate_report(&self, payload: &str) -> Result<String, JobError> {
        if payload == "database_locked" {
            return Err(JobError::Transient {
                reason: String::from("Database locked, retry later"),
                retry_after: Duration::from_secs(10),
            });
        }

        Ok(format!("Report generated: {}", payload))
    }

    fn handle_job(&self, mut job: Job) -> (Job, JobStatus) {
        match self.process_job(&job) {
            Ok(result) => {
                println!("✓ Job {} succeeded: {}", job.id, result);
                (job, JobStatus::Success)
            }
            Err(JobError::Permanent { reason }) => {
                eprintln!("✗ Job {} permanently failed: {}", job.id, reason);
                (job, JobStatus::Failed { reason })
            }
            Err(JobError::Transient { reason, retry_after }) |
            Err(JobError::RateLimited { retry_after }) => {
                job.attempts += 1;

                if job.attempts >= job.max_attempts {
                    eprintln!("✗ Job {} exceeded max attempts, moving to dead letter queue", job.id);
                    return (job, JobStatus::MovedToDeadLetter);
                }

                // Calculate retry delay using exponential backoff
                let delay = if let JobError::RateLimited { .. } = JobError::RateLimited { retry_after } {
                    retry_after
                } else {
                    self.retry_delays
                        .get(job.attempts as usize - 1)
                        .copied()
                        .unwrap_or(retry_after)
                };

                let retry_at = SystemTime::now() + delay;
                eprintln!("⟳ Job {} will retry in {:?} (attempt {}/{})",
                         job.id, delay, job.attempts, job.max_attempts);

                (job, JobStatus::RetryScheduled { retry_at })
            }
        }
    }
}

// Dead letter queue for permanently failed jobs
struct DeadLetterQueue {
    jobs: Vec<Job>,
}

impl DeadLetterQueue {
    fn new() -> Self {
        DeadLetterQueue { jobs: Vec::new() }
    }

    fn add(&mut self, job: Job) {
        println!("Adding job {} to dead letter queue", job.id);
        self.jobs.push(job);
    }

    fn list(&self) {
        println!("\n=== Dead Letter Queue ({} jobs) ===", self.jobs.len());
        for job in &self.jobs {
            println!("  Job {}: {} (attempts: {})", job.id, job.job_type, job.attempts);
        }
    }
}

fn main() {
    let processor = JobProcessor::new();
    let mut dead_letter_queue = DeadLetterQueue::new();

    // Test cases
    let test_jobs = vec![
        Job {
            id: String::from("job1"),
            job_type: String::from("send_email"),
            payload: String::from("user@example.com"),
            attempts: 0,
            max_attempts: 5,
            created_at: SystemTime::now(),
        },
        Job {
            id: String::from("job2"),
            job_type: String::from("send_email"),
            payload: String::from("invalid_email"),
            attempts: 0,
            max_attempts: 5,
            created_at: SystemTime::now(),
        },
        Job {
            id: String::from("job3"),
            job_type: String::from("process_payment"),
            payload: String::from("gateway_timeout"),
            attempts: 0,
            max_attempts: 3,
            created_at: SystemTime::now(),
        },
        Job {
            id: String::from("job4"),
            job_type: String::from("send_email"),
            payload: String::from("smtp_down"),
            attempts: 0,
            max_attempts: 2,
            created_at: SystemTime::now(),
        },
    ];

    for mut job in test_jobs {
        println!("\n--- Processing {} ---", job.id);

        // Simulate retry loop
        loop {
            let (updated_job, status) = processor.handle_job(job.clone());
            job = updated_job;

            match status {
                JobStatus::Success => break,
                JobStatus::Failed { .. } => break,
                JobStatus::MovedToDeadLetter => {
                    dead_letter_queue.add(job.clone());
                    break;
                }
                JobStatus::RetryScheduled { .. } => {
                    // In a real system, we'd schedule the retry
                    // For demo purposes, we'll immediately retry until max attempts
                    if job.attempts >= job.max_attempts {
                        dead_letter_queue.add(job.clone());
                        break;
                    }
                    continue;
                }
            }
        }
    }

    dead_letter_queue.list();
}
```

**Explanation**: This example demonstrates error handling in background job processing systems. Jobs can fail for various reasons, and we need to distinguish between errors that warrant retrying and those that don't.

Key concepts:

- **Error classification**: Transient errors (temporary issues) vs permanent errors (bad data or business logic failures)
- **Exponential backoff**: Increasing delay between retries to avoid overwhelming failing services
- **Max attempts**: Preventing infinite retry loops
- **Dead letter queue**: Storing jobs that exhausted all retries for manual investigation
- **Rate limiting**: Respecting external service limits by scheduling retries appropriately

The `JobError` enum categorizes failures, allowing the processor to make intelligent decisions about retry strategies. Permanent errors (like invalid email addresses) don't get retried. Transient errors (like network timeouts) trigger retries with increasing delays.

## Chapter 11: Testing Error Handling

### Writing Tests for Error Cases

Testing error paths is as important as testing happy paths:

```rust
#[derive(Debug, PartialEq)]
enum ValidationError {
    TooShort { min_length: usize, actual_length: usize },
    TooLong { max_length: usize, actual_length: usize },
    InvalidCharacter { character: char, position: usize },
}

fn validate_username(username: &str) -> Result<String, ValidationError> {
    const MIN_LENGTH: usize = 3;
    const MAX_LENGTH: usize = 20;

    let len = username.len();

    if len < MIN_LENGTH {
        return Err(ValidationError::TooShort {
            min_length: MIN_LENGTH,
            actual_length: len,
        });
    }

    if len > MAX_LENGTH {
        return Err(ValidationError::TooLong {
            max_length: MAX_LENGTH,
            actual_length: len,
        });
    }

    for (pos, ch) in username.chars().enumerate() {
        if !ch.is_alphanumeric() && ch != '_' {
            return Err(ValidationError::InvalidCharacter {
                character: ch,
                position: pos,
            });
        }
    }

    Ok(username.to_string())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_valid_username() {
        let result = validate_username("valid_user123");
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "valid_user123");
    }

    #[test]
    fn test_username_too_short() {
        let result = validate_username("ab");
        assert!(result.is_err());

        match result {
            Err(ValidationError::TooShort { min_length, actual_length }) => {
                assert_eq!(min_length, 3);
                assert_eq!(actual_length, 2);
            }
            _ => panic!("Expected TooShort error"),
        }
    }

    #[test]
    fn test_username_too_long() {
        let long_username = "a".repeat(25);
        let result = validate_username(&long_username);

        assert!(result.is_err());
        assert!(matches!(
            result,
            Err(ValidationError::TooLong { max_length: 20, actual_length: 25 })
        ));
    }

    #[test]
    fn test_invalid_character() {
        let result = validate_username("user@name");

        match result {
            Err(ValidationError::InvalidCharacter { character, position }) => {
                assert_eq!(character, '@');
                assert_eq!(position, 4);
            }
            _ => panic!("Expected InvalidCharacter error"),
        }
    }

    #[test]
    fn test_multiple_validation_scenarios() {
        let test_cases = vec![
            ("abc", true),
            ("ab", false),
            ("valid_user_123", true),
            ("invalid-user", false),
            ("user name", false),
        ];

        for (username, should_succeed) in test_cases {
            let result = validate_username(username);
            assert_eq!(
                result.is_ok(),
                should_succeed,
                "Username '{}' validation unexpected result",
                username
            );
        }
    }
}

fn main() {
    println!("Run tests with: cargo test");

    // Demonstration
    let test_usernames = vec!["valid_user", "ab", "user@name", "a".repeat(25).as_str()];

    for username in test_usernames {
        match validate_username(username) {
            Ok(validated) => println!("✓ '{}' is valid", validated),
            Err(e) => println!("✗ '{}' is invalid: {:?}", username, e),
        }
    }
}
```

**Explanation**: Testing error conditions requires asserting that functions return the expected error variant with correct data. The tests show several approaches:

- `assert!(result.is_err())` - Basic check that an error occurred
- Pattern matching to verify specific error variants and their data
- `matches!` macro for concise error variant checking
- Table-driven tests to cover multiple scenarios efficiently

Good error tests verify not just that an error occurred, but that it's the _right_ error with the _right_ information.

## Chapter 12: Summary and Final Best Practices

### The Complete Error Handling Strategy

After exploring Rust's error handling ecosystem in depth, let's consolidate everything into a comprehensive strategy:

**1. Choose the Right Error Type**

- Use `Result<T, E>` for recoverable errors
- Use `panic!` only for unrecoverable bugs or truly exceptional situations
- Use `Option<T>` when absence is a valid state (not an error)

**2. Design Errors Thoughtfully**

- Make errors specific to your domain
- Include contextual information in error variants
- Implement `Display` for user-friendly messages
- Implement `Error` trait for ecosystem compatibility

**3. Propagate Errors Efficiently**

- Use `?` operator for clean error propagation
- Implement `From` for automatic error conversion
- Use `map_err` to add context while propagating

**4. Handle Errors at the Right Level**

- Propagate errors up the call stack until you reach code that can meaningfully handle them
- Don't catch and re-throw without adding value
- Log errors appropriately based on severity

**5. Provide Recovery Mechanisms**

- Use retry logic for transient failures
- Implement circuit breakers for cascading failures
- Provide fallback values when appropriate

Let's look at a comprehensive real-world example that brings all these principles together:

```rust
use std::fmt;
use std::time::{Duration, SystemTime};

// ============================================================================
// SECTION 1: Domain-Specific Error Types
// ============================================================================

/// Errors that can occur in our e-commerce system
#[derive(Debug)]
enum EcommerceError {
    // Database errors
    Database(DatabaseError),

    // Payment processing errors
    Payment(PaymentError),

    // Inventory errors
    Inventory(InventoryError),

    // Validation errors
    Validation(ValidationError),

    // External service errors
    ExternalService { service: String, error: String },
}

#[derive(Debug)]
enum DatabaseError {
    ConnectionFailed { attempt: u32, max_attempts: u32 },
    QueryFailed { query: String, details: String },
    TransactionAborted { reason: String },
}

#[derive(Debug)]
enum PaymentError {
    InsufficientFunds { required: f64, available: f64 },
    PaymentGatewayTimeout { duration: Duration },
    InvalidPaymentMethod { reason: String },
    FraudDetected { risk_score: f64 },
}

#[derive(Debug)]
enum InventoryError {
    OutOfStock { product_id: String, requested: i32, available: i32 },
    ReservationFailed { product_id: String, reason: String },
}

#[derive(Debug)]
enum ValidationError {
    InvalidEmail { email: String },
    InvalidQuantity { quantity: i32, reason: String },
    PriceMismatch { expected: f64, provided: f64 },
}

// Implement Display for user-facing error messages
impl fmt::Display for EcommerceError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            EcommerceError::Database(e) => write!(f, "Database error: {}", e),
            EcommerceError::Payment(e) => write!(f, "Payment error: {}", e),
            EcommerceError::Inventory(e) => write!(f, "Inventory error: {}", e),
            EcommerceError::Validation(e) => write!(f, "Validation error: {}", e),
            EcommerceError::ExternalService { service, error } => {
                write!(f, "External service '{}' error: {}", service, error)
            }
        }
    }
}

impl fmt::Display for DatabaseError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            DatabaseError::ConnectionFailed { attempt, max_attempts } => {
                write!(f, "Failed to connect to database (attempt {}/{})", attempt, max_attempts)
            }
            DatabaseError::QueryFailed { query, details } => {
                write!(f, "Query failed: {} - {}", query, details)
            }
            DatabaseError::TransactionAborted { reason } => {
                write!(f, "Transaction aborted: {}", reason)
            }
        }
    }
}

impl fmt::Display for PaymentError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            PaymentError::InsufficientFunds { required, available } => {
                write!(f, "Insufficient funds: ${:.2} required, ${:.2} available", required, available)
            }
            PaymentError::PaymentGatewayTimeout { duration } => {
                write!(f, "Payment gateway timed out after {:?}", duration)
            }
            PaymentError::InvalidPaymentMethod { reason } => {
                write!(f, "Invalid payment method: {}", reason)
            }
            PaymentError::FraudDetected { risk_score } => {
                write!(f, "Potential fraud detected (risk score: {:.2})", risk_score)
            }
        }
    }
}

impl fmt::Display for InventoryError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            InventoryError::OutOfStock { product_id, requested, available } => {
                write!(f, "Product {} out of stock: {} requested, {} available",
                       product_id, requested, available)
            }
            InventoryError::ReservationFailed { product_id, reason } => {
                write!(f, "Failed to reserve product {}: {}", product_id, reason)
            }
        }
    }
}

impl fmt::Display for ValidationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ValidationError::InvalidEmail { email } => {
                write!(f, "Invalid email address: {}", email)
            }
            ValidationError::InvalidQuantity { quantity, reason } => {
                write!(f, "Invalid quantity {}: {}", quantity, reason)
            }
            ValidationError::PriceMismatch { expected, provided } => {
                write!(f, "Price mismatch: expected ${:.2}, provided ${:.2}", expected, provided)
            }
        }
    }
}

impl std::error::Error for EcommerceError {}
impl std::error::Error for DatabaseError {}
impl std::error::Error for PaymentError {}
impl std::error::Error for InventoryError {}
impl std::error::Error for ValidationError {}

// Implement From for automatic error conversion
impl From<DatabaseError> for EcommerceError {
    fn from(error: DatabaseError) -> Self {
        EcommerceError::Database(error)
    }
}

impl From<PaymentError> for EcommerceError {
    fn from(error: PaymentError) -> Self {
        EcommerceError::Payment(error)
    }
}

impl From<InventoryError> for EcommerceError {
    fn from(error: InventoryError) -> Self {
        EcommerceError::Inventory(error)
    }
}

impl From<ValidationError> for EcommerceError {
    fn from(error: ValidationError) -> Self {
        EcommerceError::Validation(error)
    }
}

// ============================================================================
// SECTION 2: Domain Models
// ============================================================================

#[derive(Debug, Clone)]
struct Product {
    id: String,
    name: String,
    price: f64,
    stock: i32,
}

#[derive(Debug, Clone)]
struct Customer {
    id: String,
    email: String,
    balance: f64,
}

#[derive(Debug)]
struct Order {
    id: String,
    customer_id: String,
    product_id: String,
    quantity: i32,
    total_price: f64,
    status: OrderStatus,
    created_at: SystemTime,
}

#[derive(Debug, PartialEq)]
enum OrderStatus {
    Pending,
    PaymentProcessed,
    Confirmed,
    Failed,
}

// ============================================================================
// SECTION 3: Repository Layer (Data Access with Error Handling)
// ============================================================================

struct ProductRepository {
    products: Vec<Product>,
}

impl ProductRepository {
    fn new() -> Self {
        ProductRepository {
            products: vec![
                Product {
                    id: String::from("PROD001"),
                    name: String::from("Laptop"),
                    price: 999.99,
                    stock: 5,
                },
                Product {
                    id: String::from("PROD002"),
                    name: String::from("Mouse"),
                    price: 29.99,
                    stock: 0,
                },
                Product {
                    id: String::from("PROD003"),
                    name: String::from("Keyboard"),
                    price: 79.99,
                    stock: 10,
                },
            ],
        }
    }

    fn find_by_id(&self, product_id: &str) -> Result<Product, DatabaseError> {
        // Simulate potential database errors
        if product_id == "DB_ERROR" {
            return Err(DatabaseError::QueryFailed {
                query: format!("SELECT * FROM products WHERE id = '{}'", product_id),
                details: String::from("Database connection lost"),
            });
        }

        self.products
            .iter()
            .find(|p| p.id == product_id)
            .cloned()
            .ok_or_else(|| DatabaseError::QueryFailed {
                query: format!("SELECT * FROM products WHERE id = '{}'", product_id),
                details: format!("Product {} not found", product_id),
            })
    }

    fn reserve_stock(&mut self, product_id: &str, quantity: i32)
        -> Result<(), InventoryError> {
        let product = self.products
            .iter_mut()
            .find(|p| p.id == product_id)
            .ok_or_else(|| InventoryError::ReservationFailed {
                product_id: product_id.to_string(),
                reason: String::from("Product not found"),
            })?;

        if product.stock < quantity {
            return Err(InventoryError::OutOfStock {
                product_id: product_id.to_string(),
                requested: quantity,
                available: product.stock,
            });
        }

        product.stock -= quantity;
        println!("Reserved {} units of {} (remaining stock: {})",
                 quantity, product.name, product.stock);
        Ok(())
    }
}

struct CustomerRepository {
    customers: Vec<Customer>,
}

impl CustomerRepository {
    fn new() -> Self {
        CustomerRepository {
            customers: vec![
                Customer {
                    id: String::from("CUST001"),
                    email: String::from("alice@example.com"),
                    balance: 5000.0,
                },
                Customer {
                    id: String::from("CUST002"),
                    email: String::from("bob@example.com"),
                    balance: 50.0,
                },
            ],
        }
    }

    fn find_by_id(&self, customer_id: &str) -> Result<Customer, DatabaseError> {
        self.customers
            .iter()
            .find(|c| c.id == customer_id)
            .cloned()
            .ok_or_else(|| DatabaseError::QueryFailed {
                query: format!("SELECT * FROM customers WHERE id = '{}'", customer_id),
                details: format!("Customer {} not found", customer_id),
            })
    }

    fn deduct_balance(&mut self, customer_id: &str, amount: f64)
        -> Result<(), PaymentError> {
        let customer = self.customers
            .iter_mut()
            .find(|c| c.id == customer_id)
            .ok_or_else(|| PaymentError::InvalidPaymentMethod {
                reason: String::from("Customer not found"),
            })?;

        if customer.balance < amount {
            return Err(PaymentError::InsufficientFunds {
                required: amount,
                available: customer.balance,
            });
        }

        customer.balance -= amount;
        println!("Deducted ${:.2} from customer {} (remaining balance: ${:.2})",
                 amount, customer_id, customer.balance);
        Ok(())
    }
}

// ============================================================================
// SECTION 4: Service Layer (Business Logic with Error Handling)
// ============================================================================

struct OrderService {
    product_repo: ProductRepository,
    customer_repo: CustomerRepository,
    fraud_detector: FraudDetector,
}

impl OrderService {
    fn new() -> Self {
        OrderService {
            product_repo: ProductRepository::new(),
            customer_repo: CustomerRepository::new(),
            fraud_detector: FraudDetector::new(),
        }
    }

    /// Validates order input data
    fn validate_order(&self, customer_id: &str, product_id: &str, quantity: i32, price: f64)
        -> Result<(), ValidationError> {
        // Validate quantity
        if quantity <= 0 {
            return Err(ValidationError::InvalidQuantity {
                quantity,
                reason: String::from("Quantity must be positive"),
            });
        }

        if quantity > 100 {
            return Err(ValidationError::InvalidQuantity {
                quantity,
                reason: String::from("Quantity exceeds maximum order size (100)"),
            });
        }

        // Validate customer email format (simplified check)
        let customer = self.customer_repo.find_by_id(customer_id)
            .map_err(|_| ValidationError::InvalidEmail {
                email: String::from("Customer not found"),
            })?;

        if !customer.email.contains('@') {
            return Err(ValidationError::InvalidEmail {
                email: customer.email,
            });
        }

        Ok(())
    }

    /// Main order processing method - coordinates all steps
    fn process_order(&mut self, customer_id: &str, product_id: &str, quantity: i32)
        -> Result<Order, EcommerceError> {

        println!("\n=== Processing order ===");
        println!("Customer: {}, Product: {}, Quantity: {}", customer_id, product_id, quantity);

        // Step 1: Validate input
        self.validate_order(customer_id, product_id, quantity, 0.0)?;
        println!("✓ Validation passed");

        // Step 2: Fetch product and check availability
        let product = self.product_repo.find_by_id(product_id)?;
        println!("✓ Product found: {} (${:.2})", product.name, product.price);

        let total_price = product.price * quantity as f64;

        // Step 3: Check fraud
        self.fraud_detector.check_order(customer_id, total_price)?;
        println!("✓ Fraud check passed");

        // Step 4: Reserve inventory
        self.product_repo.reserve_stock(product_id, quantity)?;
        println!("✓ Inventory reserved");

        // Step 5: Process payment
        self.customer_repo.deduct_balance(customer_id, total_price)?;
        println!("✓ Payment processed");

        // Step 6: Create order record
        let order = Order {
            id: format!("ORD{}", SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap().as_secs()),
            customer_id: customer_id.to_string(),
            product_id: product_id.to_string(),
            quantity,
            total_price,
            status: OrderStatus::Confirmed,
            created_at: SystemTime::now(),
        };

        println!("✓ Order {} created successfully", order.id);
        Ok(order)
    }

    /// Process order with automatic retry on transient errors
    fn process_order_with_retry(&mut self, customer_id: &str, product_id: &str, quantity: i32)
        -> Result<Order, EcommerceError> {
        const MAX_RETRIES: u32 = 3;

        for attempt in 1..=MAX_RETRIES {
            match self.process_order(customer_id, product_id, quantity) {
                Ok(order) => return Ok(order),
                Err(e) => {
                    // Determine if error is retryable
                    let should_retry = matches!(
                        e,
                        EcommerceError::Database(DatabaseError::ConnectionFailed { .. }) |
                        EcommerceError::Payment(PaymentError::PaymentGatewayTimeout { .. })
                    );

                    if should_retry && attempt < MAX_RETRIES {
                        eprintln!("Attempt {} failed: {}. Retrying...", attempt, e);
                        std::thread::sleep(Duration::from_millis(100 * attempt as u64));
                        continue;
                    } else {
                        return Err(e);
                    }
                }
            }
        }

        unreachable!()
    }
}

struct FraudDetector;

impl FraudDetector {
    fn new() -> Self {
        FraudDetector
    }

    fn check_order(&self, customer_id: &str, amount: f64) -> Result<(), PaymentError> {
        // Simulate fraud detection logic
        if amount > 10000.0 {
            return Err(PaymentError::FraudDetected {
                risk_score: 0.95,
            });
        }

        // Simulate specific customer flagged as suspicious
        if customer_id == "CUST999" {
            return Err(PaymentError::FraudDetected {
                risk_score: 0.87,
            });
        }

        Ok(())
    }
}

// ============================================================================
// SECTION 5: Application Layer (Error Recovery and Logging)
// ============================================================================

struct OrderController {
    service: OrderService,
    metrics: Metrics,
}

impl OrderController {
    fn new() -> Self {
        OrderController {
            service: OrderService::new(),
            metrics: Metrics::new(),
        }
    }

    fn handle_order_request(&mut self, customer_id: &str, product_id: &str, quantity: i32) {
        let start_time = SystemTime::now();

        match self.service.process_order_with_retry(customer_id, product_id, quantity) {
            Ok(order) => {
                self.metrics.record_success();
                println!("\n✓✓✓ Order completed successfully ✓✓✓");
                println!("Order ID: {}", order.id);
                println!("Total: ${:.2}", order.total_price);

                // Log success
                self.log_info(&format!("Order {} completed for customer {}",
                                      order.id, customer_id));
            }
            Err(e) => {
                self.metrics.record_failure();
                println!("\n✗✗✗ Order failed ✗✗✗");
                println!("Error: {}", e);

                // Log error with appropriate severity
                match e {
                    EcommerceError::Database(_) => {
                        self.log_error(&format!("Database error: {}", e));
                        // Alert operations team
                        self.send_alert("Database error in order processing", &e.to_string());
                    }
                    EcommerceError::Payment(PaymentError::FraudDetected { .. }) => {
                        self.log_warning(&format!("Fraud detected: {}", e));
                        // Alert fraud team
                        self.send_alert("Potential fraud", &e.to_string());
                    }
                    EcommerceError::Validation(_) | EcommerceError::Inventory(_) => {
                        // User errors - log but don't alert
                        self.log_info(&format!("Order validation failed: {}", e));
                    }
                    _ => {
                        self.log_error(&format!("Order failed: {}", e));
                    }
                }

                // Provide user-friendly error message
                self.send_user_notification(customer_id, &self.format_user_error(&e));
            }
        }

        let duration = SystemTime::now().duration_since(start_time).unwrap();
        self.metrics.record_latency(duration);
    }

    fn format_user_error(&self, error: &EcommerceError) -> String {
        match error {
            EcommerceError::Validation(e) => format!("Please check your order: {}", e),
            EcommerceError::Inventory(InventoryError::OutOfStock { product_id, available, .. }) => {
                format!("Sorry, product {} is out of stock. {} units available.", product_id, available)
            }
            EcommerceError::Payment(PaymentError::InsufficientFunds { required, available }) => {
                format!("Insufficient funds. Required: ${:.2}, Available: ${:.2}", required, available)
            }
            _ => String::from("We're sorry, an error occurred processing your order. Please try again later."),
        }
    }

    fn log_info(&self, message: &str) {
        println!("[INFO] {}", message);
    }

    fn log_warning(&self, message: &str) {
        eprintln!("[WARN] {}", message);
    }

    fn log_error(&self, message: &str) {
        eprintln!("[ERROR] {}", message);
    }

    fn send_alert(&self, title: &str, details: &str) {
        println!("[ALERT] {}: {}", title, details);
    }

    fn send_user_notification(&self, customer_id: &str, message: &str) {
        println!("[NOTIFICATION to {}] {}", customer_id, message);
    }
}

struct Metrics {
    success_count: u32,
    failure_count: u32,
    total_latency: Duration,
}

impl Metrics {
    fn new() -> Self {
        Metrics {
            success_count: 0,
            failure_count: 0,
            total_latency: Duration::from_secs(0),
        }
    }

    fn record_success(&mut self) {
        self.success_count += 1;
    }

    fn record_failure(&mut self) {
        self.failure_count += 1;
    }

    fn record_latency(&mut self, duration: Duration) {
        self.total_latency += duration;
    }

    fn print_summary(&self) {
        let total_requests = self.success_count + self.failure_count;
        if total_requests > 0 {
            let success_rate = (self.success_count as f64 / total_requests as f64) * 100.0;
            let avg_latency = self.total_latency / total_requests;

            println!("\n========== METRICS SUMMARY ==========");
            println!("Total Requests: {}", total_requests);
            println!("Successful: {} ({:.1}%)", self.success_count, success_rate);
            println!("Failed: {} ({:.1}%)", self.failure_count, 100.0 - success_rate);
            println!("Average Latency: {:?}", avg_latency);
            println!("=====================================");
        }
    }
}

// ============================================================================
// SECTION 6: Main - Demonstration of Complete System
// ============================================================================

fn main() {
    let mut controller = OrderController::new();

    println!("======================================");
    println!("E-COMMERCE ORDER PROCESSING SYSTEM");
    println!("======================================");

    // Test Case 1: Successful order
    println!("\n[TEST 1] Valid order");
    controller.handle_order_request("CUST001", "PROD001", 2);

    // Test Case 2: Out of stock
    println!("\n[TEST 2] Out of stock product");
    controller.handle_order_request("CUST001", "PROD002", 1);

    // Test Case 3: Insufficient funds
    println!("\n[TEST 3] Insufficient funds");
    controller.handle_order_request("CUST002", "PROD001", 5);

    // Test Case 4: Invalid quantity
    println!("\n[TEST 4] Invalid quantity");
    controller.handle_order_request("CUST001", "PROD003", -5);

    // Test Case 5: Fraud detection
    println!("\n[TEST 5] Large order (fraud detection)");
    controller.handle_order_request("CUST001", "PROD001", 50);

    // Print final metrics
    controller.metrics.print_summary();
}
```

**Explanation of This Comprehensive Example**:

This final example brings together every error handling concept we've covered:

1. **Layered Architecture**: We separate concerns into Repository (data access), Service (business logic), and Controller (application logic) layers. Each layer has specific error responsibilities.

2. **Domain-Specific Errors**: We define error types that match our e-commerce domain (`PaymentError`, `InventoryError`, etc.), making errors self-documenting.

3. **Error Propagation**: Using `?` operator and `From` trait implementations, errors flow smoothly up the stack with automatic conversion.

4. **Error Recovery**: The `process_order_with_retry` method demonstrates automatic retry logic for transient errors.

5. **Logging Strategy**: Different error types trigger different log levels and actions (alerts for database errors, simple logs for validation errors).

6. **User-Friendly Messages**: The controller translates technical errors into messages users can understand and act on.

7. **Metrics Collection**: We track success rates and latencies to monitor system health.

8. **Transaction Coordination**: The `process_order` method coordinates multiple operations, with each able to fail independently.

This is how error handling works in real production systems: errors are anticipated, classified, handled appropriately, logged for debugging, and translated into meaningful feedback for users and operators.

## Final Thoughts

Rust's error handling system represents a fundamental shift in how we think about failures in software. By making errors explicit through the type system, Rust eliminates entire classes of bugs that plague other languages. While it may feel verbose at first, this explicitness leads to more reliable, maintainable software.

The key is to embrace Rust's philosophy: **errors are not exceptional—they're expected**. Design your systems to handle them gracefully, provide good error messages, and fail fast when recovery isn't possible. Your future self (and your users) will thank you.
