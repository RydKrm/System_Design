# Vector

## üß† The Core Concept: How a Vector Works

A Rust `Vec<T>` is a **resizable, heap-allocated list** of elements of the same type, `T`. Think of it as a "smart array" that can grow or shrink as you need it to.

At its heart, a vector's job is to manage a contiguous block of memory on the **heap** for you. The vector _itself_ is a small object that lives on the **stack** and holds three key pieces of information:

1.  **Pointer:** A memory address pointing to the start of the data on the heap. This is where your elements are actually stored.
2.  **Length (or `len`):** The number of elements currently stored in the vector.
3.  **Capacity (or `cap`):** The total number of elements the allocated memory on the heap _can_ hold before it needs to be resized.

The length is always less than or equal to the capacity (`len <= cap`).

**Analogy üìö:** Imagine you have a small card on your desk (the **stack**). This card tells you the location of a specific bookshelf in a giant library (the **heap**). The card also notes how many books are currently on that shelf (**length**) and the total number of books the shelf can hold (**capacity**). The books themselves are on the shelf in the library, not on your desk card.

---

## üèóÔ∏è Memory Management: Growth and Deallocation

This is where the "smart" part of the vector comes in. Rust's ownership system manages this memory for you automatically, preventing common bugs like memory leaks or using deallocated memory.

### The Growth Strategy (Reallocation)

When you want to add a new element to a vector (using `push()`), it first checks if its `length` is less than its `capacity`.

- **If `len < cap`:** There's empty space\! The vector simply places the new element at the end and increments its `length` by one. This is a very fast operation, often described as **$O(1)$**.
- **If `len == cap`:** The vector is full\! It must **reallocate**. This involves:
  1.  Finding a new, larger block of memory on the heap (often doubling the previous capacity).
  2.  Copying all the elements from the old memory location to the new one.
  3.  Freeing (deallocating) the old block of memory.
  4.  Updating its internal pointer to the new memory location and updating its `capacity`.
  5.  Finally, adding the new element.

This reallocation process can be slower, but because it happens infrequently (and the capacity grows exponentially), adding an element is considered **amortized constant time**, or **$O(1)$ on average**.

#### Example: Visualizing Growth

Let's see what happens when we create a vector and push items into it.

```rust
fn main() {
    // 1. Create a new, empty vector.
    // Pointer: null, Length: 0, Capacity: 0
    let mut numbers: Vec<i32> = Vec::new();
    println!("Initial -> len: {}, cap: {}", numbers.len(), numbers.capacity());

    // 2. Push the first element.
    // Rust allocates memory (e.g., for 4 elements).
    // Pointer: -> [?, ?, ?, ?], Length: 0, Capacity: 4
    numbers.push(10);
    // Pointer: -> [10, ?, ?, ?], Length: 1, Capacity: 4
    println!("After 1 push -> len: {}, cap: {}", numbers.len(), numbers.capacity());

    // 3. Push more elements.
    numbers.push(20);
    numbers.push(30);
    numbers.push(40);
    // Pointer: -> [10, 20, 30, 40], Length: 4, Capacity: 4
    println!("After 4 pushes -> len: {}, cap: {}", numbers.len(), numbers.capacity());

    // 4. Push one more. Reallocation happens!
    // The vector is full (len == cap).
    // Rust allocates new memory (e.g., for 8 elements), copies old data,
    // deallocates old memory, and then pushes the new element.
    numbers.push(50);
    // Pointer: -> [10, 20, 30, 40, 50, ?, ?, ?], Length: 5, Capacity: 8
    println!("After 5 pushes -> len: {}, cap: {}", numbers.len(), numbers.capacity());
}
```

**Explanation of the Code:**

- `Vec::new()` creates a vector with `len` 0 and `cap` 0. It doesn't allocate any heap memory until the first element is pushed.
- The first `push(10)` triggers the first allocation. Rust's allocator decides on a small starting capacity (often 4, but this is an implementation detail).
- We fill it up to its capacity of 4.
- The fifth `push(50)` forces a reallocation. The capacity is doubled to 8, and the length becomes 5.

### The Cleanup Strategy (Dropping) üóëÔ∏è

When a vector goes out of scope (e.g., at the end of a function), Rust automatically calls its "destructor" (a special function defined in the `Drop` trait). This destructor does one crucial thing: **it deallocates the memory on the heap that its pointer was pointing to.**

This ensures that you never have to manually free the memory, preventing memory leaks. This is a core feature of Rust's safety guarantees.

```rust
fn create_and_drop_vector() {
    let v = vec![1, 2, 3]; // Vector 'v' is created on the stack, its data [1, 2, 3] is on the heap.
    println!("Vector created.");
} // 'v' goes out of scope here. Rust calls its Drop logic, freeing the heap memory for [1, 2, 3].

fn main() {
    create_and_drop_vector();
    println!("Vector has been dropped and its memory freed.");
}
```

---

#### Usage and Common Operations

Here are the most common ways to use a `Vec<T>`.

#### Creating a Vector

The most common way is with the `vec!` macro.

```rust
fn main() {
    // Create an empty vector of type i32
    let v1: Vec<i32> = Vec::new();

    // Create a vector with initial elements using the vec! macro
    // Rust infers the type from the elements (Vec<i32>)
    let v2 = vec![10, 20, 30];

    // Create a vector with 5 elements, all initialized to 0
    let v3 = vec![0; 5]; // This creates [0, 0, 0, 0, 0]

    println!("v2: {:?}", v2);
    println!("v3: {:?}", v3);
}
```

**Explanation of the Code:**

- `Vec::new()` is the explicit constructor.
- `vec![...]` is a convenient macro for creating a vector with pre-defined elements.
- `vec![value; count]` is a handy syntax for creating a vector by repeating a value.

#### Accessing Elements

You can access elements using indexing or the safer `.get()` method.

```rust
fn main() {
    let fruits = vec!["apple", "banana", "cherry"];

    // 1. Access using indexing (can panic!)
    // This is fine, as index 1 exists.
    let second_fruit = fruits[1];
    println!("The second fruit is: {}", second_fruit);

    // This would cause the program to crash (panic!) because index 99 does not exist.
    // let ninety_ninth = fruits[99];

    // 2. Safe access using .get()
    // .get() returns an Option<&T>, which is either Some(&value) or None.
    match fruits.get(2) {
        Some(fruit) => println!("Found a fruit at index 2: {}", fruit),
        None => println!("No fruit found at index 2."),
    }

    match fruits.get(99) {
        Some(fruit) => println!("Found a fruit at index 99: {}", fruit),
        None => println!("No fruit found at index 99. (This is safe!)"),
    }
}
```

**Explanation of the Code:**

- `fruits[1]` gives you direct access. If the index is out of bounds, your program will **panic** (a controlled crash). This is useful when you are certain the index is valid.
- `fruits.get(1)` is safer. It returns an `Option`. This forces you to handle the case where the element might not exist, preventing crashes.

#### Iterating Over a Vector

There are three ways to iterate, depending on whether you need to read, modify, or take ownership of the elements.

```rust
fn main() {
    let mut numbers = vec![10, 20, 30];

    // 1. Immutable iteration (reading only)
    // We are borrowing each element immutably. `num` is a `&i32`.
    println!("Reading elements:");
    for num in &numbers {
        println!("- {}", num);
        // *num += 1; // This would be a COMPILE ERROR because num is an immutable reference.
    }

    // 2. Mutable iteration (reading and writing)
    // We are borrowing each element mutably. `num` is a `&mut i32`.
    println!("\nModifying elements:");
    for num in &mut numbers {
        *num += 5; // Use the dereference operator (*) to change the value.
    }
    println!("Vector after modification: {:?}", numbers);


    // 3. Consuming iteration (taking ownership)
    // This moves the vector, so you can't use `numbers` after the loop.
    // `num` is an `i32` (not a reference).
    println!("\nConsuming the vector:");
    for num in numbers {
        println!("- Took ownership of {}", num);
    }

    // The line below would cause a COMPILE ERROR because `numbers` was moved.
    // println!("Can't access numbers anymore: {:?}", numbers);
}
```

**Explanation of the Code:**

- `for num in &numbers`: This is the most common loop. It **borrows** each element, allowing you to read it without changing it.
- `for num in &mut numbers`: This **mutably borrows** each element, allowing you to modify it in place. Note the `*` is needed to change the value behind the reference.
- `for num in numbers`: This loop **takes ownership** of the vector and its elements. After the loop is finished, the vector is gone and cannot be used again. This is useful when you want to pass each element to another function that needs to own it.

Of course. Let's take a deep dive into Rust's `VecDeque<T>`, the powerful sibling of `Vec<T>`.

# Vector Dequeue

A `VecDeque<T>` (Vector Double-Ended Queue) is a sequence collection that allows for efficient addition and removal of elements from **both the front and the back**. While a `Vec<T>` is excellent for adding to the back (`push`), it's very slow at adding to the front, as it requires shifting every single element. `VecDeque<T>` is specifically designed to solve this problem.

---

### üß† The Core Concept: The Ring Buffer

The magic behind `VecDeque<T>` is its internal data structure: a **ring buffer** (or circular buffer). Like a `Vec`, it uses a single, contiguous block of memory on the heap. However, it treats this block of memory as if the two ends were connected, forming a circle.

To manage this, the `VecDeque` keeps track of not just a `length` and `capacity`, but also a **`head`** (or `start`) index. This `head` marks where the first element of the queue is located.

**Analogy üç£:** Imagine a sushi conveyor belt that is circular.

- The **capacity** is the total number of empty plates on the entire belt.
- The **elements** are the sushi dishes placed on the plates.
- The **`head`** is a pointer to the first dish you want to eat.
- The **`tail`** is the spot right after the last dish where the chef will place the next one.

When the chef adds a new dish (`push_back`), they place it at the tail. When they need to add a "special order" to the front of the queue (`push_front`), they can just move the `head` pointer backward one spot and place it there. Because the belt is circular, moving "before" the beginning is easy‚Äîit just wraps around to the end of the memory block.

This "wrap-around" behavior is what makes operations at both ends fast. The `VecDeque` doesn't need to shift elements; it just moves its internal `head` and `tail` pointers.

---

### üèóÔ∏è Memory Management: Growth and Reordering

The memory management of a `VecDeque` is similar to a `Vec` but with one key difference during reallocation.

### The Growth Strategy (Reallocation)

When you try to add an element to a full `VecDeque` (its `length` equals its `capacity`), it must reallocate.

1.  **Allocate New Memory:** It allocates a new, larger block of memory on the heap (often doubling the capacity).
2.  **Copy and Reorder:** This is the crucial step. The data in the old ring buffer might be "split" (e.g., the end of the queue is at the start of the memory block, and the beginning of the queue is at the end). The `VecDeque` copies the elements from the old buffer to the **beginning** of the new, larger buffer in their correct logical order. This "unwraps" or "straightens out" the queue.
3.  **Reset Pointers:** The `head` is reset to index `0`, and the `tail` is set to the current `length`.
4.  **Deallocate Old Memory:** The old block of memory is freed.

This reordering makes sure that after reallocation, the elements are contiguous and at the start of the new memory block, making future operations simpler until it wraps around again.

#### Example: Visualizing Reallocation

```rust
use std::collections::VecDeque;

fn main() {
    // 1. Create a VecDeque with a specific capacity.
    // Memory: [_, _, _, _], len: 0, cap: 4, head: 0
    let mut deque: VecDeque<i32> = VecDeque::with_capacity(4);
    println!("Initial -> len: {}, cap: {}", deque.len(), deque.capacity());

    // 2. Add some items to the back and front.
    deque.push_back(10); // [10, _, _, _], head: 0
    deque.push_back(20); // [10, 20, _, _], head: 0
    deque.push_front(5); // [10, 20, _, 5], head: 3 (wraps around)
    deque.push_front(1); // [10, 20, 1, 5], head: 2
    // The logical order is [1, 5, 10, 20]. The memory is split.
    println!("Full -> len: {}, cap: {}", deque.len(), deque.capacity());

    // 3. Push one more item, forcing reallocation.
    deque.push_back(30);

    // Reallocation happens:
    // a. New memory of capacity 8 is allocated: [_, _, _, _, _, _, _, _]
    // b. Old elements [1, 5, 10, 20] are copied to the start of the new memory.
    // c. The new element 30 is added.
    // Final memory: [1, 5, 10, 20, 30, _, _, _]
    // Pointers are reset: head is now 0.
    println!("After realloc -> len: {}, cap: {}", deque.len(), deque.capacity());
    println!("Final deque state: {:?}", deque);
}
```

**Explanation of the Code:**

- We start with a capacity of 4.
- `push_back` adds elements at the tail (indices 0, 1).
- `push_front` needs to add elements before the `head`. Since `head` is at 0, it wraps around to the end of the allocated memory, placing `5` at index 3 and `1` at index 2. The `head` pointer moves backward accordingly.
- When we `push_back(30)`, the deque is full. It reallocates to a capacity of 8.
- During reallocation, it "unwraps" the data. It starts copying from `head` (index 2) to get `1`, then `5`, then wraps around to index 0 to get `10`, then `20`. The final state in the new memory block is `[1, 5, 10, 20, 30]`.

---

### Usage and Common Operations

`VecDeque` is perfect for when you need a queue or a buffer that works efficiently from both ends.

#### Creating a `VecDeque`

```rust
use std::collections::VecDeque;

fn main() {
    // Create an empty VecDeque
    let mut d1: VecDeque<i32> = VecDeque::new();

    // Create from an existing Vec
    let vec = vec![10, 20, 30];
    let d2: VecDeque<i32> = VecDeque::from(vec);

    println!("d2: {:?}", d2);
}
```

**Explanation of the Code:**

- `VecDeque::new()` creates an empty deque, just like `Vec::new()`.
- You can easily convert other collections, like a `Vec`, into a `VecDeque` using the `from` function.

#### Adding and Removing Elements (The Main Use Case)

This is the primary strength of `VecDeque`.

```rust
use std::collections::VecDeque;

fn main() {
    let mut tasks = VecDeque::new();

    // Add tasks to the end of the queue
    tasks.push_back("Task 1: Do the dishes");
    tasks.push_back("Task 2: Walk the dog");
    println!("Tasks: {:?}", tasks);

    // An urgent task comes in and is added to the front
    tasks.push_front("Urgent Task: Pay the bills!");
    println!("Urgent task added: {:?}", tasks);

    // Process the first task in the queue
    let next_task = tasks.pop_front(); // Removes and returns the first element
    match next_task {
        Some(task) => println!("Processing: {}", task),
        None => println!("No tasks to process."),
    }
    println!("Remaining tasks: {:?}", tasks);

    // Remove the last task added
    let last_task = tasks.pop_back();
    println!("Removed last task: {:?}", last_task.unwrap());
    println!("Final tasks: {:?}", tasks);
}
```

**Explanation of the Code:**

- `push_back()`: Appends an element to the end. Fast ($O(1)$ amortized).
- `push_front()`: Prepends an element to the start. Also fast ($O(1)$ amortized). This would be $O(n)$ in a `Vec`.
- `pop_front()`: Removes and returns the first element. Fast ($O(1)$). This would be $O(n)$ in a `Vec`.
- `pop_back()`: Removes and returns the last element. Fast ($O(1)$).

#### Accessing Elements

You can still access elements by index, though it's slightly more complex internally than a `Vec`.

```rust
use std::collections::VecDeque;

fn main() {
    let mut letters = VecDeque::new();
    letters.push_back('b');
    letters.push_front('a');
    letters.push_back('c'); // Logically: ['a', 'b', 'c']

    // Access by index (can panic)
    println!("Element at index 1 is: {}", letters[1]); // Prints 'b'

    // Safe access with .get()
    if let Some(letter) = letters.get(2) {
        println!("Safely got element at index 2: {}", letter);
    }

    // Peek at the first and last elements without removing them
    println!("Front element is: {:?}", letters.front()); // Some('a')
    println!("Back element is: {:?}", letters.back());   // Some('c')
}
```

**Explanation of the Code:**

- Indexing (`letters[1]`) and `.get()` work just like with a `Vec`. The `VecDeque` handles the internal calculation to find the correct memory location based on its `head` pointer, but this is still an $O(1)$ operation.
- `front()` and `back()` are convenient methods to get references to the first and last elements without removing them.

# Linked List

A `LinkedList<T>` is a **doubly-linked list**. It stores a sequence of elements, but unlike a `Vec`, each element is in its own separate memory allocation on the heap, wrapped in a "node" that holds pointers to the next and previous elements in the sequence.

---

### üß† The Core Concept: A Chain of Nodes

The fundamental difference from a `Vec` is its memory layout. A `Vec` stores all its data together in one continuous block of memory. A `LinkedList` is a collection of scattered blocks connected by pointers.

**Analogy üöÇ:** Think of a **train**.

- Each **train car** is a **Node** on the heap. It's a separate entity.
- The **cargo** inside a car is your **data** (the element of type `T`).
- Each car has a **hitch at the front** (a `prev` pointer) and a **hitch at the back** (a `next` pointer).
- The `LinkedList` object itself is like the **train manifest** held by the station master. It's a small document (on the stack) that only needs to know where the **engine** (`head`) and the **caboose** (`tail`) are, and the total number of cars (`length`).

Because each element is a separate allocation, a `LinkedList` has these core properties:

- **Non-Contiguous Memory:** The nodes can be located anywhere on the heap. This is **not cache-friendly**, as accessing one element doesn't pre-load the next one into the CPU cache, making iteration surprisingly slow compared to a `Vec`.
- **Stable Pointers:** Adding or removing an element from the list does not change the memory address of the _other_ elements. Their pointers remain valid. In a `Vec`, a reallocation can move all elements, invalidating existing pointers.
- **Per-Element Overhead:** Every element you store requires extra memory for the `next` and `prev` pointers.

---

### üìú Properties and Performance

Here are the key trade-offs for a `LinkedList`.

#### The Good ‚úÖ

- **Fast Splicing and Merging:** Its main (and perhaps only significant) advantage. If you have two lists, you can join them together (`append`) in constant time, $O(1)$, just by changing a few pointers. Similarly, splitting a list is very efficient.
- **Fast Insertion/Removal at Ends:** Adding or removing from the front or back (`push_front`, `pop_back`, etc.) is a constant time, $O(1)$, operation.

#### The Bad ‚ùå

- **Slow Traversal and Indexing:** To get to the 50th element, you **must** start at the head (or tail) and walk through 49 nodes first. This makes indexed access a slow, linear time, $O(n)$, operation. There is no `list[49]` syntax.
- **Poor Cache Performance:** As mentioned, the scattered memory layout leads to poor CPU cache utilization, making iteration much slower in practice than for a `Vec` or `VecDeque`.

**Conclusion:** For almost all use cases, **`Vec` or `VecDeque` is a better choice**. `VecDeque` gives you the fast front/back operations of a `LinkedList` but with the superior cache performance of a contiguous memory block. Use `LinkedList` only when you have a specific need for its splicing/merging capabilities.

---

### üõ†Ô∏è Built-in Functions and Usage

Here are the common ways to interact with a `LinkedList`.

#### Creation and Basic Information

**Concept:** You can create an empty list and check its length.

```rust
use std::collections::LinkedList;

fn main() {
    // Create a new, empty linked list
    let mut list: LinkedList<i32> = LinkedList::new();

    // Check if it's empty
    println!("Is the list empty? {}", list.is_empty()); // true

    // Add some elements
    list.push_back(10);
    list.push_back(20);

    println!("Current length: {}", list.len()); // 2
    println!("Is the list empty now? {}", list.is_empty()); // false
}
```

**Explanation:** `new()`, `len()`, and `is_empty()` are straightforward and work as you'd expect from other collections.

#### Adding and Removing Elements (from the ends)

**Concept:** The primary way to add/remove data is via the `head` (front) or `tail` (back) of the list.

```rust
use std::collections::LinkedList;

fn main() {
    let mut list = LinkedList::new();

    // push_back adds to the end (tail)
    list.push_back('B'); // list: ['B']
    list.push_back('C'); // list: ['B', 'C']

    // push_front adds to the beginning (head)
    list.push_front('A'); // list: ['A', 'B', 'C']
    println!("List after pushes: {:?}", list);

    // pop_front removes from the beginning
    let front_item = list.pop_front(); // Returns Some('A')
    println!("Popped from front: {:?}", front_item.unwrap()); // 'A'

    // pop_back removes from the end
    let back_item = list.pop_back(); // Returns Some('C')
    println!("Popped from back: {:?}", back_item.unwrap()); // 'C'

    println!("Final list: {:?}", list); // list: ['B']
}
```

**Explanation:** These four methods‚Äî`push_front`, `push_back`, `pop_front`, and `pop_back`‚Äîare all efficient $O(1)$ operations because the list keeps direct pointers to its `head` and `tail` nodes.

#### Peeking and Iterating

**Concept:** You can view the first or last elements without removing them, and you can iterate over the list's elements.

```rust
use std::collections::LinkedList;

fn main() {
    let mut list = LinkedList::new();
    list.push_back("See");
    list.push_back("the");
    list.push_back("world");

    // Peek at the front and back elements
    println!("Front element: {:?}", list.front()); // Some("See")
    println!("Back element: {:?}", list.back()); // Some("world")

    // Iterate immutably
    println!("\nIterating:");
    for item in list.iter() {
        println!("- {}", item);
    }

    // Iterate mutably and modify elements
    for item in list.iter_mut() {
        *item = "hello"; // Change every item to "hello"
    }
    println!("\nList after mutation: {:?}", list);
}
```

**Explanation:**

- `front()` and `back()` provide read-only access to the end elements, returning an `Option`.
- `iter()` and `iter_mut()` allow you to get immutable and mutable iterators, respectively. Remember that this iteration will be slower than with a `Vec` due to cache misses.

#### Appending and Splitting (The Superpower)

**Concept:** The most unique and powerful feature of a `LinkedList` is its ability to efficiently break and combine lists.

```rust
use std::collections::LinkedList;

fn main() {
    let mut list1 = LinkedList::new();
    list1.push_back(1);
    list1.push_back(2);

    let mut list2 = LinkedList::new();
    list2.push_back(3);
    list2.push_back(4);

    // append() moves all elements from list2 to list1
    // This is O(1) and leaves list2 empty.
    list1.append(&mut list2);
    println!("After append: {:?}", list1); // [1, 2, 3, 4]
    println!("list2 is now empty: {}", list2.is_empty()); // true

    // split_off() splits the list at the given index.
    // Finding the index is O(n), but the split itself is O(1).
    // It returns a new list containing elements from the index onwards.
    let second_half = list1.split_off(2); // Split after index 1
    println!("First half (list1): {:?}", list1); // [1, 2]
    println!("Second half: {:?}", second_half); // [3, 4]
}
```

**Explanation:**

- `append()` is incredibly efficient. It doesn't copy any elements. It simply takes the `head` of the second list and links it to the `tail` of the first list by changing a few pointers.
- `split_off(n)` first iterates `n` steps to find the split point (the slow part) and then performs a quick pointer rearrangement to create the new list (the fast part). This is the canonical example of a `LinkedList`'s unique capabilities.

# Map

## üß≠ 1. What Is a Map in Rust

A **map** (sometimes called a dictionary, associative array, or key-value store) is a data structure that **stores pairs of data** ‚Äî one piece (the _key_) is unique, and it‚Äôs used to find another piece (the _value_).

In Rust, the standard library offers two main types of maps:

- `HashMap<K, V>` ‚Äî unordered, uses hashing.
- `BTreeMap<K, V>` ‚Äî ordered, uses a balanced tree.

Both live in `std::collections`.

---

## üß© 2. `HashMap<K, V>` ‚Äî The Default Map

### Concept

A **HashMap** uses a _hash function_ to turn your key (like `"name"`) into a numeric value called a **hash code**.
That number decides **where** the key-value pair should go in memory (inside a "bucket").

When you look up a key later, Rust:

1. Re-hashes your key.
2. Finds the matching bucket.
3. Compares keys in that bucket for equality.
4. Returns the value.

It‚Äôs _fast_ ‚Äî usually **O(1)** for insert and lookup.

---

### üß† Memory Management in HashMap

- **Heap allocation**: When you create a `HashMap`, it allocates memory on the **heap** for its internal buckets.
- The keys and values are **moved into** the map‚Äôs heap memory.
- The map can **resize** itself (rehash) when it gets too full. This triggers:

  - Allocation of a larger internal buffer.
  - Recalculation of where each key should go.

- When the `HashMap` goes out of scope, Rust automatically **drops** (deallocates) both the keys and values ‚Äî because it owns them.

Rust‚Äôs ownership system ensures there‚Äôs no leak, and you can‚Äôt have dangling references to inside elements without borrowing rules enforcing safety.

---

### üß© Example 1: Basic Usage

```rust
use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();

    scores.insert(String::from("Alice"), 50);
    scores.insert(String::from("Bob"), 70);
    scores.insert(String::from("Charlie"), 90);

    println!("{:?}", scores);
}
```

#### Explanation

- `HashMap::new()` creates an empty map (heap-allocated, ready for key-value pairs).
- `insert()` takes ownership of the key and value.
- Printing with `{:?}` shows all pairs, but order is **random** (hash maps are unordered).
- Memory-wise, each insert copies the `String` and `i32` into heap memory managed by the map.

---

### üß© Example 2: Getting and Iterating

```rust
fn main() {
    let mut scores = HashMap::new();
    scores.insert("Alice", 50);
    scores.insert("Bob", 70);

    if let Some(score) = scores.get("Alice") {
        println!("Alice's score: {}", score);
    }

    for (key, value) in &scores {
        println!("{}: {}", key, value);
    }
}
```

#### Explanation

- `.get(key)` returns an `Option<&V>` ‚Äî a _borrowed reference_, not ownership.
  This means Rust doesn‚Äôt clone or copy data unnecessarily.
- `for (key, value) in &scores` borrows each pair immutably.
- The map stays in memory; iteration doesn‚Äôt destroy it.

---

### üß© Example 3: Updating Values

```rust
fn main() {
    use std::collections::HashMap;
    let mut scores = HashMap::new();

    scores.insert("Alice", 50);
    scores.entry("Alice").and_modify(|v| *v += 10).or_insert(0);
    scores.entry("Bob").and_modify(|v| *v += 10).or_insert(70);

    println!("{:?}", scores);
}
```

#### Explanation

- `.entry(key)` lets you **access or create** a key in one step.
- `.and_modify()` updates the value if the key exists.
- `.or_insert()` adds the key if missing.
- This API avoids multiple lookups ‚Äî efficient and memory-safe.

---

## üå≥ 3. `BTreeMap<K, V>` ‚Äî Ordered Map

### Concept

While `HashMap` is fast but unordered, `BTreeMap` keeps keys **sorted**.
It‚Äôs implemented as a **balanced binary tree** (specifically, a B-tree).

This makes lookups a bit slower (O(log n)), but you can:

- Iterate keys in order.
- Find ranges easily (`range()`, `first_key_value()`, etc.).

---

### üß© Example: Ordered Map

```rust
use std::collections::BTreeMap;

fn main() {
    let mut population = BTreeMap::new();
    population.insert("Bangladesh", 170_000_000);
    population.insert("India", 1_400_000_000);
    population.insert("Nepal", 30_000_000);

    for (country, pop) in &population {
        println!("{}: {}", country, pop);
    }
}
```

#### Explanation

- The keys come out in **alphabetical order** automatically.
- Internally, data is stored in sorted nodes in a tree structure.
- Each node is heap-allocated and linked; the tree keeps itself balanced for efficient operations.

---

## üß† 4. Ownership and Borrowing in Maps

Rust enforces strong rules here:

- When you insert a `String`, you _move_ it into the map.
- You can‚Äôt directly modify keys or values unless you use mutable references.
- Iterating with `&map` borrows immutably; iterating with `&mut map` borrows mutably.

Example:

```rust
let mut map = HashMap::new();
map.insert(String::from("hello"), 5);

// Borrow key temporarily
if let Some(v) = map.get_mut("hello") {
    *v += 1;
}
```

This is safe ‚Äî Rust ensures no two mutable references exist at once.

---

## üíæ 5. Memory Details (Under the Hood)

### For `HashMap`

- Internally, it uses _buckets_ ‚Äî an array of entries.
- Each bucket may hold zero or more key-value pairs (in case of hash collisions).
- Buckets are stored contiguously in heap memory.
- Rust uses **Robin Hood hashing** for even distribution.
- The load factor (fullness) triggers reallocation ‚Äî usually when about 75% full.

### For `BTreeMap`

- It allocates _nodes_ (small fixed-size blocks) on the heap.
- Each node contains multiple key-value pairs.
- The tree balances itself by splitting or merging nodes as elements are inserted or removed.

Both structures rely on Rust‚Äôs **Drop** trait ‚Äî when the map goes out of scope, all owned data (keys, values, nodes) are recursively dropped and heap memory is freed automatically.

---

## üßÆ 6. When to Use Which

| Use Case                          | Best Map                |
| --------------------------------- | ----------------------- |
| Need fastest lookups, unordered   | `HashMap`               |
| Need sorted keys or range queries | `BTreeMap`              |
| Keys are few and predictable      | Either ‚Äî both efficient |
| Stable iteration order not needed | `HashMap`               |
| Stable sorted order required      | `BTreeMap`              |

---

## üß© 7. Example: Counting Words (Practical)

```rust
use std::collections::HashMap;

fn main() {
    let text = "hello world wonderful world";
    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!("{:?}", map);
}
```

### How It Works

- `split_whitespace()` gives each word.
- `.entry(word)` gets or creates the entry for that word.
- `.or_insert(0)` returns a mutable reference to the value.
- Then we increment through the reference.
- The map grows automatically on heap as needed.

Memory-wise:

- Each word (`&str`) is borrowed; not owned.
- The map holds references valid within the loop scope.
- If you used `String`, those would be heap-owned.

---

## üìò In Summary

| Concept            | `HashMap`               | `BTreeMap`        |
| ------------------ | ----------------------- | ----------------- |
| Internal Structure | Buckets (hash table)    | Balanced tree     |
| Order              | Unordered               | Sorted            |
| Speed              | O(1) average            | O(log n)          |
| Memory             | Contiguous heap buckets | Linked heap nodes |
| Use case           | Fast access             | Ordered traversal |

Both are:

- Heap-allocated
- Fully type-safe
- Automatically memory-managed
- Designed to avoid runtime crashes or invalid pointers

---

# Set

---

## üß≠ 1. What Is a Set in Rust

A **set** is a collection of **unique values** ‚Äî no duplicates, no associated values.
If you just care whether something _exists_ in the collection (not what it maps to), you use a set.

In Rust:

- `HashSet<T>` ‚Äî built on a hash table (unordered, fast).
- `BTreeSet<T>` ‚Äî built on a balanced tree (ordered).

They live in `std::collections`.

Internally:

- `HashSet<T>` = wrapper around `HashMap<T, ()>`.
  (Each value is a key in a map, the value part is `()` ‚Äî an empty type.)

---

## üß© 2. `HashSet<T>` ‚Äî Fast, Unordered Set

### Concept

When you insert an element, Rust:

1. Hashes it to find a bucket.
2. Checks if that value already exists (using `Eq` and `Hash` traits).
3. Stores it if not found.

All lookups, insertions, and deletions are on average **O(1)**.

---

### üß† Memory Management in HashSet

- Elements are **heap-allocated**, just like `HashMap`.
- Each element is stored once, without duplicates.
- When you insert, the element is **moved** into the set.
- When the set grows, Rust **rehashes** (allocates a new, larger buffer).
- When the set goes out of scope, it drops all elements and frees heap memory.

---

## üß© Example 1: Basic Usage

```rust
use std::collections::HashSet;

fn main() {
    let mut fruits = HashSet::new();

    fruits.insert("apple");
    fruits.insert("banana");
    fruits.insert("mango");
    fruits.insert("apple"); // ignored ‚Äî already exists

    println!("{:?}", fruits);
    println!("Total fruits: {}", fruits.len());
}
```

### Explanation

- `insert()` takes ownership of the value.
- Duplicates are ignored automatically.
- The order of printing is **random**, because it‚Äôs based on hashes.
- Memory-wise, each string literal here (`&str`) is a reference, not heap-allocated by the set. If you used `String`, they would be moved and owned.

---

## üß© Example 2: Checking Existence and Removal

```rust
fn main() {
    use std::collections::HashSet;

    let mut set = HashSet::new();
    set.insert("Dhaka");
    set.insert("Chittagong");

    if set.contains("Dhaka") {
        println!("Found Dhaka");
    }

    set.remove("Dhaka");

    println!("{:?}", set);
}
```

### Explanation

- `.contains()` checks if the element is present ‚Äî uses hashing.
- `.remove()` deletes it if found.
- After removal, the bucket memory may stay allocated until rehash or drop, but the entry is marked empty.

---

## üå≥ 3. `BTreeSet<T>` ‚Äî Sorted Set

### Concept

If you need an ordered collection of unique elements, use a **BTreeSet**.
It uses a **B-tree**, keeping elements sorted by their natural order (`Ord` trait).

- Insertion, lookup, deletion: **O(log n)**.
- Iteration always yields items in **sorted order**.

---

### üß© Example: Ordered Numbers

```rust
use std::collections::BTreeSet;

fn main() {
    let mut numbers = BTreeSet::new();
    numbers.insert(30);
    numbers.insert(10);
    numbers.insert(20);

    for num in &numbers {
        println!("{}", num);
    }
}
```

### Output

```
10
20
30
```

### Explanation

- The set stores elements in sorted order.
- Internally, each node holds a few values, and pointers to children.
- Balanced tree keeps the depth small for efficiency.

Memory-wise:

- Nodes are heap-allocated.
- Each node stores several elements contiguously for cache efficiency.
- When dropped, Rust automatically deallocates recursively.

---

## üß† 4. Set Operations (Mathematical Ones)

Rust provides classic set operations ‚Äî available for both `HashSet` and `BTreeSet`.

```rust
use std::collections::HashSet;

fn main() {
    let a: HashSet<_> = [1, 2, 3, 4].iter().cloned().collect();
    let b: HashSet<_> = [3, 4, 5, 6].iter().cloned().collect();

    let union = a.union(&b);         // all unique items from both
    let intersection = a.intersection(&b); // only common items
    let difference = a.difference(&b);     // items in a but not b
    let symmetric = a.symmetric_difference(&b); // items in one or the other, not both

    println!("Union: {:?}", union.collect::<Vec<_>>());
    println!("Intersection: {:?}", intersection.collect::<Vec<_>>());
    println!("Difference: {:?}", difference.collect::<Vec<_>>());
    println!("Symmetric difference: {:?}", symmetric.collect::<Vec<_>>());
}
```

### Explanation

- `.union()` and others return **lazy iterators** ‚Äî they don‚Äôt allocate until collected.
- This is efficient: Rust iterates through buckets, borrowing data.
- The final `collect()` builds a `Vec` for printing.

---

## üíæ 5. Memory View

### HashSet

- Under the hood: a table of buckets (like `HashMap`).
- Each element is stored only once, hashed to find a position.
- If two elements hash to the same spot, they live in the same bucket.
- Reallocation happens when the table fills up.

### BTreeSet

- Tree of nodes (each node has multiple elements and child pointers).
- Balanced for efficient search.
- Great for sorted data and range queries (`range()`, `first()`, `last()`).

---

## üß© 6. Borrowing and Ownership Rules

- When you insert into a set, you **move** the item in.
- `.contains()` and `.remove()` borrow the key.
- You can‚Äôt mutate while iterating without a mutable borrow (`&mut`).
- Iteration borrows immutably ‚Äî safe and efficient.

Example:

```rust
let mut names = HashSet::new();
names.insert(String::from("Alice"));
names.insert(String::from("Bob"));

for name in &names {
    println!("{}", name);
}
```

No copying ‚Äî only borrowing. The strings live inside the set until drop.

---

## üßÆ 7. Choosing Between Them

| Use Case                           | Best Choice |
| ---------------------------------- | ----------- |
| Fast lookup, no order needed       | `HashSet`   |
| Sorted data, need range operations | `BTreeSet`  |
| Small collections                  | Either      |
| Predictable iteration order        | `BTreeSet`  |

---

## üß© 8. Practical Example ‚Äî Tracking Unique Visitors

```rust
use std::collections::HashSet;

fn main() {
    let visits = vec!["alice", "bob", "charlie", "alice", "bob"];
    let unique: HashSet<_> = visits.into_iter().collect();

    println!("Unique visitors: {:?}", unique);
    println!("Total: {}", unique.len());
}
```

### Explanation

- Converts a `Vec` to a `HashSet` using `.collect()`.
- Automatically filters duplicates.
- Memory: each string reference is stored once, no extra allocations per duplicate.

---

## üìò Summary

| Concept         | `HashSet`              | `BTreeSet`        |
| --------------- | ---------------------- | ----------------- |
| Structure       | Hash table             | Balanced B-tree   |
| Order           | Unordered              | Sorted            |
| Time complexity | O(1) average           | O(log n)          |
| Memory layout   | Contiguous buckets     | Linked nodes      |
| Duplicates      | Not allowed            | Not allowed       |
| Use case        | Fast membership checks | Ordered iteration |

Both:

- Store unique elements.
- Manage memory automatically.
- Use heap for internal structures.
- Require types that implement specific traits:

  - `HashSet<T>` ‚Üí `Eq + Hash`
  - `BTreeSet<T>` ‚Üí `Ord`

---
