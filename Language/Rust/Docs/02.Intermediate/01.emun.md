# Enums and Pattern Matching in Rust: A Comprehensive Guide

## Part I: Understanding Enums

### What Are Enums?

Enums (short for "enumerations") allow you to define a type by enumerating its possible variants. Unlike structs that group related data together, enums let you express that a value is one of several possible variants. Rust's enums are extraordinarily powerful—far more than enums in most other languages—because each variant can hold different types and amounts of data.

Think of enums as a way to say: "This value is one of these specific possibilities, and each possibility might carry different information."

---

## Basic Enum Definition

### Simple Enums

The most basic form lists possible variants:

```rust
enum Direction {
    North,
    South,
    East,
    West,
}

fn main() {
    let player_direction = Direction::North;
    let enemy_direction = Direction::South;

    // Each variant is a distinct value of the Direction type
    move_character(player_direction);
}

fn move_character(direction: Direction) {
    // We'll see how to handle this in pattern matching section
}
```

### Enums with Values

Each variant can store associated data:

```rust
enum IpAddress {
    V4(u8, u8, u8, u8),
    V6(String),
}

fn main() {
    let home = IpAddress::V4(127, 0, 0, 1);
    let loopback = IpAddress::V6(String::from("::1"));

    route_packet(home);
    route_packet(loopback);
}

fn route_packet(ip: IpAddress) {
    // Handle routing
}
```

### Enums with Different Data Types

Each variant can hold completely different types:

```rust
enum Message {
    Quit,                       // No data
    Move { x: i32, y: i32 },   // Named fields (like a struct)
    Write(String),              // Single value
    ChangeColor(u8, u8, u8),   // Tuple values
}

fn main() {
    let msg1 = Message::Quit;
    let msg2 = Message::Move { x: 10, y: 20 };
    let msg3 = Message::Write(String::from("Hello"));
    let msg4 = Message::ChangeColor(255, 0, 0);
}
```

This is powerful! Each variant is like a mini-struct with its own shape.

---

## Enums vs Structs

You could represent the same data with separate structs:

```rust
// Using structs (verbose)
struct QuitMessage;
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String);
struct ChangeColorMessage(u8, u8, u8);

// Using enum (clean and type-safe)
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(u8, u8, u8),
}

// With enum, you can write a single function:
fn process_message(msg: Message) {
    // Handles all variants
}

// With structs, you'd need multiple functions or trait objects
```

The enum approach gives you:

- **Type safety**: All variants are part of one type
- **Exhaustiveness checking**: The compiler ensures you handle all cases
- **Cleaner APIs**: One type instead of many

---

## Methods on Enums

Just like structs, enums can have methods:

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(u8, u8, u8),
}

impl Message {
    // Associated function (constructor)
    fn new_move(x: i32, y: i32) -> Self {
        Message::Move { x, y }
    }

    // Method that works with any variant
    fn call(&self) {
        match self {
            Message::Quit => println!("Quitting..."),
            Message::Move { x, y } => println!("Moving to ({}, {})", x, y),
            Message::Write(text) => println!("Writing: {}", text),
            Message::ChangeColor(r, g, b) => {
                println!("Changing color to RGB({}, {}, {})", r, g, b)
            }
        }
    }

    // Method that checks variant type
    fn is_quit(&self) -> bool {
        matches!(self, Message::Quit)
    }

    // Method that transforms the enum
    fn to_uppercase(self) -> Self {
        match self {
            Message::Write(text) => Message::Write(text.to_uppercase()),
            other => other,
        }
    }
}

fn main() {
    let msg = Message::new_move(5, 10);
    msg.call();

    let quit_msg = Message::Quit;
    if quit_msg.is_quit() {
        println!("It's a quit message!");
    }

    let write_msg = Message::Write(String::from("hello"));
    let upper_msg = write_msg.to_uppercase();
    upper_msg.call();
}
```

---

## The `Option` Enum

One of Rust's most important enums is `Option<T>`, which represents a value that might or might not exist:

```rust
// Defined in the standard library as:
enum Option<T> {
    Some(T),
    None,
}

fn main() {
    // Option is so common it's in the prelude
    // You can use Some and None without Option::
    let some_number = Some(5);
    let some_string = Some("hello");
    let absent_number: Option<i32> = None;

    // Option forces you to handle the None case
    let x: Option<i32> = Some(5);
    let y: i32 = 10;

    // This won't compile:
    // let sum = x + y;  // Can't add Option<i32> to i32

    // You must handle the possibility of None:
    let sum = x.unwrap_or(0) + y;
    println!("Sum: {}", sum);
}
```

### Why Option is Better Than Null

In languages with `null`, any reference might be null, leading to runtime errors. Rust's `Option` makes the possibility of absence explicit:

```rust
// Finding an item in a list
fn find_user(id: u32) -> Option<String> {
    if id == 1 {
        Some(String::from("Alice"))
    } else {
        None
    }
}

fn main() {
    match find_user(1) {
        Some(name) => println!("Found user: {}", name),
        None => println!("User not found"),
    }

    // The compiler forces you to consider both cases!
}
```

### Working with Option

```rust
fn main() {
    let x = Some(5);

    // unwrap: Get value or panic
    let value = x.unwrap();

    // unwrap_or: Get value or default
    let value = x.unwrap_or(0);

    // unwrap_or_else: Get value or compute default
    let value = x.unwrap_or_else(|| {
        println!("Computing default");
        0
    });

    // expect: unwrap with custom panic message
    let value = x.expect("x should have a value");

    // is_some / is_none: Check variant
    if x.is_some() {
        println!("x has a value");
    }

    // map: Transform the inner value
    let y = x.map(|v| v * 2);  // Some(10)

    // and_then: Chain operations that return Option
    let z = x.and_then(|v| {
        if v > 0 {
            Some(v * 2)
        } else {
            None
        }
    });

    // filter: Keep Some only if predicate is true
    let even = x.filter(|v| v % 2 == 0);

    // or: Use this Option or another
    let result = None.or(Some(5));  // Some(5)

    // take: Take value, leaving None
    let mut opt = Some(5);
    let taken = opt.take();  // taken = Some(5), opt = None
}
```

---

## The `Result` Enum

`Result<T, E>` represents either success or failure:

```rust
// Defined in standard library as:
enum Result<T, E> {
    Ok(T),
    Err(E),
}

// Example: Reading a file
use std::fs::File;
use std::io::Read;

fn read_username_from_file(path: &str) -> Result<String, std::io::Error> {
    let mut file = File::open(path)?;  // ? propagates errors
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

fn main() {
    match read_username_from_file("user.txt") {
        Ok(username) => println!("Username: {}", username),
        Err(e) => println!("Error reading file: {}", e),
    }
}
```

### Result Methods

```rust
fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err(String::from("Division by zero"))
    } else {
        Ok(a / b)
    }
}

fn main() {
    let result = divide(10.0, 2.0);

    // unwrap: Get Ok value or panic
    let value = result.unwrap();

    // expect: unwrap with custom panic message
    let value = result.expect("Division should work");

    // unwrap_or: Get Ok value or default
    let value = result.unwrap_or(0.0);

    // unwrap_or_else: Get Ok value or compute
    let value = result.unwrap_or_else(|err| {
        println!("Error: {}", err);
        0.0
    });

    // is_ok / is_err: Check variant
    if result.is_ok() {
        println!("Success!");
    }

    // map: Transform Ok value
    let doubled = result.map(|v| v * 2.0);

    // map_err: Transform Err value
    let with_different_error = result.map_err(|e| format!("Math error: {}", e));

    // and_then: Chain operations that return Result
    let chained = result.and_then(|v| divide(v, 3.0));

    // or: Use this Result or another
    let alternative = result.or(Ok(0.0));
}
```

### The `?` Operator

The `?` operator is shorthand for propagating errors:

```rust
fn read_and_parse() -> Result<i32, Box<dyn std::error::Error>> {
    let contents = std::fs::read_to_string("number.txt")?;  // Propagate error
    let number = contents.trim().parse()?;  // Propagate error
    Ok(number)
}

// The above is equivalent to:
fn read_and_parse_verbose() -> Result<i32, Box<dyn std::error::Error>> {
    let contents = match std::fs::read_to_string("number.txt") {
        Ok(c) => c,
        Err(e) => return Err(e.into()),
    };

    let number = match contents.trim().parse() {
        Ok(n) => n,
        Err(e) => return Err(e.into()),
    };

    Ok(number)
}
```

---

## Custom Enums for Domain Modeling

### State Machine Example

```rust
enum ConnectionState {
    Disconnected,
    Connecting { attempt: u32 },
    Connected { session_id: String, connected_at: u64 },
    Failed { reason: String, can_retry: bool },
}

impl ConnectionState {
    fn is_connected(&self) -> bool {
        matches!(self, ConnectionState::Connected { .. })
    }

    fn transition_to_connecting(&mut self, attempt: u32) {
        *self = ConnectionState::Connecting { attempt };
    }

    fn transition_to_connected(&mut self, session_id: String) {
        *self = ConnectionState::Connected {
            session_id,
            connected_at: 1234567890, // timestamp
        };
    }

    fn describe(&self) -> String {
        match self {
            ConnectionState::Disconnected => {
                String::from("Not connected")
            }
            ConnectionState::Connecting { attempt } => {
                format!("Connecting (attempt {})", attempt)
            }
            ConnectionState::Connected { session_id, .. } => {
                format!("Connected with session {}", session_id)
            }
            ConnectionState::Failed { reason, can_retry } => {
                if *can_retry {
                    format!("Failed: {} (can retry)", reason)
                } else {
                    format!("Failed: {} (cannot retry)", reason)
                }
            }
        }
    }
}

fn main() {
    let mut state = ConnectionState::Disconnected;
    println!("{}", state.describe());

    state.transition_to_connecting(1);
    println!("{}", state.describe());

    state.transition_to_connected(String::from("abc123"));
    println!("{}", state.describe());
}
```

### Payment Method Example

```rust
#[derive(Debug)]
enum PaymentMethod {
    Cash,
    CreditCard {
        card_number: String,
        expiry: String,
        cvv: String,
    },
    DebitCard {
        card_number: String,
        expiry: String,
        pin: String,
    },
    DigitalWallet {
        provider: WalletProvider,
        account_id: String,
    },
    BankTransfer {
        account_number: String,
        routing_number: String,
    },
}

#[derive(Debug)]
enum WalletProvider {
    PayPal,
    ApplePay,
    GooglePay,
    Venmo,
}

impl PaymentMethod {
    fn process_payment(&self, amount: f64) -> Result<String, String> {
        match self {
            PaymentMethod::Cash => {
                Ok(format!("Processed cash payment of ${:.2}", amount))
            }
            PaymentMethod::CreditCard { card_number, .. } => {
                // Mask card number
                let masked = format!(
                    "****-****-****-{}",
                    &card_number[card_number.len() - 4..]
                );
                Ok(format!("Charged ${:.2} to card {}", amount, masked))
            }
            PaymentMethod::DebitCard { card_number, .. } => {
                let masked = format!(
                    "****-****-****-{}",
                    &card_number[card_number.len() - 4..]
                );
                Ok(format!("Debited ${:.2} from card {}", amount, masked))
            }
            PaymentMethod::DigitalWallet { provider, account_id } => {
                Ok(format!(
                    "Paid ${:.2} via {:?} account {}",
                    amount, provider, account_id
                ))
            }
            PaymentMethod::BankTransfer { account_number, .. } => {
                if amount > 10000.0 {
                    Err(String::from("Amount exceeds transfer limit"))
                } else {
                    Ok(format!(
                        "Transferred ${:.2} from account {}",
                        amount, account_number
                    ))
                }
            }
        }
    }

    fn requires_signature(&self) -> bool {
        match self {
            PaymentMethod::CreditCard { .. } | PaymentMethod::DebitCard { .. } => true,
            _ => false,
        }
    }

    fn processing_fee(&self, amount: f64) -> f64 {
        match self {
            PaymentMethod::Cash => 0.0,
            PaymentMethod::CreditCard { .. } => amount * 0.029 + 0.30,
            PaymentMethod::DebitCard { .. } => amount * 0.015 + 0.25,
            PaymentMethod::DigitalWallet { .. } => amount * 0.025,
            PaymentMethod::BankTransfer { .. } => 1.00,
        }
    }
}

fn main() {
    let payment = PaymentMethod::CreditCard {
        card_number: String::from("1234567890123456"),
        expiry: String::from("12/25"),
        cvv: String::from("123"),
    };

    match payment.process_payment(50.00) {
        Ok(msg) => println!("{}", msg),
        Err(e) => println!("Payment failed: {}", e),
    }

    let fee = payment.processing_fee(50.00);
    println!("Processing fee: ${:.2}", fee);
}
```

---

## Part II: Pattern Matching

Pattern matching is Rust's most powerful control flow construct. It allows you to compare a value against a series of patterns and execute code based on which pattern matches.

### Basic `match` Expression

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u32 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

fn main() {
    let coin = Coin::Dime;
    println!("Value: {} cents", value_in_cents(coin));
}
```

**Key Points:**

- `match` must be exhaustive (cover all possibilities)
- Each arm is: `pattern => expression`
- The expression can be a block: `pattern => { /* code */ }`

---

### Matching with Values

```rust
enum UsState {
    Alabama,
    Alaska,
    California,
    // ... etc
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u32 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
```

---

### Matching Option

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

fn main() {
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

    println!("{:?}, {:?}", six, none);
}
```

---

### The `_` Placeholder

When you don't want to handle all cases explicitly:

```rust
fn describe_number(n: u8) {
    match n {
        1 => println!("One"),
        2 => println!("Two"),
        3 => println!("Three"),
        _ => println!("Something else"),
    }
}

// Ignoring values in patterns
fn process_config(config: (u32, u32, u32)) {
    match config {
        (_, _, 0) => println!("Third value is zero"),
        (0, _, _) => println!("First value is zero"),
        _ => println!("Other configuration"),
    }
}
```

---

### `if let` - Concise Pattern Matching

When you only care about one pattern:

```rust
fn main() {
    let some_value = Some(7);

    // Using match (verbose)
    match some_value {
        Some(7) => println!("Seven!"),
        _ => (),
    }

    // Using if let (concise)
    if let Some(7) = some_value {
        println!("Seven!");
    }

    // With else
    let some_value = Some(3);
    if let Some(7) = some_value {
        println!("Seven!");
    } else {
        println!("Not seven");
    }

    // Extracting values
    let color = Some("blue");
    if let Some(c) = color {
        println!("The color is {}", c);
    }
}
```

---

### `while let` - Loop with Pattern Matching

```rust
fn main() {
    let mut stack = Vec::new();
    stack.push(1);
    stack.push(2);
    stack.push(3);

    // Pop values while Some
    while let Some(top) = stack.pop() {
        println!("Popped: {}", top);
    }
    // Loop ends when pop() returns None
}
```

---

### `let` Patterns

Even regular `let` statements use pattern matching:

```rust
fn main() {
    // Destructuring tuples
    let (x, y, z) = (1, 2, 3);
    println!("x={}, y={}, z={}", x, y, z);

    // Destructuring structs
    struct Point {
        x: i32,
        y: i32,
    }

    let point = Point { x: 10, y: 20 };
    let Point { x, y } = point;
    println!("x={}, y={}", x, y);

    // Renaming fields
    let Point { x: a, y: b } = point;
    println!("a={}, b={}", a, b);
}
```

---

### Advanced Pattern Matching

#### Matching Ranges

```rust
fn describe_age(age: u32) {
    match age {
        0 => println!("Newborn"),
        1..=12 => println!("Child"),
        13..=19 => println!("Teenager"),
        20..=64 => println!("Adult"),
        65.. => println!("Senior"),
    }
}

fn classify_char(c: char) {
    match c {
        'a'..='z' => println!("Lowercase letter"),
        'A'..='Z' => println!("Uppercase letter"),
        '0'..='9' => println!("Digit"),
        _ => println!("Other character"),
    }
}
```

#### Destructuring Structs

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x: 0, y: 0 } => println!("At origin"),
        Point { x: 0, y } => println!("On y-axis at {}", y),
        Point { x, y: 0 } => println!("On x-axis at {}", x),
        Point { x, y } => println!("At ({}, {})", x, y),
    }

    // Shorthand when variable names match field names
    let Point { x, y } = p;
}
```

#### Destructuring Enums

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn process_message(msg: Message) {
    match msg {
        Message::Quit => {
            println!("Quitting");
        }
        Message::Move { x, y } => {
            println!("Moving to ({}, {})", x, y);
        }
        Message::Write(text) => {
            println!("Writing: {}", text);
        }
        Message::ChangeColor(r, g, b) => {
            println!("Changing color to RGB({}, {}, {})", r, g, b);
        }
    }
}
```

#### Nested Destructuring

```rust
enum Color {
    Rgb(u8, u8, u8),
    Hsv(u8, u8, u8),
}

enum Message {
    ChangeColor(Color),
    Move { x: i32, y: i32 },
}

fn process(msg: Message) {
    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => {
            println!("RGB: {}, {}, {}", r, g, b);
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) => {
            println!("HSV: {}, {}, {}", h, s, v);
        }
        Message::Move { x, y } => {
            println!("Move to ({}, {})", x, y);
        }
    }
}
```

#### Ignoring Parts with `..`

```rust
struct Point3D {
    x: i32,
    y: i32,
    z: i32,
}

fn main() {
    let point = Point3D { x: 1, y: 2, z: 3 };

    match point {
        Point3D { x, .. } => println!("x is {}", x),
    }

    // In tuples
    let numbers = (1, 2, 3, 4, 5);
    match numbers {
        (first, .., last) => {
            println!("First: {}, Last: {}", first, last);
        }
    }
}
```

---

### Match Guards

Add extra conditions to patterns:

```rust
fn main() {
    let num = Some(4);

    match num {
        Some(x) if x < 5 => println!("Less than five: {}", x),
        Some(x) => println!("Greater than or equal to five: {}", x),
        None => println!("No value"),
    }

    // Multiple patterns with guard
    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y => println!("yes"),
        _ => println!("no"),
    }
}
```

---

### `@` Bindings

Test a value and save it in a variable:

```rust
enum Message {
    Hello { id: i32 },
}

fn main() {
    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } => println!("Found id in range: {}", id_variable),
        Message::Hello { id: 10..=12 } => {
            println!("Found id in another range");
        }
        Message::Hello { id } => println!("Found other id: {}", id),
    }
}
```

---

### The `matches!` Macro

Check if a value matches a pattern (returns bool):

```rust
fn main() {
    let value = Some(5);

    if matches!(value, Some(x) if x > 3) {
        println!("Value is Some and greater than 3");
    }

    // Useful in filters
    let numbers = vec![Some(1), None, Some(3), None, Some(5)];
    let filtered: Vec<_> = numbers
        .into_iter()
        .filter(|x| matches!(x, Some(n) if *n > 2))
        .collect();

    println!("{:?}", filtered);
}
```

---

## Real-World Example: HTTP Request Handler

Let's build a comprehensive example:

```rust
#[derive(Debug)]
enum HttpMethod {
    Get,
    Post,
    Put,
    Delete,
    Patch,
}

#[derive(Debug)]
struct HttpRequest {
    method: HttpMethod,
    path: String,
    headers: Vec<(String, String)>,
    body: Option<String>,
}

#[derive(Debug)]
enum HttpResponse {
    Ok { body: String },
    Created { id: u32, body: String },
    NoContent,
    BadRequest { message: String },
    NotFound { path: String },
    InternalServerError { error: String },
}

impl HttpResponse {
    fn status_code(&self) -> u16 {
        match self {
            HttpResponse::Ok { .. } => 200,
            HttpResponse::Created { .. } => 201,
            HttpResponse::NoContent => 204,
            HttpResponse::BadRequest { .. } => 400,
            HttpResponse::NotFound { .. } => 404,
            HttpResponse::InternalServerError { .. } => 500,
        }
    }

    fn status_text(&self) -> &str {
        match self {
            HttpResponse::Ok { .. } => "OK",
            HttpResponse::Created { .. } => "Created",
            HttpResponse::NoContent => "No Content",
            HttpResponse::BadRequest { .. } => "Bad Request",
            HttpResponse::NotFound { .. } => "Not Found",
            HttpResponse::InternalServerError { .. } => "Internal Server Error",
        }
    }

    fn body(&self) -> Option<String> {
        match self {
            HttpResponse::Ok { body } | HttpResponse::Created { body, .. } => {
                Some(body.clone())
            }
            HttpResponse::BadRequest { message } => Some(message.clone()),
            HttpResponse::NotFound { path } => {
                Some(format!("Path '{}' not found", path))
            }
            HttpResponse::InternalServerError { error } => {
                Some(format!("Server error: {}", error))
            }
            HttpResponse::NoContent => None,
        }
    }
}

struct Router {
    routes: Vec<Route>,
}

struct Route {
    method: HttpMethod,
    path: String,
    handler: fn(&HttpRequest) -> HttpResponse,
}

impl Router {
    fn new() -> Self {
        Router { routes: Vec::new() }
    }

    fn add_route(&mut self, method: HttpMethod, path: &str, handler: fn(&HttpRequest) -> HttpResponse) {
        self.routes.push(Route {
            method,
            path: path.to_string(),
            handler,
        });
    }

    fn handle_request(&self, request: &HttpRequest) -> HttpResponse {
        // Find matching route
        for route in &self.routes {
            if matches_route(&route.method, &request.method)
                && route.path == request.path {
                return (route.handler)(request);
            }
        }

        // No route found
        HttpResponse::NotFound {
            path: request.path.clone(),
        }
    }
}

fn matches_route(route_method: &HttpMethod, request_method: &HttpMethod) -> bool {
    match (route_method, request_method) {
        (HttpMethod::Get, HttpMethod::Get) => true,
        (HttpMethod::Post, HttpMethod::Post) => true,
        (HttpMethod::Put, HttpMethod::Put) => true,
        (HttpMethod::Delete, HttpMethod::Delete) => true,
        (HttpMethod::Patch, HttpMethod::Patch) => true,
        _ => false,
    }
}

// Handler functions
fn get_users(_req: &HttpRequest) -> HttpResponse {
    HttpResponse::Ok {
        body: String::from(r#"[{"id": 1, "name": "Alice"}, {"id": 2, "name": "Bob"}]"#),
    }
}

fn create_user(req: &HttpRequest) -> HttpResponse {
    match &req.body {
        Some(body) if !body.is_empty() => {
            HttpResponse::Created {
                id: 123,
                body: format!(r#"{{"id": 123, "data": {}}}"#, body),
            }
        }
        _ => HttpResponse::BadRequest {
            message: String::from("Request body is required"),
        },
    }
}

fn delete_user(_req: &HttpRequest) -> HttpResponse {
    HttpResponse::NoContent
}

fn main() {
    let mut router = Router::new();

    // Register routes
    router.add_route(HttpMethod::Get, "/users", get_users);
    router.add_route(HttpMethod::Post, "/users", create_user);
    router.add_route(HttpMethod::Delete, "/users/1", delete_user);

    // Simulate requests
    let requests = vec![
        HttpRequest {
            method: HttpMethod::Get,
            path: String::from("/users"),
            headers: vec![],body: None,
        },
        HttpRequest {
            method: HttpMethod::Post,
            path: String::from("/users"),
            headers: vec![(String::from("Content-Type"), String::from("application/json"))],
            body: Some(String::from(r#"{"name": "Charlie"}"#)),
        },
        HttpRequest {
            method: HttpMethod::Delete,
            path: String::from("/users/1"),
            headers: vec![],
            body: None,
        },
        HttpRequest {
            method: HttpMethod::Get,
            path: String::from("/invalid"),
            headers: vec![],
            body: None,
        },
    ];

    // Process requests
    for request in requests {
        println!("\n{:?} {}", request.method, request.path);
        let response = router.handle_request(&request);
        println!("Response: {} {}", response.status_code(), response.status_text());
        if let Some(body) = response.body() {
            println!("Body: {}", body);
        }
    }
}
```

---

## Real-World Example: Expression Evaluator

A practical example showing pattern matching with recursive structures:

```rust
#[derive(Debug, Clone)]
enum Expr {
    Number(f64),
    Variable(String),
    Add(Box<Expr>, Box<Expr>),
    Subtract(Box<Expr>, Box<Expr>),
    Multiply(Box<Expr>, Box<Expr>),
    Divide(Box<Expr>, Box<Expr>),
    Power(Box<Expr>, Box<Expr>),
    Negate(Box<Expr>),
}

use std::collections::HashMap;

impl Expr {
    // Evaluate the expression
    fn eval(&self, vars: &HashMap<String, f64>) -> Result<f64, String> {
        match self {
            Expr::Number(n) => Ok(*n),

            Expr::Variable(name) => {
                vars.get(name)
                    .copied()
                    .ok_or_else(|| format!("Variable '{}' not found", name))
            }

            Expr::Add(left, right) => {
                let l = left.eval(vars)?;
                let r = right.eval(vars)?;
                Ok(l + r)
            }

            Expr::Subtract(left, right) => {
                let l = left.eval(vars)?;
                let r = right.eval(vars)?;
                Ok(l - r)
            }

            Expr::Multiply(left, right) => {
                let l = left.eval(vars)?;
                let r = right.eval(vars)?;
                Ok(l * r)
            }

            Expr::Divide(left, right) => {
                let l = left.eval(vars)?;
                let r = right.eval(vars)?;
                if r == 0.0 {
                    Err(String::from("Division by zero"))
                } else {
                    Ok(l / r)
                }
            }

            Expr::Power(base, exp) => {
                let b = base.eval(vars)?;
                let e = exp.eval(vars)?;
                Ok(b.powf(e))
            }

            Expr::Negate(expr) => {
                let val = expr.eval(vars)?;
                Ok(-val)
            }
        }
    }

    // Simplify the expression
    fn simplify(&self) -> Expr {
        match self {
            // Addition simplifications
            Expr::Add(left, right) => {
                let l = left.simplify();
                let r = right.simplify();

                match (&l, &r) {
                    // 0 + x = x
                    (Expr::Number(0.0), _) => r,
                    // x + 0 = x
                    (_, Expr::Number(0.0)) => l,
                    // Constant folding: number + number
                    (Expr::Number(a), Expr::Number(b)) => Expr::Number(a + b),
                    // Default: return simplified
                    _ => Expr::Add(Box::new(l), Box::new(r)),
                }
            }

            // Multiplication simplifications
            Expr::Multiply(left, right) => {
                let l = left.simplify();
                let r = right.simplify();

                match (&l, &r) {
                    // 0 * x = 0
                    (Expr::Number(0.0), _) | (_, Expr::Number(0.0)) => Expr::Number(0.0),
                    // 1 * x = x
                    (Expr::Number(1.0), _) => r,
                    // x * 1 = x
                    (_, Expr::Number(1.0)) => l,
                    // Constant folding
                    (Expr::Number(a), Expr::Number(b)) => Expr::Number(a * b),
                    _ => Expr::Multiply(Box::new(l), Box::new(r)),
                }
            }

            // Power simplifications
            Expr::Power(base, exp) => {
                let b = base.simplify();
                let e = exp.simplify();

                match (&b, &e) {
                    // x^0 = 1
                    (_, Expr::Number(0.0)) => Expr::Number(1.0),
                    // x^1 = x
                    (_, Expr::Number(1.0)) => b,
                    // 0^x = 0 (assuming x != 0)
                    (Expr::Number(0.0), _) => Expr::Number(0.0),
                    // 1^x = 1
                    (Expr::Number(1.0), _) => Expr::Number(1.0),
                    // Constant folding
                    (Expr::Number(base), Expr::Number(exp)) => Expr::Number(base.powf(*exp)),
                    _ => Expr::Power(Box::new(b), Box::new(e)),
                }
            }

            // Negation simplifications
            Expr::Negate(expr) => {
                let e = expr.simplify();
                match &e {
                    // -(-x) = x
                    Expr::Negate(inner) => (**inner).clone(),
                    // Constant folding
                    Expr::Number(n) => Expr::Number(-n),
                    _ => Expr::Negate(Box::new(e)),
                }
            }

            // Recursively simplify other operations
            Expr::Subtract(left, right) => {
                let l = left.simplify();
                let r = right.simplify();
                match (&l, &r) {
                    (Expr::Number(a), Expr::Number(b)) => Expr::Number(a - b),
                    (_, Expr::Number(0.0)) => l,
                    _ => Expr::Subtract(Box::new(l), Box::new(r)),
                }
            }

            Expr::Divide(left, right) => {
                let l = left.simplify();
                let r = right.simplify();
                match (&l, &r) {
                    (Expr::Number(a), Expr::Number(b)) if *b != 0.0 => Expr::Number(a / b),
                    (_, Expr::Number(1.0)) => l,
                    _ => Expr::Divide(Box::new(l), Box::new(r)),
                }
            }

            // Base cases
            Expr::Number(_) | Expr::Variable(_) => self.clone(),
        }
    }

    // Convert to string representation
    fn to_string(&self) -> String {
        match self {
            Expr::Number(n) => format!("{}", n),
            Expr::Variable(name) => name.clone(),
            Expr::Add(left, right) => {
                format!("({} + {})", left.to_string(), right.to_string())
            }
            Expr::Subtract(left, right) => {
                format!("({} - {})", left.to_string(), right.to_string())
            }
            Expr::Multiply(left, right) => {
                format!("({} * {})", left.to_string(), right.to_string())
            }
            Expr::Divide(left, right) => {
                format!("({} / {})", left.to_string(), right.to_string())
            }
            Expr::Power(base, exp) => {
                format!("({} ^ {})", base.to_string(), exp.to_string())
            }
            Expr::Negate(expr) => {
                format!("(-{})", expr.to_string())
            }
        }
    }
}

fn main() {
    // Build expression: (x + 5) * (x - 3)
    let expr = Expr::Multiply(
        Box::new(Expr::Add(
            Box::new(Expr::Variable(String::from("x"))),
            Box::new(Expr::Number(5.0)),
        )),
        Box::new(Expr::Subtract(
            Box::new(Expr::Variable(String::from("x"))),
            Box::new(Expr::Number(3.0)),
        )),
    );

    println!("Expression: {}", expr.to_string());

    // Evaluate with x = 10
    let mut vars = HashMap::new();
    vars.insert(String::from("x"), 10.0);

    match expr.eval(&vars) {
        Ok(result) => println!("Result when x=10: {}", result),
        Err(e) => println!("Error: {}", e),
    }

    // Simplification example: (x * 0) + (y * 1)
    let complex_expr = Expr::Add(
        Box::new(Expr::Multiply(
            Box::new(Expr::Variable(String::from("x"))),
            Box::new(Expr::Number(0.0)),
        )),
        Box::new(Expr::Multiply(
            Box::new(Expr::Variable(String::from("y"))),
            Box::new(Expr::Number(1.0)),
        )),
    );

    println!("\nOriginal: {}", complex_expr.to_string());
    let simplified = complex_expr.simplify();
    println!("Simplified: {}", simplified.to_string());

    // Double negation: -(-x)
    let double_neg = Expr::Negate(Box::new(Expr::Negate(Box::new(
        Expr::Variable(String::from("x")),
    ))));
    println!("\nDouble negation: {}", double_neg.to_string());
    println!("Simplified: {}", double_neg.simplify().to_string());
}
```

---

## Real-World Example: JSON-like Data Structure

```rust
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
enum JsonValue {
    Null,
    Bool(bool),
    Number(f64),
    String(String),
    Array(Vec<JsonValue>),
    Object(HashMap<String, JsonValue>),
}

impl JsonValue {
    // Type checking methods
    fn is_null(&self) -> bool {
        matches!(self, JsonValue::Null)
    }

    fn is_number(&self) -> bool {
        matches!(self, JsonValue::Number(_))
    }

    fn is_string(&self) -> bool {
        matches!(self, JsonValue::String(_))
    }

    fn is_array(&self) -> bool {
        matches!(self, JsonValue::Array(_))
    }

    fn is_object(&self) -> bool {
        matches!(self, JsonValue::Object(_))
    }

    // Safe getters
    fn as_number(&self) -> Option<f64> {
        match self {
            JsonValue::Number(n) => Some(*n),
            _ => None,
        }
    }

    fn as_string(&self) -> Option<&str> {
        match self {
            JsonValue::String(s) => Some(s),
            _ => None,
        }
    }

    fn as_array(&self) -> Option<&Vec<JsonValue>> {
        match self {
            JsonValue::Array(arr) => Some(arr),
            _ => None,
        }
    }

    fn as_object(&self) -> Option<&HashMap<String, JsonValue>> {
        match self {
            JsonValue::Object(obj) => Some(obj),
            _ => None,
        }
    }

    // Get nested value by path
    fn get(&self, path: &[&str]) -> Option<&JsonValue> {
        if path.is_empty() {
            return Some(self);
        }

        match self {
            JsonValue::Object(map) => {
                let first = path[0];
                let rest = &path[1..];
                map.get(first).and_then(|val| val.get(rest))
            }
            JsonValue::Array(arr) => {
                let first = path[0];
                if let Ok(index) = first.parse::<usize>() {
                    let rest = &path[1..];
                    arr.get(index).and_then(|val| val.get(rest))
                } else {
                    None
                }
            }
            _ => None,
        }
    }

    // Pretty print
    fn to_pretty_string(&self, indent: usize) -> String {
        let indent_str = "  ".repeat(indent);
        let next_indent_str = "  ".repeat(indent + 1);

        match self {
            JsonValue::Null => String::from("null"),
            JsonValue::Bool(b) => format!("{}", b),
            JsonValue::Number(n) => format!("{}", n),
            JsonValue::String(s) => format!("\"{}\"", s),

            JsonValue::Array(arr) => {
                if arr.is_empty() {
                    String::from("[]")
                } else {
                    let items: Vec<String> = arr
                        .iter()
                        .map(|v| format!("{}{}", next_indent_str, v.to_pretty_string(indent + 1)))
                        .collect();
                    format!("[\n{}\n{}]", items.join(",\n"), indent_str)
                }
            }

            JsonValue::Object(obj) => {
                if obj.is_empty() {
                    String::from("{}")
                } else {
                    let items: Vec<String> = obj
                        .iter()
                        .map(|(k, v)| {
                            format!(
                                "{}\"{}\": {}",
                                next_indent_str,
                                k,
                                v.to_pretty_string(indent + 1)
                            )
                        })
                        .collect();
                    format!("{{\n{}\n{}}}", items.join(",\n"), indent_str)
                }
            }
        }
    }

    // Search for a value recursively
    fn fin
```
