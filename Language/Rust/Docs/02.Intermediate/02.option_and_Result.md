# Option and Result Types: Error Handling the Rust Way

## Introduction: Why Rust's Approach is Different

Most programming languages handle the absence of values and errors using:

- **Null/nil** - Leading to null pointer exceptions, the "billion-dollar mistake"
- **Exceptions** - Hidden control flow that can crash programs unexpectedly
- **Error codes** - Easy to ignore, requiring discipline to check

Rust takes a revolutionary approach: **make the possibility of absence and failure explicit in the type system**. This means:

- The compiler forces you to handle missing values
- Errors cannot be silently ignored
- Your code communicates whether operations can fail
- No unexpected crashes from unchecked null pointers

Let's dive deep into how this works.

---

## Part I: The Option Type

### What is Option?

`Option<T>` is an enum that represents a value that might or might not exist. It's defined as:

```rust
enum Option<T> {
    Some(T),  // Contains a value of type T
    None,     // No value present
}
```

**Why this exists:** In languages like Java, JavaScript, or C++, any reference can be null:

```javascript
// JavaScript - no type safety
let user = findUser(123);
console.log(user.name); // Runtime error if user is null!
```

In Rust, you **cannot** have a null reference. Instead:

```rust
fn find_user(id: u32) -> Option<User> {
    // Returns Some(user) if found, None if not
}

let user = find_user(123);
// Compiler forces you to handle None case!
```

---

### Basic Usage: Why Each Pattern Matters

#### Creating Option Values

```rust
fn main() {
    // Some: wraps a value that exists
    let some_number: Option<i32> = Some(5);
    let some_string: Option<String> = Some(String::from("hello"));

    // None: represents absence
    let absent_number: Option<i32> = None;

    // Option is so common it's in the prelude
    // You don't need Option::Some or Option::None
    let x = Some(42);
    let y: Option<i32> = None;
}
```

**Why this matters:** By making absence explicit, Rust prevents the entire class of null pointer errors. You can't accidentally use a None value—the compiler stops you.

---

### Pattern Matching with Option

#### The `match` Expression

```rust
fn divide(numerator: f64, denominator: f64) -> Option<f64> {
    if denominator == 0.0 {
        None  // Can't divide by zero
    } else {
        Some(numerator / denominator)  // Success case
    }
}

fn main() {
    let result = divide(10.0, 2.0);

    // match forces you to handle BOTH cases
    match result {
        Some(value) => println!("Result: {}", value),
        None => println!("Cannot divide by zero!"),
    }

    // This won't compile - you MUST handle None:
    // let value = result;  // Error! Can't use Option<f64> as f64
}
```

**Why use match:**

- **Exhaustiveness**: The compiler ensures you handle all possibilities
- **Safety**: No runtime crashes from forgetting to check for None
- **Clarity**: The code explicitly shows all paths

#### Real-World Example: Configuration Loading

```rust
use std::collections::HashMap;

struct Config {
    settings: HashMap<String, String>,
}

impl Config {
    fn new() -> Self {
        Config {
            settings: HashMap::new(),
        }
    }

    fn get(&self, key: &str) -> Option<&String> {
        self.settings.get(key)
    }

    fn load_setting(&self, key: &str) -> String {
        match self.get(key) {
            Some(value) => {
                println!("Found {}: {}", key, value);
                value.clone()
            }
            None => {
                println!("{} not found, using default", key);
                String::from("default_value")
            }
        }
    }
}

fn main() {
    let mut config = Config::new();
    config.settings.insert(String::from("database_url"),
                           String::from("localhost:5432"));

    // Explicit handling prevents bugs
    let db_url = config.load_setting("database_url");
    let api_key = config.load_setting("api_key");  // Not found, uses default

    println!("DB URL: {}", db_url);
    println!("API Key: {}", api_key);
}
```

**Why this pattern:** Configuration values might not exist. Option forces you to decide what happens when a setting is missing—use a default, show an error, or crash intentionally.

---

### The `if let` Pattern

```rust
fn main() {
    let some_value = Some(7);

    // Verbose match when you only care about Some
    match some_value {
        Some(value) => println!("Got value: {}", value),
        None => {},  // Empty - we don't care about None
    }

    // if let: concise for single pattern
    if let Some(value) = some_value {
        println!("Got value: {}", value);
    }

    // With else for the None case
    if let Some(value) = some_value {
        println!("Got value: {}", value);
    } else {
        println!("No value present");
    }
}
```

**Why use if let:**

- **Conciseness**: When you only care about one case
- **Readability**: Less ceremony than match for simple checks
- **Common pattern**: Checking if Option is Some and extracting the value

#### Practical Example: Command Line Arguments

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    // args.get(1) returns Option<&String>
    // It's None if no argument was provided
    if let Some(filename) = args.get(1) {
        println!("Processing file: {}", filename);
        // Do something with filename
    } else {
        println!("Usage: program <filename>");
        std::process::exit(1);
    }
}
```

**Why this matters:** Command line arguments might not exist. `if let` makes it explicit and concise to check and extract the value.

---

### Option Methods: Building Powerful Chains

Option has many methods that make working with optional values elegant and safe.

#### `unwrap()` - Use with Caution!

```rust
fn main() {
    let x = Some(5);
    let value = x.unwrap();  // Returns 5
    println!("Value: {}", value);

    let y: Option<i32> = None;
    // let value = y.unwrap();  // PANICS! Runtime crash
}
```

**Why unwrap exists but is dangerous:**

- **Convenience**: Quick for prototyping
- **Danger**: Crashes if None (defeats Rust's safety!)
- **Use case**: Only when you're 100% certain the value exists

**Better practice:**

```rust
fn main() {
    let x = Some(5);

    // Assert with custom message
    let value = x.expect("x should always have a value here");

    // Or handle explicitly
    let value = match x {
        Some(v) => v,
        None => {
            eprintln!("Error: x was None");
            std::process::exit(1);
        }
    };
}
```

---

#### `unwrap_or()` and `unwrap_or_else()` - Providing Defaults

```rust
fn main() {
    let some_value = Some(10);
    let no_value: Option<i32> = None;

    // unwrap_or: provide a default value
    println!("{}", some_value.unwrap_or(0));  // 10
    println!("{}", no_value.unwrap_or(0));    // 0

    // unwrap_or_else: compute default lazily
    let result = no_value.unwrap_or_else(|| {
        println!("Computing default...");
        42
    });
    println!("{}", result);  // 42
}
```

**Why these matter:**

- **unwrap_or**: Immediate default value, simple and fast
- **unwrap_or_else**: Lazy evaluation—computation only happens if None
- **Performance**: Use `unwrap_or_else` when default is expensive to compute

#### Real-World Example: User Preferences

```rust
struct UserPreferences {
    theme: Option<String>,
    font_size: Option<u32>,
    notifications: Option<bool>,
}

impl UserPreferences {
    fn get_theme(&self) -> String {
        // If user hasn't set theme, use default
        self.theme
            .clone()
            .unwrap_or_else(|| String::from("dark"))
    }

    fn get_font_size(&self) -> u32 {
        self.font_size.unwrap_or(14)
    }

    fn get_notifications(&self) -> bool {
        self.notifications.unwrap_or(true)
    }
}

fn main() {
    let prefs = UserPreferences {
        theme: None,
        font_size: Some(16),
        notifications: None,
    };

    println!("Theme: {}", prefs.get_theme());         // "dark"
    println!("Font size: {}", prefs.get_font_size()); // 16
    println!("Notifications: {}", prefs.get_notifications()); // true
}
```

**Why this pattern:** User preferences are often optional. This pattern provides sensible defaults without crashing or showing errors.

---

#### `map()` - Transforming the Inner Value

```rust
fn main() {
    let maybe_number = Some(5);

    // Transform the value if it exists
    let doubled = maybe_number.map(|n| n * 2);
    println!("{:?}", doubled);  // Some(10)

    let none: Option<i32> = None;
    let also_none = none.map(|n| n * 2);
    println!("{:?}", also_none);  // None

    // Chain transformations
    let result = Some("  hello  ")
        .map(|s| s.trim())           // Some("hello")
        .map(|s| s.to_uppercase())   // Some("HELLO")
        .map(|s| s.len());           // Some(5)

    println!("{:?}", result);  // Some(5)
}
```

**Why map is powerful:**

- **Functional style**: Transform values without explicit matching
- **Composability**: Chain multiple transformations
- **Safety**: Automatically handles None—no transformation applied

#### Practical Example: Processing User Input

```rust
fn parse_user_age(input: &str) -> Option<u32> {
    // Try to parse, returns Option
    input.trim().parse::<u32>().ok()
}

fn categorize_age(age: u32) -> &'static str {
    match age {
        0..=12 => "child",
        13..=19 => "teenager",
        20..=64 => "adult",
        _ => "senior",
    }
}

fn main() {
    let input = "  25  ";

    // Chain operations: parse → categorize
    let category = parse_user_age(input)
        .map(|age| categorize_age(age));

    match category {
        Some(cat) => println!("Category: {}", cat),
        None => println!("Invalid age input"),
    }

    // More concise with unwrap_or
    let input2 = "invalid";
    let category2 = parse_user_age(input2)
        .map(|age| categorize_age(age))
        .unwrap_or("unknown");

    println!("Category: {}", category2);  // "unknown"
}
```

**Why this pattern:** It separates parsing, validation, and transformation into clean, composable steps. Each step can fail (return None), and the chain handles it gracefully.

---

#### `and_then()` (flat_map) - Chaining Fallible Operations

```rust
fn main() {
    let maybe_number = Some(4);

    // and_then: when the operation returns Option
    let maybe_halved = maybe_number.and_then(|n| {
        if n % 2 == 0 {
            Some(n / 2)
        } else {
            None
        }
    });

    println!("{:?}", maybe_halved);  // Some(2)

    // Compare with map (returns Option<Option<T>>)
    let nested = maybe_number.map(|n| {
        if n % 2 == 0 {
            Some(n / 2)
        } else {
            None
        }
    });
    println!("{:?}", nested);  // Some(Some(2)) - nested!
}
```

**Why and_then vs map:**

- **map**: Use when transformation always succeeds
- **and_then**: Use when transformation might fail (returns Option)
- **Flattening**: `and_then` automatically flattens `Option<Option<T>>` to `Option<T>`

#### Real-World Example: Database Query Chain

```rust
use std::collections::HashMap;

#[derive(Debug)]
struct Database {
    users: HashMap<u32, User>,
    posts: HashMap<u32, Post>,
}

#[derive(Debug, Clone)]
struct User {
    id: u32,
    name: String,
}

#[derive(Debug)]
struct Post {
    id: u32,
    author_id: u32,
    content: String,
}

impl Database {
    fn get_user(&self, id: u32) -> Option<&User> {
        self.users.get(&id)
    }

    fn get_post(&self, id: u32) -> Option<&Post> {
        self.posts.get(&id)
    }

    // Get the author of a post
    fn get_post_author(&self, post_id: u32) -> Option<User> {
        self.get_post(post_id)             // Option<&Post>
            .and_then(|post| {             // Extract author_id
                self.get_user(post.author_id)  // Option<&User>
            })
            .cloned()                      // Clone to return owned User
    }
}

fn main() {
    let mut db = Database {
        users: HashMap::new(),
        posts: HashMap::new(),
    };

    db.users.insert(1, User { id: 1, name: String::from("Alice") });
    db.users.insert(2, User { id: 2, name: String::from("Bob") });

    db.posts.insert(100, Post {
        id: 100,
        author_id: 1,
        content: String::from("Hello World!"),
    });

    // Chain: get post → get its author
    match db.get_post_author(100) {
        Some(author) => println!("Post author: {}", author.name),
        None => println!("Post or author not found"),
    }

    // Non-existent post
    match db.get_post_author(999) {
        Some(author) => println!("Post author: {}", author.name),
        None => println!("Post or author not found"),
    }
}
```

**Why this pattern:** Database operations often chain—get a record, then use its ID to get another record. Each step might fail. `and_then` expresses this perfectly: if any step fails, the whole chain returns None.

---

#### `filter()` - Conditional Keeping

```rust
fn main() {
    let numbers = vec![Some(1), Some(4), None, Some(7), Some(10)];

    // Keep only Some values where number is even
    let even_numbers: Vec<_> = numbers
        .into_iter()
        .filter_map(|opt| opt.filter(|n| n % 2 == 0))
        .collect();

    println!("{:?}", even_numbers);  // [4, 10]
}

// More practical example
fn validate_age(age: u32) -> Option<u32> {
    Some(age).filter(|&a| a >= 18 && a <= 120)
}

fn main() {
    println!("{:?}", validate_age(25));   // Some(25)
    println!("{:?}", validate_age(10));   // None (too young)
    println!("{:?}", validate_age(150));  // None (too old)
}
```

**Why filter:** Combines validation with Option. Instead of separate checking and wrapping, `filter` does both: it keeps the value only if it passes the predicate.

---

#### `ok_or()` and `ok_or_else()` - Converting to Result

```rust
fn find_user(id: u32) -> Option<String> {
    if id == 1 {
        Some(String::from("Alice"))
    } else {
        None
    }
}

fn main() {
    let user = find_user(1);

    // Convert Option to Result
    let result: Result<String, &str> = user.ok_or("User not found");
    println!("{:?}", result);  // Ok("Alice")

    let user2 = find_user(999);
    let result2 = user2.ok_or_else(|| {
        format!("User with id {} not found", 999)
    });
    println!("{:?}", result2);  // Err("User with id 999 not found")
}
```

**Why convert:** Sometimes you need to integrate with code that uses Result. `ok_or` bridges the gap, turning absence (None) into an error.

---

#### `take()` - Taking Ownership

```rust
fn main() {
    let mut x = Some(5);

    // Take the value, leaving None in its place
    let value = x.take();

    println!("Value: {:?}", value);  // Some(5)
    println!("x is now: {:?}", x);   // None
}
```

**Why take:** Useful when you need to move a value out of an Option without cloning, especially in structs.

```rust
struct Connection {
    socket: Option<String>,  // Simplified; real sockets are complex
}

impl Connection {
    fn close(&mut self) -> Option<String> {
        // Take ownership of socket, leaving None
        self.socket.take()
    }
}

fn main() {
    let mut conn = Connection {
        socket: Some(String::from("connection123")),
    };

    if let Some(socket) = conn.close() {
        println!("Closed socket: {}", socket);
    }

    // socket is now None in conn
    println!("Socket after close: {:?}", conn.socket);  // None
}
```

---

### The `?` Operator with Option

The `?` operator works with Option in functions that return Option:

```rust
fn get_first_char(s: &str) -> Option<char> {
    s.chars().next()
}

fn get_second_char(s: &str) -> Option<char> {
    s.chars().nth(1)
}

// Without ? operator
fn get_both_verbose(s: &str) -> Option<(char, char)> {
    match get_first_char(s) {
        Some(first) => match get_second_char(s) {
            Some(second) => Some((first, second)),
            None => None,
        },
        None => None,
    }
}

// With ? operator
fn get_both(s: &str) -> Option<(char, char)> {
    let first = get_first_char(s)?;   // Returns None if None
    let second = get_second_char(s)?; // Returns None if None
    Some((first, second))
}

fn main() {
    println!("{:?}", get_both("Hello"));  // Some(('H', 'e'))
    println!("{:?}", get_both("H"));      // None
    println!("{:?}", get_both(""));       // None
}
```

**Why `?` is powerful:** It propagates None automatically, making code that chains optional operations clean and readable. If any step is None, the function immediately returns None.

#### Practical Example: Parsing Nested Data

```rust
use std::collections::HashMap;

#[derive(Debug)]
struct Config {
    data: HashMap<String, HashMap<String, String>>,
}

impl Config {
    fn get_nested(&self, section: &str, key: &str) -> Option<&String> {
        // Using ?

 to chain lookups
        let section_data = self.data.get(section)?;
        section_data.get(key)
    }

    // Without ?, this would be nested matches (ugly!)
    fn get_nested_verbose(&self, section: &str, key: &str) -> Option<&String> {
        match self.data.get(section) {
            Some(section_data) => section_data.get(key),
            None => None,
        }
    }
}

fn main() {
    let mut config = Config {
        data: HashMap::new(),
    };

    let mut database_section = HashMap::new();
    database_section.insert(String::from("host"), String::from("localhost"));
    database_section.insert(String::from("port"), String::from("5432"));

    config.data.insert(String::from("database"), database_section);

    // Clean nested lookup
    if let Some(host) = config.get_nested("database", "host") {
        println!("Database host: {}", host);
    }

    // Non-existent section
    if config.get_nested("cache", "ttl").is_none() {
        println!("Cache configuration not found");
    }
}
```

**Why this matters:** Nested data structures (JSON, config files, etc.) often have missing keys. The `?` operator makes traversing these structures concise and safe.

---

## Part II: The Result Type

### What is Result?

`Result<T, E>` is an enum that represents either success or failure:

```rust
enum Result<T, E> {
    Ok(T),   // Success with value of type T
    Err(E),  // Failure with error of type E
}
```

**Why Result exists:** Traditional error handling has problems:

- **Exceptions**: Hidden control flow, can be forgotten
- **Error codes**: Easy to ignore, must remember to check
- **Error returns**: Ambiguous (is -1 an error or valid?)

Result makes errors explicit and impossible to ignore.

---

### Basic Result Usage

```rust
fn divide(numerator: f64, denominator: f64) -> Result<f64, String> {
    if denominator == 0.0 {
        Err(String::from("Cannot divide by zero"))
    } else {
        Ok(numerator / denominator)
    }
}

fn main() {
    // Must handle both Ok and Err
    match divide(10.0, 2.0) {
        Ok(result) => println!("Result: {}", result),
        Err(e) => println!("Error: {}", e),
    }

    // This won't compile - can't use Result as the inner type:
    // let value: f64 = divide(10.0, 2.0);  // Error!
}
```

**Why this is better than exceptions:**

- **Visible in signature**: You know the function can fail
- **Compile-time checking**: Must handle the error
- **Type safety**: Error type is explicit

---

### Custom Error Types

String errors are okay for learning, but real applications use custom types:

```rust
#[derive(Debug)]
enum MathError {
    DivisionByZero,
    NegativeSquareRoot,
    Overflow,
}

fn divide(numerator: f64, denominator: f64) -> Result<f64, MathError> {
    if denominator == 0.0 {
        Err(MathError::DivisionByZero)
    } else {
        Ok(numerator / denominator)
    }
}

fn sqrt(value: f64) -> Result<f64, MathError> {
    if value < 0.0 {
        Err(MathError::NegativeSquareRoot)
    } else {
        Ok(value.sqrt())
    }
}

fn main() {
    match divide(10.0, 0.0) {
        Ok(result) => println!("Result: {}", result),
        Err(MathError::DivisionByZero) => {
            println!("Error: Cannot divide by zero");
        }
        Err(e) => println!("Other error: {:?}", e),
    }
}
```

**Why custom error types:**

- **Specific handling**: Match on different error cases
- **Documentation**: Errors in the type itself
- **No parsing**: Don't need to parse error strings

---

### The `?` Operator - Error Propagation

The `?` operator is Rust's killer feature for error handling:

```rust
use std::fs::File;
use std::io::{self, Read};

// Without ? operator - verbose and nested
fn read_file_verbose(path: &str) -> Result<String, io::Error> {
    let mut file = match File::open(path) {
        Ok(f) => f,
        Err(e) => return Err(e),
    };

    let mut contents = String::new();
    match file.read_to_string(&mut contents) {
        Ok(_) => Ok(contents),
        Err(e) => Err(e),
    }
}

// With ? operator - clean and linear
fn read_file(path: &str) -> Result<String, io::Error> {
    let mut file = File::open(path)?;  // Returns Err if open fails
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;  // Returns Err if read fails
    Ok(contents)
}

// Even more concise
fn read_file_concise(path: &str) -> Result<String, io::Error> {
    let mut contents = String::new();
    File::open(path)?.read_to_string(&mut contents)?;
    Ok(contents)
}

fn main() {
    match read_file("example.txt") {
        Ok(contents) => println!("File contents:\n{}", contents),
        Err(e) => println!("Error reading file: {}", e),
    }
}
```

**Why `?` is revolutionary:**

- **Concise**: One character instead of verbose matching
- **Linear flow**: Reads like non-error code
- **Early return**: Automatically returns Err on failure
- **Type conversion**: Automatically converts error types (with `From`)

---

### Chaining Operations with Result

Just like Option, Result has powerful methods:

#### `map()` and `map_err()`

```rust
fn parse_number(s: &str) -> Result<i32, std::num::ParseIntError> {
    s.parse()
}

fn main() {
    let result = parse_number("42");

    // Transform Ok value
    let doubled = result.map(|n| n * 2);
    println!("{:?}", doubled);  // Ok(84)

    // Transform Err value
    let with_context = parse_number("abc")
        .map_err(|e| format!("Parse error: {}", e));
    println!("{:?}", with_context);  // Err("Parse error: ...")
}
```

**Why map and map_err:**

- **map**: Transform success values without changing error handling
- **map_err**: Add context to errors, convert error types
- **Composability**: Chain transformations cleanly

---

#### `and_then()` - Chaining Fallible Operations

```rust
fn parse_number(s: &str) -> Result<i32, String> {
    s.parse().map_err(|e| format!("Parse error: {}", e))
}

fn divide_by_two(n: i32) -> Result<i32, String> {
    if n % 2 == 0 {
        Ok(n / 2)
    } else {
        Err(String::from("Number is not even"))
    }
}

fn main() {
    let result = parse_number("42")
        .and_then(|n| divide_by_two(n));

    println!("{:?}", result);  // Ok(21)

    let result2 = parse_number("43")
        .and_then(|n| divide_by_two(n));

    println!("{:?}", result2);  // Err("Number is not even")

    let result3 = parse_number("abc")
        .and_then(|n| divide_by_two(n));

    println!("{:?}", result3);  // Err("Parse error: ...")
}
```

**Why and_then:** Chain operations where each can fail. If any step fails, the whole chain fails with that error.

---

### Real-World Example: User Registration System

```rust
#[derive(Debug)]
enum RegistrationError {
    InvalidEmail,
    WeakPassword,
    UsernameTaken,
    DatabaseError(String),
}

struct User {
    username: String,
    email: String,
    password_hash: String,
}

struct UserService {
    existing_usernames: Vec<String>,
}

impl UserService {
    fn new() -> Self {
        UserService {
            existing_usernames: vec![
                String::from("alice"),
                String::from("bob"),
            ],
        }
    }

    fn validate_email(&self, email: &str) -> Result<(), RegistrationError> {
        if email.contains('@') && email.contains('.') {
            Ok(())
        } else {
            Err(RegistrationError::InvalidEmail)
        }
    }

    fn validate_password(&self, password: &str) -> Result<(), RegistrationError> {
        if password.len() >= 8 {
            Ok(())
        } else {
            Err(RegistrationError::WeakPassword)
        }
    }

    fn check_username_available(&self, username: &str) -> Result<(), RegistrationError> {
        if self.existing_usernames.contains(&username.to_string()) {
            Err(RegistrationError::UsernameTaken)
        } else {
            Ok(())
        }
    }

    fn hash_password(&self, password: &str) -> Result<String, RegistrationError> {
        // Simplified - real hashing would use bcrypt or argon2
        if password.is_empty() {
            Err(RegistrationError::WeakPassword)
        } else {
            Ok(format!("hashed_{}", password))
        }
    }

    fn save_to_database(&self, user: &User) -> Result<(), RegistrationError> {
        // Simulate database operation
        println!("Saving user {} to database...", user.username);
        Ok(())
    }

    // Main registration method using ? operator
    fn register_user(
        &mut self,
        username: &str,
        email: &str,
        password: &str,
    ) -> Result<User, RegistrationError> {
        // Each step can fail, ? propagates the error
        self.validate_email(email)?;
        self.validate_password(password)?;
        self.check_username_available(username)?;

        let password_hash = self.hash_password(password)?;

        let user = User {
            username: username.to_string(),
            email: email.to_string(),
            password_hash,
        };

        self.save_to_database(&user)?;
        self.existing_usernames.push(username.to_string());

        Ok(user)
    }
}

```

"Invalid email format"),
("eve", "eve@example.com", "short", "Weak password"),
("alice", "alice@example.com", "password123", "Username taken"),
];

    for (username, email, password, expected) in test_cases {
        match service.register_user(username, email, password) {
            Ok(user) => println!("✓ User {} registered", user.username),
            Err(e) => println!("✗ {} - Error: {:?}", expected, e),
        }
    }

}

````

**Why this pattern works:**
- **Clear validation**: Each validation step is a separate function
- **Early returns**: `?` exits immediately on first error
- **Type safety**: Impossible to forget to validate
- **Maintainability**: Easy to add new validation steps

---

### Working with Multiple Error Types

Real applications deal with different error types. Here's how to handle them:

#### Using `Box<dyn Error>`

```rust
use std::error::Error;
use std::fs::File;
use std::io::Read;

// Box<dyn Error> accepts any error type
fn read_and_parse(path: &str) -> Result<i32, Box<dyn Error>> {
    let mut file = File::open(path)?;  // io::Error
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;  // io::Error
    let number: i32 = contents.trim().parse()?;  // ParseIntError
    Ok(number)
}

fn main() {
    match read_and_parse("number.txt") {
        Ok(num) => println!("Number: {}", num),
        Err(e) => println!("Error: {}", e),
    }
}
````

**Why Box<dyn Error>:**

- **Flexibility**: Accepts any error type
- **Simplicity**: Don't need to define custom error enum
- **Downside**: Loses specific type information

---

#### Creating a Unified Error Type

For better control, create an enum that wraps all possible errors:

```rust
use std::fs::File;
use std::io::{self, Read};
use std::num::ParseIntError;
use std::fmt;

#[derive(Debug)]
enum AppError {
    Io(io::Error),
    Parse(ParseIntError),
    Custom(String),
}

// Implement Display for nice error messages
impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::Io(e) => write!(f, "IO error: {}", e),
            AppError::Parse(e) => write!(f, "Parse error: {}", e),
            AppError::Custom(msg) => write!(f, "Error: {}", msg),
        }
    }
}

// Implement Error trait
impl Error for AppError {}

// Implement From for automatic conversion with ?
impl From<io::Error> for AppError {
    fn from(error: io::Error) -> Self {
        AppError::Io(error)
    }
}

impl From<ParseIntError> for AppError {
    fn from(error: ParseIntError) -> Self {
        AppError::Parse(error)
    }
}

// Now ? operator automatically converts errors
fn read_and_parse(path: &str) -> Result<i32, AppError> {
    let mut file = File::open(path)?;  // Converts io::Error to AppError
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;  // Converts io::Error to AppError

    let number: i32 = contents.trim().parse()?;  // Converts ParseIntError to AppError

    if number < 0 {
        return Err(AppError::Custom(String::from("Number must be positive")));
    }

    Ok(number)
}

fn main() {
    match read_and_parse("number.txt") {
        Ok(num) => println!("Number: {}", num),
        Err(e) => println!("{}", e),
    }
}
```

**Why unified error types:**

- **Type safety**: Preserve all error information
- **Specific handling**: Match on different error variants
- **Automatic conversion**: `From` trait makes `?` work seamlessly
- **Better error messages**: Custom Display implementation

---

### The `anyhow` and `thiserror` Crates

For production code, these crates make error handling even better:

#### Using `anyhow` for Applications

```rust
use anyhow::{Context, Result};
use std::fs;

// anyhow::Result is Result<T, anyhow::Error>
fn read_config(path: &str) -> Result<String> {
    let contents = fs::read_to_string(path)
        .context("Failed to read config file")?;  // Add context

    if contents.is_empty() {
        anyhow::bail!("Config file is empty");  // Create error and return
    }

    Ok(contents)
}

fn parse_config(contents: &str) -> Result<i32> {
    contents
        .trim()
        .parse()
        .context("Failed to parse config value")  // Chain context
}

fn load_and_parse_config(path: &str) -> Result<i32> {
    let contents = read_config(path)?;
    let value = parse_config(&contents)?;
    Ok(value)
}

fn main() {
    match load_and_parse_config("config.txt") {
        Ok(value) => println!("Config value: {}", value),
        Err(e) => {
            eprintln!("Error: {}", e);
            // Print full error chain
            for cause in e.chain() {
                eprintln!("  Caused by: {}", cause);
            }
        }
    }
}
```

**Why anyhow:**

- **Context**: Easily add context to errors
- **Error chains**: See the full error chain
- **Simplicity**: No need to define error types
- **Best for**: Applications (not libraries)

---

#### Using `thiserror` for Libraries

```rust
use thiserror::Error;

#[derive(Error, Debug)]
enum DatabaseError {
    #[error("Connection failed: {0}")]
    ConnectionFailed(String),

    #[error("Query failed: {query}")]
    QueryFailed { query: String },

    #[error("User {username} not found")]
    UserNotFound { username: String },

    #[error(transparent)]
    IoError(#[from] std::io::Error),  // Automatic conversion
}

fn connect_to_database(url: &str) -> Result<(), DatabaseError> {
    if url.is_empty() {
        Err(DatabaseError::ConnectionFailed(
            String::from("URL is empty")
        ))
    } else {
        Ok(())
    }
}

fn find_user(username: &str) -> Result<String, DatabaseError> {
    if username == "alice" {
        Ok(String::from("Alice"))
    } else {
        Err(DatabaseError::UserNotFound {
            username: username.to_string(),
        })
    }
}

fn main() {
    match connect_to_database("") {
        Ok(_) => println!("Connected"),
        Err(e) => println!("{}", e),  // Prints: Connection failed: URL is empty
    }

    match find_user("bob") {
        Ok(user) => println!("Found: {}", user),
        Err(e) => println!("{}", e),  // Prints: User bob not found
    }
}
```

**Why thiserror:**

- **Derive macro**: Automatically implements Error and Display
- **Custom messages**: Format strings in the error definition
- **Type safety**: Full compile-time checking
- **Best for**: Libraries (preserve error types)

---

### Combining Option and Result

Sometimes you need to convert between Option and Result:

```rust
fn find_user(id: u32) -> Option<String> {
    if id == 1 {
        Some(String::from("Alice"))
    } else {
        None
    }
}

fn main() {
    // Option to Result
    let result: Result<String, &str> = find_user(1)
        .ok_or("User not found");
    println!("{:?}", result);  // Ok("Alice")

    // Result to Option
    let parsed: Result<i32, _> = "42".parse();
    let option = parsed.ok();
    println!("{:?}", option);  // Some(42)

    // Chaining conversions
    let user_age = find_user(1)
        .ok_or("User not found")
        .and_then(|name| {
            if name == "Alice" {
                Ok(25)
            } else {
                Err("Age not found")
            }
        });
    println!("{:?}", user_age);  // Ok(25)
}
```

**Why convert:**

- **ok_or/ok_or_else**: Turn None into a specific error
- **ok()**: Discard error information (None if error)
- **Flexibility**: Use the right type for each situation

---

### Real-World Example: File Processing Pipeline

Let's build a complete example showing everything together:

```rust
use std::fs::File;
use std::io::{self, BufRead, BufReader, Write};
use std::path::Path;

#[derive(Debug)]
enum ProcessingError {
    Io(io::Error),
    Parse(String),
    Validation(String),
}

impl From<io::Error> for ProcessingError {
    fn from(error: io::Error) -> Self {
        ProcessingError::Io(error)
    }
}

impl std::fmt::Display for ProcessingError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            ProcessingError::Io(e) => write!(f, "IO error: {}", e),
            ProcessingError::Parse(msg) => write!(f, "Parse error: {}", msg),
            ProcessingError::Validation(msg) => write!(f, "Validation error: {}", msg),
        }
    }
}

impl std::error::Error for ProcessingError {}

#[derive(Debug)]
struct Record {
    id: u32,
    name: String,
    score: f64,
}

impl Record {
    fn from_line(line: &str) -> Result<Self, ProcessingError> {
        let parts: Vec<&str> = line.split(',').collect();

        if parts.len() != 3 {
            return Err(ProcessingError::Parse(
                format!("Expected 3 fields, got {}", parts.len())
            ));
        }

        let id = parts[0]
            .trim()
            .parse()
            .map_err(|_| ProcessingError::Parse(
                format!("Invalid ID: {}", parts[0])
            ))?;

        let name = parts[1].trim().to_string();

        if name.is_empty() {
            return Err(ProcessingError::Validation(
                String::from("Name cannot be empty")
            ));
        }

        let score = parts[2]
            .trim()
            .parse()
            .map_err(|_| ProcessingError::Parse(
                format!("Invalid score: {}", parts[2])
            ))?;

        if score < 0.0 || score > 100.0 {
            return Err(ProcessingError::Validation(
                format!("Score must be between 0 and 100, got {}", score)
            ));
        }

        Ok(Record { id, name, score })
    }

    fn to_line(&self) -> String {
        format!("{},{},{}", self.id, self.name, self.score)
    }
}

struct FileProcessor {
    input_path: String,
    output_path: String,
}

impl FileProcessor {
    fn new(input_path: String, output_path: String) -> Self {
        FileProcessor {
            input_path,
            output_path,
        }
    }

    fn process(&self) -> Result<ProcessingStats, ProcessingError> {
        let file = File::open(&self.input_path)?;
        let reader = BufReader::new(file);

        let mut output = File::create(&self.output_path)?;
        let mut stats = ProcessingStats::new();

        for (line_num, line) in reader.lines().enumerate() {
            let line = line?;

            // Skip empty lines
            if line.trim().is_empty() {
                continue;
            }

            match Record::from_line(&line) {
                Ok(record) => {
                    stats.processed += 1;

                    // Only write records with score >= 60
                    if record.score >= 60.0 {
                        writeln!(output, "{}", record.to_line())?;
                        stats.passed += 1;
                    } else {
                        stats.failed += 1;
                    }
                }
                Err(e) => {
                    stats.errors += 1;
                    eprintln!("Error on line {}: {}", line_num + 1, e);
                }
            }
        }

        Ok(stats)
    }
}

#[derive(Debug)]
struct ProcessingStats {
    processed: usize,
    passed: usize,
    failed: usize,
    errors: usize,
}

impl ProcessingStats {
    fn new() -> Self {
        ProcessingStats {
            processed: 0,
            passed: 0,
            failed: 0,
            errors: 0,
        }
    }

    fn print(&self) {
        println!("\n=== Processing Statistics ===");
        println!("Total processed: {}", self.processed);
        println!("Passed (score >= 60): {}", self.passed);
        println!("Failed (score < 60): {}", self.failed);
        println!("Errors: {}", self.errors);
        println!("============================\n");
    }
}

fn main() {
    // Create sample input file
    let sample_data = "\
1,Alice,85.5
2,Bob,45.0
3,Charlie,92.0
4,,75.0
5,David,invalid
6,Eve,110.0
7,Frank,68.5
";

    std::fs::write("input.csv", sample_data).expect("Failed to create input file");

    // Process the file
    let processor = FileProcessor::new(
        String::from("input.csv"),
        String::from("output.csv"),
    );

    match processor.process() {
        Ok(stats) => {
            println!("✓ Processing completed successfully");
            stats.print();

            // Read and display output
            match std::fs::read_to_string("output.csv") {
                Ok(contents) => {
                    println!("Output file contents:");
                    println!("{}", contents);
                }
                Err(e) => eprintln!("Failed to read output: {}", e),
            }
        }
        Err(e) => {
            eprintln!("✗ Processing failed: {}", e);
        }
    }

    // Cleanup
    let _ = std::fs::remove_file("input.csv");
    let _ = std::fs::remove_file("output.csv");
}
```

**Why this pattern works:**

1. **Custom error type**: Unifies different error sources
2. **? operator**: Makes error propagation clean
3. **Partial success**: Processes what it can, logs errors
4. **Statistics**: Tracks successes, failures, and errors
5. **Type safety**: Compiler ensures all errors are handled

---

### Best Practices for Error Handling

#### 1. Use Result for Operations That Can Fail

```rust
// ✗ Bad: Using panic
fn divide_bad(a: i32, b: i32) -> i32 {
    if b == 0 {
        panic!("Cannot divide by zero!");
    }
    a / b
}

// ✓ Good: Using Result
fn divide_good(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err(String::from("Cannot divide by zero"))
    } else {
        Ok(a / b)
    }
}
```

**Why:** panics crash the program. Result lets the caller decide how to handle the error.

---

#### 2. Use Option for Optional Values

```rust
// ✗ Bad: Using special values
fn find_position_bad(arr: &[i32], target: i32) -> isize {
    for (i, &val) in arr.iter().enumerate() {
        if val == target {
            return i as isize;
        }
    }
    -1  // Magic number means "not found"
}

// ✓ Good: Using Option
fn find_position_good(arr: &[i32], target: i32) -> Option<usize> {
    for (i, &val) in arr.iter().enumerate() {
        if val == target {
            return Some(i);
        }
    }
    None
}
```

**Why:** Magic values (-1, null, etc.) can be misused. Option makes absence explicit.

---

#### 3. Add Context to Errors

```rust
use std::fs;

// ✗ Less helpful
fn read_config_bad(path: &str) -> Result<String, std::io::Error> {
    fs::read_to_string(path)
}

// ✓ More helpful
fn read_config_good(path: &str) -> Result<String, String> {
    fs::read_to_string(path)
        .map_err(|e| format!("Failed to read config file '{}': {}", path, e))
}
```

**Why:** Context helps debugging. Users know what file caused the error.

---

#### 4. Don't Overuse `unwrap()` and `expect()`

```rust
fn main() {
    // ✗ Bad in production: Can crash
    let file = File::open("important.txt").unwrap();

    // ✓ Better: Handle the error
    let file = match File::open("important.txt") {
        Ok(f) => f,
        Err(e) => {
            eprintln!("Failed to open file: {}", e);
            return;
        }
    };

    // ✓ Also good: Use expect with a message
    let file = File::open("important.txt")
        .expect("important.txt must exist");
}
```

**Why:** `unwrap()` crashes without explanation. Use it only when failure is impossible or during prototyping.

---

#### 5. Use the `?` Operator

```rust
// ✗ Verbose
fn read_and_process_verbose(path: &str) -> Result<i32, Box<dyn std::error::Error>> {
    let contents = match std::fs::read_to_string(path) {
        Ok(c) => c,
        Err(e) => return Err(Box::new(e)),
    };

    let number = match contents.trim().parse::<i32>() {
        Ok(n) => n,
        Err(e) => return Err(Box::new(e)),
    };

    Ok(number * 2)
}

// ✓ Clean
fn read_and_process_clean(path: &str) -> Result<i32, Box<dyn std::error::Error>> {
    let contents = std::fs::read_to_string(path)?;
    let number = contents.trim().parse::<i32>()?;
    Ok(number * 2)
}
```

**Why:** `?` makes error handling code as clean as non-error code.

---

#### 6. Return Early on Errors

```rust
fn validate_user(username: &str, age: i32) -> Result<(), String> {
    // ✓ Good: Early returns
    if username.is_empty() {
        return Err(String::from("Username cannot be empty"));
    }

    if age < 0 {
        return Err(String::from("Age cannot be negative"));
    }

    if age > 150 {
        return Err(String::from("Age seems invalid"));
    }

    Ok(())
}
```

**Why:** Reduces nesting, makes happy path clear, easier to read.

---

#### 7. Use Custom Error Types for Libraries

```rust
// ✓ Good for library code
#[derive(Debug)]
pub enum MyLibraryError {
    InvalidInput(String),
    NotFound,
    Timeout,
}

impl std::fmt::Display for MyLibraryError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            MyLibraryError::InvalidInput(msg) => write!(f, "Invalid input: {}", msg),
            MyLibraryError::NotFound => write!(f, "Resource not found"),
            MyLibraryError::Timeout => write!(f, "Operation timed out"),
        }
    }
}

impl std::error::Error for MyLibraryError {}
```

**Why:** Library users can match on specific errors. Provides better API.

---

### Summary: When to Use What

| Situation                 | Use                     | Why                         |
| ------------------------- | ----------------------- | --------------------------- |
| Value might not exist     | `Option<T>`             | No error, just absence      |
| Operation can fail        | `Result<T, E>`          | Errors need handling        |
| Prototyping/examples      | `.unwrap()`             | Quick, acceptable in demos  |
| Production with certainty | `.expect("reason")`     | Documents why it can't fail |
| Need default value        | `.unwrap_or(default)`   | Provides fallback           |
| Chaining operations       | `.map()`, `.and_then()` | Functional composition      |
| Early error return        | `?` operator            | Clean error propagation     |
| Application errors        | `anyhow`                | Context and convenience     |
| Library errors            | `thiserror`             | Type-safe public API        |

---

### Complete Real-World Example: REST API Client

```rust
use std::collections::HashMap;

#[derive(Debug)]
enum ApiError {
    NetworkError(String),
    ParseError(String),
    NotFound,
    Unauthorized,
    RateLimited,
    ServerError(u16),
}

impl std::fmt::Display for ApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            ApiError::NetworkError(msg) => write!(f, "Network error: {}", msg),
            ApiError::ParseError(msg) => write!(f, "Parse error: {}", msg),
            ApiError::NotFound => write!(f, "Resource not found"),
            ApiError::Unauthorized => write!(f, "Unauthorized"),
            ApiError::RateLimited => write!(f, "Rate limit exceeded"),
            ApiError::ServerError(code) => write!(f, "Server error: {}", code),
        }
    }
}

impl std::error::Error for ApiError {}

#[derive(Debug, Clone)]
struct User {
    id: u32,
    name: String,
    email: String,
}

struct ApiClient {
    base_url: String,
    api_key: Option<String>,
    users: HashMap<u32, User>,  // Simulated database
}

impl ApiClient {
    fn new(base_url: String) -> Self {
        let mut users = HashMap::new();
        users.insert(1, User {
            id: 1,
            name: String::from("Alice"),
            email: String::from("alice@example.com"),
        });
        users.insert(2, User {
            id: 2,
            name: String::from("Bob"),
            email: String::from("bob@example.com"),
        });

        ApiClient {
            base_url,
            api_key: None,
            users,
        }
    }

    fn with_api_key(mut self, key: String) -> Self {
        self.api_key = Some(key);
        self
    }

    fn check_auth(&self) -> Result<(), ApiError> {
        self.api_key
            .as_ref()
            .ok_or(ApiError::Unauthorized)
            .and_then(|key| {
                if key == "valid_key" {
                    Ok(())
                } else {
                    Err(ApiError::Unauthorized)
                }
            })
    }

    fn get_user(&self, id: u32) -> Result<User, ApiError> {
        self.check_auth()?;

        self.users
            .get(&id)
            .cloned()
            .ok_or(ApiError::NotFound)
    }

    fn list_users(&self) -> Result<Vec<User>, ApiError> {
        self.check_auth()?;

        Ok(self.users.values().cloned().collect())
    }

    fn create_user(&mut self, name: String, email: String) -> Result<User, ApiError> {
        self.check_auth()?;

        if name.is_empty() {
            return Err(ApiError::ParseError(
                String::from("Name cannot be empty")
            ));
        }

        if !email.contains('@') {
            return Err(ApiError::ParseError(
                String::from("Invalid email format")
            ));
        }

        let id = self.users.len() as u32 + 1;
        let user = User { id, name, email };

        self.users.insert(id, user.clone());
        Ok(user)
    }

    fn update_user(&mut self, id: u32, name: Option<String>, email: Option<String>)
        -> Result<User, ApiError> {
        self.check_auth()?;

        let user = self.users
            .get_mut(&id)
            .ok_or(ApiError::NotFound)?;

        if let Some(new_name) = name {
            if !new_name.is_empty() {
                user.name = new_name;
            }
        }

        if let Some(new_email) = email {
            if new_email.contains('@') {
                user.email = new_email;
            } else {
                return Err(ApiError::ParseError(
                    String::from("Invalid email format")
                ));
            }
        }

        Ok(user.clone())
    }

    fn delete_user(&mut self, id: u32) -> Result<(), ApiError> {
        self.check_auth()?;

        self.users
            .remove(&id)
            .ok_or(ApiError::NotFound)?;

        Ok(())
    }
}

fn main() {
    println!("=== API Client Demo ===\n");

    // Create client without auth
    let mut client = ApiClient::new(String::from("https://api.example.com"));

    // Try without authentication
    println!("1. Attempting to list users without auth:");
    match client.list_users() {
        Ok(_) => println!("  Success (unexpected)"),
        Err(e) => println!("  ✗ Error: {}", e),
    }

    // Add authentication
    client = client.with_api_key(String::from("valid_key"));

    // List users
    println!("\n2. Listing users with auth:");
    match client.list_users() {
        Ok(users) => {
            println!("  ✓ Found {} users:", users.len());
            for user in users {
                println!("    - {} ({})", user.name, user.email);
            }
        }
        Err(e) => println!("  ✗ Error: {}", e),
    }

    // Get specific user
    println!("\n3. Getting user with ID 1:");
    match client.get_user(1) {
        Ok(user) => println!("  ✓ Found: {} ({})", user.name, user.email),
        Err(e) => println!("  ✗ Error: {}", e),
    }

    // Try to get non-existent user
    println!("\n4. Getting non-existent user (ID 999):");
    match client.get_user(999) {
        Ok(user) => println!("  Found: {}", user.name),
        Err(e) => println!("  ✗ Error: {}", e),
    }

    // Create new user
    println!("\n5. Creating new user:");
    match client.create_user(
        String::from("Charlie"),
        String::from("charlie@example.com")
    ) {
        Ok(user) => println!("  ✓ Created: {} with ID {}", user.name, user.id),
        Err(e) => println!("  ✗ Error: {}", e),
    }

    // Try to create user with invalid email
    println!("\n6. Creating user with invalid email:");
    match client.create_user(
        String::from("Invalid"),
        String::from("not-an-email")
    ) {
        Ok(user) => println!("  Created: {}", user.name),
        Err(e) => println!("  ✗ Error: {}", e),
    }

    // Update user
    println!("\n7. Updating user 1:");
    match client.update_user(1, Some(String::from("Alice Updated")), None) {
        Ok(user) => println!("  ✓ Updated: {} ({})", user.name, user.email),
        Err(e) => println!("  ✗ Error: {}", e),
    }

    // Delete user
    println!("\n8. Deleting user 2:");
    match client.delete_user(2) {
        Ok(_) => println!("  ✓ User deleted"),
        Err(e) => println!("  ✗ Error: {}", e),
    }

    // Verify deletion
    println!("\n9. Verifying deletion (get user 2):");
    match client.get_user(2) {
        Ok(user) => println!("  Still exists: {}", user.name),
        Err(e) => println!("  ✗ Error (expected): {}", e),
    }

    // Final user list
    println!("\n10. Final user list:");
    if let Ok(users) = client.list_users() {
        println!("  ✓ {} users remaining:", users.len());
        for user in users {
            println!("    - {} ({})", user.name, user.email);
        }
    }
}
```

**Why this example demonstrates best practices:**

1. **Custom error type**: Specific errors for different failure modes
2. **Authentication check**: Uses `?` to propagate auth failures
3. **Chaining with `?`**: Clean error propagation throughout
4. **Option for optional fields**: `update_user` uses Option for optional updates
5. **Builder pattern**: `with_api_key` for fluent configuration
6. **Comprehensive error handling**: Every operation can fail gracefully
7. **No panics**: Production-ready error handling

---

## Conclusion

Rust's error handling through `Option` and `Result` represents a fundamental shift in how we think about errors:

- **Option**: Makes absence explicit and impossible to ignore
- **Result**: Makes failure explicit and impossible to ignore
- **Type system**: Compiler ensures you handle all cases
- **? operator**: Makes error handling as clean as non-error code
- **Composability**: Chain operations naturally with `map`, `and_then`, etc.

This approach eliminates entire classes of bugs (null pointer crashes, unhandled exceptions) while maintaining clean, readable code. The initial learning curve pays off with more reliable, maintainable software.
