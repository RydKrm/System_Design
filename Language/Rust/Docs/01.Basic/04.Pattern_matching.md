# Pattern Matching in Rust: A Comprehensive Guide

## Understanding Pattern Matching

**Pattern matching** is one of Rust's most powerful and distinctive features. It allows you to compare a value against a series of patterns and execute code based on which pattern matches. Think of it as a supercharged `switch` statement from other languages, but far more versatile and safe. Rust's compiler ensures that pattern matching is **exhaustive**, meaning you must handle all possible cases, which eliminates an entire category of bugs.

Pattern matching in Rust goes beyond simple value comparisonâ€”you can destructure complex data types, bind variables, add guards, and much more. It's a fundamental tool for writing clear, correct, and idiomatic Rust code.

## The `match` Expression

### Basic Match Syntax

The `match` expression is the primary way to do pattern matching in Rust:

```rust
fn main() {
    let number = 3;

    match number {
        1 => println!("One!"),
        2 => println!("Two!"),
        3 => println!("Three!"),
        4 => println!("Four!"),
        5 => println!("Five!"),
        _ => println!("Something else"),
    }
}
```

**Key Points:**

- Each pattern is called an "arm" of the match
- Arms are separated by commas
- The `_` pattern matches anything (like a wildcard)
- Match expressions must be exhaustive

### Match is an Expression

Like `if`, `match` is an expression that returns a value:

```rust
fn main() {
    let number = 4;

    let description = match number {
        1 => "one",
        2 => "two",
        3 => "three",
        4 => "four",
        5 => "five",
        _ => "many",
    };

    println!("The number is: {}", description);

    // Using the returned value directly
    let result = match number {
        n if n % 2 == 0 => n * 2,
        n => n * 3,
    };

    println!("Result: {}", result);
}
```

**Important:** When using `match` as an expression, all arms must return the same type:

```rust
fn main() {
    let number = 3;

    // This will NOT compile:
    // let value = match number {
    //     1 => "one",      // Returns &str
    //     2 => 2,          // Returns i32 - ERROR!
    //     _ => "other",
    // };

    // Correct: all arms return &str
    let value = match number {
        1 => "one",
        2 => "two",
        _ => "other",
    };

    println!("{}", value);
}
```

### Multiple Patterns with `|`

You can match multiple patterns in a single arm using the `|` operator:

```rust
fn main() {
    let number = 2;

    match number {
        1 | 2 => println!("One or two"),
        3 | 4 | 5 => println!("Three, four, or five"),
        6..=10 => println!("Six through ten"),
        _ => println!("Something else"),
    }

    // Practical example: weekday vs weekend
    let day = "Saturday";

    let day_type = match day {
        "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" => "Weekday",
        "Saturday" | "Sunday" => "Weekend",
        _ => "Invalid day",
    };

    println!("{} is a {}", day, day_type);
}
```

### Matching Ranges

Rust allows you to match ranges of values:

```rust
fn main() {
    let age = 25;

    match age {
        0..=12 => println!("Child"),
        13..=19 => println!("Teenager"),
        20..=64 => println!("Adult"),
        65..=120 => println!("Senior"),
        _ => println!("Invalid age"),
    }

    // Character ranges
    let letter = 'g';

    match letter {
        'a'..='z' => println!("Lowercase letter"),
        'A'..='Z' => println!("Uppercase letter"),
        '0'..='9' => println!("Digit"),
        _ => println!("Other character"),
    }
}
```

### Exhaustiveness: All Cases Must Be Covered

Rust requires that match expressions handle all possible cases:

```rust
fn main() {
    let number = 5;

    // This will NOT compile:
    // match number {
    //     1 => println!("One"),
    //     2 => println!("Two"),
    // }
    // ERROR: non-exhaustive patterns

    // You must handle all cases:
    match number {
        1 => println!("One"),
        2 => println!("Two"),
        _ => println!("Other"),  // Catch-all pattern
    }

    // For enums, you must match all variants:
    let direction = Direction::North;

    match direction {
        Direction::North => println!("Going north"),
        Direction::South => println!("Going south"),
        Direction::East => println!("Going east"),
        Direction::West => println!("Going west"),
        // If you remove any of these, it won't compile!
    }
}

enum Direction {
    North,
    South,
    East,
    West,
}
```

## Destructuring with Patterns

### Destructuring Tuples

```rust
fn main() {
    let point = (3, 5);

    match point {
        (0, 0) => println!("Origin"),
        (0, y) => println!("On the y-axis at y = {}", y),
        (x, 0) => println!("On the x-axis at x = {}", x),
        (x, y) => println!("Point at ({}, {})", x, y),
    }

    // Destructuring in function parameters
    print_coordinates((10, 20));
}

fn print_coordinates((x, y): (i32, i32)) {
    println!("Coordinates: x = {}, y = {}", x, y);
}
```

### Destructuring Structs

```rust
fn main() {
    let person = Person {
        name: String::from("Alice"),
        age: 30,
        email: String::from("alice@example.com"),
    };

    match person {
        Person { name, age: 30, .. } => {
            println!("{} is exactly 30 years old", name);
        }
        Person { name, age, .. } if age < 18 => {
            println!("{} is a minor (age: {})", name, age);
        }
        Person { name, age, email } => {
            println!("{} is {} years old, email: {}", name, age, email);
        }
    }

    // Shorthand when variable names match field names
    let Person { name, age, email } = person;
    println!("Name: {}, Age: {}, Email: {}", name, age, email);
}

struct Person {
    name: String,
    age: u32,
    email: String,
}
```

### Destructuring Enums

```rust
fn main() {
    let message = Message::Move { x: 10, y: 20 };

    match message {
        Message::Quit => {
            println!("Quit message received");
        }
        Message::Move { x, y } => {
            println!("Move to coordinates: ({}, {})", x, y);
        }
        Message::Write(text) => {
            println!("Text message: {}", text);
        }
        Message::ChangeColor(r, g, b) => {
            println!("Change color to RGB({}, {}, {})", r, g, b);
        }
    }

    // Multiple messages
    let messages = vec![
        Message::Write(String::from("Hello")),
        Message::Move { x: 5, y: 10 },
        Message::ChangeColor(255, 0, 0),
        Message::Quit,
    ];

    for msg in messages {
        process_message(msg);
    }
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(u8, u8, u8),
}

fn process_message(msg: Message) {
    match msg {
        Message::Quit => println!("Application is quitting"),
        Message::Move { x, y } => println!("Moving to ({}, {})", x, y),
        Message::Write(text) => println!("Message: {}", text),
        Message::ChangeColor(r, g, b) => println!("Color: #{:02X}{:02X}{:02X}", r, g, b),
    }
}
```

### Nested Destructuring

```rust
fn main() {
    let data = ((1, 2), (3, 4));

    match data {
        ((0, y), _) => println!("First x is 0, y is {}", y),
        (_, (3, y)) => println!("Second x is 3, y is {}", y),
        ((x1, y1), (x2, y2)) => {
            println!("Points: ({}, {}) and ({}, {})", x1, y1, x2, y2);
        }
    }

    // Complex nested structure
    let complex = Some((String::from("Hello"), 42));

    match complex {
        Some((text, number)) => {
            println!("Found text: '{}' with number: {}", text, number);
        }
        None => println!("Nothing here"),
    }
}
```

## Working with Option and Result

### Matching Option<T>

The `Option` type is one of the most common uses of pattern matching:

```rust
fn main() {
    let some_number = Some(5);
    let no_number: Option<i32> = None;

    // Basic Option matching
    match some_number {
        Some(value) => println!("Got a value: {}", value),
        None => println!("Got nothing"),
    }

    match no_number {
        Some(value) => println!("Got a value: {}", value),
        None => println!("Got nothing"),
    }

    // Practical example: finding in a list
    let numbers = vec![1, 2, 3, 4, 5];
    let search_result = find_number(&numbers, 3);

    match search_result {
        Some(index) => println!("Found at index: {}", index),
        None => println!("Not found"),
    }
}

fn find_number(numbers: &[i32], target: i32) -> Option<usize> {
    for (index, &num) in numbers.iter().enumerate() {
        if num == target {
            return Some(index);
        }
    }
    None
}
```

### Matching Result<T, E>

The `Result` type is essential for error handling:

```rust
fn main() {
    let success: Result<i32, String> = Ok(42);
    let failure: Result<i32, String> = Err(String::from("Something went wrong"));

    // Basic Result matching
    match success {
        Ok(value) => println!("Success! Value: {}", value),
        Err(error) => println!("Error: {}", error),
    }

    match failure {
        Ok(value) => println!("Success! Value: {}", value),
        Err(error) => println!("Error: {}", error),
    }

    // Practical example: division with error handling
    let result1 = divide(10.0, 2.0);
    let result2 = divide(10.0, 0.0);

    match result1 {
        Ok(quotient) => println!("10.0 / 2.0 = {}", quotient),
        Err(e) => println!("Error: {}", e),
    }

    match result2 {
        Ok(quotient) => println!("10.0 / 0.0 = {}", quotient),
        Err(e) => println!("Error: {}", e),
    }
}

fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err(String::from("Cannot divide by zero"))
    } else {
        Ok(a / b)
    }
}
```

### Nested Option and Result

```rust
fn main() {
    let data: Option<Result<i32, String>> = Some(Ok(42));

    match data {
        Some(Ok(value)) => println!("Success: {}", value),
        Some(Err(e)) => println!("Error: {}", e),
        None => println!("No data"),
    }

    // Practical example: parsing optional user input
    let inputs = vec![
        Some("42"),
        Some("not a number"),
        None,
    ];

    for input in inputs {
        let result = parse_input(input);

        match result {
            Some(Ok(num)) => println!("Parsed number: {}", num),
            Some(Err(e)) => println!("Parse error: {}", e),
            None => println!("No input provided"),
        }
    }
}

fn parse_input(input: Option<&str>) -> Option<Result<i32, String>> {
    input.map(|s| {
        s.parse::<i32>()
            .map_err(|_| format!("'{}' is not a valid number", s))
    })
}
```

## Pattern Guards

Guards allow you to add additional conditions to match arms using `if`:

```rust
fn main() {
    let number = 4;

    match number {
        n if n < 0 => println!("Negative: {}", n),
        n if n == 0 => println!("Zero"),
        n if n % 2 == 0 => println!("Positive even: {}", n),
        n => println!("Positive odd: {}", n),
    }

    // Multiple conditions in guard
    let pair = (2, 5);

    match pair {
        (x, y) if x == y => println!("Both values are equal"),
        (x, y) if x + y == 10 => println!("Sum is 10"),
        (x, y) if x > y => println!("First is greater"),
        (x, y) => println!("First: {}, Second: {}", x, y),
    }
}
```

### Guards with Enums

```rust
fn main() {
    let user = User {
        name: String::from("Alice"),
        age: 17,
        is_premium: true,
    };

    check_access(user);

    let adult_user = User {
        name: String::from("Bob"),
        age: 25,
        is_premium: false,
    };

    check_access(adult_user);
}

struct User {
    name: String,
    age: u32,
    is_premium: bool,
}

fn check_access(user: User) {
    match user {
        User { age, is_premium: true, .. } if age >= 18 => {
            println!("Premium adult user - full access");
        }
        User { age, is_premium: false, .. } if age >= 18 => {
            println!("Regular adult user - standard access");
        }
        User { age, .. } if age < 18 => {
            println!("Minor user - restricted access");
        }
        _ => println!("Unknown access level"),
    }
}
```

### Guards with Option

```rust
fn main() {
    let numbers = vec![Some(1), Some(5), None, Some(10), Some(15)];

    for num in numbers {
        match num {
            Some(n) if n < 5 => println!("Small number: {}", n),
            Some(n) if n >= 5 && n < 10 => println!("Medium number: {}", n),
            Some(n) if n >= 10 => println!("Large number: {}", n),
            None => println!("No number"),
            _ => println!("Other"),
        }
    }
}
```

## The `@` Binding

The `@` operator lets you test a value and bind it to a variable at the same time:

```rust
fn main() {
    let number = 15;

    match number {
        n @ 1..=10 => println!("Small number: {}", n),
        n @ 11..=20 => println!("Medium number: {}", n),
        n @ 21..=30 => println!("Large number: {}", n),
        n => println!("Out of range: {}", n),
    }

    // Practical example: age categories
    let person_age = 25;

    let category = match person_age {
        age @ 0..=12 => format!("Child (age {})", age),
        age @ 13..=17 => format!("Teen (age {})", age),
        age @ 18..=64 => format!("Adult (age {})", age),
        age @ 65.. => format!("Senior (age {})", age),
        _ => String::from("Invalid"),
    };

    println!("{}", category);
}
```

### @ with Enums

```rust
fn main() {
    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello { id: id_variable @ 3..=7 } => {
            println!("Found an id in range: {}", id_variable);
        }
        Message::Hello { id: 10..=12 } => {
            println!("Found an id in another range");
        }
        Message::Hello { id } => {
            println!("Found some other id: {}", id);
        }
    }
}

enum Message {
    Hello { id: i32 },
}
```

## `if let` and `while let`

### `if let`: Concise Pattern Matching

When you only care about one pattern, `if let` is more concise than `match`:

```rust
fn main() {
    let some_value = Some(7);

    // Using match (verbose)
    match some_value {
        Some(7) => println!("Got seven!"),
        _ => (),
    }

    // Using if let (concise)
    if let Some(7) = some_value {
        println!("Got seven!");
    }

    // With else
    let number = Some(3);

    if let Some(3) = number {
        println!("three");
    } else {
        println!("not three");
    }

    // Practical example: optional configuration
    let config_value = Some(100);

    if let Some(max) = config_value {
        println!("The maximum is configured to be {}", max);
    } else {
        println!("No maximum configured, using default");
    }
}
```

### `if let` with Multiple Patterns

```rust
fn main() {
    let favorite_color: Option<&str> = None;
    let is_tuesday = false;
    let age: Result<u8, _> = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {}, as the background", color);
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        if age > 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}
```

### `while let`: Looping with Pattern Matching

```rust
fn main() {
    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    // Pop values while Some
    while let Some(top) = stack.pop() {
        println!("Popped: {}", top);
    }

    println!("Stack is now empty");

    // Practical example: processing a queue
    let mut queue = vec![
        Some("Task 1"),
        Some("Task 2"),
        None,
        Some("Task 3"),
    ];

    println!("\nProcessing queue:");
    let mut index = 0;
    while index < queue.len() {
        if let Some(Some(task)) = queue.get(index) {
            println!("Processing: {}", task);
        } else {
            println!("Skipping empty slot");
        }
        index += 1;
    }
}
```

## Ignoring Values in Patterns

### Using `_` to Ignore Values

```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    // Ignore specific values
    match numbers {
        (first, _, third, _, fifth) => {
            println!("Values: {}, {}, {}", first, third, fifth);
        }
    }

    // Ignore entire value
    let some_value = Some(5);

    match some_value {
        Some(_) => println!("Got some value"),
        None => println!("Got nothing"),
    }
}
```

### Using `_` to Ignore Function Parameters

```rust
fn main() {
    let result = process_data(10, 20);
    println!("Result: {}", result);
}

fn process_data(important: i32, _unused: i32) -> i32 {
    // The _ prefix tells Rust we're intentionally not using this parameter
    important * 2
}
```

### Using `..` to Ignore Remaining Parts

```rust
fn main() {
    let point = (1, 2, 3, 4, 5);

    match point {
        (first, .., last) => {
            println!("First: {}, Last: {}", first, last);
        }
    }

    // With structs
    let person = Person {
        name: String::from("Alice"),
        age: 30,
        email: String::from("alice@example.com"),
        phone: String::from("123-456-7890"),
    };

    match person {
        Person { name, age, .. } => {
            println!("{} is {} years old", name, age);
        }
    }
}

struct Person {
    name: String,
    age: u32,
    email: String,
    phone: String,
}
```

## Common Problems Developers Face

### Problem 1: Non-Exhaustive Patterns

**The Mistake:**

```rust
fn main() {
    let number = 5;

    // This will NOT compile:
    // match number {
    //     1 => println!("One"),
    //     2 => println!("Two"),
    //     3 => println!("Three"),
    // }
    // ERROR: non-exhaustive patterns: `i32::MIN..=0_i32` and
    //        `4_i32..=i32::MAX` not covered
}
```

**The Error:**

```
error[E0004]: non-exhaustive patterns: `i32::MIN..=0_i32` and `4_i32..=i32::MAX` not covered
```

**The Fix:**

```rust
fn main() {
    let number = 5;

    match number {
        1 => println!("One"),
        2 => println!("Two"),
        3 => println!("Three"),
        _ => println!("Something else"),  // Catch-all pattern
    }
}
```

### Problem 2: Type Mismatch in Match Arms

**The Mistake:**

```rust
fn main() {
    let value = Some(5);

    // This will NOT compile:
    // let result = match value {
    //     Some(n) => n,           // Returns i32
    //     None => "nothing",      // Returns &str - ERROR!
    // };
}
```

**The Error:**

```
error[E0308]: `match` arms have incompatible types
```

**The Fix:**

```rust
fn main() {
    let value = Some(5);

    // All arms return the same type
    let result = match value {
        Some(n) => format!("{}", n),
        None => String::from("nothing"),
    };

    println!("{}", result);
}
```

### Problem 3: Moving Values in Match

**The Mistake:**

```rust
fn main() {
    let optional = Some(String::from("Hello"));

    match optional {
        Some(s) => println!("Got: {}", s),
        None => println!("Got nothing"),
    }

    // This will NOT compile:
    // match optional {  // ERROR: value used after being moved
    //     Some(s) => println!("Again: {}", s),
    //     None => println!("Still nothing"),
    // }
}
```

**The Fix (Using References):**

```rust
fn main() {
    let optional = Some(String::from("Hello"));

    // Borrow instead of move
    match &optional {
        Some(s) => println!("Got: {}", s),
        None => println!("Got nothing"),
    }

    // Now we can use it again
    match &optional {
        Some(s) => println!("Again: {}", s),
        None => println!("Still nothing"),
    }

    // Original value still owned
    println!("Original: {:?}", optional);
}
```

### Problem 4: Unreachable Patterns

**The Mistake:**

```rust
fn main() {
    let number = 5;

    match number {
        _ => println!("Anything"),
        1 => println!("One"),  // WARNING: unreachable pattern
        2 => println!("Two"),  // WARNING: unreachable pattern
    }
}
```

**The Warning:**

```
warning: unreachable pattern
```

**The Fix:**

```rust
fn main() {
    let number = 5;

    // Put specific patterns before catch-all
    match number {
        1 => println!("One"),
        2 => println!("Two"),
        _ => println!("Anything else"),
    }
}
```

### Problem 5: Shadowing in Match Arms

**The Pitfall:**

```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(y) => println!("Matched, y = {}", y),  // This shadows outer y!
        None => println!("Default case, y = {}", y),
    }

    println!("at the end: y = {}", y);  // Original y is still 10
}
```

**Output:**

```
Matched, y = 5
at the end: y = 10
```

**To avoid confusion, use different variable names:**

```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(value) => println!("Matched, value = {}", value),
        None => println!("Default case, y = {}", y),
    }

    println!("at the end: y = {}", y);
}
```

### Problem 6: Incorrect Range Syntax

**The Mistake:**

```rust
fn main() {
    let number = 5;

    // This will NOT compile:
    // match number {
    //     1..5 => println!("One to four"),  // ERROR: exclusive ranges not allowed
    //     _ => println!("Something else"),
    // }
}
```

**The Fix:**

```rust
fn main() {
    let number = 5;

    // Use inclusive range
    match number {
        1..=4 => println!("One to four"),
        5..=10 => println!("Five to ten"),
        _ => println!("Something else"),
    }
}
```

## Best Practices for Pattern Matching

### Practice 1: Prefer Match Over Complex if/else

**Less Idiomatic:**

```rust
fn main() {
    let value = Some(42);

    if value.is_some() {
        let num = value.unwrap();
        if num > 0 {
            if num % 2 == 0 {
                println!("Positive even number: {}", num);
            } else {
                println!("Positive odd number: {}", num);
            }
        } else {
            println!("Non-positive number");
        }
    } else {
        println!("No value");
    }
}
```

**More Idiomatic:**

```rust
fn main() {
    let value = Some(42);

    match value {
        Some(n) if n > 0 && n % 2 == 0 => {
            println!("Positive even number: {}", n);
        }
        Some(n) if n > 0 => {
            println!("Positive odd number: {}", n);
        }
        Some(n) => {
            println!("Non-positive number: {}", n);
        }
        None => {
            println!("No value");
        }
    }
}
```

### Practice 2: Use `if let` for Single Pattern Matches

**When You Only Care About One Case:**

```rust
fn main() {
    let config_max = Some(3u8);

    // Verbose
    match config_max {
        Some(max) => println!("The maximum is configured to be {}", max),
        _ => (),
    }

    // Concise
    if let Some(max) = config_max {
        println!("The maximum is configured to be {}", max);
    }
}
```

### Practice 3: Order Patterns from Specific to General

```rust
fn main() {
    let number = 42;

    match number {
        0 => println!("Zero"),                    // Most specific
        1..=10 => println!("Small"),
        11..=100 => println!("Medium"),
        101..=1000 => println!("Large"),
        _ => println!("Very large"),              // Most general
    }
}
```

### Practice 4: Use Descriptive Variable Names in Patterns

**Less Clear:**

```rust
fn main() {
    let data = (String::from("Alice"), 30, true);

    match data {
        (x, y, z) => {
            println!("{} {} {}", x, y, z);
        }
    }
}
```

**More Clear:**

```rust
fn main() {
    let data = (String::from("Alice"), 30, true);

    match data {
        (name, age, is_active) => {
            println!("Name: {}, Age: {}, Active: {}", name, age, is_active);
        }
    }
}
```

### Practice 5: Avoid Nested Matches When Possible

**Deeply Nested:**

```rust
fn main() {
    let result: Result<Option<i32>, String> = Ok(Some(42));

    match result {
        Ok(option) => {
            match option {
                Some(value) => println!("Got value: {}", value),
                None => println!("Got None"),
            }
        }
        Err(e) => println!("Error: {}", e),
    }
}
```

**Flattened:**

```rust
fn main() {
    let result: Result<Option<i32>, String> = Ok(Some(42));

    match result {
        Ok(Some(value)) => println!("Got value: {}", value),
        Ok(None) => println!("Got None"),
        Err(e) => println!("Error: {}", e),
    }
}
```

### Practice 6: Use Match for Error Propagation

````rust
fn main() {
    match process_data() {
        Ok(result) => println!("Success: {}", result),
        Err(e) => println!("Error: {}", e),
    }
}

fn process_data() -> Result<i32, String> {
    let input = get_input()?;
    let ```rust
fn process_data() -> Result<i32, String> {
    let input = get_input()?;
    let validated = validate_input(input)?;
    let processed = transform_data(validated)?;
    Ok(processed)
}

fn get_input() -> Result<i32, String> {
    Ok(42)
}

fn validate_input(value: i32) -> Result<i32, String> {
    if value > 0 {
        Ok(value)
    } else {
        Err(String::from("Value must be positive"))
    }
}

fn transform_data(value: i32) -> Result<i32, String> {
    Ok(value * 2)
}
````

## Advanced Pattern Matching Techniques

### Technique 1: Matching Multiple Values Simultaneously

```rust
fn main() {
    let x = 1;
    let y = 2;

    match (x, y) {
        (1, 1) => println!("Both are 1"),
        (1, _) => println!("x is 1, y is something else"),
        (_, 1) => println!("x is something else, y is 1"),
        _ => println!("Neither is 1"),
    }

    // Game state example
    let player_health = 50;
    let enemy_health = 0;

    match (player_health, enemy_health) {
        (0, _) => println!("Game Over - You died!"),
        (_, 0) => println!("Victory - Enemy defeated!"),
        (h1, h2) if h1 < 20 && h2 < 20 => println!("Both low on health!"),
        (h1, h2) if h1 > h2 => println!("You're winning!"),
        (h1, h2) if h1 < h2 => println!("You're losing!"),
        _ => println!("Battle continues..."),
    }
}
```

### Technique 2: Slice Patterns

```rust
fn main() {
    let numbers = [1, 2, 3, 4, 5];

    match numbers {
        [] => println!("Empty array"),
        [single] => println!("Single element: {}", single),
        [first, second] => println!("Two elements: {}, {}", first, second),
        [first, .., last] => println!("First: {}, Last: {}", first, last),
    }

    // Practical example: parsing command-line arguments
    let args = vec!["program", "command", "arg1", "arg2"];

    match args.as_slice() {
        [program] => println!("No command provided"),
        [program, command] => println!("Command: {}, no arguments", command),
        [program, command, args @ ..] => {
            println!("Command: {}", command);
            println!("Arguments: {:?}", args);
        }
        [] => println!("Empty"),
    }
}
```

### Technique 3: Reference Patterns

```rust
fn main() {
    let robot_name = Some(String::from("Bors"));

    // Match by reference to avoid moving
    match robot_name.as_ref() {
        Some(name) => println!("Found a name: {}", name),
        None => (),
    }

    // robot_name is still usable
    println!("robot_name is: {:?}", robot_name);

    // Destructuring references
    let point = &(3, 5);

    match point {
        &(x, y) => println!("Point coordinates: ({}, {})", x, y),
    }

    // Multiple references
    let values = vec![1, 2, 3, 4, 5];

    for value in &values {
        match value {
            1 => println!("One!"),
            2 | 3 => println!("Two or three!"),
            _ => println!("Something else: {}", value),
        }
    }
}
```

### Technique 4: Creating References in Patterns

```rust
fn main() {
    let value = 5;

    match value {
        ref r => println!("Got a reference to {}", r),
    }

    // Mutable references
    let mut mut_value = 5;

    match mut_value {
        ref mut m => {
            *m += 10;
            println!("Modified to: {}", m);
        }
    }

    println!("Final value: {}", mut_value);

    // Practical example: modifying struct fields
    let mut user = User {
        name: String::from("Alice"),
        score: 100,
    };

    match user {
        User { ref mut score, .. } => {
            *score += 50;
        }
    }

    println!("User score: {}", user.score);
}

struct User {
    name: String,
    score: i32,
}
```

### Technique 5: Match Guards with Complex Logic

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    for num in numbers {
        let description = match num {
            n if n % 3 == 0 && n % 5 == 0 => "FizzBuzz",
            n if n % 3 == 0 => "Fizz",
            n if n % 5 == 0 => "Buzz",
            n if is_prime(n) => "Prime",
            n if n % 2 == 0 => "Even",
            _ => "Odd",
        };

        println!("{}: {}", num, description);
    }
}

fn is_prime(n: i32) -> bool {
    if n < 2 {
        return false;
    }
    for i in 2..=(n as f64).sqrt() as i32 {
        if n % i == 0 {
            return false;
        }
    }
    true
}
```

### Technique 6: Exhaustive Enum Matching

```rust
fn main() {
    let request = HttpRequest::Get { path: String::from("/home") };

    handle_request(request);

    let post_request = HttpRequest::Post {
        path: String::from("/api/users"),
        body: String::from(r#"{"name": "Alice"}"#),
    };

    handle_request(post_request);
}

enum HttpRequest {
    Get { path: String },
    Post { path: String, body: String },
    Put { path: String, body: String },
    Delete { path: String },
}

fn handle_request(request: HttpRequest) {
    match request {
        HttpRequest::Get { path } => {
            println!("GET request to: {}", path);
        }
        HttpRequest::Post { path, body } => {
            println!("POST request to: {}", path);
            println!("Body: {}", body);
        }
        HttpRequest::Put { path, body } => {
            println!("PUT request to: {}", path);
            println!("Body: {}", body);
        }
        HttpRequest::Delete { path } => {
            println!("DELETE request to: {}", path);
        }
    }
}
```

## Practical Real-World Examples

### Example 1: JSON-Like Data Parser

```rust
fn main() {
    let data = vec![
        JsonValue::Null,
        JsonValue::Bool(true),
        JsonValue::Number(42.0),
        JsonValue::String(String::from("Hello")),
        JsonValue::Array(vec![
            JsonValue::Number(1.0),
            JsonValue::Number(2.0),
            JsonValue::Number(3.0),
        ]),
    ];

    for value in data {
        print_json_value(&value, 0);
    }
}

enum JsonValue {
    Null,
    Bool(bool),
    Number(f64),
    String(String),
    Array(Vec<JsonValue>),
}

fn print_json_value(value: &JsonValue, indent: usize) {
    let spacing = "  ".repeat(indent);

    match value {
        JsonValue::Null => println!("{}null", spacing),
        JsonValue::Bool(b) => println!("{}{}", spacing, b),
        JsonValue::Number(n) => println!("{}{}", spacing, n),
        JsonValue::String(s) => println!("{}\"{}\"", spacing, s),
        JsonValue::Array(arr) => {
            println!("{}[", spacing);
            for item in arr {
                print_json_value(item, indent + 1);
            }
            println!("{}]", spacing);
        }
    }
}
```

### Example 2: State Machine Implementation

```rust
fn main() {
    let mut traffic_light = TrafficLight::new();

    println!("=== Traffic Light Simulation ===\n");

    for _ in 0..10 {
        traffic_light.describe();
        traffic_light.next();
        println!();
    }
}

enum LightState {
    Red { duration: u32 },
    Yellow { duration: u32 },
    Green { duration: u32 },
}

struct TrafficLight {
    state: LightState,
}

impl TrafficLight {
    fn new() -> Self {
        TrafficLight {
            state: LightState::Red { duration: 30 },
        }
    }

    fn next(&mut self) {
        self.state = match self.state {
            LightState::Red { .. } => {
                println!("Switching: Red â†’ Green");
                LightState::Green { duration: 45 }
            }
            LightState::Green { .. } => {
                println!("Switching: Green â†’ Yellow");
                LightState::Yellow { duration: 5 }
            }
            LightState::Yellow { .. } => {
                println!("Switching: Yellow â†’ Red");
                LightState::Red { duration: 30 }
            }
        };
    }

    fn describe(&self) {
        match &self.state {
            LightState::Red { duration } => {
                println!("ðŸ”´ RED light ({}s)", duration);
                println!("   STOP - Do not proceed");
            }
            LightState::Yellow { duration } => {
                println!("ðŸŸ¡ YELLOW light ({}s)", duration);
                println!("   CAUTION - Prepare to stop");
            }
            LightState::Green { duration } => {
                println!("ðŸŸ¢ GREEN light ({}s)", duration);
                println!("   GO - Proceed safely");
            }
        }
    }
}
```

### Example 3: Expression Evaluator

```rust
fn main() {
    // (5 + 3) * 2
    let expr = Expr::Multiply(
        Box::new(Expr::Add(
            Box::new(Expr::Number(5)),
            Box::new(Expr::Number(3)),
        )),
        Box::new(Expr::Number(2)),
    );

    println!("Expression: {:?}", expr);

    match eval(&expr) {
        Ok(result) => println!("Result: {}", result),
        Err(e) => println!("Error: {}", e),
    }

    // Division by zero example
    let bad_expr = Expr::Divide(
        Box::new(Expr::Number(10)),
        Box::new(Expr::Number(0)),
    );

    println!("\nExpression: {:?}", bad_expr);

    match eval(&bad_expr) {
        Ok(result) => println!("Result: {}", result),
        Err(e) => println!("Error: {}", e),
    }
}

#[derive(Debug)]
enum Expr {
    Number(f64),
    Add(Box<Expr>, Box<Expr>),
    Subtract(Box<Expr>, Box<Expr>),
    Multiply(Box<Expr>, Box<Expr>),
    Divide(Box<Expr>, Box<Expr>),
}

fn eval(expr: &Expr) -> Result<f64, String> {
    match expr {
        Expr::Number(n) => Ok(*n),
        Expr::Add(left, right) => {
            let l = eval(left)?;
            let r = eval(right)?;
            Ok(l + r)
        }
        Expr::Subtract(left, right) => {
            let l = eval(left)?;
            let r = eval(right)?;
            Ok(l - r)
        }
        Expr::Multiply(left, right) => {
            let l = eval(left)?;
            let r = eval(right)?;
            Ok(l * r)
        }
        Expr::Divide(left, right) => {
            let l = eval(left)?;
            let r = eval(right)?;
            if r == 0.0 {
                Err(String::from("Division by zero"))
            } else {
                Ok(l / r)
            }
        }
    }
}
```

### Example 4: Command Parser

```rust
fn main() {
    let commands = vec![
        "create user Alice",
        "delete user Bob",
        "list users",
        "update user Charlie email charlie@example.com",
        "invalid command",
    ];

    println!("=== Command Parser ===\n");

    for cmd in commands {
        println!("Parsing: '{}'", cmd);

        match parse_command(cmd) {
            Some(command) => execute_command(command),
            None => println!("  âŒ Invalid command\n"),
        }
    }
}

enum Command {
    Create { entity: String, name: String },
    Delete { entity: String, name: String },
    List { entity: String },
    Update { entity: String, name: String, field: String, value: String },
}

fn parse_command(input: &str) -> Option<Command> {
    let parts: Vec<&str> = input.split_whitespace().collect();

    match parts.as_slice() {
        ["create", entity, name] => Some(Command::Create {
            entity: entity.to_string(),
            name: name.to_string(),
        }),
        ["delete", entity, name] => Some(Command::Delete {
            entity: entity.to_string(),
            name: name.to_string(),
        }),
        ["list", entity] => Some(Command::List {
            entity: entity.to_string(),
        }),
        ["update", entity, name, field, value] => Some(Command::Update {
            entity: entity.to_string(),
            name: name.to_string(),
            field: field.to_string(),
            value: value.to_string(),
        }),
        _ => None,
    }
}

fn execute_command(command: Command) {
    match command {
        Command::Create { entity, name } => {
            println!("  âœ“ Creating {} '{}'", entity, name);
        }
        Command::Delete { entity, name } => {
            println!("  âœ“ Deleting {} '{}'", entity, name);
        }
        Command::List { entity } => {
            println!("  âœ“ Listing all {}", entity);
        }
        Command::Update { entity, name, field, value } => {
            println!("  âœ“ Updating {} '{}': {} = {}", entity, name, field, value);
        }
    }
    println!();
}
```

### Example 5: File System Operations

```rust
fn main() {
    let operations = vec![
        FileOp::Create { path: String::from("/home/user/file.txt") },
        FileOp::Read { path: String::from("/home/user/file.txt") },
        FileOp::Write {
            path: String::from("/home/user/file.txt"),
            content: String::from("Hello, World!"),
        },
        FileOp::Delete { path: String::from("/home/user/file.txt") },
        FileOp::Move {
            from: String::from("/home/user/old.txt"),
            to: String::from("/home/user/new.txt"),
        },
    ];

    println!("=== File System Operations ===\n");

    for op in operations {
        let result = execute_file_operation(op);

        match result {
            Ok(msg) => println!("âœ“ {}", msg),
            Err(e) => println!("âœ— Error: {}", e),
        }
    }
}

enum FileOp {
    Create { path: String },
    Read { path: String },
    Write { path: String, content: String },
    Delete { path: String },
    Move { from: String, to: String },
}

fn execute_file_operation(op: FileOp) -> Result<String, String> {
    match op {
        FileOp::Create { path } => {
            if path.is_empty() {
                Err(String::from("Path cannot be empty"))
            } else {
                Ok(format!("Created file: {}", path))
            }
        }
        FileOp::Read { path } => {
            if path.ends_with(".txt") {
                Ok(format!("Read file: {}", path))
            } else {
                Err(format!("Cannot read non-text file: {}", path))
            }
        }
        FileOp::Write { path, content } => {
            if content.is_empty() {
                Err(String::from("Content cannot be empty"))
            } else {
                Ok(format!("Wrote {} bytes to: {}", content.len(), path))
            }
        }
        FileOp::Delete { path } => {
            Ok(format!("Deleted file: {}", path))
        }
        FileOp::Move { from, to } => {
            if from == to {
                Err(String::from("Source and destination are the same"))
            } else {
                Ok(format!("Moved {} to {}", from, to))
            }
        }
    }
}
```

### Example 6: Event Handler System

```rust
fn main() {
    let mut handler = EventHandler::new();

    let events = vec![
        Event::Click { x: 100, y: 200, button: MouseButton::Left },
        Event::KeyPress { key: 'A', ctrl: false, shift: true },
        Event::MouseMove { x: 150, y: 250 },
        Event::KeyPress { key: 'C', ctrl: true, shift: false },
        Event::Scroll { delta: -5 },
    ];

    println!("=== Event Handler System ===\n");

    for event in events {
        handler.handle_event(event);
    }
}

enum MouseButton {
    Left,
    Right,
    Middle,
}

enum Event {
    Click { x: i32, y: i32, button: MouseButton },
    KeyPress { key: char, ctrl: bool, shift: bool },
    MouseMove { x: i32, y: i32 },
    Scroll { delta: i32 },
}

struct EventHandler {
    click_count: u32,
}

impl EventHandler {
    fn new() -> Self {
        EventHandler { click_count: 0 }
    }

    fn handle_event(&mut self, event: Event) {
        match event {
            Event::Click { x, y, button: MouseButton::Left } => {
                self.click_count += 1;
                println!("Left click at ({}, {}) - Total clicks: {}",
                         x, y, self.click_count);
            }
            Event::Click { x, y, button: MouseButton::Right } => {
                println!("Right click at ({}, {}) - Opening context menu", x, y);
            }
            Event::Click { x, y, button: MouseButton::Middle } => {
                println!("Middle click at ({}, {})", x, y);
            }
            Event::KeyPress { key, ctrl: true, shift: false } => {
                println!("Ctrl+{} pressed - Executing shortcut", key);
            }
            Event::KeyPress { key, ctrl: false, shift: true } => {
                println!("Shift+{} pressed - Typing: {}", key, key.to_uppercase());
            }
            Event::KeyPress { key, ctrl: false, shift: false } => {
                println!("Key '{}' pressed", key);
            }
            Event::KeyPress { key, ctrl: true, shift: true } => {
                println!("Ctrl+Shift+{} pressed - Advanced shortcut", key);
            }
            Event::MouseMove { x, y } => {
                println!("Mouse moved to ({}, {})", x, y);
            }
            Event::Scroll { delta } if delta > 0 => {
                println!("Scrolled up {} units", delta);
            }
            Event::Scroll { delta } if delta < 0 => {
                println!("Scrolled down {} units", delta.abs());
            }
            Event::Scroll { .. } => {
                println!("No scroll movement");
            }
        }
    }
}
```

### Example 7: Result Chain with Pattern Matching

```rust
fn main() {
    println!("=== Data Processing Pipeline ===\n");

    let test_inputs = vec!["42", "abc", "100", "-5"];

    for input in test_inputs {
        println!("Processing input: '{}'", input);

        match process_pipeline(input) {
            Ok(result) => println!("  âœ“ Final result: {}\n", result),
            Err(e) => println!("  âœ— Error: {}\n", e),
        }
    }
}

fn process_pipeline(input: &str) -> Result<i32, String> {
    let parsed = parse_input(input)?;
    let validated = validate_number(parsed)?;
    let transformed = transform_number(validated)?;
    Ok(transformed)
}

fn parse_input(input: &str) -> Result<i32, String> {
    match input.parse::<i32>() {
        Ok(num) => {
            println!("  â†’ Parsed: {}", num);
            Ok(num)
        }
        Err(_) => Err(format!("'{}' is not a valid number", input)),
    }
}

fn validate_number(num: i32) -> Result<i32, String> {
    match num {
        n if n < 0 => Err(String::from("Number must be non-negative")),
        n if n > 200 => Err(String::from("Number must be 200 or less")),
        n => {
            println!("  â†’ Validated: {}", n);
            Ok(n)
        }
    }
}

fn transform_number(num: i32) -> Result<i32, String> {
    let result = num * 2 + 10;
    println!("  â†’ Transformed: {}", result);
    Ok(result)
}
```

### Example 8: Configuration Parser

```rust
fn main() {
    let config_lines = vec![
        "server.port=8080",
        "server.host=localhost",
        "database.url=postgres://localhost/mydb",
        "invalid line",
        "cache.enabled=true",
        "cache.ttl=3600",
    ];

    println!("=== Configuration Parser ===\n");

    let mut config = Config::new();

    for line in config_lines {
        match parse_config_line(line) {
            Ok((key, value)) => {
                config.set(key, value);
                println!("âœ“ Set: {} = {}", key, value);
            }
            Err(e) => {
                println!("âœ— Error parsing '{}': {}", line, e);
            }
        }
    }

    println!("\n=== Final Configuration ===");
    config.display();
}

struct Config {
    settings: Vec<(String, String)>,
}

impl Config {
    fn new() -> Self {
        Config {
            settings: Vec::new(),
        }
    }

    fn set(&mut self, key: String, value: String) {
        self.settings.push((key, value));
    }

    fn display(&self) {
        for (key, value) in &self.settings {
            println!("{} = {}", key, value);
        }
    }
}

fn parse_config_line(line: &str) -> Result<(String, String), String> {
    let parts: Vec<&str> = line.split('=').collect();

    match parts.as_slice() {
        [key, value] if !key.trim().is_empty() && !value.trim().is_empty() => {
            Ok((key.trim().to_string(), value.trim().to_string()))
        }
        [key, value] if key.trim().is_empty() => {
            Err(String::from("Key cannot be empty"))
        }
        [key, value] if value.trim().is_empty() => {
            Err(String::from("Value cannot be empty"))
        }
        _ => Err(String::from("Invalid format - expected key=value")),
    }
}
```

## Pattern Matching Performance Tips

### Tip 1: Order Patterns by Frequency

```rust
fn main() {
    let values = vec![1, 2, 3, 1, 2, 1, 1, 1, 4, 1];

    // Since 1 appears most frequently, check it first
    for value in values {
        match value {
            1 => println!("One (most common)"),  // Check most common first
            2 => println!("Two"),
            3 => println!("Three"),
            _ => println!("Other"),
        }
    }
}
```

### Tip 2: Use Ranges for Continuous Values

```rust
fn main() {
    let score = 85;

    // Efficient: uses range matching
    let grade = match score {
        90..=100 => 'A',
        80..=89 => 'B',
        70..=79 => 'C',
        60..=69 => 'D',
        0..=59 => 'F',
        _ => '?',
    };

    println!("Grade: {}", grade);
}
```

### Tip 3: Avoid Expensive Guards When Possible

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    // Less efficient: guard calls function every time
    for num in &numbers {
        match num {
            n if expensive_check(*n) => println!("Special: {}", n),
            n => println!("Normal: {}", n),
        }
    }

    // More efficient: pre-filter
    let special: Vec<_> = numbers.iter()
        .filter(|&&n| expensive_check(n))
        .collect();

    for num in &numbers {
        if special.contains(&num) {
            println!("Special: {}", num);
        } else {
            println!("Normal: {}", num);
        }
    }
}

fn expensive_check(n: i32) -> bool {
    // Simulate expensive operation
    n % 3 == 0
}
```

## Summary: Pattern Matching Mastery

### Key Principles

1. **Exhaustiveness is Safety** - The compiler ensures you handle all cases, preventing bugs

2. **Match is an Expression** - You can use the result directly, but all arms must return the same type

3. **Destructuring is Powerful** - Break apart complex data structures inline

4. **Guards Add Flexibility** - Use `if` conditions for complex logic

5. **`if let` for Single Patterns** - More concise than `match` when you only care about one case

6. **`while let` for Loops** - Combine pattern matching with iteration

7. **Order Matters** - Place specific patterns before general ones

8. **Use `@` for Binding** - Test and capture values simultaneously

9. **References Prevent Moves** - Match on references to keep ownership

10. **Prefer Patterns Over Methods** - Pattern matching is often clearer than `.is_some()`, `.unwrap()`, etc.

### Pattern Matching Checklist

```rust
// âœ“ Exhaustive matching
match value {
    Pattern1 => {},
    Pattern2 => {},
    _ => {},  // Don't forget the catch-all
}

// âœ“ Type consistency
let result = match value {
    Pattern1 => return_same_type_1,
    Pattern2 => return_same_type_2,
};

// âœ“ Destructuring
match complex_value {
    Type { field1, field2, .. } => {},
}

// âœ“ Guards for complex conditions
match value {
    n if n > 0 && n < 100 => {},
    _ => {},
}

// âœ“ Early returns with if let
if let Some(value) = optional {
    // Handle the Some case
}
```

Pattern matching is one of Rust's superpowers. Master it, and you'll write safer, clearer, and more maintainable code. The compiler's exhaustiveness checking catches bugs at compile time that would be runtime errors in other languages, and the expressiveness of patterns makes your intent crystal clear!
