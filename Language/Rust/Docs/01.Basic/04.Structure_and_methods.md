# Structs and Methods in Rust: A Comprehensive Guide

## Part I: Understanding Structs

### What Are Structs?

Structs (short for "structures") are custom data types that let you package together and name multiple related values that make up a meaningful group. Think of them as blueprints for creating complex data types that model real-world entities or concepts.

Rust provides three types of structs, each serving different purposes:

1. **Classic (Named-Field) Structs** - The most common type
2. **Tuple Structs** - Structs without named fields
3. **Unit-Like Structs** - Structs without any fields

---

### 1. Classic Structs (Named-Field Structs)

These are the workhorses of Rust programming. Each field has a name and a type.

#### Basic Definition and Usage

```rust
// Define a struct
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    // Create an instance
    let user1 = User {
        email: String::from("alice@example.com"),
        username: String::from("alice123"),
        active: true,
        sign_in_count: 1,
    };

    // Access fields using dot notation
    println!("Username: {}", user1.username);
    println!("Email: {}", user1.email);
}
```

#### Mutable Structs

To modify struct fields, the entire instance must be mutable:

```rust
fn main() {
    let mut user1 = User {
        email: String::from("alice@example.com"),
        username: String::from("alice123"),
        active: true,
        sign_in_count: 1,
    };

    // Now we can modify fields
    user1.email = String::from("newemail@example.com");
    user1.sign_in_count += 1;

    println!("Updated email: {}", user1.email);
}
```

**Important Note:** Rust doesn't allow marking individual fields as mutable. It's all or nothing for the entire struct instance.

#### Constructor Functions

It's idiomatic to create constructor functions (often called `new`) that return struct instances:

```rust
impl User {
    fn new(username: String, email: String) -> User {
        User {
            username,
            email,
            active: true,
            sign_in_count: 1,
        }
    }
}

fn main() {
    let user = User::new(
        String::from("bob456"),
        String::from("bob@example.com")
    );
}
```

#### Field Init Shorthand

When variables have the same name as struct fields, you can use shorthand syntax:

```rust
fn build_user(email: String, username: String) -> User {
    User {
        email,      // shorthand for email: email
        username,   // shorthand for username: username
        active: true,
        sign_in_count: 1,
    }
}
```

#### Struct Update Syntax

Create new instances from existing ones, updating only specific fields:

```rust
fn main() {
    let user1 = User {
        email: String::from("alice@example.com"),
        username: String::from("alice123"),
        active: true,
        sign_in_count: 1,
    };

    // Create user2 based on user1, changing only email
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1  // Copy remaining fields from user1
    };

    // Note: user1.username and user1.email have been moved to user2
    // We can still use user1.active and user1.sign_in_count (they're Copy types)
    println!("user1 active: {}", user1.active);
}
```

**Ownership Caveat:** The `..` syntax moves non-Copy fields. In the example above, `user1.username` is no longer accessible because `String` doesn't implement `Copy`.

---

### 2. Tuple Structs

Tuple structs are useful when you want to give a tuple a name and make it a different type from other tuples:

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);

    // Access fields by index
    println!("Red component: {}", black.0);
    println!("X coordinate: {}", origin.0);

    // black and origin are different types, even with same structure
    // This won't compile: let color_point: Color = origin;
}
```

#### Newtype Pattern

A common use of tuple structs is the "newtype" pattern - wrapping a single value to create a distinct type:

```rust
struct Meters(f64);
struct Kilometers(f64);

fn main() {
    let distance_m = Meters(1000.0);
    let distance_km = Kilometers(1.0);

    // These are different types, preventing accidental mixing
    // This won't compile: let total: Meters = distance_m + distance_km;
}

// You can add methods to distinguish behavior
impl Meters {
    fn to_kilometers(&self) -> Kilometers {
        Kilometers(self.0 / 1000.0)
    }
}

impl Kilometers {
    fn to_meters(&self) -> Meters {
        Meters(self.0 * 1000.0)
    }
}
```

---

### 3. Unit-Like Structs

Structs with no fields. Useful for implementing traits without storing data:

```rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;

    // Often used with traits
    // We'll see more practical examples in the traits section
}
```

---

### Struct Visibility and Privacy

By default, structs and their fields are private:

```rust
mod shapes {
    pub struct Rectangle {
        pub width: u32,    // Public field
        height: u32,       // Private field
    }

    impl Rectangle {
        // Public constructor
        pub fn new(width: u32, height: u32) -> Rectangle {
            Rectangle { width, height }
        }

        // Public method to access private field
        pub fn height(&self) -> u32 {
            self.height
        }
    }
}

fn main() {
    let rect = shapes::Rectangle::new(30, 50);
    println!("Width: {}", rect.width);     // OK - public field
    // println!("Height: {}", rect.height); // ERROR - private field
    println!("Height: {}", rect.height()); // OK - public method
}
```

---

### Derived Traits

Rust can automatically implement common traits for structs:

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = Point { x: 5, y: 10 };
    let p2 = Point { x: 5, y: 10 };

    // Debug trait allows printing with {:?}
    println!("Point: {:?}", p1);
    println!("Point (pretty): {:#?}", p1);

    // PartialEq allows comparison
    if p1 == p2 {
        println!("Points are equal!");
    }

    // Clone and Copy allow easy duplication
    let p3 = p1; // Copy
    let p4 = p1.clone(); // Clone (same as copy for Copy types)

    println!("p1 is still usable: {:?}", p1);
}
```

Common derivable traits:

- `Debug` - Formatted debugging output
- `Clone` - Explicit duplication
- `Copy` - Implicit copying (for simple types)
- `PartialEq`/`Eq` - Equality comparison
- `PartialOrd`/`Ord` - Ordering comparison
- `Hash` - Hashing for hash maps
- `Default` - Default values

---

## Part II: Methods and Implementation Blocks

### What Are Methods?

Methods are functions defined within the context of a struct (or enum or trait). They always take `self` as their first parameter, representing the instance of the struct.

### Basic Method Definition

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // Method with immutable borrow of self
    fn area(&self) -> u32 {
        self.width * self.height
    }

    // Method with mutable borrow of self
    fn set_width(&mut self, width: u32) {
        self.width = width;
    }

    // Method that takes ownership of self
    fn destroy(self) -> String {
        format!("Rectangle {}x{} destroyed!", self.width, self.height)
    }
}

fn main() {
    let rect = Rectangle { width: 30, height: 50 };
    println!("Area: {}", rect.area());

    let mut rect2 = Rectangle { width: 20, height: 40 };
    rect2.set_width(25);
    println!("New width: {}", rect2.width);

    let rect3 = Rectangle { width: 10, height: 10 };
    let message = rect3.destroy();
    println!("{}", message);
    // rect3 is no longer accessible here
}
```

---

### The Three Forms of Self

Understanding the different forms of `self` is crucial:

#### 1. `&self` - Immutable Borrow

```rust
impl Rectangle {
    // Read-only access to the struct
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn is_square(&self) -> bool {
        self.width == self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```

Most methods use `&self` because they just need to read data.

#### 2. `&mut self` - Mutable Borrow

```rust
impl Rectangle {
    // Modify the struct's data
    fn set_width(&mut self, width: u32) {
        self.width = width;
    }

    fn scale(&mut self, factor: u32) {
        self.width *= factor;
        self.height *= factor;
    }

    fn make_square(&mut self) {
        let side = self.width.max(self.height);
        self.width = side;
        self.height = side;
    }
}
```

Use `&mut self` when you need to change the struct's state.

#### 3. `self` - Taking Ownership

```rust
impl Rectangle {
    // Consume the struct, return something else
    fn into_square(self) -> Square {
        let side = self.width.max(self.height);
        Square { side }
    }

    fn combine(self, other: Rectangle) -> Rectangle {
        Rectangle {
            width: self.width + other.width,
            height: self.height.max(other.height),
        }
    }
}

struct Square {
    side: u32,
}
```

Use `self` when you want to transform or consume the struct. After calling such a method, the original value is no longer usable.

---

### Associated Functions (Static Methods)

Functions in `impl` blocks that don't take `self` are called associated functions:

```rust
impl Rectangle {
    // Constructor - a common pattern
    fn new(width: u32, height: u32) -> Rectangle {
        Rectangle { width, height }
    }

    // Create a square (convenience constructor)
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }

    // Factory method with validation
    fn new_valid(width: u32, height: u32) -> Result<Rectangle, String> {
        if width == 0 || height == 0 {
            Err(String::from("Dimensions must be positive"))
        } else {
            Ok(Rectangle { width, height })
        }
    }
}

fn main() {
    // Call with :: syntax (like static methods)
    let rect1 = Rectangle::new(30, 50);
    let rect2 = Rectangle::square(25);

    match Rectangle::new_valid(0, 10) {
        Ok(r) => println!("Created rectangle"),
        Err(e) => println!("Error: {}", e),
    }
}
```

---

### Multiple Implementation Blocks

You can have multiple `impl` blocks for the same struct:

```rust
struct Circle {
    radius: f64,
}

// Basic geometric operations
impl Circle {
    fn new(radius: f64) -> Circle {
        Circle { radius }
    }

    fn area(&self) -> f64 {
        std::f64::consts::PI * self.radius * self.radius
    }

    fn circumference(&self) -> f64 {
        2.0 * std::f64::consts::PI * self.radius
    }
}

// Comparison operations
impl Circle {
    fn is_larger_than(&self, other: &Circle) -> bool {
        self.radius > other.radius
    }

    fn diameter(&self) -> f64 {
        self.radius * 2.0
    }
}

// Transformation operations
impl Circle {
    fn scale(&mut self, factor: f64) {
        self.radius *= factor;
    }

    fn scaled(self, factor: f64) -> Circle {
        Circle {
            radius: self.radius * factor,
        }
    }
}
```

This is useful for organizing code logically, especially in large structs.

---

### Method Chaining (Builder Pattern)

Methods that return `Self` or `&mut Self` enable method chaining:

```rust
struct RequestBuilder {
    url: String,
    method: String,
    headers: Vec<(String, String)>,
    body: Option<String>,
}

impl RequestBuilder {
    fn new(url: String) -> Self {
        RequestBuilder {
            url,
            method: String::from("GET"),
            headers: Vec::new(),
            body: None,
        }
    }

    fn method(mut self, method: &str) -> Self {
        self.method = method.to_string();
        self
    }

    fn header(mut self, key: &str, value: &str) -> Self {
        self.headers.push((key.to_string(), value.to_string()));
        self
    }

    fn body(mut self, body: &str) -> Self {
        self.body = Some(body.to_string());
        self
    }

    fn build(self) -> Request {
        Request {
            url: self.url,
            method: self.method,
            headers: self.headers,
            body: self.body,
        }
    }
}

struct Request {
    url: String,
    method: String,
    headers: Vec<(String, String)>,
    body: Option<String>,
}

fn main() {
    let request = RequestBuilder::new(String::from("https://api.example.com"))
        .method("POST")
        .header("Content-Type", "application/json")
        .header("Authorization", "Bearer token123")
        .body(r#"{"name": "Alice"}"#)
        .build();
}
```

---

### Generic Methods

Methods can have their own generic type parameters:

```rust
struct Container<T> {
    value: T,
}

impl<T> Container<T> {
    fn new(value: T) -> Self {
        Container { value }
    }

    fn get(&self) -> &T {
        &self.value
    }

    // Method with its own generic parameter
    fn map<U, F>(self, f: F) -> Container<U>
    where
        F: FnOnce(T) -> U,
    {
        Container { value: f(self.value) }
    }

    // Method that works with any type U
    fn pair_with<U>(self, other: U) -> (T, U) {
        (self.value, other)
    }
}

// Implement methods only for specific types
impl Container<String> {
    fn len(&self) -> usize {
        self.value.len()
    }

    fn to_uppercase(&self) -> String {
        self.value.to_uppercase()
    }
}

impl<T: std::fmt::Display> Container<T> {
    fn print(&self) {
        println!("Container holds: {}", self.value);
    }
}

fn main() {
    let num_container = Container::new(42);
    let string_container = num_container.map(|n| format!("Number: {}", n));

    println!("Length: {}", string_container.len());
    string_container.print();

    let paired = Container::new(100).pair_with("hello");
    println!("Pair: {:?}", paired);
}
```

---

### Real-World Example: A Complete Bank Account

Let's build a comprehensive example combining everything:

```rust
#[derive(Debug)]
struct BankAccount {
    account_number: String,
    holder_name: String,
    balance: f64,
    transaction_history: Vec<Transaction>,
}

#[derive(Debug, Clone)]
struct Transaction {
    transaction_type: TransactionType,
    amount: f64,
    timestamp: String, // In real code, use a datetime library
    description: String,
}

#[derive(Debug, Clone)]
enum TransactionType {
    Deposit,
    Withdrawal,
    Transfer,
}

impl BankAccount {
    // Constructor
    fn new(account_number: String, holder_name: String) -> Self {
        BankAccount {
            account_number,
            holder_name,
            balance: 0.0,
            transaction_history: Vec::new(),
        }
    }

    // Constructor with initial deposit
    fn with_initial_deposit(
        account_number: String,
        holder_name: String,
        amount: f64,
    ) -> Result<Self, String> {
        if amount < 0.0 {
            return Err(String::from("Initial deposit cannot be negative"));
        }

        let mut account = BankAccount::new(account_number, holder_name);
        account.deposit(amount, "Initial deposit");
        Ok(account)
    }

    // Getter methods
    fn balance(&self) -> f64 {
        self.balance
    }

    fn account_number(&self) -> &str {
        &self.account_number
    }

    fn holder_name(&self) -> &str {
        &self.holder_name
    }

    // Transaction methods
    fn deposit(&mut self, amount: f64, description: &str) {
        if amount > 0.0 {
            self.balance += amount;
            self.record_transaction(TransactionType::Deposit, amount, description);
        }
    }

    fn withdraw(&mut self, amount: f64, description: &str) -> Result<(), String> {
        if amount <= 0.0 {
            return Err(String::from("Withdrawal amount must be positive"));
        }

        if amount > self.balance {
            return Err(String::from("Insufficient funds"));
        }

        self.balance -= amount;
        self.record_transaction(TransactionType::Withdrawal, amount, description);
        Ok(())
    }

    fn transfer(&mut self, to_account: &mut BankAccount, amount: f64) -> Result<(), String> {
        self.withdraw(
            amount,
            &format!("Transfer to {}", to_account.account_number),
        )?;

        to_account.deposit(
            amount,
            &format!("Transfer from {}", self.account_number),
        );

        Ok(())
    }

    // Private helper method
    fn record_transaction(&mut self, trans_type: TransactionType, amount: f64, description: &str) {
        let transaction = Transaction {
            transaction_type: trans_type,
            amount,
            timestamp: String::from("2025-10-15 12:00:00"), // Simplified
            description: description.to_string(),
        };
        self.transaction_history.push(transaction);
    }

    // Query methods
    fn get_transaction_history(&self) -> &[Transaction] {
        &self.transaction_history
    }

    fn total_deposits(&self) -> f64 {
        self.transaction_history
            .iter()
            .filter(|t| matches!(t.transaction_type, TransactionType::Deposit))
            .map(|t| t.amount)
            .sum()
    }

    fn total_withdrawals(&self) -> f64 {
        self.transaction_history
            .iter()
            .filter(|t| matches!(t.transaction_type, TransactionType::Withdrawal))
            .map(|t| t.amount)
            .sum()
    }

    // Display method
    fn print_statement(&self) {
        println!("\n=== Account Statement ===");
        println!("Account: {}", self.account_number);
        println!("Holder: {}", self.holder_name);
        println!("Balance: ${:.2}", self.balance);
        println!("\nTransaction History:");

        for (i, trans) in self.transaction_history.iter().enumerate() {
            println!(
                "{}. {:?} - ${:.2} - {} ({})",
                i + 1,
                trans.transaction_type,
                trans.amount,
                trans.description,
                trans.timestamp
            );
        }
        println!("========================\n");
    }
}

fn main() {
    // Create accounts
    let mut alice_account = BankAccount::with_initial_deposit(
        String::from("ACC001"),
        String::from("Alice Johnson"),
        1000.0,
    ).unwrap();

    let mut bob_account = BankAccount::new(
        String::from("ACC002"),
        String::from("Bob Smith"),
    );

    // Perform transactions
    alice_account.deposit(500.0, "Salary deposit");
    alice_account.withdraw(200.0, "ATM withdrawal").unwrap();

    bob_account.deposit(300.0, "Initial deposit");

    // Transfer money
    alice_account.transfer(&mut bob_account, 250.0).unwrap();

    // Print statements
    alice_account.print_statement();
    bob_account.print_statement();

    // Statistics
    println!("Alice's total deposits: ${:.2}", alice_account.total_deposits());
    println!("Alice's total withdrawals: ${:.2}", alice_account.total_withdrawals());
}
```

---

## Part III: Best Practices for Writing Rust Code

### 1. Naming Conventions

```rust
// Structs and Enums: PascalCase
struct UserAccount { }
enum HttpStatus { }

// Functions, methods, variables: snake_case
fn calculate_total_price() { }
let user_count = 0;

// Constants and statics: SCREAMING_SNAKE_CASE
const MAX_CONNECTIONS: u32 = 100;
static GLOBAL_CONFIG: &str = "config";

// Type parameters: Single capital letters or PascalCase
struct Container<T> { }
struct Parser<Input, Output> { }
```

### 2. Error Handling

Always use `Result` for operations that can fail:

```rust
// Good: Explicit error handling
fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err(String::from("Division by zero"))
    } else {
        Ok(a / b)
    }
}

// Better: Custom error types
#[derive(Debug)]
enum MathError {
    DivisionByZero,
    Overflow,
    InvalidInput,
}

fn divide_better(a: f64, b: f64) -> Result<f64, MathError> {
    if b == 0.0 {
        Err(MathError::DivisionByZero)
    } else {
        Ok(a / b)
    }
}

// Usage with ? operator
fn calculate() -> Result<f64, MathError> {
    let result1 = divide_better(10.0, 2.0)?;
    let result2 = divide_better(result1, 3.0)?;
    Ok(result2)
}
```

### 3. Ownership and Borrowing

```rust
// Prefer borrowing over taking ownership
fn process_string(s: &String) { } // Good
fn process_string_bad(s: String) { } // Takes ownership - less flexible

// Return owned data, accept borrowed data
fn create_greeting(name: &str) -> String {
    format!("Hello, {}!", name)
}

// Use references for large data structures
struct LargeData {
    data: Vec<u8>,
}

impl LargeData {
    // Return reference, not owned data
    fn get_data(&self) -> &[u8] {
        &self.data
    }
}
```

### 4. Use Type System for Correctness

```rust
// Use newtypes to prevent mixing units
struct Meters(f64);
struct Seconds(f64);

// This prevents: let time: Seconds = Meters(5.0);

// Use enums for states
enum ConnectionState {
    Disconnected,
    Connecting,
    Connected { session_id: String },
    Failed { error: String },
}

// Builder pattern for complex construction
struct Configuration {
    host: String,
    port: u16,
    timeout: u64,
    retry_count: u32,
}

impl Configuration {
    fn builder() -> ConfigurationBuilder {
        ConfigurationBuilder::default()
    }
}

#[derive(Default)]
struct ConfigurationBuilder {
    host: Option<String>,
    port: Option<u16>,
    timeout: Option<u64>,
    retry_count: Option<u32>,
}

impl ConfigurationBuilder {
    fn host(mut self, host: String) -> Self {
        self.host = Some(host);
        self
    }

    fn port(mut self, port: u16) -> Self {
        self.port = Some(port);
        self
    }

    fn build(self) -> Result<Configuration, String> {
        Ok(Configuration {
            host: self.host.ok_or("Host is required")?,
            port: self.port.unwrap_or(8080),
            timeout: self.timeout.unwrap_or(30),
            retry_count: self.retry_count.unwrap_or(3),
        })
    }
}
```

### 5. Documentation

````rust
/// A rectangle defined by width and height.
///
/// # Examples
///
/// ```
/// let rect = Rectangle::new(10, 20);
/// assert_eq!(rect.area(), 200);
/// ```
pub struct Rectangle {
    /// The width of the rectangle in pixels
    pub width: u32,
    /// The height of the rectangle in pixels
    pub height: u32,
}

impl Rectangle {
    /// Creates a new rectangle with the given dimensions.
    ///
    /// # Arguments
    ///
    /// * `width` - The width of the rectangle
    /// * `height` - The height of the rectangle
    ///
    /// # Examples
    ///
    /// ```
    /// let rect = Rectangle::new(5, 10);
    /// ```
    pub fn new(width: u32, height: u32) -> Self {
        Rectangle { width, height }
    }

    /// Calculates the area of the rectangle.
    ///
    /// # Returns
    ///
    /// The area as a `u32`
    pub fn area(&self) -> u32 {
        self.width * self.height
    }
}
````

### 6. Iterators Over Loops

```rust
// Prefer this
let sum: i32 = numbers.iter().sum();

let doubled: Vec<i32> = numbers.iter()
    .map(|x| x * 2)
    .collect();

let evens: Vec<i32> = numbers.iter()
    .filter(|x| *x % 2 == 0)
    .copied()
    .collect();

// Over this
let mut sum = 0;
for num in &numbers {
    sum += num;
}
```

### 7. Use `Option` and `Result`

```rust
// Don't use sentinel values
struct User {
    id: u64,
    name: String,
    email: Option<String>, // Email is optional
}

// Chain operations
fn get_user_email_domain(user: &User) -> Option<String> {
    user.email
        .as_ref()
        .and_then(|email| email.split('@').nth(1))
        .map(|domain| domain.to_string())
}
```

### 8. Module Organization

```rust
// src/lib.rs or src/main.rs
mod models;
mod services;
mod utils;

pub use models::User;
pub use services::UserService;

// src/models/mod.rs
mod user;
mod account;

pub use user::User;
pub use account::Account;

// src/models/user.rs
pub struct User {
    // ...
}
```

### 9. Testing

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rectangle_area() {
        let rect = Rectangle::new(10, 20);
        assert_eq!(rect.area(), 200);
    }

    #[test]
    fn test_divide_by_zero() {
        let result = divide(10.0, 0.0);
        assert!(result.is_err());
    }

    #[test]
    #[should_panic(expected = "Division by zero")]
    fn test_panic_on_zero() {
        divide_panic(10.0, 0.0);
    }
}
```

### 10. Performance Tips

```rust
// Use references in loops
for item in &large_collection {
    // item is &T, no copying
}

// Reserve capacity when you know the size
let mut vec = Vec::with_capacity(1000);

// Use appropriate collection types
use std::collections::HashMap;
use std::collections::HashSet;
use std::collections::BTreeMap; // When you need sorting

// Clone only when necessary
let shared = Rc::new(data); // For single-threaded sharing
let thread_safe = Arc::new(data); // For multi-threaded sharing
```

### 11. Formatting and Linting

Always use:

```bash
cargo fmt   # Format code
cargo clippy  # Lint code
cargo test    # Run tests
cargo doc --open  # Generate and view documentation
```

### 12. Common Patterns Summary

```rust
// Constructor pattern
impl MyStruct {
    pub fn new() -> Self { }
}

// Builder pattern
impl MyStruct {
    pub fn builder() -> MyStructBuilder { }
}

// Method chaining
impl MyStruct {
    pub fn with_value(mut self, val: i32) -> Self {
        self.value = val;
        self
    }
}

// Conversion traits
impl From<OtherType> for MyStruct {
    fn from(other: OtherType) -> Self { }
}

// Display trait
impl std::fmt::Display for MyStruct {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "MyStruct {{ ... }}")
    }
}
```

---

## Conclusion

Mastering structs and methods in Rust involves understanding:

1. **Struct types** - Classic, tuple, and unit-like structs
2. **Ownership** - How data is owned, borrowed, and moved
3. **Methods** - Different forms of `self` and when to use each
4. **Patterns** - Builders, constructors, method chaining
5. **Best practices** - Error handling, documentation, testing

The key to writing idiomatic Rust is to leverage the type system for correctness, embrace ownership rules rather than fight them, and use the rich ecosystem of traits and patterns that the community has developed. Start simple, refactor as you learn, and always run `cargo clippy` to learn from the linter's suggestions.
