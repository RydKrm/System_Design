# Variables in Rust: A Comprehensive Guide

## Understanding Variables in Rust

In Rust, a **variable** is a named storage location in memory that holds a value. Think of it as a labeled box where you can store data for later use. However, Rust treats variables quite differently from many other programming languages, and this difference is what makes Rust special for writing safe and efficient code.

## Variable Declaration and Immutability

### The Default: Immutable Variables

By default, all variables in Rust are **immutable**, meaning once you assign a value to them, you cannot change it. This is a fundamental departure from most programming languages where variables are mutable by default.

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);

    // This would cause a compilation error:
    // x = 6;  // ERROR: cannot assign twice to immutable variable
}
```

This default immutability helps prevent bugs. Imagine you're reading a large codebaseâ€”if variables can change anywhere, you need to track all possible modifications. With immutable variables, you can be confident the value stays constant.

### Making Variables Mutable

When you need to change a variable's value, you must explicitly declare it as mutable using the `mut` keyword:

```rust
fn main() {
    let mut y = 5;
    println!("The value of y is: {}", y);

    y = 6;  // This is perfectly fine now
    println!("The value of y is now: {}", y);
}
```

### Constants: The Truly Unchangeable

Constants are similar to immutable variables but with important differences:

```rust
const MAX_POINTS: u32 = 100_000;
const PI: f64 = 3.14159;

fn main() {
    println!("Maximum points: {}", MAX_POINTS);
}
```

**Key differences between constants and immutable variables:**

- Constants use the `const` keyword instead of `let`
- Constants _must_ have an explicit type annotation
- Constants can only be set to constant expressions, not runtime values
- Constants can be declared in any scope, including global scope
- By convention, constants use SCREAMING_SNAKE_CASE

## Variable Shadowing

Rust allows you to declare a new variable with the same name as a previous variable. This is called **shadowing**:

```rust
fn main() {
    let x = 5;

    let x = x + 1;  // Shadows the first x

    {
        let x = x * 2;  // Shadows in this scope
        println!("Inner scope x: {}", x);  // Prints 12
    }

    println!("Outer scope x: {}", x);  // Prints 6
}
```

Shadowing is different from making a variable mutable. With shadowing, you're creating a new variable that happens to have the same name. This allows you to:

- Change the type of a value while reusing the name
- Transform a value without declaring it mutable

```rust
fn main() {
    let spaces = "   ";  // This is a string
    let spaces = spaces.len();  // Now it's a number

    // This wouldn't work with mut:
    // let mut spaces = "   ";
    // spaces = spaces.len();  // ERROR: mismatched types
}
```

## Data Types in Rust

Rust is a **statically typed** language, meaning all variable types must be known at compile time. The compiler can usually infer types, but sometimes you need to specify them explicitly.

### Scalar Types

Scalar types represent a single value. Rust has four primary scalar types:

#### 1. Integer Types

Integers are numbers without fractional components. Rust provides both signed and unsigned integers of various sizes:

| Length  | Signed | Unsigned |
| ------- | ------ | -------- |
| 8-bit   | i8     | u8       |
| 16-bit  | i16    | u16      |
| 32-bit  | i32    | u32      |
| 64-bit  | i64    | u64      |
| 128-bit | i128   | u128     |
| arch    | isize  | usize    |

```rust
fn main() {
    let small_number: i8 = 127;  // Can hold -128 to 127
    let big_number: u64 = 18_446_744_073_709_551_615;
    let default_int = 42;  // Defaults to i32

    // Using underscores for readability
    let million = 1_000_000;

    // Different number formats
    let hex = 0xff;
    let octal = 0o77;
    let binary = 0b1111_0000;
    let byte = b'A';  // u8 only
}
```

**Signed vs. Unsigned:** Signed integers (i8, i16, etc.) can represent both positive and negative numbers. Unsigned integers (u8, u16, etc.) can only represent non-negative numbers, but can hold larger positive values.

#### 2. Floating-Point Types

Rust has two floating-point types for numbers with decimal points:

```rust
fn main() {
    let x = 2.0;  // Defaults to f64
    let y: f32 = 3.0;  // Explicit f32

    // Floating-point arithmetic
    let sum = 5.5 + 10.3;
    let difference = 95.5 - 4.3;
    let product = 4.0 * 30.0;
    let quotient = 56.7 / 32.2;
}
```

The `f64` type is the default because on modern CPUs, it's roughly the same speed as `f32` but with more precision.

#### 3. Boolean Type

The boolean type has two possible values:

```rust
fn main() {
    let t = true;
    let f: bool = false;  // With explicit type annotation

    // Booleans are often used in conditionals
    if t {
        println!("The condition was true!");
    }
}
```

#### 4. Character Type

Rust's `char` type represents a Unicode Scalar Value, meaning it can represent more than just ASCII:

```rust
fn main() {
    let c = 'z';
    let z: char = 'â„¤';
    let heart_eyed_cat = 'ðŸ˜»';

    // Note: char uses single quotes
    // Strings use double quotes
    let not_a_char = "z";  // This is a string slice
}
```

Rust's `char` type is four bytes in size, representing any Unicode character from emoji to Chinese characters.

### Compound Types

Compound types can group multiple values into one type.

#### 1. Tuple Type

A tuple groups together values of different types:

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);

    // Destructuring a tuple
    let (x, y, z) = tup;
    println!("The value of y is: {}", y);

    // Accessing tuple elements directly
    let five_hundred = tup.0;
    let six_point_four = tup.1;
    let one = tup.2;

    // Unit type - a tuple with no elements
    let unit: () = ();
}
```

Tuples have a fixed length and cannot grow or shrink after declaration.

#### 2. Array Type

Arrays hold multiple values of the _same_ type with a _fixed_ length:

```rust
fn main() {
    // Basic array declaration
    let a = [1, 2, 3, 4, 5];

    // Array with explicit type annotation
    let months: [&str; 12] = [
        "January", "February", "March", "April",
        "May", "June", "July", "August",
        "September", "October", "November", "December"
    ];

    // Array with same value repeated
    let zeros = [0; 5];  // Creates [0, 0, 0, 0, 0]

    // Accessing array elements
    let first = a[0];
    let second = a[1];

    println!("First element: {}", first);
}
```

Arrays in Rust are allocated on the stack and have a fixed size known at compile time.

### String Types

Rust has two main string types:

#### String Slice (&str)

```rust
fn main() {
    let s: &str = "Hello, world!";

    // String literals are string slices
    let literal = "I'm stored in the binary";
}
```

String slices are immutable references to string data.

#### String (Owned String)

```rust
fn main() {
    // Creating a String from a string literal
    let mut s = String::from("Hello");

    // Strings can grow
    s.push_str(", world!");

    println!("{}", s);
}
```

## How Rust Differs from Other Languages

### 1. Ownership and Borrowing

This is Rust's most distinctive feature. Unlike languages with garbage collection (Java, Python, Go) or manual memory management (C, C++), Rust uses a unique ownership system:

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;  // Ownership moves to s2

    // This would cause an error:
    // println!("{}", s1);  // ERROR: value borrowed after move

    println!("{}", s2);  // This works fine
}
```

**Compare with Python:**

```python
s1 = "hello"
s2 = s1
print(s1)  # Works fine - both reference the same object
print(s2)
```

### 2. No Null Values

Unlike most languages, Rust doesn't have null. Instead, it uses the `Option` type:

```rust
fn main() {
    let some_number: Option<i32> = Some(5);
    let no_number: Option<i32> = None;

    // Must explicitly handle both cases
    match some_number {
        Some(num) => println!("Number is: {}", num),
        None => println!("No number present"),
    }
}
```

**Compare with Java:**

```java
Integer number = 5;
Integer noNumber = null;
// Can cause NullPointerException at runtime!
```

### 3. Immutability by Default

Most languages make variables mutable by default:

**JavaScript:**

```javascript
let x = 5;
x = 6; // Fine
```

**Rust:**

```rust
let x = 5;
// x = 6;  // Compilation error!
let mut y = 5;
y = 6;  // This is fine
```

### 4. Type Inference with Strong Typing

Rust combines the best of both worlds:

```rust
fn main() {
    let x = 5;  // Type inferred as i32
    let y = 2.5;  // Type inferred as f64

    // But still strongly typed
    // let z = x + y;  // ERROR: mismatched types

    let z = x as f64 + y;  // Must explicitly cast
}
```

**Compare with Python (dynamically typed):**

```python
x = 5
y = 2.5
z = x + y  # Works fine, Python handles this at runtime
```

### 5. No Implicit Type Coercion

```rust
fn main() {
    let x: i32 = 5;
    let y: i64 = 10;

    // This won't work:
    // let sum = x + y;  // ERROR: type mismatch

    // Must explicitly cast:
    let sum = x as i64 + y;
}
```

**Compare with C:**

```c
int x = 5;
long y = 10;
long sum = x + y;  // C implicitly converts x to long
```

## Practical Examples

### Example 1: Temperature Converter

```rust
fn main() {
    let fahrenheit: f64 = 32.0;
    let celsius = (fahrenheit - 32.0) * 5.0 / 9.0;

    println!("{}Â°F is {:.2}Â°C", fahrenheit, celsius);

    // Converting back
    let back_to_f = celsius * 9.0 / 5.0 + 32.0;
    println!("{}Â°C is {:.2}Â°F", celsius, back_to_f);
}
```

### Example 2: Working with Arrays

```rust
fn main() {
    let numbers = [1, 2, 3, 4, 5];
    let mut sum = 0;

    // Iterating over an array
    for num in numbers.iter() {
        sum += num;
    }

    let average = sum as f64 / numbers.len() as f64;
    println!("Average: {:.2}", average);
}
```

### Example 3: Type Safety in Action

```rust
fn main() {
    let age: u8 = 25;
    let name = "Alice";

    // This demonstrates type safety
    let info = format!("{} is {} years old", name, age);
    println!("{}", info);

    // Cannot accidentally mix types
    // let wrong = age + name;  // Compilation error!
}
```

## Summary

Rust's variable system emphasizes **safety**, **explicitness**, and **control**. The key principles are:

1. **Immutability by default** prevents accidental mutations
2. **Explicit mutability** (`mut`) makes change intentions clear
3. **Strong static typing** catches errors at compile time
4. **No null values** eliminates null pointer errors
5. **Ownership system** manages memory without garbage collection
6. **Type inference** reduces boilerplate while maintaining type safety

These features make Rust ideal for systems programming where reliability and performance are crucial, while the compiler helps you write correct code from the start.
