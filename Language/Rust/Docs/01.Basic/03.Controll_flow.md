# Control Flow in Rust: A Comprehensive Guide

## Understanding Control Flow

**Control flow** refers to the order in which individual statements, instructions, or function calls are executed in a program. In Rust, control flow constructs allow you to make decisions (`if/else`), repeat operations (`loop`, `while`, `for`), and handle different scenarios based on conditions. Rust's control flow mechanisms are both powerful and safe, preventing many common programming errors at compile time.

## Conditional Statements: if/else

### Basic if Expressions

In Rust, `if` is an **expression**, not just a statement. This means it evaluates to a value, which is a key difference from many other languages.

```rust
fn main() {
    let number = 7;

    if number > 5 {
        println!("The number is greater than 5");
    }

    let temperature = 25;

    if temperature > 30 {
        println!("It's hot outside!");
    }
}
```

**Important:** The condition in an `if` expression must be a `bool`. Rust won't automatically convert non-boolean types to boolean.

```rust
fn main() {
    let number = 3;

    // This will NOT work in Rust:
    // if number {  // ERROR! expected `bool`, found integer
    //     println!("number was something");
    // }

    // You must be explicit:
    if number != 0 {
        println!("number was something other than zero");
    }
}
```

### if/else Expressions

```rust
fn main() {
    let number = 6;

    if number % 2 == 0 {
        println!("{} is even", number);
    } else {
        println!("{} is odd", number);
    }

    // Checking age eligibility
    let age = 18;

    if age >= 18 {
        println!("You can vote!");
    } else {
        println!("You cannot vote yet.");
    }
}
```

### Multiple Conditions with else if

```rust
fn main() {
    let number = 42;

    if number < 0 {
        println!("The number is negative");
    } else if number == 0 {
        println!("The number is zero");
    } else if number < 10 {
        println!("The number is a single digit");
    } else if number < 100 {
        println!("The number is a two-digit number");
    } else {
        println!("The number is 100 or greater");
    }
}
```

**Performance Note:** Rust evaluates conditions from top to bottom and stops at the first true condition. Order your conditions from most specific to least specific for best results.

### Using if in a let Statement

Because `if` is an expression, you can use it on the right side of a `let` statement:

```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);

    // Practical example: determining status
    let score = 85;
    let grade = if score >= 90 {
        'A'
    } else if score >= 80 {
        'B'
    } else if score >= 70 {
        'C'
    } else if score >= 60 {
        'D'
    } else {
        'F'
    };

    println!("Your grade is: {}", grade);
}
```

**Critical Rule:** All branches of an `if` expression used in a `let` statement must return the same type:

```rust
fn main() {
    let condition = true;

    // This will NOT compile:
    // let number = if condition { 5 } else { "six" };
    // ERROR: `if` and `else` have incompatible types

    // Both branches must return the same type:
    let number = if condition { 5 } else { 6 };  // Both i32
}
```

### Nested if Expressions

```rust
fn main() {
    let user_age = 25;
    let has_id = true;

    if user_age >= 18 {
        if has_id {
            println!("Access granted");
        } else {
            println!("Please show your ID");
        }
    } else {
        println!("You must be 18 or older");
    }

    // Better: using logical operators
    if user_age >= 18 && has_id {
        println!("Access granted");
    } else if user_age >= 18 {
        println!("Please show your ID");
    } else {
        println!("You must be 18 or older");
    }
}
```

## Loops in Rust

Rust provides three kinds of loops: `loop`, `while`, and `for`. Each serves a different purpose and has its own use cases.

## The `loop` Keyword: Infinite Loops

The `loop` keyword creates an infinite loop that continues until you explicitly tell it to stop using `break`.

### Basic loop

```rust
fn main() {
    let mut counter = 0;

    loop {
        counter += 1;
        println!("Count: {}", counter);

        if counter == 5 {
            break;
        }
    }

    println!("Loop ended!");
}
```

### Returning Values from Loops

One of Rust's unique features: you can return a value from a loop using `break`:

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;  // Return value from loop
        }
    };

    println!("The result is: {}", result);  // Prints: 20
}
```

This is incredibly useful for retry logic or searching operations:

```rust
fn main() {
    let search_target = 7;
    let numbers = [1, 3, 5, 7, 9, 11];
    let mut index = 0;

    let found_index = loop {
        if index >= numbers.len() {
            break None;  // Not found
        }

        if numbers[index] == search_target {
            break Some(index);  // Found!
        }

        index += 1;
    };

    match found_index {
        Some(i) => println!("Found {} at index {}", search_target, i),
        None => println!("{} not found", search_target),
    }
}
```

### Loop Labels for Nested Loops

When you have nested loops, loop labels let you specify which loop to `break` or `continue`:

```rust
fn main() {
    let mut count = 0;

    'outer: loop {
        println!("Outer loop count: {}", count);
        let mut remaining = 10;

        loop {
            println!("  Inner loop remaining: {}", remaining);

            if remaining == 5 {
                break;  // Breaks inner loop
            }

            if count == 2 {
                break 'outer;  // Breaks outer loop
            }

            remaining -= 1;
        }

        count += 1;
    }

    println!("All loops ended!");
}
```

Practical example with loop labels:

```rust
fn main() {
    let matrix = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9],
    ];

    let search_for = 5;
    let mut found = false;

    'search: for (row_index, row) in matrix.iter().enumerate() {
        for (col_index, &value) in row.iter().enumerate() {
            if value == search_for {
                println!("Found {} at position ({}, {})",
                         search_for, row_index, col_index);
                found = true;
                break 'search;  // Exit both loops
            }
        }
    }

    if !found {
        println!("{} not found in matrix", search_for);
    }
}
```

## The `while` Loop: Conditional Loops

A `while` loop runs as long as a condition is true. It's perfect when you don't know in advance how many iterations you'll need.

### Basic while Loop

```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);
        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```

### while Loop with Complex Conditions

```rust
fn main() {
    let mut attempts = 0;
    let max_attempts = 3;
    let mut success = false;

    while attempts < max_attempts && !success {
        attempts += 1;
        println!("Attempt #{}", attempts);

        // Simulate some operation (e.g., network request)
        let random_success = attempts == 2;  // Succeeds on 2nd try

        if random_success {
            success = true;
            println!("Operation succeeded!");
        } else {
            println!("Operation failed, retrying...");
        }
    }

    if !success {
        println!("Failed after {} attempts", max_attempts);
    }
}
```

### while Loop for Input Processing

```rust
fn main() {
    let mut input = String::from("Hello, World!");

    while !input.is_empty() {
        println!("Current: {}", input);
        input.pop();  // Remove last character
    }

    println!("String is now empty!");
}
```

### Potential Pitfall: Infinite while Loops

```rust
fn main() {
    let mut x = 0;

    // BE CAREFUL: This is an infinite loop!
    // while x >= 0 {
    //     println!("{}", x);
    //     x += 1;
    // }
    // x will never be negative, so this never stops!

    // Correct version with a reasonable exit condition:
    while x < 10 {
        println!("{}", x);
        x += 1;
    }
}
```

## The `for` Loop: Iterating Over Collections

The `for` loop is the most commonly used loop in Rust. It's safe, concise, and eliminates many common errors associated with indexing.

### Iterating Over Ranges

```rust
fn main() {
    // Inclusive range: 1 to 5
    for number in 1..6 {
        println!("{}", number);
    }

    println!("---");

    // Inclusive on both ends
    for number in 1..=5 {
        println!("{}", number);
    }
}
```

### Reverse Iteration

```rust
fn main() {
    // Countdown
    for number in (1..6).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
```

### Iterating Over Arrays

```rust
fn main() {
    let animals = ["cat", "dog", "bird", "fish"];

    // Method 1: Direct iteration (most idiomatic)
    for animal in animals.iter() {
        println!("Animal: {}", animal);
    }

    println!("---");

    // Method 2: With index using enumerate
    for (index, animal) in animals.iter().enumerate() {
        println!("Animal #{}: {}", index + 1, animal);
    }
}
```

### Iterating Over Vectors

```rust
fn main() {
    let numbers = vec![10, 20, 30, 40, 50];

    // Borrowing (read-only)
    for num in &numbers {
        println!("Number: {}", num);
    }

    println!("---");

    // Mutable borrowing
    let mut numbers_mut = vec![1, 2, 3, 4, 5];
    for num in &mut numbers_mut {
        *num *= 2;  // Double each number
    }
    println!("Doubled: {:?}", numbers_mut);

    println!("---");

    // Taking ownership (consumes the vector)
    for num in numbers {
        println!("Owned: {}", num);
    }
    // numbers is no longer valid here!
}
```

### Why for is Safer Than while

**Using while (error-prone):**

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("Value: {}", a[index]);
        index += 1;
    }

    // Problems:
    // 1. Hardcoded length (5)
    // 2. Risk of index out of bounds
    // 3. More verbose
}
```

**Using for (safe and idiomatic):**

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!("Value: {}", element);
    }

    // Benefits:
    // 1. No index management
    // 2. No possibility of index errors
    // 3. Works with any length array
    // 4. More concise
}
```

## Common Problems Developers Face

### Problem 1: Using Assignment Instead of Comparison

**The Mistake:**

```rust
fn main() {
    let mut x = 5;

    // This won't compile in Rust!
    // if x = 10 {  // ERROR: mismatched types
    //     println!("x is 10");
    // }

    // Should be:
    if x == 10 {
        println!("x is 10");
    }
}
```

**Why Rust Prevents This:** In languages like C or JavaScript, `if (x = 10)` assigns 10 to x and then evaluates the result, often causing bugs. Rust requires boolean conditions, preventing this entire class of errors.

### Problem 2: Type Mismatch in if/else Expressions

**The Mistake:**

```rust
fn main() {
    let condition = true;

    // This will NOT compile:
    // let result = if condition {
    //     5
    // } else {
    //     "six"  // ERROR: different types!
    // };
}
```

**The Error:**

```
error[E0308]: `if` and `else` have incompatible types
 --> src/main.rs:4:9
  |
4 |     let result = if condition {
  |                  -- expected because of this
5 |         5
  |         - expected because of this
6 |     } else {
7 |         "six"
  |         ^^^^^ expected integer, found `&str`
```

**The Fix:**

```rust
fn main() {
    let condition = true;

    // Both branches return the same type
    let result = if condition {
        5
    } else {
        6
    };

    println!("Result: {}", result);
}
```

### Problem 3: Forgetting to Modify Loop Variable

**The Mistake (Infinite Loop):**

```rust
fn main() {
    let mut count = 0;

    // DANGER: Infinite loop!
    // while count < 5 {
    //     println!("Count: {}", count);
    //     // Forgot to increment count!
    // }
}
```

**The Fix:**

```rust
fn main() {
    let mut count = 0;

    while count < 5 {
        println!("Count: {}", count);
        count += 1;  // Don't forget this!
    }
}
```

### Problem 4: Index Out of Bounds with while

**The Mistake:**

```rust
fn main() {
    let array = [1, 2, 3, 4, 5];
    let mut index = 0;

    // Potential panic if condition is wrong
    while index <= 5 {  // Should be < 5, not <= 5
        println!("{}", array[index]);  // Panic on index 5!
        index += 1;
    }
}
```

**The Fix (Use for):**

```rust
fn main() {
    let array = [1, 2, 3, 4, 5];

    // Safe: no possibility of index errors
    for element in array.iter() {
        println!("{}", element);
    }
}
```

### Problem 5: Borrowing Issues in Loops

**The Mistake:**

```rust
fn main() {
    let mut numbers = vec![1, 2, 3, 4, 5];

    // This won't compile:
    // for num in &numbers {
    //     numbers.push(6);  // ERROR: can't mutate while borrowed
    // }
}
```

**The Error:**

```
error[E0502]: cannot borrow `numbers` as mutable because it is also borrowed as immutable
```

**The Fix:**

```rust
fn main() {
    let mut numbers = vec![1, 2, 3, 4, 5];

    // Collect indices first, then modify
    let indices_to_double: Vec<usize> = (0..numbers.len()).collect();

    for i in indices_to_double {
        numbers[i] *= 2;
    }

    println!("{:?}", numbers);

    // Or use a different approach:
    let mut numbers2 = vec![1, 2, 3, 4, 5];
    numbers2 = numbers2.into_iter().map(|x| x * 2).collect();
    println!("{:?}", numbers2);
}
```

### Problem 6: Using continue/break Incorrectly

**Understanding the Difference:**

```rust
fn main() {
    println!("Using continue:");
    for i in 1..=10 {
        if i % 2 == 0 {
            continue;  // Skip even numbers
        }
        println!("{}", i);  // Only odd numbers printed
    }

    println!("\nUsing break:");
    for i in 1..=10 {
        if i == 5 {
            break;  // Stop completely at 5
        }
        println!("{}", i);  // Prints 1, 2, 3, 4
    }
}
```

### Problem 7: Shadowing Loop Variables

**Be Careful:**

```rust
fn main() {
    let mut x = 0;

    loop {
        let x = x + 1;  // This shadows, doesn't modify outer x!
        println!("x: {}", x);  // Always prints 1

        if x > 3 {
            break;  // This never happens!
        }
    }

    // Correct version:
    let mut y = 0;

    loop {
        y = y + 1;  // Modifies the outer y
        println!("y: {}", y);

        if y > 3 {
            break;
        }
    }
}
```

## Best Practices for Control Flow

### Practice 1: Prefer `for` Over `while` for Iteration

**Less Idiomatic:**

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    let mut i = 0;

    while i < numbers.len() {
        println!("{}", numbers[i]);
        i += 1;
    }
}
```

**More Idiomatic:**

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];

    for number in &numbers {
        println!("{}", number);
    }
}
```

### Practice 2: Use `match` Instead of Complex if/else Chains

**Less Clean:**

```rust
fn main() {
    let number = 3;

    if number == 1 {
        println!("One");
    } else if number == 2 {
        println!("Two");
    } else if number == 3 {
        println!("Three");
    } else {
        println!("Other");
    }
}
```

**Cleaner:**

```rust
fn main() {
    let number = 3;

    match number {
        1 => println!("One"),
        2 => println!("Two"),
        3 => println!("Three"),
        _ => println!("Other"),
    }
}
```

### Practice 3: Return Early to Reduce Nesting

**Deeply Nested:**

```rust
fn process_value(value: Option<i32>) {
    if let Some(v) = value {
        if v > 0 {
            if v < 100 {
                println!("Valid value: {}", v);
            } else {
                println!("Value too large");
            }
        } else {
            println!("Value must be positive");
        }
    } else {
        println!("No value provided");
    }
}
```

**Early Return (Better):**

```rust
fn process_value(value: Option<i32>) {
    let v = match value {
        Some(val) => val,
        None => {
            println!("No value provided");
            return;
        }
    };

    if v <= 0 {
        println!("Value must be positive");
        return;
    }

    if v >= 100 {
        println!("Value too large");
        return;
    }

    println!("Valid value: {}", v);
}

fn main() {
    process_value(Some(50));
    process_value(Some(-5));
    process_value(Some(150));
    process_value(None);
}
```

### Practice 4: Use Iterator Methods Instead of Manual Loops

**Manual Loop:**

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    let mut sum = 0;

    for num in &numbers {
        sum += num;
    }

    println!("Sum: {}", sum);
}
```

**Iterator Method (More Functional):**

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    let sum: i32 = numbers.iter().sum();

    println!("Sum: {}", sum);
}
```

### Practice 5: Use `loop` with `break` for Retry Logic

```rust
use std::io::{self, Write};

fn main() {
    let correct_password = "rust123";
    let max_attempts = 3;
    let mut attempts = 0;

    let authenticated = loop {
        attempts += 1;

        print!("Enter password (attempt {}/{}): ", attempts, max_attempts);
        io::stdout().flush().unwrap();

        let mut input = String::new();
        io::stdin().read_line(&mut input).unwrap();
        let input = input.trim();

        if input == correct_password {
            break true;
        }

        if attempts >= max_attempts {
            break false;
        }

        println!("Incorrect password. Try again.");
    };

    if authenticated {
        println!("Access granted!");
    } else {
        println!("Access denied. Too many failed attempts.");
    }
}
```

### Practice 6: Combine Guards for Cleaner Code

**Multiple Nested Conditions:**

```rust
fn can_drive(age: u32, has_license: bool, has_insurance: bool) -> bool {
    if age >= 16 {
        if has_license {
            if has_insurance {
                return true;
            }
        }
    }
    false
}
```

**Combined Conditions (Better):**

```rust
fn can_drive(age: u32, has_license: bool, has_insurance: bool) -> bool {
    age >= 16 && has_license && has_insurance
}

fn main() {
    println!("Can drive: {}", can_drive(18, true, true));
    println!("Can drive: {}", can_drive(15, true, true));
    println!("Can drive: {}", can_drive(18, false, true));
}
```

## Practical Real-World Examples

### Example 1: FizzBuzz

```rust
fn main() {
    for number in 1..=100 {
        if number % 15 == 0 {
            println!("FizzBuzz");
        } else if number % 3 == 0 {
            println!("Fizz");
        } else if number % 5 == 0 {
            println!("Buzz");
        } else {
            println!("{}", number);
        }
    }
}
```

**Alternative with match:**

```rust
fn main() {
    for number in 1..=100 {
        match (number % 3, number % 5) {
            (0, 0) => println!("FizzBuzz"),
            (0, _) => println!("Fizz"),
            (_, 0) => println!("Buzz"),
            _ => println!("{}", number),
        }
    }
}
```

### Example 2: Finding Prime Numbers

```rust
fn main() {
    let limit = 50;
    println!("Prime numbers up to {}:", limit);

    for number in 2..=limit {
        if is_prime(number) {
            print!("{} ", number);
        }
    }
    println!();
}

fn is_prime(n: u32) -> bool {
    if n < 2 {
        return false;
    }

    if n == 2 {
        return true;
    }

    if n % 2 == 0 {
        return false;
    }

    let limit = (n as f64).sqrt() as u32;

    for divisor in (3..=limit).step_by(2) {
        if n % divisor == 0 {
            return false;
        }
    }

    true
}
```

### Example 3: Menu-Driven Program

```rust
use std::io::{self, Write};

fn main() {
    loop {
        println!("\n=== Calculator Menu ===");
        println!("1. Add");
        println!("2. Subtract");
        println!("3. Multiply");
        println!("4. Divide");
        println!("5. Exit");
        print!("Enter your choice: ");
        io::stdout().flush().unwrap();

        let mut choice = String::new();
        io::stdin().read_line(&mut choice).unwrap();
        let choice: u32 = match choice.trim().parse() {
            Ok(num) => num,
            Err(_) => {
                println!("Invalid input!");
                continue;
            }
        };

        if choice == 5 {
            println!("Goodbye!");
            break;
        }

        if choice < 1 || choice > 5 {
            println!("Invalid choice!");
            continue;
        }

        print!("Enter first number: ");
        io::stdout().flush().unwrap();
        let mut num1 = String::new();
        io::stdin().read_line(&mut num1).unwrap();
        let num1: f64 = num1.trim().parse().unwrap_or(0.0);

        print!("Enter second number: ");
        io::stdout().flush().unwrap();
        let mut num2 = String::new();
        io::stdin().read_line(&mut num2).unwrap();
        let num2: f64 = num2.trim().parse().unwrap_or(0.0);

        let result = match choice {
            1 => num1 + num2,
            2 => num1 - num2,
            3 => num1 * num2,
            4 => {
                if num2 == 0.0 {
                    println!("Cannot divide by zero!");
                    continue;
                }
                num1 / num2
            }
            _ => unreachable!(),
        };

        println!("Result: {}", result);
    }
}
```

### Example 4: Pattern Search with Nested Loops

```rust
fn main() {
    let text = "The quick brown fox jumps over the lazy dog";
    let patterns = ["fox", "cat", "dog", "bird"];

    println!("Searching for patterns in: \"{}\"", text);

    for pattern in &patterns {
        if text.contains(pattern) {
            // Find position
            let mut position = 0;
            let mut found = false;

            for (i, _) in text.char_indices() {
                if text[i..].starts_with(pattern) {
                    position = i;
                    found = true;
                    break;
                }
            }

            if found {
                println!("✓ Found '{}' at position {}", pattern, position);
            }
        } else {
            println!("✗ '{}' not found", pattern);
        }
    }
}
```

### Example 5: Game Loop with Score Tracking

```rust
fn main() {
    let mut score = 0;
    let mut level = 1;
    let mut game_over = false;

    println!("=== Simple Number Guessing Game ===");

    while !game_over {
        println!("\n--- Level {} ---", level);
        println!("Current Score: {}", score);

        let target = 5 * level;  // Target increases with level
        let mut attempts = 3;
        let mut level_won = false;

        println!("Guess a number between 1 and {}", target * 2);
        println!("You have {} attempts", attempts);

        while attempts > 0 {
            // Simulate user input (in real game, read from stdin)
            let guess = (target as f64 * 0.8) as i32;  // Simulate guess

            println!("Guess {}: {}", 4 - attempts, guess);

            if guess == target {
                println!("Correct! +10 points");
                score += 10;
                level_won = true;
                break;
            } else if guess < target {
                println!("Too low!");
            } else {
                println!("Too high!");
            }

            attempts -= 1;
            score -= 2;  // Penalty for wrong guess
        }

        if !level_won {
            println!("\nGame Over! Final Score: {}", score);
            game_over = true;
        } else {
            level += 1;

            if level > 3 {
                println!("\nYou Win! Final Score: {}", score);
                game_over = true;
            }
        }
    }
}
```

### Example 6: Data Processing Pipeline

````rust
fn main() {
    let data = vec![
        ("Alice", 85),
        ("Bob", 92),
        ("Charlie", 78),
        ("Diana", 95),
        ("Eve", 88),
    ];

    println!("=== Student Grade Report ===\n");

    let mut total_score = 0;
    let mut count = 0;
    let mut highest_score = 0;
    let mut highest_scorer = "";

    for (name, score) in &data {
        // Calculate letter grade
        let grade = if *score >= 90 {
            'A'
        } else if *score >= 80 {
            'B'
        } else if *score >= 70 {
            'C'
        } else if *score >= 60 {
            'D'
        } else {
            'F'
        };

        // Display status
        let status = match grade {
            'A' | 'B' => "Excellent!",
            'C' => "Good",
            'D' => "Needs Improvement",
            'F' => "Failed",
            _ => "Unknown",
        };

        println!("{:10} - Score: {:3} - Grade: {} ({})",
                 name, score, grade, status);

        // Track statistics
        total_score += score;
        count += 1;
        ```rust
        if *score > highest_score {
            highest_score = *score;
            highest_scorer = name;
        }
    }

    // Calculate and display average
    let average = if count > 0 {
        total_score as f64 / count as f64
    } else {
        0.0
    };

    println!("\n=== Class Statistics ===");
    println!("Total Students: {}", count);
    println!("Average Score: {:.2}", average);
    println!("Highest Score: {} ({})", highest_score, highest_scorer);
}
````

### Example 7: Fibonacci Sequence Generator

```rust
fn main() {
    println!("=== Fibonacci Sequence Generator ===\n");

    let limit = 10;
    let mut a = 0;
    let mut b = 1;
    let mut count = 0;

    println!("First {} Fibonacci numbers:", limit);

    while count < limit {
        print!("{} ", a);

        let next = a + b;
        a = b;
        b = next;
        count += 1;
    }

    println!("\n");

    // Alternative: Using for loop with range
    println!("Fibonacci numbers using function:");
    for i in 0..limit {
        print!("{} ", fibonacci(i));
    }
    println!();
}

fn fibonacci(n: u32) -> u64 {
    if n == 0 {
        return 0;
    }
    if n == 1 {
        return 1;
    }

    let mut a = 0;
    let mut b = 1;

    for _ in 2..=n {
        let next = a + b;
        a = b;
        b = next;
    }

    b
}
```

### Example 8: Password Validator

```rust
fn main() {
    let test_passwords = vec![
        "weak",
        "Better123",
        "Str0ng!Pass",
        "onlylowercase",
        "ONLYUPPERCASE",
        "NoSpecial123",
    ];

    println!("=== Password Strength Validator ===\n");

    for password in test_passwords {
        print!("Password '{}': ", password);

        let strength = validate_password(password);

        match strength {
            PasswordStrength::VeryWeak => println!("❌ Very Weak"),
            PasswordStrength::Weak => println!("⚠️  Weak"),
            PasswordStrength::Medium => println!("👍 Medium"),
            PasswordStrength::Strong => println!("✅ Strong"),
        }
    }
}

enum PasswordStrength {
    VeryWeak,
    Weak,
    Medium,
    Strong,
}

fn validate_password(password: &str) -> PasswordStrength {
    let mut score = 0;

    // Check length
    if password.len() >= 8 {
        score += 1;
    }
    if password.len() >= 12 {
        score += 1;
    }

    // Check for uppercase
    let mut has_upper = false;
    for c in password.chars() {
        if c.is_uppercase() {
            has_upper = true;
            break;
        }
    }
    if has_upper {
        score += 1;
    }

    // Check for lowercase
    let mut has_lower = false;
    for c in password.chars() {
        if c.is_lowercase() {
            has_lower = true;
            break;
        }
    }
    if has_lower {
        score += 1;
    }

    // Check for digits
    let mut has_digit = false;
    for c in password.chars() {
        if c.is_numeric() {
            has_digit = true;
            break;
        }
    }
    if has_digit {
        score += 1;
    }

    // Check for special characters
    let mut has_special = false;
    for c in password.chars() {
        if !c.is_alphanumeric() {
            has_special = true;
            break;
        }
    }
    if has_special {
        score += 1;
    }

    // Determine strength based on score
    match score {
        0..=2 => PasswordStrength::VeryWeak,
        3..=4 => PasswordStrength::Weak,
        5 => PasswordStrength::Medium,
        _ => PasswordStrength::Strong,
    }
}
```

### Example 9: Shopping Cart with Discounts

```rust
fn main() {
    let mut cart_total = 0.0;
    let items = vec![
        ("Laptop", 999.99, 1),
        ("Mouse", 29.99, 2),
        ("Keyboard", 79.99, 1),
        ("Monitor", 299.99, 2),
    ];

    println!("=== Shopping Cart ===\n");
    println!("{:<15} {:<10} {:<8} {:<10}", "Item", "Price", "Qty", "Subtotal");
    println!("{}", "-".repeat(50));

    for (item_name, price, quantity) in &items {
        let subtotal = price * (*quantity as f64);
        cart_total += subtotal;

        println!("{:<15} ${:<9.2} {:<8} ${:<9.2}",
                 item_name, price, quantity, subtotal);
    }

    println!("{}", "-".repeat(50));
    println!("{:<34} ${:.2}", "Subtotal:", cart_total);

    // Apply discounts based on total
    let discount_rate = if cart_total >= 1000.0 {
        0.20  // 20% discount for orders over $1000
    } else if cart_total >= 500.0 {
        0.10  // 10% discount for orders over $500
    } else if cart_total >= 200.0 {
        0.05  // 5% discount for orders over $200
    } else {
        0.0   // No discount
    };

    if discount_rate > 0.0 {
        let discount_amount = cart_total * discount_rate;
        println!("{:<34} -${:.2} ({}%)",
                 "Discount:", discount_amount, (discount_rate * 100.0) as i32);
        cart_total -= discount_amount;
    }

    let tax_rate = 0.08;  // 8% tax
    let tax = cart_total * tax_rate;
    println!("{:<34} ${:.2}", "Tax (8%):", tax);

    let final_total = cart_total + tax;
    println!("{}", "=".repeat(50));
    println!("{:<34} ${:.2}", "TOTAL:", final_total);
}
```

### Example 10: Text Analyzer

```rust
fn main() {
    let text = "Hello, World! This is a test. This test tests Rust.";

    println!("=== Text Analysis ===");
    println!("Original text: \"{}\"\n", text);

    // Count characters
    let mut char_count = 0;
    for _ in text.chars() {
        char_count += 1;
    }
    println!("Total characters: {}", char_count);

    // Count words
    let words: Vec<&str> = text.split_whitespace().collect();
    println!("Total words: {}", words.len());

    // Count sentences (simplified: count periods, exclamations, questions)
    let mut sentence_count = 0;
    for c in text.chars() {
        if c == '.' || c == '!' || c == '?' {
            sentence_count += 1;
        }
    }
    println!("Total sentences: {}", sentence_count);

    // Count vowels and consonants
    let mut vowel_count = 0;
    let mut consonant_count = 0;

    for c in text.chars() {
        if c.is_alphabetic() {
            let lower = c.to_lowercase().next().unwrap();
            if "aeiou".contains(lower) {
                vowel_count += 1;
            } else {
                consonant_count += 1;
            }
        }
    }

    println!("Vowels: {}", vowel_count);
    println!("Consonants: {}", consonant_count);

    // Find most common word
    println!("\n=== Word Frequency ===");
    let mut word_counts: Vec<(&str, usize)> = Vec::new();

    for word in &words {
        let word_lower = word.to_lowercase();
        let word_clean = word_lower.trim_matches(|c: char| !c.is_alphanumeric());

        let mut found = false;
        for (stored_word, count) in &mut word_counts {
            if stored_word.eq_ignore_ascii_case(word_clean) {
                *count += 1;
                found = true;
                break;
            }
        }

        if !found && !word_clean.is_empty() {
            word_counts.push((word_clean, 1));
        }
    }

    // Sort by frequency
    for i in 0..word_counts.len() {
        for j in 0..word_counts.len() - 1 - i {
            if word_counts[j].1 < word_counts[j + 1].1 {
                word_counts.swap(j, j + 1);
            }
        }
    }

    // Display word frequencies
    for (word, count) in word_counts.iter().take(5) {
        println!("'{}': {} time(s)", word, count);
    }
}
```

## Advanced Control Flow Patterns

### Pattern 1: State Machine

```rust
fn main() {
    let mut state = State::Idle;
    let events = vec![
        Event::Start,
        Event::Pause,
        Event::Resume,
        Event::Stop,
        Event::Start,
    ];

    println!("=== State Machine Demo ===\n");

    for event in events {
        println!("Current state: {:?}", state);
        println!("Event: {:?}", event);

        state = match (state, event) {
            (State::Idle, Event::Start) => {
                println!("→ Starting...\n");
                State::Running
            }
            (State::Running, Event::Pause) => {
                println!("→ Pausing...\n");
                State::Paused
            }
            (State::Paused, Event::Resume) => {
                println!("→ Resuming...\n");
                State::Running
            }
            (State::Running, Event::Stop) => {
                println!("→ Stopping...\n");
                State::Idle
            }
            (State::Paused, Event::Stop) => {
                println!("→ Stopping...\n");
                State::Idle
            }
            _ => {
                println!("→ Invalid transition!\n");
                state
            }
        };
    }
}

#[derive(Debug, Clone, Copy)]
enum State {
    Idle,
    Running,
    Paused,
}

#[derive(Debug, Clone, Copy)]
enum Event {
    Start,
    Pause,
    Resume,
    Stop,
}
```

### Pattern 2: Iterator Combinations

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    println!("=== Iterator Patterns ===\n");

    // Filter and map
    println!("Even numbers doubled:");
    for num in numbers.iter()
        .filter(|&&x| x % 2 == 0)
        .map(|&x| x * 2) {
        print!("{} ", num);
    }
    println!("\n");

    // Chain multiple ranges
    println!("Chained ranges:");
    for num in (1..=3).chain(10..=12) {
        print!("{} ", num);
    }
    println!("\n");

    // Take while condition is true
    println!("Take while less than 6:");
    for num in numbers.iter().take_while(|&&x| x < 6) {
        print!("{} ", num);
    }
    println!("\n");

    // Skip and take
    println!("Skip 3, take 4:");
    for num in numbers.iter().skip(3).take(4) {
        print!("{} ", num);
    }
    println!("\n");

    // Enumerate with filtering
    println!("Indexed even numbers:");
    for (index, num) in numbers.iter()
        .enumerate()
        .filter(|(_, &n)| n % 2 == 0) {
        println!("  Index {}: {}", index, num);
    }
}
```

### Pattern 3: Early Exit with Labels

```rust
fn main() {
    println!("=== Finding Twin Primes ===\n");

    let limit = 100;
    let mut twin_primes_found = 0;
    let target_pairs = 5;

    'outer: for n in 2..limit {
        if !is_prime(n) {
            continue;
        }

        // Check if n+2 is also prime (twin prime)
        if is_prime(n + 2) {
            println!("Twin prime pair: ({}, {})", n, n + 2);
            twin_primes_found += 1;

            if twin_primes_found >= target_pairs {
                println!("\nFound {} pairs, stopping search.", target_pairs);
                break 'outer;
            }
        }
    }
}

fn is_prime(n: u32) -> bool {
    if n < 2 {
        return false;
    }
    if n == 2 {
        return true;
    }
    if n % 2 == 0 {
        return false;
    }

    let limit = (n as f64).sqrt() as u32;
    for i in (3..=limit).step_by(2) {
        if n % i == 0 {
            return false;
        }
    }

    true
}
```

### Pattern 4: Collecting Results from Loops

```rust
fn main() {
    println!("=== Processing Results ===\n");

    let numbers = vec![1, 2, 3, 4, 5];
    let mut results = Vec::new();

    for num in &numbers {
        let processed = process_number(*num);
        results.push(processed);
    }

    println!("Original: {:?}", numbers);
    println!("Processed: {:?}", results);

    // Alternative: using iter().map().collect()
    let results2: Vec<Result<i32, String>> = numbers
        .iter()
        .map(|&n| process_number(n))
        .collect();

    println!("\nResults with error handling:");
    for (i, result) in results2.iter().enumerate() {
        match result {
            Ok(value) => println!("  [{}] Success: {}", i, value),
            Err(e) => println!("  [{}] Error: {}", i, e),
        }
    }
}

fn process_number(n: i32) -> Result<i32, String> {
    if n <= 0 {
        Err(format!("Number {} must be positive", n))
    } else {
        Ok(n * n)
    }
}
```

## Performance Considerations

### Consideration 1: Iterator vs. Index Loop

```rust
fn main() {
    let large_vec: Vec<i32> = (1..=1000).collect();

    // Less efficient (bounds checking on every access)
    let mut sum1 = 0;
    for i in 0..large_vec.len() {
        sum1 += large_vec[i];
    }

    // More efficient (no bounds checking, optimized by compiler)
    let mut sum2 = 0;
    for &item in &large_vec {
        sum2 += item;
    }

    // Most efficient (compiler can optimize heavily)
    let sum3: i32 = large_vec.iter().sum();

    println!("All sums equal: {}", sum1 == sum2 && sum2 == sum3);
}
```

### Consideration 2: Avoiding Unnecessary Clones

```rust
fn main() {
    let strings = vec![
        String::from("Hello"),
        String::from("World"),
        String::from("Rust"),
    ];

    // Less efficient: clones each string
    // for s in strings.clone() {
    //     println!("{}", s);
    // }

    // More efficient: borrows each string
    for s in &strings {
        println!("{}", s);
    }

    // strings is still usable here
    println!("\nOriginal vector still available: {:?}", strings);
}
```

### Consideration 3: Breaking Early

```rust
fn main() {
    let numbers: Vec<i32> = (1..=1000).collect();
    let target = 42;

    // Efficient: stops as soon as found
    let mut found = false;
    for &num in &numbers {
        if num == target {
            println!("Found {} at position", target);
            found = true;
            break;  // Don't continue searching
        }
    }

    if !found {
        println!("Target not found");
    }

    // Alternative using iterator method
    let position = numbers.iter().position(|&x| x == target);
    match position {
        Some(pos) => println!("Found at index: {}", pos),
        None => println!("Not found"),
    }
}
```

## Summary: Control Flow Best Practices

### Key Takeaways

1. **Use `for` loops for iteration** - They're safer and more idiomatic than `while` loops with manual index management

2. **`if` is an expression** - You can assign its result to a variable, but all branches must return the same type

3. **Prefer `loop` with `break` for infinite loops** - More explicit than `while true`

4. **Use loop labels for nested loops** - Makes break/continue intentions clear

5. **Match over complex if/else chains** - More readable and exhaustive

6. **Return early to reduce nesting** - Improves readability

7. **Use iterator methods** - Often more concise and efficient than manual loops

8. **Break early when possible** - Don't waste cycles on unnecessary iterations

9. **Use descriptive loop variable names** - Except for simple counters (`i`, `j`)

10. **Remember borrowing rules** - Can't mutate a collection while iterating over it

### Common Control Flow Patterns

```rust
// Pattern 1: Searching
for item in collection {
    if condition(item) {
        return Some(item);
    }
}
None

// Pattern 2: Filtering
for item in collection {
    if condition(item) {
        results.push(item);
    }
}

// Pattern 3: Transforming
for item in collection {
    let transformed = transform(item);
    results.push(transformed);
}

// Pattern 4: Accumulating
for item in collection {
    accumulator += item;
}

// Pattern 5: Validation
for item in collection {
    if !is_valid(item) {
        return Err(error);
    }
}
Ok(())
```

By mastering these control flow constructs and patterns, you'll write more efficient, readable, and idiomatic Rust code. The compiler's strict rules might seem constraining at first, but they prevent entire classes of bugs that plague other languages!
