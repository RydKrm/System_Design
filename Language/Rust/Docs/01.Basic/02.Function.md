# Functions and Return Values in Rust: A Comprehensive Guide

## Understanding Functions in Rust

A **function** is a reusable block of code that performs a specific task. Functions are the building blocks of Rust programs, allowing you to organize code into logical, maintainable units. In Rust, functions are declared using the `fn` keyword, and the language has strict rules about how functions work, which helps prevent common programming errors.

## Basic Function Syntax

### The Simplest Function

```rust
fn main() {
    println!("Hello from main!");
    greet();
}

fn greet() {
    println!("Hello, world!");
}
```

In Rust, function names follow **snake_case** convention (lowercase with underscores). The `main` function is special—it's the entry point of every executable Rust program.

### Functions with Parameters

Parameters allow you to pass data into functions:

```rust
fn main() {
    greet_person("Alice");
    greet_person("Bob");
}

fn greet_person(name: &str) {
    println!("Hello, {}!", name);
}
```

**Key Point:** In Rust, you must always specify the type of each parameter. This is non-negotiable and different from dynamically-typed languages like Python or JavaScript.

### Multiple Parameters

```rust
fn main() {
    print_sum(5, 10);
    print_labeled_measurement(42, 'kg');
}

fn print_sum(x: i32, y: i32) {
    println!("The sum of {} and {} is {}", x, y, x + y);
}

fn print_labeled_measurement(value: i32, unit: char) {
    println!("The measurement is: {}{}", value, unit);
}
```

## Return Values: The Rust Way

### Understanding Expressions vs Statements

This is crucial to understand: Rust is an **expression-oriented** language, which means most things evaluate to a value.

**Statement:** An instruction that performs an action but doesn't return a value.

```rust
let x = 5;  // This is a statement
```

**Expression:** Code that evaluates to a value.

```rust
5 + 6  // This is an expression that evaluates to 11
```

### The Implicit Return

In Rust, the last expression in a function is automatically returned. Notice there's **no semicolon** and **no return keyword**:

```rust
fn main() {
    let result = add(5, 3);
    println!("5 + 3 = {}", result);
}

fn add(x: i32, y: i32) -> i32 {
    x + y  // No semicolon! This is an expression that gets returned
}
```

**If you add a semicolon, you turn it into a statement, and it won't return the value:**

```rust
fn add_wrong(x: i32, y: i32) -> i32 {
    x + y;  // ERROR! This is now a statement, returns nothing
}
```

### Explicit Return with the `return` Keyword

You can use `return` for early returns or when you prefer being explicit:

```rust
fn main() {
    println!("Absolute value of -5: {}", absolute_value(-5));
    println!("Absolute value of 3: {}", absolute_value(3));
}

fn absolute_value(x: i32) -> i32 {
    if x < 0 {
        return -x;  // Early return
    }
    x  // Implicit return for the normal case
}
```

### Multiple Return Types with Tuples

When you need to return multiple values, use tuples:

```rust
fn main() {
    let (quot, rem) = divide_with_remainder(17, 5);
    println!("17 ÷ 5 = {} remainder {}", quot, rem);

    let (min, max) = min_max(42, 7);
    println!("Min: {}, Max: {}", min, max);
}

fn divide_with_remainder(dividend: i32, divisor: i32) -> (i32, i32) {
    let quotient = dividend / divisor;
    let remainder = dividend % divisor;
    (quotient, remainder)  // Returning a tuple
}

fn min_max(a: i32, b: i32) -> (i32, i32) {
    if a < b {
        (a, b)
    } else {
        (b, a)
    }
}
```

### The Unit Type: Functions That Return Nothing

Functions that don't return a meaningful value have a return type of `()`, called the **unit type**:

```rust
fn main() {
    say_hello();
    print_number(42);
}

// These are equivalent:
fn say_hello() -> () {
    println!("Hello!");
}

fn print_number(n: i32) {
    println!("Number: {}", n);
}  // Return type () is implicit
```

## Common Problems Developers Face

### Problem 1: Adding Semicolons to Return Expressions

**The Mistake:**

```rust
fn calculate_area(width: f64, height: f64) -> f64 {
    width * height;  // ERROR! Added semicolon by accident
}
```

**The Error Message:**

```
error[E0308]: mismatched types
 --> src/main.rs:2:48
  |
2 | fn calculate_area(width: f64, height: f64) -> f64 {
  |    --------------                              ^^^ expected `f64`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
3 |     width * height;
  |                   - help: remove this semicolon to return this value
```

**The Fix:**

```rust
fn calculate_area(width: f64, height: f64) -> f64 {
    width * height  // No semicolon!
}
```

**Understanding:** The semicolon turns your expression into a statement, which returns `()` instead of the calculated value.

### Problem 2: Forgetting Return Type Annotation

**The Mistake:**

```rust
fn multiply(a: i32, b: i32) {  // Missing -> i32
    a * b
}
```

**The Error Message:**

```
error[E0308]: mismatched types
 --> src/main.rs:1:33
  |
1 | fn multiply(a: i32, b: i32) {
  |    --------                 ^ expected `()`, found `i32`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
2 |     a * b
  |     ----- help: consider returning this value
```

**The Fix:**

```rust
fn multiply(a: i32, b: i32) -> i32 {
    a * b
}
```

### Problem 3: Type Mismatches in Returns

**The Mistake:**

```rust
fn get_age() -> i32 {
    let age = 25;
    age.to_string()  // Returning String instead of i32
}
```

**The Error Message:**

```
error[E0308]: mismatched types
 --> src/main.rs:3:5
  |
1 | fn get_age() -> i32 {
  |                 --- expected `i32` because of return type
2 |     let age = 25;
3 |     age.to_string()
  |     ^^^^^^^^^^^^^^^ expected `i32`, found `String`
```

**The Fix:**

```rust
fn get_age() -> i32 {
    let age = 25;
    age  // Return the integer itself
}

// Or if you need the string version:
fn get_age_as_string() -> String {
    let age = 25;
    age.to_string()
}
```

### Problem 4: Returning References Without Proper Lifetimes

**The Mistake:**

```rust
fn create_string() -> &str {
    let s = String::from("Hello");
    &s  // ERROR! Returning reference to local variable
}
```

**The Error Message:**

```
error[E0106]: missing lifetime specifier
 --> src/main.rs:1:23
  |
1 | fn create_string() -> &str {
  |                       ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value,
          but there is no value for it to be borrowed from
```

**The Fix (Option 1 - Return Owned Data):**

```rust
fn create_string() -> String {
    let s = String::from("Hello");
    s  // Return ownership
}
```

**The Fix (Option 2 - Return String Literal):**

```rust
fn get_greeting() -> &'static str {
    "Hello, World!"  // String literals have 'static lifetime
}
```

### Problem 5: Mixing Mutable and Immutable References

**The Mistake:**

```rust
fn main() {
    let mut value = 10;
    let result = add_and_modify(&mut value, 5);
    println!("Value: {}, Result: {}", value, result);
}

fn add_and_modify(x: &mut i32, y: i32) -> &i32 {
    *x += y;
    x  // ERROR! Returning mutable reference as immutable
}
```

**The Fix:**

```rust
fn main() {
    let mut value = 10;
    add_and_modify(&mut value, 5);
    println!("Modified value: {}", value);
}

fn add_and_modify(x: &mut i32, y: i32) {
    *x += y;
    // Don't return the reference, just modify in place
}

// Or return the new value:
fn add_and_return(x: &mut i32, y: i32) -> i32 {
    *x += y;
    *x  // Return the value, not the reference
}
```

### Problem 6: Unreachable Code After Return

**The Mistake:**

```rust
fn check_number(n: i32) -> &str {
    if n > 0 {
        return "Positive";
    }
    if n < 0 {
        return "Negative";
    }
    println!("This will never execute!");  // Unreachable!
    "Zero"
}
```

**Warning Message:**

```
warning: unreachable statement
 --> src/main.rs:8:5
  |
8 |     println!("This will never execute!");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
```

**The Fix:**

```rust
fn check_number(n: i32) -> &str {
    if n > 0 {
        "Positive"
    } else if n < 0 {
        "Negative"
    } else {
        "Zero"
    }
}
```

## Best Practices for Writing Rust Functions

### Practice 1: Keep Functions Small and Focused

**Bad Example:**

```rust
fn process_user_data(name: &str, age: i32, email: &str,
                     is_premium: bool) -> String {
    // Validate name
    let validated_name = if name.len() > 0 {
        name.to_uppercase()
    } else {
        "UNKNOWN".to_string()
    };

    // Validate age
    let validated_age = if age >= 0 && age <= 120 {
        age
    } else {
        0
    };

    // Validate email
    let validated_email = if email.contains('@') {
        email.to_lowercase()
    } else {
        "invalid@email.com".to_string()
    };

    // Format output
    format!("{} ({}) - {} - Premium: {}",
            validated_name, validated_age, validated_email, is_premium)
}
```

**Good Example (Single Responsibility):**

```rust
fn main() {
    let user_info = format_user_info("alice", 25, "Alice@Example.com", true);
    println!("{}", user_info);
}

fn validate_name(name: &str) -> String {
    if name.is_empty() {
        "UNKNOWN".to_string()
    } else {
        name.to_uppercase()
    }
}

fn validate_age(age: i32) -> i32 {
    if age >= 0 && age <= 120 {
        age
    } else {
        0
    }
}

fn validate_email(email: &str) -> String {
    if email.contains('@') {
        email.to_lowercase()
    } else {
        "invalid@email.com".to_string()
    }
}

fn format_user_info(name: &str, age: i32, email: &str,
                    is_premium: bool) -> String {
    let valid_name = validate_name(name);
    let valid_age = validate_age(age);
    let valid_email = validate_email(email);

    format!("{} ({}) - {} - Premium: {}",
            valid_name, valid_age, valid_email, is_premium)
}
```

### Practice 2: Use Descriptive Function Names

**Bad:**

```rust
fn proc(x: i32, y: i32) -> i32 {
    x * y + 10
}

fn do_thing(s: &str) -> bool {
    s.len() > 5
}
```

**Good:**

```rust
fn calculate_price_with_tax(base_price: i32, tax_rate: i32) -> i32 {
    base_price * tax_rate / 100 + base_price
}

fn is_valid_password(password: &str) -> bool {
    password.len() > 8
}
```

### Practice 3: Use Type Aliases for Complex Types

**Without Type Alias:**

```rust
fn process_data(input: Vec<(String, i32, bool)>)
    -> Result<Vec<(String, i32, bool)>, String> {
    // Function body
    Ok(input)
}
```

**With Type Alias:**

```rust
type UserRecord = (String, i32, bool);
type ProcessingResult = Result<Vec<UserRecord>, String>;

fn process_data(input: Vec<UserRecord>) -> ProcessingResult {
    // Much more readable!
    Ok(input)
}
```

### Practice 4: Use the `Result` Type for Error Handling

**Bad (Using Panic):**

```rust
fn divide(a: f64, b: f64) -> f64 {
    if b == 0.0 {
        panic!("Division by zero!");  // Program crashes!
    }
    a / b
}
```

**Good (Using Result):**

```rust
fn main() {
    match divide(10.0, 2.0) {
        Ok(result) => println!("Result: {}", result),
        Err(e) => println!("Error: {}", e),
    }

    match divide(10.0, 0.0) {
        Ok(result) => println!("Result: {}", result),
        Err(e) => println!("Error: {}", e),
    }
}

fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err("Division by zero".to_string())
    } else {
        Ok(a / b)
    }
}
```

### Practice 5: Use `Option` for Optional Values

**Bad (Using Magic Values):**

```rust
fn find_user_age(name: &str) -> i32 {
    if name == "Alice" {
        30
    } else {
        -1  // Magic value indicating "not found"
    }
}
```

**Good (Using Option):**

```rust
fn main() {
    match find_user_age("Alice") {
        Some(age) => println!("Alice is {} years old", age),
        None => println!("User not found"),
    }
}

fn find_user_age(name: &str) -> Option<i32> {
    if name == "Alice" {
        Some(30)
    } else {
        None
    }
}
```

### Practice 6: Prefer Borrowing Over Ownership

**Less Efficient (Takes Ownership):**

```rust
fn print_string(s: String) {
    println!("{}", s);
}  // s is dropped here, can't be used again

fn main() {
    let my_string = String::from("Hello");
    print_string(my_string);
    // Can't use my_string anymore!
}
```

**More Efficient (Borrows):**

```rust
fn print_string(s: &str) {
    println!("{}", s);
}

fn main() {
    let my_string = String::from("Hello");
    print_string(&my_string);
    print_string(&my_string);  // Can use it again!
    println!("Still have: {}", my_string);
}
```

### Practice 7: Use `impl Trait` for Complex Return Types

**Without `impl Trait`:**

```rust
use std::iter::Map;
use std::slice::Iter;

fn get_doubled_numbers(numbers: &[i32])
    -> Map<Iter<i32>, fn(&i32) -> i32> {
    numbers.iter().map(|x| x * 2)
}
```

**With `impl Trait`:**

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    let doubled: Vec<i32> = get_doubled_numbers(&numbers).collect();
    println!("{:?}", doubled);
}

fn get_doubled_numbers(numbers: &[i32]) -> impl Iterator<Item = i32> + '_ {
    numbers.iter().map(|x| x * 2)
}
```

### Practice 8: Document Your Functions

````rust
/// Calculates the area of a rectangle.
///
/// # Arguments
///
/// * `width` - The width of the rectangle in meters
/// * `height` - The height of the rectangle in meters
///
/// # Returns
///
/// The area in square meters
///
/// # Examples
///
/// ```
/// let area = calculate_rectangle_area(5.0, 10.0);
/// assert_eq!(area, 50.0);
/// ```
fn calculate_rectangle_area(width: f64, height: f64) -> f64 {
    width * height
}
````

## Advanced Function Patterns

### Pattern 1: Method Chaining with Builder Pattern

```rust
#[derive(Debug)]
struct User {
    name: String,
    age: i32,
    email: String,
}

impl User {
    fn new(name: &str) -> Self {
        User {
            name: name.to_string(),
            age: 0,
            email: String::new(),
        }
    }

    fn with_age(mut self, age: i32) -> Self {
        self.age = age;
        self
    }

    fn with_email(mut self, email: &str) -> Self {
        self.email = email.to_string();
        self
    }
}

fn main() {
    let user = User::new("Alice")
        .with_age(30)
        .with_email("alice@example.com");

    println!("{:?}", user);
}
```

### Pattern 2: Higher-Order Functions

Functions that take other functions as parameters:

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];

    let doubled = apply_operation(&numbers, double);
    let squared = apply_operation(&numbers, square);

    println!("Doubled: {:?}", doubled);
    println!("Squared: {:?}", squared);
}

fn apply_operation<F>(numbers: &[i32], operation: F) -> Vec<i32>
where
    F: Fn(i32) -> i32,
{
    numbers.iter().map(|&x| operation(x)).collect()
}

fn double(x: i32) -> i32 {
    x * 2
}

fn square(x: i32) -> i32 {
    x * x
}
```

### Pattern 3: Closures as Function Parameters

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let evens = filter_numbers(&numbers, |x| x % 2 == 0);
    let greater_than_five = filter_numbers(&numbers, |x| x > 5);

    println!("Even numbers: {:?}", evens);
    println!("Greater than 5: {:?}", greater_than_five);
}

fn filter_numbers<F>(numbers: &[i32], predicate: F) -> Vec<i32>
where
    F: Fn(i32) -> bool,
{
    numbers.iter()
        .filter(|&&x| predicate(x))
        .copied()
        .collect()
}
```

### Pattern 4: Generic Functions

```rust
fn main() {
    println!("Max of 5 and 10: {}", max(5, 10));
    println!("Max of 3.14 and 2.71: {}", max(3.14, 2.71));
    println!("Max of 'a' and 'z': {}", max('a', 'z'));
}

fn max<T: PartialOrd>(a: T, b: T) -> T {
    if a > b {
        a
    } else {
        b
    }
}
```

## Practical Real-World Examples

### Example 1: Input Validation Function

```rust
fn main() {
    let test_cases = vec![
        "user@example.com",
        "invalid-email",
        "another@valid.org",
    ];

    for email in test_cases {
        match validate_email(email) {
            Ok(valid_email) => println!("✓ Valid: {}", valid_email),
            Err(e) => println!("✗ Invalid: {} - {}", email, e),
        }
    }
}

fn validate_email(email: &str) -> Result<String, String> {
    if email.is_empty() {
        return Err("Email cannot be empty".to_string());
    }

    if !email.contains('@') {
        return Err("Email must contain @".to_string());
    }

    if !email.contains('.') {
        return Err("Email must contain a domain".to_string());
    }

    Ok(email.to_lowercase())
}
```

### Example 2: Data Transformation Pipeline

```rust
fn main() {
    let raw_data = vec!["  Alice  ", "BOB", "  charlie  "];
    let processed = process_names(raw_data);
    println!("{:?}", processed);
}

fn process_names(names: Vec<&str>) -> Vec<String> {
    names.into_iter()
        .map(|name| trim_whitespace(name))
        .map(|name| capitalize_first_letter(&name))
        .filter(|name| is_valid_name(name))
        .collect()
}

fn trim_whitespace(s: &str) -> String {
    s.trim().to_string()
}

fn capitalize_first_letter(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(first) => {
            first.to_uppercase().collect::<String>() +
            &chars.as_str().to_lowercase()
        }
    }
}

fn is_valid_name(name: &str) -> bool {
    !name.is_empty() && name.len() >= 2
}
```

### Example 3: Calculator with Error Handling

```rust
fn main() {
    let operations = vec![
        (10.0, 5.0, "add"),
        (10.0, 5.0, "subtract"),
        (10.0, 5.0, "multiply"),
        (10.0, 5.0, "divide"),
        (10.0, 0.0, "divide"),
    ];

    for (a, b, op) in operations {
        match calculate(a, b, op) {
            Ok(result) => {
                println!("{} {} {} = {}", a, op, b, result);
            }
            Err(e) => {
                println!("Error: {} {} {} - {}", a, op, b, e);
            }
        }
    }
}

fn calculate(a: f64, b: f64, operation: &str) -> Result<f64, String> {
    match operation {
        "add" => Ok(add(a, b)),
        "subtract" => Ok(subtract(a, b)),
        "multiply" => Ok(multiply(a, b)),
        "divide" => divide(a, b),
        _ => Err(format!("Unknown operation: {}", operation)),
    }
}

fn add(a: f64, b: f64) -> f64 {
    a + b
}

fn subtract(a: f64, b: f64) -> f64 {
    a - b
}

fn multiply(a: f64, b: f64) -> f64 {
    a * b
}

fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err("Cannot divide by zero".to_string())
    } else {
        Ok(a / b)
    }
}
```

## Summary: Key Takeaways

### Essential Rules for Rust Functions

1. **Always specify parameter types** - Rust requires explicit type annotations for function parameters
2. **Omit semicolon for implicit returns** - The last expression without a semicolon is returned
3. **Specify return type with `-> Type`** - Be explicit about what your function returns
4. **Use `Result<T, E>` for operations that can fail** - Don't panic unless absolutely necessary
5. **Use `Option<T>` for optional values** - Avoid magic values like -1 or null
6. **Prefer borrowing (`&T`) over ownership (`T`)** - Unless you need to own the data
7. **Keep functions small and focused** - Each function should do one thing well
8. **Use descriptive names** - Function names should clearly indicate what they do
9. **Document complex functions** - Use doc comments (`///`) for important functions
10. **Handle all cases explicitly** - Use `match` or `if let` to handle all possibilities
