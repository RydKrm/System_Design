# The Complete Guide to Go Generics - Part 1 of 3

## From Type Parameters to Production-Ready Generic Code

---

## Table of Contents - Complete Guide

### Part 1 (This Document)

1. [Introduction: The Problem Generics Solve](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#introduction-the-problem-generics-solve)
2. [The Necessity of Generics](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#the-necessity-of-generics)
3. [Generics Fundamentals](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#generics-fundamentals)
4. [Type Parameters](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#type-parameters)
5. [Type Constraints](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#type-constraints)
6. [Generic Functions](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#generic-functions)

### Part 2

7. Generic Types (Structs and Interfaces)
8. Generic Methods
9. Type Inference
10. Advanced Constraints
11. Generic Collections
12. Real-World Patterns

### Part 3

13. Performance Considerations
14. Generic Testing Patterns
15. Common Pitfalls and Anti-Patterns
16. Migration from interface{} to Generics
17. Production Best Practices
18. Complete Production Examples

---

## Introduction: The Problem Generics Solve

Before Go 1.18 (March 2022), writing type-safe, reusable code was painful. Let's see why.

### The Problem: Code Duplication Without Generics

**Scenario:** You need a function to find the maximum value in a slice.

```go
// Before Generics - Need separate function for each type

func MaxInt(slice []int) int {
    if len(slice) == 0 {
        panic("empty slice")
    }
    max := slice[0]
    for _, v := range slice[1:] {
        if v > max {
            max = v
        }
    }
    return max
}

func MaxFloat64(slice []float64) float64 {
    if len(slice) == 0 {
        panic("empty slice")
    }
    max := slice[0]
    for _, v := range slice[1:] {
        if v > max {
            max = v
        }
    }
    return max
}

func MaxString(slice []string) string {
    if len(slice) == 0 {
        panic("empty slice")
    }
    max := slice[0]
    for _, v := range slice[1:] {
        if v > max {
            max = v
        }
    }
    return max
}

// Need to duplicate for every type: int8, int16, int32, int64,
// uint, uint8, uint16, uint32, uint64, float32, string, etc.
// That's at least 12+ nearly identical functions!

func main() {
    ints := []int{1, 5, 3, 9, 2}
    fmt.Println(MaxInt(ints)) // 9
    
    floats := []float64{1.5, 5.2, 3.1, 9.8, 2.3}
    fmt.Println(MaxFloat64(floats)) // 9.8
    
    strings := []string{"apple", "zebra", "banana"}
    fmt.Println(MaxString(strings)) // zebra
}
```

**Problems:**

- ❌ Code duplication (same logic, different types)
- ❌ Maintenance nightmare (fix bug in 12+ places)
- ❌ Can't add new types without modifying code
- ❌ No compile-time type safety

### Alternative: interface{} - Type Safety Lost

```go
// Using interface{} - Loses type safety

func Max(slice []interface{}) interface{} {
    if len(slice) == 0 {
        panic("empty slice")
    }
    
    max := slice[0]
    for _, v := range slice[1:] {
        // Runtime type assertions and comparisons
        switch max.(type) {
        case int:
            if v.(int) > max.(int) {
                max = v
            }
        case float64:
            if v.(float64) > max.(float64) {
                max = v
            }
        case string:
            if v.(string) > max.(string) {
                max = v
            }
        // ... need cases for every type
        }
    }
    return max
}

func main() {
    // Have to wrap everything in interface{}
    ints := []interface{}{1, 5, 3, 9, 2}
    result := Max(ints)
    
    // Have to type assert the result
    maxInt := result.(int) // Runtime panic if wrong type!
    fmt.Println(maxInt)
    
    // No compile-time type checking
    mixed := []interface{}{1, "hello", 3.14} // Compiles but wrong!
    Max(mixed) // Runtime panic!
}
```

**Problems:**

- ❌ No type safety (errors at runtime, not compile-time)
- ❌ Performance overhead (interface boxing/unboxing)
- ❌ Verbose (type assertions everywhere)
- ❌ Can accidentally mix types

### Solution: Generics - Best of Both Worlds

```go
// With Generics - Single function, type safe, reusable

import "cmp"

func Max[T cmp.Ordered](slice []T) T {
    if len(slice) == 0 {
        var zero T
        return zero
    }
    
    max := slice[0]
    for _, v := range slice[1:] {
        if v > max {
            max = v
        }
    }
    return max
}

func main() {
    // Works with any ordered type
    ints := []int{1, 5, 3, 9, 2}
    fmt.Println(Max(ints)) // 9
    
    floats := []float64{1.5, 5.2, 3.1, 9.8, 2.3}
    fmt.Println(Max(floats)) // 9.8
    
    strings := []string{"apple", "zebra", "banana"}
    fmt.Println(Max(strings)) // zebra
    
    // Compile-time type safety!
    // Max([]interface{}{1, "hello"}) // Won't compile!
}
```

**Benefits:**

- ✅ Single implementation for all types
- ✅ Compile-time type safety
- ✅ No code duplication
- ✅ No performance overhead
- ✅ Clean, readable code

---

## The Necessity of Generics

Generics aren't just convenient—they're essential for building robust, maintainable Go applications.

### Problem 1: The Type-Safe Data Structure Dilemma

**Without Generics:**

```go
// Want to build a Stack data structure

// Option 1: Specific type (not reusable)
type IntStack struct {
    items []int
}

func (s *IntStack) Push(item int) {
    s.items = append(s.items, item)
}

func (s *IntStack) Pop() int {
    if len(s.items) == 0 {
        panic("empty stack")
    }
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item
}

// Need separate Stack for every type:
type StringStack struct { /* duplicate code */ }
type UserStack struct { /* duplicate code */ }
type OrderStack struct { /* duplicate code */ }
// ... etc

// Option 2: interface{} (loses type safety)
type Stack struct {
    items []interface{}
}

func (s *Stack) Push(item interface{}) {
    s.items = append(s.items, item)
}

func (s *Stack) Pop() interface{} {
    if len(s.items) == 0 {
        panic("empty stack")
    }
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item
}

func main() {
    stack := &Stack{}
    stack.Push(42)
    stack.Push("wrong type") // No compile error!
    
    value := stack.Pop()
    // Type assertion required, can panic at runtime
    num := value.(int) // Panics if value is string!
}
```

**With Generics:**

```go
type Stack[T any] struct {
    items []T
}

func (s *Stack[T]) Push(item T) {
    s.items = append(s.items, item)
}

func (s *Stack[T]) Pop() T {
    if len(s.items) == 0 {
        var zero T
        return zero
    }
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item
}

func main() {
    // Type-safe integer stack
    intStack := &Stack[int]{}
    intStack.Push(42)
    // intStack.Push("wrong") // Won't compile!
    
    value := intStack.Pop() // value is int, no type assertion needed!
    fmt.Println(value + 10) // Safe to use as int
    
    // Different type, same code
    stringStack := &Stack[string]{}
    stringStack.Push("hello")
    str := stringStack.Pop() // str is string
    fmt.Println(strings.ToUpper(str))
}
```

### Problem 2: The Utility Function Explosion

**Without Generics:**

```go
// Utility functions need duplication

// Map function for integers
func MapInt(slice []int, fn func(int) int) []int {
    result := make([]int, len(slice))
    for i, v := range slice {
        result[i] = fn(v)
    }
    return result
}

// Map function for strings
func MapString(slice []string, fn func(string) string) []string {
    result := make([]string, len(slice))
    for i, v := range slice {
        result[i] = fn(v)
    }
    return result
}

// Need MapFloat64, MapByte, MapRune, MapUser, etc.

// Filter function for integers
func FilterInt(slice []int, fn func(int) bool) []int {
    result := []int{}
    for _, v := range slice {
        if fn(v) {
            result = append(result, v)
        }
    }
    return result
}

// Filter function for strings
func FilterString(slice []string, fn func(string) bool) []string {
    result := []string{}
    for _, v := range slice {
        if fn(v) {
            result = append(result, v)
        }
    }
    return result
}

// Need FilterFloat64, FilterByte, FilterRune, etc.

func main() {
    nums := []int{1, 2, 3, 4, 5}
    doubled := MapInt(nums, func(n int) int { return n * 2 })
    evens := FilterInt(doubled, func(n int) bool { return n%2 == 0 })
    
    // If I want to work with float64, I need all new functions!
}
```

**With Generics:**

```go
// Single Map function for all types
func Map[T any, U any](slice []T, fn func(T) U) []U {
    result := make([]U, len(slice))
    for i, v := range slice {
        result[i] = fn(v)
    }
    return result
}

// Single Filter function for all types
func Filter[T any](slice []T, fn func(T) bool) []T {
    result := []T{}
    for _, v := range slice {
        if fn(v) {
            result = append(result, v)
        }
    }
    return result
}

func main() {
    // Works with any type
    nums := []int{1, 2, 3, 4, 5}
    doubled := Map(nums, func(n int) int { return n * 2 })
    evens := Filter(doubled, func(n int) bool { return n%2 == 0 })
    
    floats := []float64{1.1, 2.2, 3.3}
    rounded := Map(floats, func(f float64) int { return int(f) })
    
    strings := []string{"hello", "world"}
    upper := Map(strings, strings.ToUpper)
    
    // Type conversions work too
    nums2 := []int{1, 2, 3}
    strs := Map(nums2, func(n int) string { return fmt.Sprintf("%d", n) })
}
```

### Problem 3: The Optional Value Problem

**Without Generics:**

```go
// Optional int
type OptionalInt struct {
    value   int
    present bool
}

func SomeInt(v int) OptionalInt {
    return OptionalInt{value: v, present: true}
}

func NoneInt() OptionalInt {
    return OptionalInt{present: false}
}

func (o OptionalInt) Get() (int, bool) {
    return o.value, o.present
}

// Need OptionalString, OptionalFloat64, OptionalUser, etc.

func FindInt(slice []int, predicate func(int) bool) OptionalInt {
    for _, v := range slice {
        if predicate(v) {
            return SomeInt(v)
        }
    }
    return NoneInt()
}

// Need FindString, FindFloat64, etc.
```

**With Generics:**

```go
// Single Optional type for all types
type Optional[T any] struct {
    value   T
    present bool
}

func Some[T any](v T) Optional[T] {
    return Optional[T]{value: v, present: true}
}

func None[T any]() Optional[T] {
    return Optional[T]{present: false}
}

func (o Optional[T]) Get() (T, bool) {
    return o.value, o.present
}

func (o Optional[T]) OrElse(defaultValue T) T {
    if o.present {
        return o.value
    }
    return defaultValue
}

// Single Find function for all types
func Find[T any](slice []T, predicate func(T) bool) Optional[T] {
    for _, v := range slice {
        if predicate(v) {
            return Some(v)
        }
    }
    return None[T]()
}

func main() {
    nums := []int{1, 2, 3, 4, 5}
    result := Find(nums, func(n int) bool { return n > 3 })
    
    if val, ok := result.Get(); ok {
        fmt.Println("Found:", val) // Found: 4
    }
    
    result2 := Find(nums, func(n int) bool { return n > 10 })
    fmt.Println("Or else:", result2.OrElse(999)) // Or else: 999
}
```

---

## Generics Fundamentals

### Type Parameters Syntax

Generics in Go use square brackets `[]` for type parameters:

```go
// Generic function
func FunctionName[T TypeConstraint](param T) T {
    return param
}

// Generic type
type TypeName[T TypeConstraint] struct {
    field T
}

// Multiple type parameters
func Map[T any, U any](input []T, fn func(T) U) []U {
    // ...
}

// Type parameter with constraint
func Sum[T int | float64](slice []T) T {
    // ...
}
```

### The `any` Constraint

`any` is an alias for `interface{}` and means "any type":

```go
// These are equivalent
func Print[T any](value T) {
    fmt.Println(value)
}

func Print[T interface{}](value T) {
    fmt.Println(value)
}

// Usage - works with any type
Print(42)           // int
Print("hello")      // string
Print(3.14)         // float64
Print(true)         // bool
Print([]int{1, 2})  // slice
```

### The `comparable` Constraint

`comparable` constraint allows `==` and `!=` operations:

```go
func Contains[T comparable](slice []T, target T) bool {
    for _, v := range slice {
        if v == target { // Can use == because T is comparable
            return true
        }
    }
    return false
}

// Works with comparable types
fmt.Println(Contains([]int{1, 2, 3}, 2))          // true
fmt.Println(Contains([]string{"a", "b"}, "c"))    // false

// Won't compile with non-comparable types
// Contains([][]int{{1}}, []int{1}) // Error: []int is not comparable
```

---

## Type Parameters

Type parameters allow functions and types to work with multiple types.

### Single Type Parameter

```go
// Identity function - returns same type as input
func Identity[T any](value T) T {
    return value
}

func main() {
    // Type is inferred from argument
    fmt.Println(Identity(42))      // 42 (int)
    fmt.Println(Identity("hello")) // hello (string)
    fmt.Println(Identity(3.14))    // 3.14 (float64)
    
    // Can explicitly specify type
    result := Identity[int](42)
    fmt.Println(result)
}
```

### Multiple Type Parameters

```go
// Pair holds two values of potentially different types
type Pair[T any, U any] struct {
    First  T
    Second U
}

func NewPair[T any, U any](first T, second U) Pair[T, U] {
    return Pair[T, U]{First: first, Second: second}
}

func main() {
    // int and string
    p1 := NewPair(42, "hello")
    fmt.Printf("First: %d, Second: %s\n", p1.First, p1.Second)
    
    // string and float64
    p2 := NewPair("pi", 3.14)
    fmt.Printf("First: %s, Second: %.2f\n", p2.First, p2.Second)
    
    // Both same type is also fine
    p3 := NewPair(1, 2)
    fmt.Printf("First: %d, Second: %d\n", p3.First, p3.Second)
}
```

### Type Parameter Naming Conventions

```go
// Common conventions:

// T - single type parameter (Type)
func Process[T any](value T) T { return value }

// T, U - multiple unrelated type parameters
func Convert[T any, U any](from T) U { /* ... */ }

// K, V - Key and Value (for maps/dictionaries)
type Map[K comparable, V any] struct {
    data map[K]V
}

// E - Element (for collections)
type List[E any] struct {
    elements []E
}

// Descriptive names for clarity
type Cache[Key comparable, Value any] struct {
    data map[Key]Value
}
```

---

## Type Constraints

Constraints limit which types can be used with generics, enabling operations on those types.

### Built-in Constraints

```go
import "constraints"

// any - any type (no operations available)
func Store[T any](value T) {
    // Can only store, assign, return
    // Cannot compare, add, etc.
}

// comparable - types that support == and !=
func Equal[T comparable](a, b T) bool {
    return a == b
}

// constraints.Ordered - types that support <, <=, >, >=
func Min[T constraints.Ordered](a, b T) T {
    if a < b {
        return a
    }
    return b
}
```

### Union Constraints (Type Sets)

```go
// Allow specific types using | (union)
func Add[T int | float64](a, b T) T {
    return a + b
}

func main() {
    fmt.Println(Add(1, 2))       // 3 (int)
    fmt.Println(Add(1.5, 2.5))   // 4.0 (float64)
    // Add("a", "b")             // Error: string not in constraint
}

// More complex unions
func Process[T int | int64 | float32 | float64](value T) T {
    return value * 2
}

// Underlying type constraint
type CustomInt int

func Double[T ~int](value T) T {
    return value * 2
}

func main() {
    var x int = 5
    fmt.Println(Double(x)) // 10
    
    var y CustomInt = 5
    fmt.Println(Double(y)) // 10 - works because CustomInt's underlying type is int
}
```

### Custom Constraint Interfaces

```go
// Define your own constraint
type Number interface {
    int | int8 | int16 | int32 | int64 |
    uint | uint8 | uint16 | uint32 | uint64 |
    float32 | float64
}

func Sum[T Number](numbers []T) T {
    var sum T
    for _, n := range numbers {
        sum += n
    }
    return sum
}

func main() {
    ints := []int{1, 2, 3, 4, 5}
    fmt.Println(Sum(ints)) // 15
    
    floats := []float64{1.1, 2.2, 3.3}
    fmt.Println(Sum(floats)) // 6.6
}

// Constraint with methods
type Stringer interface {
    String() string
}

func PrintAll[T Stringer](items []T) {
    for _, item := range items {
        fmt.Println(item.String())
    }
}

// Combining type set and methods
type Numeric interface {
    ~int | ~float64
    Abs() float64
}
```

### Approximate Type Constraints (~)

```go
// ~ means "underlying type"

type MyInt int

func Double[T ~int](value T) T {
    return value * 2
}

func main() {
    var regular int = 5
    fmt.Println(Double(regular)) // 10
    
    var custom MyInt = 5
    fmt.Println(Double(custom)) // 10 - works with ~int
}

// Without ~, would need exact type match
func DoubleExact[T int](value T) T {
    return value * 2
}

func main() {
    var regular int = 5
    fmt.Println(DoubleExact(regular)) // OK
    
    var custom MyInt = 5
    // DoubleExact(custom) // Error: MyInt is not int
}
```

---

## Generic Functions

### Basic Generic Functions

```go
// Swap two values
func Swap[T any](a, b T) (T, T) {
    return b, a
}

func main() {
    x, y := Swap(1, 2)
    fmt.Println(x, y) // 2 1
    
    s1, s2 := Swap("hello", "world")
    fmt.Println(s1, s2) // world hello
}

// First element of slice
func First[T any](slice []T) (T, bool) {
    if len(slice) == 0 {
        var zero T
        return zero, false
    }
    return slice[0], true
}

func main() {
    nums := []int{1, 2, 3}
    if first, ok := First(nums); ok {
        fmt.Println(first) // 1
    }
    
    empty := []string{}
    if _, ok := First(empty); !ok {
        fmt.Println("Empty slice")
    }
}
```

### Generic Functions with Constraints

```go
import "constraints"

// Max with ordered constraint
func Max[T constraints.Ordered](a, b T) T {
    if a > b {
        return a
    }
    return b
}

// Sum with numeric constraint
type Number interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64 |
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 |
    ~float32 | ~float64
}

func Sum[T Number](numbers ...T) T {
    var sum T
    for _, n := range numbers {
        sum += n
    }
    return sum
}

func main() {
    fmt.Println(Max(5, 10))           // 10
    fmt.Println(Max(3.14, 2.71))      // 3.14
    fmt.Println(Max("apple", "zebra")) // zebra
    
    fmt.Println(Sum(1, 2, 3, 4, 5))           // 15
    fmt.Println(Sum(1.5, 2.5, 3.5))           // 7.5
}
```

### Generic Slice Operations

```go
// Map applies function to each element
func Map[T any, U any](slice []T, fn func(T) U) []U {
    result := make([]U, len(slice))
    for i, v := range slice {
        result[i] = fn(v)
    }
    return result
}

// Filter keeps elements matching predicate
func Filter[T any](slice []T, predicate func(T) bool) []T {
    result := []T{}
    for _, v := range slice {
        if predicate(v) {
            result = append(result, v)
        }
    }
    return result
}

// Reduce combines elements into single value
func Reduce[T any, U any](slice []T, initial U, fn func(U, T) U) U {
    result := initial
    for _, v := range slice {
        result = fn(result, v)
    }
    return result
}

func main() {
    nums := []int{1, 2, 3, 4, 5}
    
    // Double each number
    doubled := Map(nums, func(n int) int { return n * 2 })
    fmt.Println(doubled) // [2 4 6 8 10]
    
    // Keep only even numbers
    evens := Filter(nums, func(n int) bool { return n%2 == 0 })
    fmt.Println(evens) // [2 4]
    
    // Sum all numbers
    sum := Reduce(nums, 0, func(acc, n int) int { return acc + n })
    fmt.Println(sum) // 15
    
    // Convert to strings
    strs := Map(nums, func(n int) string { return fmt.Sprintf("%d", n) })
    fmt.Println(strs) // ["1" "2" "3" "4" "5"]
}
```

### Generic Functions with Multiple Constraints

```go
// Keys returns all keys from a map
func Keys[K comparable, V any](m map[K]V) []K {
    keys := make([]K, 0, len(m))
    for k := range m {
        keys = append(keys, k)
    }
    return keys
}

// Values returns all values from a map
func Values[K comparable, V any](m map[K]V) []V {
    values := make([]V, 0, len(m))
    for _, v := range m {
        values = append(values, v)
    }
    return values
}

func main() {
    ages := map[string]int{
        "Alice": 30,
        "Bob":   25,
        "Carol": 35,
    }
    
    fmt.Println(Keys(ages))   // [Alice Bob Carol]
    fmt.Println(Values(ages)) // [30 25 35]
}
```

This completes Part 1 of the Go Generics guide. Part 2 will continue with Generic Types, Methods, and Advanced Patterns!

# The Complete Guide to Go Generics - Part 2 of 3

## Generic Types, Methods, Inference, and Real-World Patterns

---

## Table of Contents - Part 2

1. [Generic Types (Structs and Interfaces)](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#generic-types-structs-and-interfaces)
2. [Generic Methods](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#generic-methods)
3. [Type Inference](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#type-inference)
4. [Advanced Constraints](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#advanced-constraints)
5. [Generic Collections](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#generic-collections)
6. [Real-World Patterns](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#real-world-patterns)

---

## Generic Types (Structs and Interfaces)

### Generic Structs

```go
// Basic generic struct
type Box[T any] struct {
    Value T
}

func NewBox[T any](value T) Box[T] {
    return Box[T]{Value: value}
}

func (b Box[T]) Get() T {
    return b.Value
}

func main() {
    intBox := NewBox(42)
    fmt.Println(intBox.Get()) // 42
    
    stringBox := NewBox("hello")
    fmt.Println(stringBox.Get()) // hello
    
    // Can use struct literal too
    floatBox := Box[float64]{Value: 3.14}
    fmt.Println(floatBox.Value) // 3.14
}
```

### Generic Struct with Multiple Type Parameters

```go
// Result type - success or error
type Result[T any, E error] struct {
    value T
    err   E
}

func Ok[T any, E error](value T) Result[T, E] {
    return Result[T, E]{value: value}
}

func Err[T any, E error](err E) Result[T, E] {
    return Result[T, E]{err: err}
}

func (r Result[T, E]) IsOk() bool {
    return r.err == nil
}

func (r Result[T, E]) IsErr() bool {
    return r.err != nil
}

func (r Result[T, E]) Unwrap() (T, E) {
    return r.value, r.err
}

func (r Result[T, E]) UnwrapOr(defaultValue T) T {
    if r.IsOk() {
        return r.value
    }
    return defaultValue
}

// Usage
func Divide(a, b float64) Result[float64, error] {
    if b == 0 {
        return Err[float64, error](fmt.Errorf("division by zero"))
    }
    return Ok[float64, error](a / b)
}

func main() {
    result1 := Divide(10, 2)
    if result1.IsOk() {
        fmt.Println("Result:", result1.UnwrapOr(0)) // Result: 5
    }
    
    result2 := Divide(10, 0)
    if result2.IsErr() {
        _, err := result2.Unwrap()
        fmt.Println("Error:", err) // Error: division by zero
    }
    
    // With default value
    fmt.Println(result2.UnwrapOr(999)) // 999
}
```

### Generic Linked List

```go
type Node[T any] struct {
    Value T
    Next  *Node[T]
}

type LinkedList[T any] struct {
    head *Node[T]
    tail *Node[T]
    size int
}

func NewLinkedList[T any]() *LinkedList[T] {
    return &LinkedList[T]{}
}

func (l *LinkedList[T]) Append(value T) {
    node := &Node[T]{Value: value}
    
    if l.head == nil {
        l.head = node
        l.tail = node
    } else {
        l.tail.Next = node
        l.tail = node
    }
    
    l.size++
}

func (l *LinkedList[T]) Prepend(value T) {
    node := &Node[T]{Value: value, Next: l.head}
    l.head = node
    
    if l.tail == nil {
        l.tail = node
    }
    
    l.size++
}

func (l *LinkedList[T]) Size() int {
    return l.size
}

func (l *LinkedList[T]) ToSlice() []T {
    result := make([]T, 0, l.size)
    current := l.head
    
    for current != nil {
        result = append(result, current.Value)
        current = current.Next
    }
    
    return result
}

func (l *LinkedList[T]) ForEach(fn func(T)) {
    current := l.head
    for current != nil {
        fn(current.Value)
        current = current.Next
    }
}

func main() {
    list := NewLinkedList[int]()
    list.Append(1)
    list.Append(2)
    list.Append(3)
    list.Prepend(0)
    
    fmt.Println("Size:", list.Size()) // Size: 4
    fmt.Println("Items:", list.ToSlice()) // Items: [0 1 2 3]
    
    list.ForEach(func(value int) {
        fmt.Printf("%d ", value) // 0 1 2 3
    })
    fmt.Println()
}
```

### Generic Binary Tree

```go
type TreeNode[T constraints.Ordered] struct {
    Value T
    Left  *TreeNode[T]
    Right *TreeNode[T]
}

type BinarySearchTree[T constraints.Ordered] struct {
    root *TreeNode[T]
    size int
}

func NewBST[T constraints.Ordered]() *BinarySearchTree[T] {
    return &BinarySearchTree[T]{}
}

func (bst *BinarySearchTree[T]) Insert(value T) {
    bst.root = bst.insertNode(bst.root, value)
    bst.size++
}

func (bst *BinarySearchTree[T]) insertNode(node *TreeNode[T], value T) *TreeNode[T] {
    if node == nil {
        return &TreeNode[T]{Value: value}
    }
    
    if value < node.Value {
        node.Left = bst.insertNode(node.Left, value)
    } else if value > node.Value {
        node.Right = bst.insertNode(node.Right, value)
    }
    
    return node
}

func (bst *BinarySearchTree[T]) Contains(value T) bool {
    return bst.search(bst.root, value)
}

func (bst *BinarySearchTree[T]) search(node *TreeNode[T], value T) bool {
    if node == nil {
        return false
    }
    
    if value == node.Value {
        return true
    } else if value < node.Value {
        return bst.search(node.Left, value)
    } else {
        return bst.search(node.Right, value)
    }
}

func (bst *BinarySearchTree[T]) InOrder() []T {
    result := []T{}
    bst.inOrderTraversal(bst.root, &result)
    return result
}

func (bst *BinarySearchTree[T]) inOrderTraversal(node *TreeNode[T], result *[]T) {
    if node == nil {
        return
    }
    
    bst.inOrderTraversal(node.Left, result)
    *result = append(*result, node.Value)
    bst.inOrderTraversal(node.Right, result)
}

func main() {
    bst := NewBST[int]()
    bst.Insert(5)
    bst.Insert(3)
    bst.Insert(7)
    bst.Insert(1)
    bst.Insert(9)
    
    fmt.Println("Contains 7:", bst.Contains(7))   // true
    fmt.Println("Contains 4:", bst.Contains(4))   // false
    fmt.Println("In-order:", bst.InOrder())       // [1 3 5 7 9]
    
    // Works with strings too
    strBst := NewBST[string]()
    strBst.Insert("dog")
    strBst.Insert("cat")
    strBst.Insert("elephant")
    fmt.Println("Strings:", strBst.InOrder()) // [cat dog elephant]
}
```

### Generic Interfaces

```go
// Generic interface
type Container[T any] interface {
    Add(item T)
    Remove() (T, bool)
    Size() int
    IsEmpty() bool
}

// Stack implementation
type Stack[T any] struct {
    items []T
}

func NewStack[T any]() *Stack[T] {
    return &Stack[T]{items: []T{}}
}

func (s *Stack[T]) Add(item T) {
    s.items = append(s.items, item)
}

func (s *Stack[T]) Remove() (T, bool) {
    if len(s.items) == 0 {
        var zero T
        return zero, false
    }
    
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item, true
}

func (s *Stack[T]) Size() int {
    return len(s.items)
}

func (s *Stack[T]) IsEmpty() bool {
    return len(s.items) == 0
}

// Queue implementation
type Queue[T any] struct {
    items []T
}

func NewQueue[T any]() *Queue[T] {
    return &Queue[T]{items: []T{}}
}

func (q *Queue[T]) Add(item T) {
    q.items = append(q.items, item)
}

func (q *Queue[T]) Remove() (T, bool) {
    if len(q.items) == 0 {
        var zero T
        return zero, false
    }
    
    item := q.items[0]
    q.items = q.items[1:]
    return item, true
}

func (q *Queue[T]) Size() int {
    return len(q.items)
}

func (q *Queue[T]) IsEmpty() bool {
    return len(q.items) == 0
}

// Generic function working with Container interface
func ProcessContainer[T any](container Container[T], items []T) {
    for _, item := range items {
        container.Add(item)
    }
    
    fmt.Printf("Container has %d items\n", container.Size())
    
    for !container.IsEmpty() {
        if item, ok := container.Remove(); ok {
            fmt.Printf("Removed: %v\n", item)
        }
    }
}

func main() {
    // Use Stack
    stack := NewStack[int]()
    ProcessContainer[int](stack, []int{1, 2, 3})
    // Output:
    // Container has 3 items
    // Removed: 3
    // Removed: 2
    // Removed: 1
    
    fmt.Println()
    
    // Use Queue
    queue := NewQueue[string]()
    ProcessContainer[string](queue, []string{"first", "second", "third"})
    // Output:
    // Container has 3 items
    // Removed: first
    // Removed: second
    // Removed: third
}
```

---

## Generic Methods

### Methods on Generic Types

```go
type Pair[T any, U any] struct {
    First  T
    Second U
}

// Method with receiver type parameters
func (p Pair[T, U]) GetFirst() T {
    return p.First
}

func (p Pair[T, U]) GetSecond() U {
    return p.Second
}

func (p Pair[T, U]) Swap() Pair[U, T] {
    return Pair[U, T]{
        First:  p.Second,
        Second: p.First,
    }
}

// Method with additional type parameter
func (p Pair[T, U]) Map(f func(T) T, g func(U) U) Pair[T, U] {
    return Pair[T, U]{
        First:  f(p.First),
        Second: g(p.Second),
    }
}

func main() {
    p := Pair[int, string]{First: 42, Second: "hello"}
    
    fmt.Println(p.GetFirst())  // 42
    fmt.Println(p.GetSecond()) // hello
    
    // Swap
    swapped := p.Swap()
    fmt.Printf("%+v\n", swapped) // {First:hello Second:42}
    
    // Map
    mapped := p.Map(
        func(i int) int { return i * 2 },
        func(s string) string { return strings.ToUpper(s) },
    )
    fmt.Printf("%+v\n", mapped) // {First:84 Second:HELLO}
}
```

### Generic Type with Pointer Receivers

```go
type Set[T comparable] struct {
    items map[T]struct{}
}

func NewSet[T comparable]() *Set[T] {
    return &Set[T]{
        items: make(map[T]struct{}),
    }
}

func (s *Set[T]) Add(item T) {
    s.items[item] = struct{}{}
}

func (s *Set[T]) Remove(item T) {
    delete(s.items, item)
}

func (s *Set[T]) Contains(item T) bool {
    _, exists := s.items[item]
    return exists
}

func (s *Set[T]) Size() int {
    return len(s.items)
}

func (s *Set[T]) ToSlice() []T {
    result := make([]T, 0, len(s.items))
    for item := range s.items {
        result = append(result, item)
    }
    return result
}

// Set operations
func (s *Set[T]) Union(other *Set[T]) *Set[T] {
    result := NewSet[T]()
    
    for item := range s.items {
        result.Add(item)
    }
    
    for item := range other.items {
        result.Add(item)
    }
    
    return result
}

func (s *Set[T]) Intersection(other *Set[T]) *Set[T] {
    result := NewSet[T]()
    
    for item := range s.items {
        if other.Contains(item) {
            result.Add(item)
        }
    }
    
    return result
}

func (s *Set[T]) Difference(other *Set[T]) *Set[T] {
    result := NewSet[T]()
    
    for item := range s.items {
        if !other.Contains(item) {
            result.Add(item)
        }
    }
    
    return result
}

func main() {
    set1 := NewSet[int]()
    set1.Add(1)
    set1.Add(2)
    set1.Add(3)
    
    set2 := NewSet[int]()
    set2.Add(2)
    set2.Add(3)
    set2.Add(4)
    
    fmt.Println("Set1:", set1.ToSlice())        // [1 2 3]
    fmt.Println("Set2:", set2.ToSlice())        // [2 3 4]
    
    union := set1.Union(set2)
    fmt.Println("Union:", union.ToSlice())      // [1 2 3 4]
    
    intersection := set1.Intersection(set2)
    fmt.Println("Intersection:", intersection.ToSlice()) // [2 3]
    
    diff := set1.Difference(set2)
    fmt.Println("Difference:", diff.ToSlice())  // [1]
}
```

---

## Type Inference

Type inference allows the compiler to deduce type parameters automatically.

### Function Argument Type Inference

```go
func Print[T any](value T) {
    fmt.Printf("Value: %v, Type: %T\n", value, value)
}

func main() {
    // Type inferred from argument
    Print(42)           // T is int
    Print("hello")      // T is string
    Print(3.14)         // T is float64
    Print([]int{1, 2})  // T is []int
    
    // Can explicitly specify if needed
    Print[int](42)
    Print[string]("hello")
}
```

### Constraint Type Inference

```go
func Max[T constraints.Ordered](a, b T) T {
    if a > b {
        return a
    }
    return b
}

func main() {
    // Type inferred from arguments
    fmt.Println(Max(5, 10))        // T is int
    fmt.Println(Max(3.14, 2.71))   // T is float64
    fmt.Println(Max("a", "z"))     // T is string
}
```

### Return Type Inference

```go
func MakePair[T any, U any](first T, second U) Pair[T, U] {
    return Pair[T, U]{First: first, Second: second}
}

func main() {
    // Type parameters inferred from arguments
    p1 := MakePair(42, "hello")    // Pair[int, string]
    p2 := MakePair(3.14, true)     // Pair[float64, bool]
    
    fmt.Printf("%T\n", p1) // main.Pair[int,string]
    fmt.Printf("%T\n", p2) // main.Pair[float64,bool]
}
```

### Partial Type Inference

```go
func Convert[T any, U any](value T, converter func(T) U) U {
    return converter(value)
}

func main() {
    // Can specify some type parameters
    result := Convert[int, string](42, func(i int) string {
        return fmt.Sprintf("%d", i)
    })
    fmt.Println(result) // "42"
    
    // Or let all be inferred
    result2 := Convert(42, func(i int) string {
        return fmt.Sprintf("num: %d", i)
    })
    fmt.Println(result2) // "num: 42"
}
```

### When Inference Fails

```go
// Can't infer from return type alone
func Zero[T any]() T {
    var zero T
    return zero
}

func main() {
    // Must specify type explicitly
    var i int = Zero[int]()
    var s string = Zero[string]()
    
    fmt.Printf("int: %v, string: '%v'\n", i, s)
}
```

---

## Advanced Constraints

### Constraints with Methods

```go
// Constraint requiring specific methods
type Printable interface {
    String() string
}

func PrintAll[T Printable](items []T) {
    for _, item := range items {
        fmt.Println(item.String())
    }
}

type Person struct {
    Name string
    Age  int
}

func (p Person) String() string {
    return fmt.Sprintf("%s (%d years old)", p.Name, p.Age)
}

func main() {
    people := []Person{
        {Name: "Alice", Age: 30},
        {Name: "Bob", Age: 25},
    }
    
    PrintAll(people)
    // Output:
    // Alice (30 years old)
    // Bob (25 years old)
}
```

### Combining Type Sets and Methods

```go
// Number types with Abs method
type SignedNumber interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64 | ~float32 | ~float64
}

type Number[T SignedNumber] struct {
    Value T
}

func (n Number[T]) Abs() T {
    if n.Value < 0 {
        return -n.Value
    }
    return n.Value
}

func (n Number[T]) Add(other Number[T]) Number[T] {
    return Number[T]{Value: n.Value + other.Value}
}

func main() {
    n1 := Number[int]{Value: -5}
    fmt.Println("Abs:", n1.Abs()) // 5
    
    n2 := Number[int]{Value: 10}
    sum := n1.Add(n2)
    fmt.Println("Sum:", sum.Value) // 5
    
    f1 := Number[float64]{Value: -3.14}
    fmt.Println("Abs float:", f1.Abs()) // 3.14
}
```

### Nested Constraints

```go
// Constraint for types that can be compared and converted to string
type ComparableString interface {
    comparable
    ~string
}

func FindLongest[T ComparableString](items []T) T {
    if len(items) == 0 {
        var zero T
        return zero
    }
    
    longest := items[0]
    for _, item := range items[1:] {
        if len(string(item)) > len(string(longest)) {
            longest = item
        }
    }
    return longest
}

type MyString string

func main() {
    strings := []MyString{"hi", "hello", "hey"}
    fmt.Println(FindLongest(strings)) // hello
}
```

---

## Generic Collections

### Generic Slice Wrapper

```go
type Slice[T any] []T

func (s Slice[T]) Map(fn func(T) T) Slice[T] {
    result := make(Slice[T], len(s))
    for i, v := range s {
        result[i] = fn(v)
    }
    return result
}

func (s Slice[T]) Filter(predicate func(T) bool) Slice[T] {
    result := Slice[T]{}
    for _, v := range s {
        if predicate(v) {
            result = append(result, v)
        }
    }
    return result
}

func (s Slice[T]) ForEach(fn func(T)) {
    for _, v := range s {
        fn(v)
    }
}

func (s Slice[T]) Any(predicate func(T) bool) bool {
    for _, v := range s {
        if predicate(v) {
            return true
        }
    }
    return false
}

func (s Slice[T]) All(predicate func(T) bool) bool {
    for _, v := range s {
        if !predicate(v) {
            return false
        }
    }
    return true
}

func main() {
    nums := Slice[int]{1, 2, 3, 4, 5}
    
    doubled := nums.Map(func(n int) int { return n * 2 })
    fmt.Println("Doubled:", doubled) // [2 4 6 8 10]
    
    evens := nums.Filter(func(n int) bool { return n%2 == 0 })
    fmt.Println("Evens:", evens) // [2 4]
    
    hasLarge := nums.Any(func(n int) bool { return n > 3 })
    fmt.Println("Has large:", hasLarge) // true
    
    allPositive := nums.All(func(n int) bool { return n > 0 })
    fmt.Println("All positive:", allPositive) // true
}
```

### Generic Map with Additional Operations

```go
type Map[K comparable, V any] map[K]V

func NewMap[K comparable, V any]() Map[K, V] {
    return make(Map[K, V])
}

func (m Map[K, V]) Get(key K) (V, bool) {
    value, exists := m[key]
    return value, exists
}

func (m Map[K, V]) GetOrDefault(key K, defaultValue V) V {
    if value, exists := m[key]; exists {
        return value
    }
    return defaultValue
}

func (m Map[K, V]) Keys() []K {
    keys := make([]K, 0, len(m))
    for k := range m {
        keys = append(keys, k)
    }
    return keys
}

func (m Map[K, V]) Values() []V {
    values := make([]V, 0, len(m))
    for _, v := range m {
        values = append(values, v)
    }
    return values
}

func (m Map[K, V]) Filter(predicate func(K, V) bool) Map[K, V] {
    result := NewMap[K, V]()
    for k, v := range m {
        if predicate(k, v) {
            result[k] = v
        }
    }
    return result
}

func (m Map[K, V]) MapValues(fn func(V) V) Map[K, V] {
    result := NewMap[K, V]()
    for k, v := range m {
        result[k] = fn(v)
    }
    return result
}

func main() {
    ages := NewMap[string, int]()
    ages["Alice"] = 30
    ages["Bob"] = 25
    ages["Carol"] = 35
    
    fmt.Println("Keys:", ages.Keys())     // [Alice Bob Carol]
    fmt.Println("Values:", ages.Values()) // [30 25 35]
    
    age := ages.GetOrDefault("Dave", 0)
    fmt.Println("Dave's age:", age) // 0
    
    adults := ages.Filter(func(name string, age int) bool {
        return age >= 30
    })
    fmt.Println("Adults:", adults) // map[Alice:30 Carol:35]
    
    nextYear := ages.MapValues(func(age int) int {
        return age + 1
    })
    fmt.Println("Next year:", nextYear) // map[Alice:31 Bob:26 Carol:36]
}
```

### Generic Priority Queue

```go
import "container/heap"

type PriorityQueue[T any] struct {
    items    []T
    priority func(T) int
}

func NewPriorityQueue[T any](priority func(T) int) *PriorityQueue[T] {
    pq := &PriorityQueue[T]{
        items:    []T{},
        priority: priority,
    }
    heap.Init(pq)
    return pq
}

// Implement heap.Interface
func (pq *PriorityQueue[T]) Len() int {
    return len(pq.items)
}

func (pq *PriorityQueue[T]) Less(i, j int) bool {
    return pq.priority(pq.items[i]) < pq.priority(pq.items[j])
}

func (pq *PriorityQueue[T]) Swap(i, j int) {
    pq.items[i], pq.items[j] = pq.items[j], pq.items[i]
}

func (pq *PriorityQueue[T]) Push(x interface{}) {
    pq.items = append(pq.items, x.(T))
}

func (pq *PriorityQueue[T]) Pop() interface{} {
    old := pq.items
    n := len(old)
    item := old[n-1]
    pq.items = old[0 : n-1]
    return item
}

// Public methods
func (pq *PriorityQueue[T]) Enqueue(item T) {
    heap.Push(pq, item)
}

func (pq *PriorityQueue[T]) Dequeue() (T, bool) {
    if pq.Len() == 0 {
        var zero T
        return zero, false
    }
    return heap.Pop(pq).(T), true
}

func (pq *PriorityQueue[T]) Peek() (T, bool) {
    if pq.Len() == 0 {
        var zero T
        return zero, false
    }
    return pq.items[0], true
}

// Task example
type Task struct {
    Name     string
    Priority int
}

func main() {
    // Create priority queue for tasks
    pq := NewPriorityQueue[Task](func(t Task) int {
        return t.Priority
    })
    
    pq.Enqueue(Task{Name: "Low priority", Priority: 1})
    pq.Enqueue(Task{Name: "High priority", Priority: 10})
    pq.Enqueue(Task{Name: "Medium priority", Priority: 5})
    
    // Dequeue in priority order
    for pq.Len() > 0 {
        if task, ok := pq.Dequeue(); ok {
            fmt.Printf("Processing: %s (priority: %d)\n", task.Name, task.Priority)
        }
    }
    // Output:
    // Processing: Low priority (priority: 1)
    // Processing: Medium priority (priority: 5)
    // Processing: High priority (priority: 10)
}
```

This completes Part 2. Let me now create Part 3!
# The Complete Guide to Go Generics - Part 3 of 3

## Real-World Patterns, Performance, Testing, and Production Examples

---

## Table of Contents - Part 3

1. [Real-World Patterns (Continued)](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#real-world-patterns-continued)
2. [Performance Considerations](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#performance-considerations)
3. [Generic Testing Patterns](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#generic-testing-patterns)
4. [Common Pitfalls and Anti-Patterns](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#common-pitfalls-and-anti-patterns)
5. [Migration from interface{} to Generics](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#migration-from-interfaceto-generics)
6. [Production Best Practices](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#production-best-practices)
7. [Complete Production Examples](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#complete-production-examples)

---

## Real-World Patterns (Continued)

### Pattern 1: Option/Maybe Type

```go
type Option[T any] struct {
    value   T
    present bool
}

func Some[T any](value T) Option[T] {
    return Option[T]{value: value, present: true}
}

func None[T any]() Option[T] {
    return Option[T]{present: false}
}

func (o Option[T]) IsSome() bool {
    return o.present
}

func (o Option[T]) IsNone() bool {
    return !o.present
}

func (o Option[T]) Unwrap() T {
    if !o.present {
        panic("called Unwrap on None value")
    }
    return o.value
}

func (o Option[T]) UnwrapOr(defaultValue T) T {
    if o.present {
        return o.value
    }
    return defaultValue
}

func (o Option[T]) UnwrapOrElse(fn func() T) T {
    if o.present {
        return o.value
    }
    return fn()
}

func (o Option[T]) Map(fn func(T) T) Option[T] {
    if o.present {
        return Some(fn(o.value))
    }
    return None[T]()
}

func (o Option[T]) Filter(predicate func(T) bool) Option[T] {
    if o.present && predicate(o.value) {
        return o
    }
    return None[T]()
}

// Usage in database query
func FindUserByID(id int) Option[User] {
    // Simulate database lookup
    users := map[int]User{
        1: {ID: 1, Name: "Alice", Email: "alice@example.com"},
        2: {ID: 2, Name: "Bob", Email: "bob@example.com"},
    }
    
    if user, exists := users[id]; exists {
        return Some(user)
    }
    return None[User]()
}

type User struct {
    ID    int
    Name  string
    Email string
}

func main() {
    // Found user
    result := FindUserByID(1)
    if result.IsSome() {
        user := result.Unwrap()
        fmt.Printf("Found: %s\n", user.Name) // Found: Alice
    }
    
    // Not found - with default
    result2 := FindUserByID(999)
    defaultUser := result2.UnwrapOr(User{Name: "Guest"})
    fmt.Printf("User: %s\n", defaultUser.Name) // User: Guest
    
    // Map transformation
    result3 := FindUserByID(1).Map(func(u User) User {
        u.Email = strings.ToUpper(u.Email)
        return u
    })
    fmt.Println(result3.Unwrap().Email) // ALICE@EXAMPLE.COM
}
```

### Pattern 2: Either/Result Type for Error Handling

```go
type Either[L any, R any] struct {
    left    L
    right   R
    isRight bool
}

func Left[L any, R any](value L) Either[L, R] {
    return Either[L, R]{left: value, isRight: false}
}

func Right[L any, R any](value R) Either[L, R] {
    return Either[L, R]{right: value, isRight: true}
}

func (e Either[L, R]) IsLeft() bool {
    return !e.isRight
}

func (e Either[L, R]) IsRight() bool {
    return e.isRight
}

func (e Either[L, R]) Left() L {
    return e.left
}

func (e Either[L, R]) Right() R {
    return e.right
}

func (e Either[L, R]) MapLeft(fn func(L) L) Either[L, R] {
    if e.IsLeft() {
        return Left[L, R](fn(e.left))
    }
    return e
}

func (e Either[L, R]) MapRight(fn func(R) R) Either[L, R] {
    if e.IsRight() {
        return Right[L, R](fn(e.right))
    }
    return e
}

// Result is Either with error on left, value on right
type Result[T any] = Either[error, T]

func Ok[T any](value T) Result[T] {
    return Right[error, T](value)
}

func Err[T any](err error) Result[T] {
    return Left[error, T](err)
}

// Example: File operations with Result
func ReadFile(path string) Result[string] {
    data, err := os.ReadFile(path)
    if err != nil {
        return Err[string](err)
    }
    return Ok(string(data))
}

func ParseJSON[T any](jsonStr string) Result[T] {
    var result T
    err := json.Unmarshal([]byte(jsonStr), &result)
    if err != nil {
        return Err[T](err)
    }
    return Ok(result)
}

func main() {
    // Success case
    result := ReadFile("config.json")
    if result.IsRight() {
        content := result.Right()
        fmt.Println("File content:", content)
    } else {
        fmt.Println("Error:", result.Left())
    }
    
    // Chain operations
    configResult := ReadFile("config.json").
        MapRight(func(content string) string {
            return strings.ToUpper(content)
        })
    
    if configResult.IsRight() {
        fmt.Println("Uppercase content:", configResult.Right())
    }
}
```

### Pattern 3: Generic Cache

```go
type Cache[K comparable, V any] struct {
    data   map[K]*cacheEntry[V]
    mu     sync.RWMutex
    ttl    time.Duration
    maxSize int
}

type cacheEntry[V any] struct {
    value      V
    expiration time.Time
}

func NewCache[K comparable, V any](ttl time.Duration, maxSize int) *Cache[K, V] {
    c := &Cache[K, V]{
        data:    make(map[K]*cacheEntry[V]),
        ttl:     ttl,
        maxSize: maxSize,
    }
    
    // Start cleanup goroutine
    go c.cleanup()
    
    return c
}

func (c *Cache[K, V]) Set(key K, value V) {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    // Evict if at capacity
    if len(c.data) >= c.maxSize {
        c.evictOldest()
    }
    
    c.data[key] = &cacheEntry[V]{
        value:      value,
        expiration: time.Now().Add(c.ttl),
    }
}

func (c *Cache[K, V]) Get(key K) (V, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    entry, exists := c.data[key]
    if !exists {
        var zero V
        return zero, false
    }
    
    // Check expiration
    if time.Now().After(entry.expiration) {
        var zero V
        return zero, false
    }
    
    return entry.value, true
}

func (c *Cache[K, V]) GetOrCompute(key K, compute func() V) V {
    // Try to get from cache first
    if value, exists := c.Get(key); exists {
        return value
    }
    
    // Compute and cache
    value := compute()
    c.Set(key, value)
    return value
}

func (c *Cache[K, V]) Delete(key K) {
    c.mu.Lock()
    defer c.mu.Unlock()
    delete(c.data, key)
}

func (c *Cache[K, V]) Clear() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.data = make(map[K]*cacheEntry[V])
}

func (c *Cache[K, V]) Size() int {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return len(c.data)
}

func (c *Cache[K, V]) evictOldest() {
    var oldestKey K
    var oldestTime time.Time
    first := true
    
    for key, entry := range c.data {
        if first || entry.expiration.Before(oldestTime) {
            oldestKey = key
            oldestTime = entry.expiration
            first = false
        }
    }
    
    delete(c.data, oldestKey)
}

func (c *Cache[K, V]) cleanup() {
    ticker := time.NewTicker(c.ttl / 2)
    defer ticker.Stop()
    
    for range ticker.C {
        c.mu.Lock()
        now := time.Now()
        for key, entry := range c.data {
            if now.After(entry.expiration) {
                delete(c.data, key)
            }
        }
        c.mu.Unlock()
    }
}

func main() {
    // String -> User cache
    userCache := NewCache[string, User](5*time.Minute, 100)
    
    userCache.Set("user:1", User{ID: 1, Name: "Alice"})
    
    if user, exists := userCache.Get("user:1"); exists {
        fmt.Println("Cached user:", user.Name)
    }
    
    // Get or compute pattern
    user := userCache.GetOrCompute("user:2", func() User {
        fmt.Println("Computing user...")
        return User{ID: 2, Name: "Bob"}
    })
    fmt.Println("User:", user.Name)
    
    // Second call uses cache
    user2 := userCache.GetOrCompute("user:2", func() User {
        fmt.Println("This won't print - using cache")
        return User{}
    })
    fmt.Println("Cached user:", user2.Name)
}
```

### Pattern 4: Generic Event Bus

```go
type EventBus[T any] struct {
    subscribers map[string][]func(T)
    mu          sync.RWMutex
}

func NewEventBus[T any]() *EventBus[T] {
    return &EventBus[T]{
        subscribers: make(map[string][]func(T)),
    }
}

func (eb *EventBus[T]) Subscribe(eventType string, handler func(T)) func() {
    eb.mu.Lock()
    defer eb.mu.Unlock()
    
    eb.subscribers[eventType] = append(eb.subscribers[eventType], handler)
    
    // Return unsubscribe function
    return func() {
        eb.mu.Lock()
        defer eb.mu.Unlock()
        
        handlers := eb.subscribers[eventType]
        for i, h := range handlers {
            // Compare function pointers (won't work for closures)
            if &h == &handler {
                eb.subscribers[eventType] = append(handlers[:i], handlers[i+1:]...)
                break
            }
        }
    }
}

func (eb *EventBus[T]) Publish(eventType string, event T) {
    eb.mu.RLock()
    handlers := eb.subscribers[eventType]
    eb.mu.RUnlock()
    
    for _, handler := range handlers {
        go handler(event) // Async execution
    }
}

func (eb *EventBus[T]) PublishSync(eventType string, event T) {
    eb.mu.RLock()
    handlers := eb.subscribers[eventType]
    eb.mu.RUnlock()
    
    for _, handler := range handlers {
        handler(event) // Sync execution
    }
}

// Event types
type UserEvent struct {
    Type   string
    UserID int
    Data   map[string]interface{}
}

func main() {
    bus := NewEventBus[UserEvent]()
    
    // Subscribe to user.created events
    unsubscribe := bus.Subscribe("user.created", func(event UserEvent) {
        fmt.Printf("User created: %d\n", event.UserID)
    })
    
    // Subscribe to user.updated events
    bus.Subscribe("user.updated", func(event UserEvent) {
        fmt.Printf("User updated: %d\n", event.UserID)
    })
    
    // Publish events
    bus.Publish("user.created", UserEvent{
        Type:   "user.created",
        UserID: 1,
        Data:   map[string]interface{}{"name": "Alice"},
    })
    
    bus.Publish("user.updated", UserEvent{
        Type:   "user.updated",
        UserID: 1,
        Data:   map[string]interface{}{"name": "Alice Updated"},
    })
    
    // Unsubscribe
    unsubscribe()
    
    // This won't trigger the first handler
    bus.Publish("user.created", UserEvent{
        Type:   "user.created",
        UserID: 2,
    })
    
    time.Sleep(100 * time.Millisecond) // Wait for async handlers
}
```

---

## Performance Considerations

### Generics vs interface{} Performance

```go
// Benchmark: Generic vs Interface

// Generic version
func SumGeneric[T int | int64 | float64](numbers []T) T {
    var sum T
    for _, n := range numbers {
        sum += n
    }
    return sum
}

// Interface version
func SumInterface(numbers []interface{}) interface{} {
    var sum float64
    for _, n := range numbers {
        switch v := n.(type) {
        case int:
            sum += float64(v)
        case int64:
            sum += float64(v)
        case float64:
            sum += v
        }
    }
    return sum
}

func BenchmarkSumGeneric(b *testing.B) {
    numbers := make([]int, 1000)
    for i := range numbers {
        numbers[i] = i
    }
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = SumGeneric(numbers)
    }
}

func BenchmarkSumInterface(b *testing.B) {
    numbers := make([]interface{}, 1000)
    for i := range numbers {
        numbers[i] = i
    }
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = SumInterface(numbers)
    }
}

// Results (example):
// BenchmarkSumGeneric-8      1000000    1200 ns/op     0 B/op    0 allocs/op
// BenchmarkSumInterface-8     100000   12000 ns/op  8000 B/op 1000 allocs/op
//
// Generic version is ~10x faster with zero allocations!
```

### Memory Layout of Generic Types

```go
// Generics use monomorphization - separate code for each type
type Stack[T any] struct {
    items []T
}

// Compiled as if you wrote:
// type StackInt struct { items []int }
// type StackString struct { items []string }
// etc.

// This means:
// ✓ No boxing/unboxing overhead
// ✓ No interface method dispatch
// ✓ Direct memory access
// ✓ Better CPU cache locality

// Trade-off: Slightly larger binary size (one copy per type used)
```

### When to Use Generics vs interface{}

```go
// Use Generics when:
// ✓ Type safety is important
// ✓ Performance matters
// ✓ You know the types at compile time
// ✓ You want to avoid allocations

func Max[T constraints.Ordered](a, b T) T {
    if a > b {
        return a
    }
    return b
}

// Use interface{} when:
// ✓ You truly need runtime polymorphism
// ✓ Working with reflection
// ✓ Types are unknown at compile time
// ✓ JSON marshaling/unmarshaling

func LogValue(key string, value interface{}) {
    log.Printf("%s: %v (type: %T)", key, value, value)
}
```

---

## Generic Testing Patterns

### Testing Generic Functions

```go
func TestMax(t *testing.T) {
    t.Run("integers", func(t *testing.T) {
        result := Max(5, 10)
        if result != 10 {
            t.Errorf("Max(5, 10) = %d, want 10", result)
        }
    })
    
    t.Run("floats", func(t *testing.T) {
        result := Max(3.14, 2.71)
        if result != 3.14 {
            t.Errorf("Max(3.14, 2.71) = %f, want 3.14", result)
        }
    })
    
    t.Run("strings", func(t *testing.T) {
        result := Max("apple", "zebra")
        if result != "zebra" {
            t.Errorf("Max('apple', 'zebra') = %s, want 'zebra'", result)
        }
    })
}
```

### Table-Driven Tests with Generics

```go
func TestSliceOperations(t *testing.T) {
    tests := []struct {
        name     string
        test     func(t *testing.T)
    }{
        {
            name: "Map integers",
            test: func(t *testing.T) {
                input := []int{1, 2, 3}
                result := Map(input, func(n int) int { return n * 2 })
                expected := []int{2, 4, 6}
                
                if !sliceEqual(result, expected) {
                    t.Errorf("got %v, want %v", result, expected)
                }
            },
        },
        {
            name: "Filter strings",
            test: func(t *testing.T) {
                input := []string{"a", "ab", "abc"}
                result := Filter(input, func(s string) bool { return len(s) > 1 })
                expected := []string{"ab", "abc"}
                
                if !sliceEqual(result, expected) {
                    t.Errorf("got %v, want %v", result, expected)
                }
            },
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, tt.test)
    }
}

func sliceEqual[T comparable](a, b []T) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}
```

### Testing Generic Data Structures

```go
func TestStack(t *testing.T) {
    t.Run("int stack", func(t *testing.T) {
        testStackBehavior(t, []int{1, 2, 3})
    })
    
    t.Run("string stack", func(t *testing.T) {
        testStackBehavior(t, []string{"a", "b", "c"})
    })
}

func testStackBehavior[T comparable](t *testing.T, values []T) {
    stack := NewStack[T]()
    
    // Test push
    for _, v := range values {
        stack.Push(v)
    }
    
    if stack.Size() != len(values) {
        t.Errorf("Size = %d, want %d", stack.Size(), len(values))
    }
    
    // Test pop (LIFO)
    for i := len(values) - 1; i >= 0; i-- {
        if v, ok := stack.Pop(); !ok || v != values[i] {
            t.Errorf("Pop() = %v, want %v", v, values[i])
        }
    }
    
    // Test empty
    if !stack.IsEmpty() {
        t.Error("Stack should be empty")
    }
}
```

---

## Common Pitfalls and Anti-Patterns

### Pitfall 1: Over-Using Generics

```go
// BAD: Generic for no reason
func Add[T int](a, b T) T {
    return a + b
}

// GOOD: Just use int
func Add(a, b int) int {
    return a + b
}

// BAD: Generic when specific types are known
type Config[T any] struct {
    Host string
    Port int
    Data T  // Always map[string]string in practice
}

// GOOD: Use concrete type
type Config struct {
    Host string
    Port int
    Data map[string]string
}
```

### Pitfall 2: Can't Use Type Parameters in Methods

```go
type Container[T any] struct {
    value T
}

// BAD: Can't add new type parameter to method
// func (c Container[T]) Convert[U any]() Container[U] {
//     // Won't compile!
// }

// GOOD: Make it a function instead
func Convert[T any, U any](c Container[T], fn func(T) U) Container[U] {
    return Container[U]{value: fn(c.value)}
}
```

### Pitfall 3: Type Inference Limitations

```go
// BAD: Type can't be inferred
func MakeSlice[T any](size int) []T {
    return make([]T, size)
}

// Usage requires explicit type
// s := MakeSlice(10)  // Won't compile
s := MakeSlice[int](10) // Must specify

// GOOD: Add parameter to help inference
func MakeSliceFrom[T any](size int, zero T) []T {
    return make([]T, size)
}

// Usage with inference
s := MakeSliceFrom(10, 0) // Infers int from 0
```

### Pitfall 4: Constraints Too Restrictive

```go
// BAD: Too restrictive
func Process[T int](value T) T {
    return value * 2
}

// Can only use with int, not int32, int64, etc.

// GOOD: Use union or ~
func Process[T ~int | ~int32 | ~int64](value T) T {
    return value * 2
}
```

### Pitfall 5: Forgetting comparable for Map Keys

```go
// BAD: Will compile but panic at runtime if K is not comparable
type BadMap[K any, V any] struct {
    data map[K]V
}

// GOOD: Enforce comparable constraint
type GoodMap[K comparable, V any] struct {
    data map[K]V
}
```

---

## Migration from interface{} to Generics

### Before: Using interface{}

```go
// Old code using interface{}
type OldStack struct {
    items []interface{}
}

func (s *OldStack) Push(item interface{}) {
    s.items = append(s.items, item)
}

func (s *OldStack) Pop() interface{} {
    if len(s.items) == 0 {
        return nil
    }
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item
}

// Usage with type assertions
stack := &OldStack{}
stack.Push(42)
value := stack.Pop().(int) // Type assertion required, can panic!
```

### After: Using Generics

```go
// New code with generics
type Stack[T any] struct {
    items []T
}

func (s *Stack[T]) Push(item T) {
    s.items = append(s.items, item)
}

func (s *Stack[T]) Pop() (T, bool) {
    if len(s.items) == 0 {
        var zero T
        return zero, false
    }
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item, true
}

// Usage - type safe!
stack := &Stack[int]{}
stack.Push(42)
value, ok := stack.Pop() // No type assertion, can't panic!
```

### Migration Strategy

```go
// Step 1: Create generic version alongside old version
type OldContainer struct {
    items []interface{}
}

type Container[T any] struct {
    items []T
}

// Step 2: Migrate users gradually
// Old code still works
old := &OldContainer{}
old.items = append(old.items, 42)

// New code uses generics
new := &Container[int]{}
new.items = append(new.items, 42)

// Step 3: Mark old version as deprecated
// @deprecated: Use Container[T] instead
type OldContainer struct {
    items []interface{}
}

// Step 4: Remove old version in next major version
```

---

## Production Best Practices

### 1. Use Meaningful Type Parameter Names

```go
// BAD: Single letters for everything
func Process[T any, U any, V any](a T, b U) V {
    // Hard to understand
}

// GOOD: Descriptive names
func TransformData[Input any, Output any, Config any](
    data Input,
    config Config,
) Output {
    // Clear purpose
}

// GOOD: Standard conventions
type Cache[Key comparable, Value any] struct {
    data map[Key]Value
}

type List[Element any] struct {
    items []Element
}
```

### 2. Document Type Constraints

```go
// GOOD: Document what types are expected
// Number represents numeric types that support arithmetic operations.
// Supported types: int, int8, int16, int32, int64, float32, float64
type Number interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64 |
    ~float32 | ~float64
}

// Sum calculates the sum of all numbers in the slice.
// Type parameter T must be a numeric type (see Number interface).
func Sum[T Number](numbers []T) T {
    var sum T
    for _, n := range numbers {
        sum += n
    }
    return sum
}
```

### 3. Provide Helper Constructors

```go
// GOOD: Provide New* functions
type Result[T any] struct {
    value T
    err   error
}

func NewResult[T any](value T, err error) Result[T] {
    return Result[T]{value: value, err: err}
}

func Ok[T any](value T) Result[T] {
    return Result[T]{value: value}
}

func Err[T any](err error) Result[T] {
    return Result[T]{err: err}
}
```

### 4. Keep Constraints Simple

```go
// BAD: Overly complex constraint
type Complex interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64 |
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 |
    ~float32 | ~float64 |
    ~string |
    comparable
}

// GOOD: Use standard constraints or compose
import "golang.org/x/exp/constraints"

type Number interface {
    constraints.Integer | constraints.Float
}

type Comparable interface {
    comparable
}
```

### 5. Error Handling with Generics

```go
// Pattern: Generic result type with error handling
type Result[T any] struct {
    value T
    err   error
}

func (r Result[T]) IsOk() bool {
    return r.err == nil
}

func (r Result[T]) IsErr() bool {
    return r.err != nil
}

func (r Result[T]) Unwrap() (T, error) {
    return r.value, r.err
}

func (r Result[T]) Must() T {
    if r.err != nil {
        panic(r.err)
    }
    return r.value
}

// Usage
func FetchUser(id int) Result[User] {
    user, err := db.Query("SELECT * FROM users WHERE id = ?", id)
    return Result[User]{value: user, err: err}
}

func main() {
    result := FetchUser(1)
    if result.IsOk() {
        user := result.Must()
        fmt.Println(user.Name)
    }
}
```

---

## Complete Production Examples

### Example 1: Generic Repository Pattern

```go
package repository

import (
    "database/sql"
    "errors"
)

// Entity is anything with an ID
type Entity interface {
    GetID() int64
    SetID(int64)
}

// Repository provides CRUD operations for any entity
type Repository[T Entity] struct {
    db        *sql.DB
    tableName string
    scanner   func(*sql.Rows) (T, error)
}

func NewRepository[T Entity](
    db *sql.DB,
    tableName string,
    scanner func(*sql.Rows) (T, error),
) *Repository[T] {
    return &Repository[T]{
        db:        db,
        tableName: tableName,
        scanner:   scanner,
    }
}

func (r *Repository[T]) FindByID(id int64) (T, error) {
    var entity T
    
    query := fmt.Sprintf("SELECT * FROM %s WHERE id = ?", r.tableName)
    rows, err := r.db.Query(query, id)
    if err != nil {
        return entity, err
    }
    defer rows.Close()
    
    if !rows.Next() {
        return entity, errors.New("not found")
    }
    
    return r.scanner(rows)
}

func (r *Repository[T]) FindAll() ([]T, error) {
    query := fmt.Sprintf("SELECT * FROM %s", r.tableName)
    rows, err := r.db.Query(query)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var entities []T
    for rows.Next() {
        entity, err := r.scanner(rows)
        if err != nil {
            return nil, err
        }
        entities = append(entities, entity)
    }
    
    return entities, nil
}

func (r *Repository[T]) Create(entity T) error {
    query := fmt.Sprintf(
        "INSERT INTO %s (name, email) VALUES (?, ?)",
        r.tableName,
    )
    
    result, err := r.db.Exec(query /* fields */)
    if err != nil {
        return err
    }
    
    id, err := result.LastInsertId()
    if err != nil {
        return err
    }
    
    entity.SetID(id)
    return nil
}

func (r *Repository[T]) Update(entity T) error {
    query := fmt.Sprintf(
        "UPDATE %s SET name = ?, email = ? WHERE id = ?",
        r.tableName,
    )
    
    _, err := r.db.Exec(query /* fields */, entity.GetID())
    return err
}

func (r *Repository[T]) Delete(id int64) error {
    query := fmt.Sprintf("DELETE FROM %s WHERE id = ?", r.tableName)
    _, err := r.db.Exec(query, id)
    return err
}

// User entity
type User struct {
    ID    int64
    Name  string
    Email string
}

func (u *User) GetID() int64      { return u.ID }
func (u *User) SetID(id int64)    { u.ID = id }

func scanUser(rows *sql.Rows) (*User, error) {
    var user User
    err := rows.Scan(&user.ID, &user.Name, &user.Email)
    return &user, err
}

// Usage
func main() {
    db, _ := sql.Open("postgres", "connection-string")
    defer db.Close()
    
    userRepo := NewRepository[*User](db, "users", scanUser)
    
    // Create
    user := &User{Name: "Alice", Email: "alice@example.com"}
    userRepo.Create(user)
    fmt.Println("Created user with ID:", user.ID)
    
    // Find
    found, _ := userRepo.FindByID(user.ID)
    fmt.Println("Found:", found.Name)
    
    // Update
    found.Email = "newemail@example.com"
    userRepo.Update(found)
    
    // List all
    users, _ := userRepo.FindAll()
    fmt.Println("Total users:", len(users))
    
    // Delete
    userRepo.Delete(user.ID)
}
```

### Example 2: Generic HTTP Handler with Validation

```go
package handlers

import (
    "encoding/json"
    "net/http"
)

// Validator interface
type Validator interface {
    Validate() error
}

// Response wrapper
type Response[T any] struct {
    Success bool   `json:"success"`
    Data    T      `json:"data,omitempty"`
    Error   string `json:"error,omitempty"`
}

// Generic handler for POST requests with validation
func HandlePost[T Validator](
    handler func(T) (interface{}, error),
) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost {
            sendError(w, http.StatusMethodNotAllowed, "Method not allowed")
            return
        }
        
        var input T
        if err := json.NewDecoder(r.Body).Decode(&input); err != nil {
            sendError(w, http.StatusBadRequest, "Invalid JSON: "+err.Error())
            return
        }
        
        if err := input.Validate(); err != nil {
            sendError(w, http.StatusBadRequest, "Validation failed: "+err.Error())
            return
        }
        
        result, err := handler(input)
        if err != nil {
            sendError(w, http.StatusInternalServerError, err.Error())
            return
        }
        
        sendSuccess(w, result)
    }
}

func sendSuccess(w http.ResponseWriter, data interface{}) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(Response[interface{}]{
        Success: true,
        Data:    data,
    })
}

func sendError(w http.ResponseWriter, status int, message string) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(status)
    json.NewEncoder(w).Encode(Response[interface{}]{
        Success: false,
        Error:   message,
    })
}

// Request types
type CreateUserRequest struct {
    Name  string `json:"name"`
    Email string `json:"email"`
}

func (r CreateUserRequest) Validate() error {
    if r.Name == "" {
        return errors.New("name is required")
    }
    if r.Email == "" {
        return errors.New("email is required")
    }
    if !strings.Contains(r.Email, "@") {
        return errors.New("invalid email format")
    }
    return nil
}

type UpdateUserRequest struct {
    ID    int64  `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

func (r UpdateUserRequest) Validate() error {
    if r.ID == 0 {
        return errors.New("id is required")
    }
    if r.Name == "" && r.Email == "" {
        return errors.New("at least one field must be provided")
    }
    return nil
}

// Handlers
func handleCreateUser(req CreateUserRequest) (interface{}, error) {
    user := User{
        ID:    generateID(),
        Name:  req.Name,
        Email: req.Email,
    }
    
    // Save to database...
    
    return user, nil
}

func handleUpdateUser(req UpdateUserRequest) (interface{}, error) {
    // Fetch and update user...
    
    return map[string]interface{}{
        "message": "User updated successfully",
        "id":      req.ID,
    }, nil
}

// Setup routes
func main() {
    http.HandleFunc("/users/create", HandlePost(handleCreateUser))
    http.HandleFunc("/users/update", HandlePost(handleUpdateUser))
    
    http.ListenAndServe(":8080", nil)
}
```

---

## Summary

This completes the comprehensive Go Generics guide!

### **Part 1 - Fundamentals:**

✅ Introduction and problem definition ✅ Necessity of generics ✅ Type parameters ✅ Constraints (built-in, union, custom) ✅ Generic functions

### **Part 2 - Advanced:**

✅ Generic types (structs, interfaces) ✅ Generic methods ✅ Type inference ✅ Advanced constraints ✅ Generic collections ✅ Real-world patterns

### **Part 3 - Production:**

✅ Option/Either/Result patterns ✅ Generic cache and event bus ✅ Performance considerations ✅ Testing strategies ✅ Common pitfalls ✅ Migration from interface{} ✅ Best practices ✅ **2 Complete production examples:**

- Generic repository pattern
- Generic HTTP handlers with validation

## **Key Takeaways:**

1. **When to Use:** Type safety + performance + reusability
2. **Constraints:** Use standard ones (any, comparable, Ordered)
3. **Performance:** 10x faster than interface{} with zero allocations
4. **Testing:** Table-driven tests work great with generics
5. **Migration:** Gradual, keep old versions temporarily
6. **Best Practices:** Document constraints, provide constructors, keep simple

Your Go code is now production-ready with type-safe, performant generics! 🚀