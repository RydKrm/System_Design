# Go Data Types, Memory Storage & Program Execution

## **Introduction to Data Types in Go**

Go is a statically typed language, meaning every variable has a specific type known at compile time. Understanding data types is crucial because it determines how much memory is allocated, what operations can be performed, and how data is stored in memory.

## **Classification of Go Data Types**

### **1. Basic Types (Primitive Types)**

#### **Integer Types**
Integers are whole numbers without fractional components. Go provides several integer types with different sizes:

**Signed Integers:**
- `int8` - 8-bit signed integer (range: -128 to 127)
- `int16` - 16-bit signed integer (range: -32,768 to 32,767)
- `int32` - 32-bit signed integer (range: -2.1 billion to 2.1 billion)
- `int64` - 64-bit signed integer (range: -9.2×10¹⁸ to 9.2×10¹⁸)
- `int` - Platform dependent (32-bit on 32-bit systems, 64-bit on 64-bit systems)

**Unsigned Integers:**
- `uint8` (also called `byte`) - 8-bit unsigned integer (range: 0 to 255)
- `uint16` - 16-bit unsigned integer (range: 0 to 65,535)
- `uint32` - 32-bit unsigned integer (range: 0 to 4.3 billion)
- `uint64` - 64-bit unsigned integer (range: 0 to 1.8×10¹⁹)
- `uint` - Platform dependent unsigned integer
- `uintptr` - Unsigned integer large enough to store a pointer address

**Memory Storage:**
Each integer type occupies a fixed amount of memory. For example, `int32` always occupies 4 bytes (32 bits) regardless of the value stored. The value is stored in binary format using two's complement representation for signed integers.

```
Memory layout for int32 with value 42:
┌─────────────────────────────────────┐
│ 00000000 00000000 00000000 00101010 │
└─────────────────────────────────────┘
4 bytes = 32 bits
```

#### **Floating-Point Types**
These represent numbers with fractional components:

- `float32` - 32-bit floating-point number (single precision)
- `float64` - 64-bit floating-point number (double precision)

**Memory Storage:**
Floats use IEEE 754 standard representation:
- `float32`: 1 sign bit + 8 exponent bits + 23 mantissa bits
- `float64`: 1 sign bit + 11 exponent bits + 52 mantissa bits

```
float64 memory layout (value 3.14):
┌─────┬─────────────┬──────────────────────────────────--───────────┐
│ 0   │ 10000000000 │ 100100011110101110000101000111101011100001010 │
└─────┴─────────────┴────────────────────────────────────--─────────┘
Sign  Exponent (11 bits)     Mantissa (52 bits)
```

#### **Complex Types**
For complex numbers with real and imaginary parts:
- `complex64` - Real and imaginary parts are `float32`
- `complex128` - Real and imaginary parts are `float64`

**Memory Storage:**
Stored as two consecutive floating-point numbers:
- `complex64`: 8 bytes total (4 + 4 bytes)
- `complex128`: 16 bytes total (8 + 8 bytes)

#### **Boolean Type**
- `bool` - Represents true or false

**Memory Storage:**
Typically 1 byte, though the actual storage size isn't specified in the language spec. Only two possible values: `true` (usually 1) or `false` (usually 0).

#### **String Type**
- `string` - Sequence of bytes (usually UTF-8 encoded)

**Memory Storage:**
Strings in Go are immutable and represented as a structure containing:
1. A pointer to the underlying byte array
2. The length of the string in bytes

```
String "Hello" memory layout:
┌─────────────┬────────────┐
│ Pointer     │ Length = 5 │
└─────────────┴────────────┘
       │
       ↓
┌─────────────--────┐
│ H │ e │ l │ l │ o │
└───────────────--──┘
```

### **2. Composite Types**

#### **Arrays**
Fixed-size collection of elements of the same type:
```go
var arr [5]int  // Array of 5 integers
```

**Memory Storage:**
Arrays are stored as contiguous blocks of memory. The total size is `element_size × array_length`.

```
Array [3]int32 with values {10, 20, 30}:
┌──────────┬──────────┬──────────┐
│ 10 (4B)  │ 20 (4B)  │ 30 (4B)  │
└──────────┴──────────┴──────────┘
Total: 12 contiguous bytes
```

#### **Slices**
Dynamic-sized view into an array. Slices are references to underlying arrays.

**Memory Storage:**
A slice is a three-word structure (on 64-bit systems, 24 bytes total):
1. Pointer to underlying array
2. Length (number of elements in slice)
3. Capacity (maximum size without reallocation)

```
Slice structure:
┌─────────────┬─────────┬───────────┐
│ Pointer     │ Len = 3 │ Cap = 5   │
└─────────────┴─────────┴───────────┘
       │
       ↓
┌─────────────────────────────────┐
│ [0] │ [1] │ [2] │ [3] │ [4]     │
└─────────────────────────────────┘
```

#### **Maps**
Key-value pairs (hash tables):
```go
var m map[string]int
```

**Memory Storage:**
Maps are implemented as hash tables. They're more complex structures containing:
- Buckets array (each bucket holds 8 key-value pairs)
- Hash seeds
- Count of elements
- Overflow bucket pointers

```
Simplified map structure:
┌─────────────────────────────────────┐
│  Bucket 0  │  Bucket 1  │  Bucket N │
│ [8 pairs]  │ [8 pairs]  │ [8 pairs] │
└─────────────────────────────────────┘
```

#### **Structs**
Collection of fields, each with its own type:
```go
type Person struct {
    Name string
    Age  int
}
```

**Memory Storage:**
Structs are stored as contiguous memory blocks, but with padding for alignment. Fields are arranged in memory in the order they're declared, but the compiler may add padding to ensure proper memory alignment.

```
struct Person {Name string; Age int32}:
┌─────────────┬─────────┬────────────┐--------------
│ Name pointer│ Name len│ Age (4B)   │ Padding (4B) │
└─────────────┴─────────┴────────────┴──────────────┘
Total: 24 bytes (64-bit system)
```

### **3. Reference Types**

#### **Pointers**
Hold memory addresses of other variables:
```go
var x int = 10
var p *int = &x
```

**Memory Storage:**
Pointers store memory addresses. Size depends on architecture:
- 32-bit systems: 4 bytes
- 64-bit systems: 8 bytes

```
Pointer memory layout:
┌──────────────────────────────┐
│ Memory address (8 bytes)     │
└──────────────────────────────┘
```

#### **Functions**
Functions are first-class citizens in Go and have their own type.

**Memory Storage:**
Function variables store references to function code. The actual function code is stored in the text/code segment of memory.

#### **Channels**
For goroutine communication:
```go
ch := make(chan int)
```

**Memory Storage:**
Channels are complex structures containing:
- Buffer ring (for buffered channels)
- Send and receive queues
- Mutex for synchronization
- Closed flag

### **4. Interface Types**

Interfaces define method sets. A variable of interface type can hold any value that implements those methods.

**Memory Storage:**
Interfaces are two-word structures (on 64-bit systems):
1. Pointer to type information (itable)
2. Pointer to actual data (or the data itself if it fits)

```
Interface storage:
┌──────────────────────┬──────────────────────┐
│ Type info pointer    │ Data pointer/value   │
└──────────────────────┴──────────────────────┘
16 bytes total (64-bit)
```

## **Memory Organization in Go Programs**

### **Memory Segments**

When a Go program runs, the operating system allocates memory divided into segments:

```
┌─────────────────────────────────────────┐
│         Stack Segment                   │
│  (Function frames, local variables)     │
├─────────────────────────────────────────┤
│              ↓ Grows downward           │
│                                         │
│              ↑ Grows upward             │
├─────────────────────────────────────────┤
│         Heap Segment                    │
│   (Dynamically allocated memory)        │
├─────────────────────────────────────────┤
│         Data Segment                    │
│   (Global/static variables)             │
├─────────────────────────────────────────┤
│         Text/Code Segment               │
│   (Executable code, functions)          │
└─────────────────────────────────────────┘
```

## **Workflow of Creating a Variable: From Memory Allocation to Program Execution**

### **Step 1: Compilation Phase**

When you write a Go program and run `go build`, the compiler performs several steps:

1. **Lexical Analysis**: The source code is broken into tokens
2. **Syntax Analysis**: Tokens are parsed into Abstract Syntax Tree (AST)
3. **Semantic Analysis**: Type checking and validation
4. **Intermediate Representation**: Conversion to SSA (Static Single Assignment) form
5. **Optimization**: Various optimizations are applied
6. **Code Generation**: Machine code is generated
7. **Linking**: All pieces are combined into an executable

During compilation, the compiler determines:
- Memory layout for each data type
- Size of each variable
- Where variables will be stored (stack, heap, or data segment)

### **Step 2: Program Loading**

When you execute the compiled program:

1. **OS Allocates Memory**: The operating system creates a process and allocates memory segments
2. **Load Executable**: Code segment is loaded with your program's instructions
3. **Initialize Data Segment**: Global variables are allocated and initialized
4. **Set Up Stack**: Stack pointer is initialized
5. **Heap Initialization**: Go runtime initializes heap memory manager

### **Step 3: Variable Declaration and Initialization**

Consider this simple program:

```go
package main

import "fmt"

var globalVar int = 100  // Global variable

func main() {
    var localVar int = 42  // Local variable
    fmt.Println(localVar)
}
```

#### **Memory Allocation Process:**

**For `globalVar`:**
1. **Compile-time determination**: The compiler determines `globalVar` needs 8 bytes (on 64-bit)
2. **Program start**: When program starts, space is reserved in the Data Segment
3. **Initialization**: Value 100 is stored at that location

```
Data Segment:
┌─────────────────────┐
│ globalVar: 100 (8B) │
├─────────────────────┤
│ Other globals...    │
└─────────────────────┘
```

**For `localVar` inside `main()`:**
1. **Function call**: When `main()` is called, a stack frame is created
2. **Stack allocation**: 8 bytes are reserved on the stack for `localVar`
3. **Initialization**: Value 42 is stored in that stack location

```
Stack (during main() execution):
┌─────────────────────┐
│ Return address      │
├─────────────────────┤
│ Previous frame ptr  │
├─────────────────────┤
│ localVar: 42 (8B)   │ ← Stack pointer
├─────────────────────┤
│ Other locals...     │
└─────────────────────┘
```

### **Step 4: Heap Allocation (When Needed)**

Heap allocation occurs for:
- Variables that escape the stack (live beyond function return)
- Dynamically sized data (slices, maps, channels created with `make()`)
- Explicit allocation with `new()`

Example with heap allocation:

```go
func createSlice() []int {
    s := make([]int, 1000)  // Large slice escapes to heap
    return s
}
```

**Heap Allocation Process:**
1. **Escape Analysis**: Compiler determines variable escapes function scope
2. **Runtime Call**: `make()` calls runtime functions
3. **Heap Allocation**: Go memory allocator finds space in heap
4. **Slice Creation**: Slice header is created (possibly on stack), pointing to heap data

### **Step 5: Memory Management with Go Runtime**

Go has a sophisticated runtime with:
- **Garbage Collector**: Marks and sweeps unreachable heap objects
- **Memory Allocator**: Manages heap memory using spans and arenas
- **Scheduler**: Manages goroutines and their stacks

### **Step 6: Program Execution**

During execution:

1. **CPU Instructions**: The CPU reads instructions from the code segment
2. **Memory Access**: When variables are accessed, CPU reads/writes to appropriate memory locations
3. **Register Use**: Frequently used variables may be cached in CPU registers
4. **Function Calls**: Each creates a new stack frame
5. **Returns**: Stack frames are popped when functions return

## **Detailed Example: Complete Variable Lifecycle**

Let's trace a complete example:

```go
package main

import "fmt"

type Student struct {
    Name string
    Age  int
}

func main() {
    // 1. Integer variable
    var score int = 95
    
    // 2. String variable
    var name string = "Alice"
    
    // 3. Struct variable
    var student Student
    student.Name = "Bob"
    student.Age = 20
    
    // 4. Slice (heap allocated)
    var grades []int = make([]int, 3)
    grades[0] = 85
    
    fmt.Println(score, name, student, grades[0])
}
```

### **Memory Map During Execution:**

```
┌─────────────────────────────────────────────────┐
│ TEXT SEGMENT (Code)                             │
│  - main() function instructions                  │
│  - fmt.Println() instructions                   │
└─────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────┐
│ DATA SEGMENT                                    │
│  - String literal "Alice"                       │
│  - String literal "Bob"                         │
│  - Interface tables for fmt.Println             │
└─────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────┐
│ STACK (main() frame)                           │
│  ┌─────────────────────────────────────────┐   │
│  │ score: 95 (8 bytes)                     │   │
│  ├─────────────────────────────────────────┤   │
│  │ name: (string header)                   │   │
│  │   - data pointer → "Alice" in data seg  │   │
│  │   - length: 5                           │   │
│  ├─────────────────────────────────────────┤   │
│  │ student: (Student struct)               │   │
│  │   - Name: (string header) → "Bob"       │   │
│  │   - Age: 20 (8 bytes)                   │   │
│  ├─────────────────────────────────────────┤   │
│  │ grades: (slice header)                  │   │
│  │   - pointer → heap memory               │   │
│  │   - length: 3, capacity: 3              │   │
│  └─────────────────────────────────────────┘   │
└─────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────┐
│ HEAP                                            │
│  ┌─────────────────────────────────────────┐   │
│  │ grades underlying array: [85, 0, 0]     │   │
│  │ (24 bytes: 3 × 8 bytes)                 │   │
│  └─────────────────────────────────────────┘   │
└─────────────────────────────────────────────────┘
```

### **Step-by-Step Execution:**

1. **Program Start**: OS loads executable, sets up memory segments
2. **Main Function Call**: Stack frame for `main()` is created
3. **Variable `score`**: 8 bytes allocated on stack, value 95 stored
4. **Variable `name`**: 
   - String header (16 bytes) allocated on stack
   - Pointer set to "Alice" in data segment
   - Length set to 5
5. **Variable `student`**:
   - Struct memory (40 bytes) allocated on stack
   - Name field: string header pointing to "Bob"
   - Age field: value 20 stored
6. **Variable `grades`**:
   - Slice header (24 bytes) allocated on stack
   - `make()` allocates 24 bytes on heap for underlying array
   - Slice pointer set to heap address
   - grades[0] = 85 stores value in heap array
7. **Function Call**: `fmt.Println` creates new stack frame
8. **Garbage Collection**: After `main()` returns, heap memory for grades becomes eligible for GC
9. **Program Exit**: All memory is returned to OS

## **Memory Optimization and Best Practices**

### **Stack vs Heap Considerations**

1. **Stack allocation is faster** than heap allocation
2. **Escape analysis** determines if variables can stay on stack
3. **Pointers to stack variables** can cause them to escape to heap

### **Memory Alignment**

Processors read memory in word-sized chunks. Proper alignment improves performance:

```go
// Poor alignment (24 bytes on 64-bit)
type Bad struct {
    b byte    // 1 byte
    i int64   // 8 bytes (needs 7 bytes padding before)
    s int32   // 4 bytes
}

// Better alignment (16 bytes on 64-bit)
type Good struct {
    i int64   // 8 bytes
    s int32   // 4 bytes
    b byte    // 1 byte (only 3 bytes padding after)
}
```

## **Conclusion**

Understanding Go's data types and memory model is crucial for writing efficient programs. Remember:

1. **Basic types** have fixed sizes and direct value storage
2. **Composite types** combine basic types in different ways
3. **Reference types** store pointers to data elsewhere
4. **Memory is organized** into segments with specific purposes
5. **Go runtime manages** heap memory and garbage collection
6. **Escape analysis** determines stack vs heap allocation

The Go compiler and runtime work together to manage memory efficiently, but understanding these concepts helps you write better, more performant code. Always consider the memory implications of your data structure choices, especially for large-scale applications.