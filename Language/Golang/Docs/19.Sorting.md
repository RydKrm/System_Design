# The Complete Guide to Sorting in Go: From Basics to Advanced Patterns

## Table of Contents

1. [Introduction - Understanding Sorting](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#introduction)
2. [The sort Package](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#sort-package)
3. [Basic Sorting - Primitives](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#basic-sorting)
4. [Custom Type Sorting](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#custom-sorting)
5. [The sort.Interface](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#sort-interface)
6. [Multiple Sorting Criteria](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#multiple-criteria)
7. [Sorting Algorithms in Go](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#algorithms)
8. [Performance Analysis](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#performance)
9. [Advanced Patterns](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#advanced-patterns)
10. [Real-World Use Cases](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#use-cases)

---

## Introduction - Understanding Sorting {#introduction}

Imagine organizing a library with thousands of books. You need different ways to arrange them:

- **By title**: "A Tale of Two Cities" comes before "Moby Dick"
- **By author**: Agatha Christie before Stephen King
- **By publication year**: 1850 before 2020
- **By popularity**: Most borrowed first
- **By multiple criteria**: First by genre, then by author, then by year

Sorting is one of the most fundamental operations in programming. Go provides powerful, flexible sorting capabilities through its `sort` package.

**Go's Sorting Philosophy**:

- **Interface-based**: Sort anything that implements `sort.Interface`
- **In-place**: Sorts modify the original slice (efficient)
- **Stable option**: Maintains relative order of equal elements
- **Type-safe**: Compile-time type checking
- **Fast**: Optimized algorithms (pdqsort - pattern-defeating quicksort)

---

## The sort Package {#sort-package}

Go's `sort` package provides sorting for any collection.

### Package Overview

```
┌───────────────────────────────────────────────────────────────────────────┐
│                    GO sort PACKAGE ARCHITECTURE                           │
└───────────────────────────────────────────────────────────────────────────┘

                        import "sort"
                              │
                    ┌─────────┴─────────┐
                    │                   │
         ┌──────────▼──────────┐   ┌───▼────────────────┐
         │  Built-in Types     │   │  Custom Types      │
         │                     │   │                    │
         │  sort.Ints()        │   │  sort.Sort()       │
         │  sort.Float64s()    │   │  sort.Stable()     │
         │  sort.Strings()     │   │  sort.Slice()      │
         └─────────────────────┘   │  sort.SliceStable()│
                                   └────────────────────┘
                                            │
                                   ┌────────▼─────────┐
                                   │  sort.Interface  │
                                   │  ┌────────────┐  │
                                   │  │ Len()      │  │
                                   │  │ Less(i,j)  │  │
                                   │  │ Swap(i,j)  │  │
                                   │  └────────────┘  │
                                   └──────────────────┘

Core Functions:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

For built-in types:
  sort.Ints([]int)           // Sort integer slice
  sort.Float64s([]float64)   // Sort float slice
  sort.Strings([]string)     // Sort string slice
  
For custom types:
  sort.Sort(data Interface)       // Sort using Interface
  sort.Stable(data Interface)     // Stable sort
  sort.Slice(slice, less func)    // Sort with custom less function
  sort.SliceStable(slice, less)   // Stable sort with custom less

Search functions:
  sort.SearchInts([]int, x)      // Binary search
  sort.SearchStrings([]string, x)
  sort.Search(n, func)           // Generic binary search

Check if sorted:
  sort.IntsAreSorted([]int)      // Check if sorted
  sort.IsSorted(data Interface)
```

### Time Complexity Reference

```
┌───────────────────────────────────────────────────────────────────────────┐
│                    SORTING COMPLEXITY REFERENCE                           │
└───────────────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────┐
│  Algorithm      Best        Average     Worst       Space      │
├────────────────────────────────────────────────────────────────┤
│  Go's Sort      O(n log n)  O(n log n)  O(n log n)  O(log n)  │
│  (pdqsort)                                                     │
│                                                                │
│  Stable Sort    O(n log n)  O(n log n)  O(n log n)  O(n)      │
│                                                                │
│  Binary Search  -           O(log n)    O(log n)    O(1)      │
└────────────────────────────────────────────────────────────────┘

pdqsort = Pattern-defeating quicksort
- Hybrid of quicksort, heapsort, and insertion sort
- Detects patterns and switches algorithms
- Very fast in practice
```

---

## Basic Sorting - Primitives {#basic-sorting}

Let's start with sorting basic types.

### Sorting Integers

```go
package main

import (
    "fmt"
    "sort"
)

func main() {
    numbers := []int{42, 8, 15, 23, 4, 16}
    
    fmt.Println("Before:", numbers)
    sort.Ints(numbers)
    fmt.Println("After:", numbers)
}

// Output:
// Before: [42 8 15 23 4 16]
// After: [4 8 15 16 23 42]
```

**How It Works**:

```
┌───────────────────────────────────────────────────────────────────────────┐
│              SORTING INTEGERS - STEP BY STEP                              │
└───────────────────────────────────────────────────────────────────────────┘

Initial: [42, 8, 15, 23, 4, 16]

sort.Ints(numbers) internally:

Step 1: Wraps slice in IntSlice type
┌────────────────────────────────────┐
│  type IntSlice []int               │
│  Implements sort.Interface         │
└────────────────────────────────────┘

Step 2: Calls sort.Sort()
┌────────────────────────────────────┐
│  Uses pdqsort algorithm            │
│  In-place sorting                  │
│  Modifies original slice           │
└────────────────────────────────────┘

Step 3: Sorting process (simplified)
┌────────────────────────────────────────────────────────────────┐
│  Pass 1: [42, 8, 15, 23, 4, 16]                               │
│          └─Pick pivot (15)                                    │
│                                                               │
│  Pass 2: [8, 4] [15] [42, 23, 16]                           │
│          └─Partition around 15                               │
│                                                               │
│  Pass 3: [4, 8] [15] [16, 23, 42]                           │
│          └─Recursively sort partitions                       │
│                                                               │
│  Final:  [4, 8, 15, 16, 23, 42]  ✓                          │
└────────────────────────────────────────────────────────────────┘

Memory:
┌────────────────────────────────────┐
│  Original slice: Modified in-place │
│  Extra space: O(log n) for stack   │
│  No allocations for data           │
└────────────────────────────────────┘
```

### Sorting Floats

```go
func sortFloats() {
    prices := []float64{19.99, 5.49, 12.99, 3.99, 8.50}
    
    fmt.Println("Before:", prices)
    sort.Float64s(prices)
    fmt.Println("After:", prices)
}

// Output:
// Before: [19.99 5.49 12.99 3.99 8.5]
// After: [3.99 5.49 8.5 12.99 19.99]
```

**Float Sorting Considerations**:

```
┌───────────────────────────────────────────────────────────────────────────┐
│              FLOAT SORTING SPECIAL CASES                                  │
└───────────────────────────────────────────────────────────────────────────┘

Special Values:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

NaN (Not a Number):
┌────────────────────────────────────────────────────────────────┐
│  values := []float64{3.14, math.NaN(), 2.71, math.NaN(), 1.0} │
│  sort.Float64s(values)                                         │
│  Result: [1.0, 2.71, 3.14, NaN, NaN]                          │
│                                                                │
│  NaN sorts to the end                                         │
│  Multiple NaNs: relative order undefined                      │
└────────────────────────────────────────────────────────────────┘

Infinity:
┌────────────────────────────────────────────────────────────────┐
│  values := []float64{1.0, math.Inf(1), -math.Inf(-1), 0.0}   │
│  sort.Float64s(values)                                         │
│  Result: [-Inf, 0.0, 1.0, +Inf]                               │
│                                                                │
│  -Inf < all numbers < +Inf                                    │
└────────────────────────────────────────────────────────────────┘

Negative Zero:
┌────────────────────────────────────────────────────────────────┐
│  values := []float64{0.0, -0.0, 1.0}                          │
│  sort.Float64s(values)                                         │
│  Result: [-0.0, 0.0, 1.0]  or  [0.0, -0.0, 1.0]              │
│                                                                │
│  -0.0 and 0.0 are equal in comparison                         │
│  Relative order may vary                                      │
└────────────────────────────────────────────────────────────────┘
```

### Sorting Strings

```go
func sortStrings() {
    names := []string{"Charlie", "Alice", "Bob", "David"}
    
    fmt.Println("Before:", names)
    sort.Strings(names)
    fmt.Println("After:", names)
}

// Output:
// Before: [Charlie Alice Bob David]
// After: [Alice Bob Charlie David]
```

**String Comparison**:

```
┌───────────────────────────────────────────────────────────────────────────┐
│              STRING SORTING - HOW COMPARISON WORKS                        │
└───────────────────────────────────────────────────────────────────────────┘

Lexicographic (Dictionary) Order:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Byte-by-byte comparison:

Example: "Alice" vs "Bob"
┌────────────────────────────────────┐
│  "Alice"  [65, 108, 105, 99, 101] │  ← ASCII values
│  "Bob"    [66, 111, 98]           │
│            ↓                       │
│  Compare first bytes: 65 < 66     │
│  Result: "Alice" < "Bob"  ✓       │
└────────────────────────────────────┘

Example: "app" vs "apple"
┌────────────────────────────────────┐
│  "app"    [97, 112, 112]          │
│  "apple"  [97, 112, 112, 108, 101]│
│            ↓   ↓    ↓              │
│  First 3 bytes equal               │
│  "app" is shorter                  │
│  Result: "app" < "apple"  ✓       │
└────────────────────────────────────┘

Case Sensitivity:
┌────────────────────────────────────────────────────────────────┐
│  Uppercase comes BEFORE lowercase in ASCII                    │
│                                                                │
│  'A' = 65, 'Z' = 90                                           │
│  'a' = 97, 'z' = 122                                          │
│                                                                │
│  Example: ["apple", "Apple", "APPLE"]                         │
│  Sorted:  ["APPLE", "Apple", "apple"]                         │
│            ↑        ↑        ↑                                │
│           65-90   65-90    97-122                             │
└────────────────────────────────────────────────────────────────┘

Common Gotcha:
┌────────────────────────────────────────────────────────────────┐
│  names := []string{"zebra", "Aardvark"}                       │
│  sort.Strings(names)                                           │
│  Result: ["Aardvark", "zebra"]  ← 'A' (65) < 'z' (122)       │
│                                                                │
│  For case-insensitive sorting, need custom function           │
└────────────────────────────────────────────────────────────────┘
```

### Reverse Sorting

```go
func reverseSorting() {
    numbers := []int{5, 2, 8, 1, 9}
    
    // Method 1: Sort then reverse
    sort.Ints(numbers)
    // Reverse manually
    for i := 0; i < len(numbers)/2; i++ {
        j := len(numbers) - 1 - i
        numbers[i], numbers[j] = numbers[j], numbers[i]
    }
    fmt.Println("Reversed:", numbers)
    
    // Method 2: Use sort.Reverse (better)
    numbers2 := []int{5, 2, 8, 1, 9}
    sort.Sort(sort.Reverse(sort.IntSlice(numbers2)))
    fmt.Println("Reversed:", numbers2)
    
    // Method 3: sort.Slice with reverse comparison
    numbers3 := []int{5, 2, 8, 1, 9}
    sort.Slice(numbers3, func(i, j int) bool {
        return numbers3[i] > numbers3[j]  // Note: > instead of <
    })
    fmt.Println("Reversed:", numbers3)
}

// All output: [9 8 5 2 1]
```

**Visualization**:

```
┌───────────────────────────────────────────────────────────────────────────┐
│              REVERSE SORTING METHODS COMPARISON                           │
└───────────────────────────────────────────────────────────────────────────┘

Method 1: Sort + Manual Reverse
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Initial:  [5, 2, 8, 1, 9]
          ↓
Step 1:   [1, 2, 5, 8, 9]  ← sort.Ints()
          ↓
Step 2:   [9, 8, 5, 2, 1]  ← Manual reverse loop
          
Time: O(n log n) + O(n) = O(n log n)
Space: O(log n)
Lines of code: ~5


Method 2: sort.Reverse()
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Initial:  [5, 2, 8, 1, 9]
          ↓
Wraps in sort.Reverse(sort.IntSlice(...))
          ↓
Reverses comparison: i > j instead of i < j
          ↓
Final:    [9, 8, 5, 2, 1]

Time: O(n log n)
Space: O(log n)
Lines of code: 1


Method 3: sort.Slice() with reversed comparison
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Initial:  [5, 2, 8, 1, 9]
          ↓
sort.Slice with custom less: func(i, j) { return arr[i] > arr[j] }
          ↓
Final:    [9, 8, 5, 2, 1]

Time: O(n log n)
Space: O(log n)
Lines of code: 3


Recommendation:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✓ Method 3 (sort.Slice): Most readable and flexible
✓ Method 2: Good for built-in types with less customization
✗ Method 1: Avoid (more code, same complexity)
```

---

## Custom Type Sorting {#custom-sorting}

Sorting custom structs requires implementing comparison logic.

### Basic Struct Sorting

```go
type Person struct {
    Name string
    Age  int
}

// Method 1: Using sort.Slice (recommended for simple cases)
func sortPersonsByAge() {
    people := []Person{
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 35},
        {"David", 25},
    }
    
    sort.Slice(people, func(i, j int) bool {
        return people[i].Age < people[j].Age
    })
    
    fmt.Println(people)
}

// Output: [{Bob 25} {David 25} {Alice 30} {Charlie 35}]
```

**Visualization**:

```
┌───────────────────────────────────────────────────────────────────────────┐
│              SORTING CUSTOM STRUCTS - PROCESS                             │
└───────────────────────────────────────────────────────────────────────────┘

Initial State:
┌──────────────────────────────────────────────────────────────────┐
│  Index  Name      Age                                            │
│  ────────────────────────────────────────────────────────────    │
│  0      Alice     30                                             │
│  1      Bob       25                                             │
│  2      Charlie   35                                             │
│  3      David     25                                             │
└──────────────────────────────────────────────────────────────────┘

Comparison Function:
┌────────────────────────────────────┐
│  func(i, j int) bool {             │
│      return people[i].Age <        │
│             people[j].Age          │
│  }                                 │
└────────────────────────────────────┘

Sorting Process (conceptual):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Compare (0, 1): Alice.Age=30 vs Bob.Age=25
                30 < 25? No → Bob should come before Alice

Compare (0, 2): Alice.Age=30 vs Charlie.Age=35  
                30 < 35? Yes → Alice stays before Charlie

Compare (1, 3): Bob.Age=25 vs David.Age=25
                25 < 25? No → Equal (relative order maintained)

... (many more comparisons)

Final State:
┌──────────────────────────────────────────────────────────────────┐
│  Index  Name      Age                                            │
│  ────────────────────────────────────────────────────────────    │
│  0      Bob       25  ◄─┐                                        │
│  1      David     25  ◄─┼─ Same age, original order maintained  │
│  2      Alice     30    │   (because sort.Slice is stable)      │
│  3      Charlie   35    │                                        │
└──────────────────────────────────────────────────────────────────┘

Number of Comparisons:
┌────────────────────────────────────┐
│  n = 4 elements                    │
│  Comparisons ≈ n log n             │
│             ≈ 4 × log₂(4)          │
│             ≈ 4 × 2 = 8            │
└────────────────────────────────────┘
```

### Multiple Sort Keys

```go
// Sort by age first, then by name
func sortByAgeAndName() {
    people := []Person{
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 30},
        {"David", 25},
    }
    
    sort.Slice(people, func(i, j int) bool {
        // Primary sort: by age
        if people[i].Age != people[j].Age {
            return people[i].Age < people[j].Age
        }
        // Secondary sort: by name (if ages equal)
        return people[i].Name < people[j].Name
    })
    
    fmt.Println(people)
}

// Output: [{Bob 25} {David 25} {Alice 30} {Charlie 30}]
```

**Multi-Key Sorting Logic**:

```
┌───────────────────────────────────────────────────────────────────────────┐
│              MULTI-KEY SORTING DECISION TREE                              │
└───────────────────────────────────────────────────────────────────────────┘

Comparing people[i] vs people[j]:

                    Compare Ages
                         │
        ┌────────────────┼────────────────┐
        │                │                │
    Age[i] < Age[j]  Age[i] = Age[j]  Age[i] > Age[j]
        │                │                │
     Return            Compare           Return
      TRUE             Names             FALSE
                         │
        ┌────────────────┼────────────────┐
        │                │                │
   Name[i] < Name[j] Name[i] = Name[j] Name[i] > Name[j]
        │                │                │
     Return           Return            Return
      TRUE            FALSE             FALSE


Example Comparisons:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Compare Bob(25) vs Alice(30):
  Ages different? Yes (25 < 30)
  Result: Bob < Alice  ✓

Compare Bob(25) vs David(25):
  Ages different? No (25 = 25)
  Names: "Bob" < "David"? Yes
  Result: Bob < David  ✓

Compare Alice(30) vs Charlie(30):
  Ages different? No (30 = 30)
  Names: "Alice" < "Charlie"? Yes
  Result: Alice < Charlie  ✓

Final Order:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. Bob, 25       ◄─ Youngest, comes first alphabetically among 25s
2. David, 25     ◄─ Youngest, comes second alphabetically among 25s
3. Alice, 30     ◄─ Older, comes first alphabetically among 30s
4. Charlie, 30   ◄─ Older, comes second alphabetically among 30s
```

### Sort by Derived/Computed Value

```go
type Product struct {
    Name  string
    Price float64
    Tax   float64
}

func (p Product) TotalCost() float64 {
    return p.Price + p.Tax
}

func sortByTotalCost() {
    products := []Product{
        {"Laptop", 1000, 100},
        {"Mouse", 25, 2.5},
        {"Keyboard", 80, 8},
    }
    
    sort.Slice(products, func(i, j int) bool {
        return products[i].TotalCost() < products[j].TotalCost()
    })
    
    for _, p := range products {
        fmt.Printf("%s: $%.2f\n", p.Name, p.TotalCost())
    }
}

// Output:
// Mouse: $27.50
// Keyboard: $88.00
// Laptop: $1100.00
```

## The sort.Interface {#sort-interface}

For more control, implement the `sort.Interface`.

### Understanding sort.Interface

```go
type Interface interface {
    Len() int           // Number of elements
    Less(i, j int) bool // Compare elements at indices i and j
    Swap(i, j int)      // Swap elements at indices i and j
}
```

**Why Three Methods?**

```
┌───────────────────────────────────────────────────────────────────────────┐
│              sort.Interface - WHY THREE METHODS?                          │
└───────────────────────────────────────────────────────────────────────────┘

The sorting algorithm needs to:

1. Len() - Know the size
   ┌────────────────────────────────────┐
   │ "How many elements do I need to    │
   │  organize?"                        │
   │                                    │
   │ Used for: Loop bounds, recursion   │
   │          depth, pivot selection    │
   └────────────────────────────────────┘

2. Less(i, j) - Compare elements
   ┌────────────────────────────────────┐
   │ "Should element i come before j?"  │
   │                                    │
   │ Used for: Deciding swap order,     │
   │          partition logic           │
   │                                    │
   │ Critical: Defines sort order       │
   └────────────────────────────────────┘

3. Swap(i, j) - Rearrange elements
   ┌────────────────────────────────────┐
   │ "Exchange positions of i and j"    │
   │                                    │
   │ Used for: Moving elements during   │
   │          partitioning, heapify     │
   └────────────────────────────────────┘

Why Interface Instead of Passing Slice Directly?
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

✓ Generic: Works with any type (not just slices)
✓ Flexible: Custom comparison logic
✓ Type-safe: Compile-time checking
✓ Efficient: No reflection overhead (compared to sort.Slice)
```

### Implementing sort.Interface

```go
type Person struct {
    Name string
    Age  int
}

// ByAge implements sort.Interface for []Person based on Age field
type ByAge []Person

func (a ByAge) Len() int           { return len(a) }
func (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }
func (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

func sortUsingInterface() {
    people := []Person{
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 35},
    }
    
    sort.Sort(ByAge(people))
    fmt.Println(people)
}
```

**Step-by-Step Execution**:

```
┌───────────────────────────────────────────────────────────────────────────┐
│              sort.Interface EXECUTION FLOW                                │
└───────────────────────────────────────────────────────────────────────────┘

Step 1: Type Conversion
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
people := []Person{...}
         ↓
sort.Sort(ByAge(people))  ← Convert []Person to ByAge
         ↓
ByAge type implements sort.Interface ✓


Step 2: sort.Sort() Calls Methods
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

n := data.Len()  ───────────────────────────┐
                                            │
// Inside sorting algorithm                 │
for ... {                                   │
    if data.Less(i, j) {  ─────────────────┼─┐
        data.Swap(i, j)   ─────────────────┼─┼─┐
    }                                       │ │ │
}                                           │ │ │
                                            ↓ ↓ ↓
                                    ┌────────────────────┐
                                    │   Your Methods     │
                                    │   ────────────     │
                                    │   Len()   → 3      │
                                    │   Less()  → true   │
                                    │   Swap()  → (done) │
                                    └────────────────────┘


Step 3: Sorting Algorithm Uses These Methods
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Initial: [Alice(30), Bob(25), Charlie(35)]

Call: Len()
  → Returns: 3

Call: Less(0, 1)  // Compare Alice vs Bob
  → Returns: 30 < 25 = false
  → Bob should come before Alice

Call: Swap(0, 1)  // Swap Alice and Bob
  → Result: [Bob(25), Alice(30), Charlie(35)]

Call: Less(1, 2)  // Compare Alice vs Charlie
  → Returns: 30 < 35 = true
  → Alice stays before Charlie

Final: [Bob(25), Alice(30), Charlie(35)] ✓


Performance Note:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
For n=3 elements:
  Len() called: 1 time
  Less() called: ~5-6 times (depends on algorithm)
  Swap() called: ~1-2 times
```

### Multiple Sorting Types

```go
type Person struct {
    Name string
    Age  int
    Salary float64
}

// ByAge sorts by age
type ByAge []Person
func (a ByAge) Len() int           { return len(a) }
func (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }
func (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// ByName sorts by name
type ByName []Person
func (a ByName) Len() int           { return len(a) }
func (a ByName) Less(i, j int) bool { return a[i].Name < a[j].Name }
func (a ByName) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// BySalary sorts by salary
type BySalary []Person
func (a BySalary) Len() int           { return len(a) }
func (a BySalary) Less(i, j int) bool { return a[i].Salary < a[j].Salary }
func (a BySalary) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

func multipleSortTypes() {
    people := []Person{
        {"Alice", 30, 75000},
        {"Bob", 25, 65000},
        {"Charlie", 35, 85000},
    }
    
    // Sort by age
    sort.Sort(ByAge(people))
    fmt.Println("By Age:", people)
    
    // Sort by name
    sort.Sort(ByName(people))
    fmt.Println("By Name:", people)
    
    // Sort by salary
    sort.Sort(BySalary(people))
    fmt.Println("By Salary:", people)
}
```

**Type Conversion Visualization**:

```
┌───────────────────────────────────────────────────────────────────────────┐
│              TYPE CONVERSION FOR DIFFERENT SORT ORDERS                    │
└───────────────────────────────────────────────────────────────────────────┘

Original Type: []Person
┌────────────────────────────────────────────────────────────────┐
│  [Alice(30,$75K), Bob(25,$65K), Charlie(35,$85K)]             │
└────────────────────────────────────────────────────────────────┘
         │
         │ Can be viewed as different types:
         │
    ┌────┴────────────────┬─────────────────┬─────────────────┐
    │                     │                 │                 │
    ↓                     ↓                 ↓                 ↓
┌─────────┐         ┌─────────┐      ┌──────────┐      ┌──────────┐
│ ByAge   │         │ ByName  │      │ BySalary │      │ ByHeight │
│         │         │         │      │          │      │  (future)│
│ Less(): │         │ Less(): │      │ Less():  │      │          │
│ Age <   │         │ Name <  │      │ Salary < │      │  ...     │
└─────────┘         └─────────┘      └──────────┘      └──────────┘
    │                     │                 │
    ↓                     ↓                 ↓
Sort by Age         Sort by Name     Sort by Salary

Result:             Result:          Result:
Bob(25)             Alice(30)        Bob(65K)
Alice(30)           Bob(25)          Alice(75K)
Charlie(35)         Charlie(35)      Charlie(85K)

Same underlying data, different sort orders!
Each type defines its own Less() method.
```

---

## Multiple Sorting Criteria {#multiple-criteria}

Complex sorting with multiple keys.

### Composite Sorting

```go
type Employee struct {
    Name       string
    Department string
    Salary     float64
    HireDate   time.Time
}

// Sort by: Department (asc) → Salary (desc) → Name (asc)
type ByDeptSalaryName []Employee

func (e ByDeptSalaryName) Len() int { return len(e) }

func (e ByDeptSalaryName) Less(i, j int) bool {
    // First: Department (ascending)
    if e[i].Department != e[j].Department {
        return e[i].Department < e[j].Department
    }
    
    // Second: Salary (descending - note the reversed comparison)
    if e[i].Salary != e[j].Salary {
        return e[i].Salary > e[j].Salary  // > for descending
    }
    
    // Third: Name (ascending)
    return e[i].Name < e[j].Name
}

func (e ByDeptSalaryName) Swap(i, j int) {
    e[i], e[j] = e[j], e[i]
}
```

**Multi-Criteria Decision Flow**:

```
┌───────────────────────────────────────────────────────────────────────────┐
│              MULTI-CRITERIA SORTING DECISION FLOW                         │
└───────────────────────────────────────────────────────────────────────────┘

Comparing Employee[i] vs Employee[j]:

                         Start
                           │
                           ↓
                ┌──────────────────────┐
                │  Compare Departments │
                └──────────┬───────────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
    Dept[i] <          Dept[i] =          Dept[i] >
     Dept[j]            Dept[j]            Dept[j]
        │                  │                  │
    Return TRUE            ↓             Return FALSE
                    ┌────────────┐
                    │   Compare  │
                    │  Salaries  │
                    └──────┬─────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   Salary[i] >        Salary[i] =        Salary[i] <
   Salary[j]          Salary[j]          Salary[j]
   (DESC)                │              (DESC)
        │                 │                  │
    Return TRUE           ↓             Return FALSE
                    ┌────────────┐
                    │  Compare   │
                    │   Names    │
                    └──────┬─────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
    Name[i] <          Name[i] =          Name[i] >
    Name[j]            Name[j]            Name[j]
        │                  │                  │
    Return TRUE       Return FALSE      Return FALSE

Example Employees:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. Alice,   Engineering, $120K
2. Bob,     Engineering, $90K
3. Charlie, Engineering, $120K
4. David,   Sales,       $80K
5. Eve,     Sales,       $100K

Sorted Result:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. Alice,   Engineering, $120K  ◄─┐ Engineering comes first
2. Charlie, Engineering, $120K  ◄─┤ (alphabetically)
                                  ├─ Same dept & salary,
3. Bob,     Engineering, $90K   ◄─┤ sorted by name
                                  │
4. Eve,     Sales,       $100K  ◄─┤ Sales comes second
5. David,   Sales,       $80K   ◄─┘ Lower salary last
```

### Generic Multi-Field Sorter

```go
// Flexible sorter that takes comparison functions
type By func(e1, e2 *Employee) bool

func (by By) Sort(employees []Employee) {
    ps := &employeeSorter{
        employees: employees,
        by:        by,
    }
    sort.Sort(ps)
}

type employeeSorter struct {
    employees []Employee
    by        func(e1, e2 *Employee) bool
}

func (s *employeeSorter) Len() int {
    return len(s.employees)
}

func (s *employeeSorter) Less(i, j int) bool {
    return s.by(&s.employees[i], &s.employees[j])
}

func (s *employeeSorter) Swap(i, j int) {
    s.employees[i], s.employees[j] = s.employees[j], s.employees[i]
}

// Usage
func flexibleSort() {
    employees := []Employee{...}
    
    // Sort by salary
    By(func(e1, e2 *Employee) bool {
        return e1.Salary < e2.Salary
    }).Sort(employees)
    
    // Sort by hire date
    By(func(e1, e2 *Employee) bool {
        return e1.HireDate.Before(e2.HireDate)
    }).Sort(employees)
}
```

---

## Sorting Algorithms in Go {#algorithms}

Understanding what happens under the hood.

### Go's pdqsort Algorithm

```
┌───────────────────────────────────────────────────────────────────────────┐
│              GO'S SORTING ALGORITHM: pdqsort                              │
│              Pattern-Defeating Quicksort                                  │
└───────────────────────────────────────────────────────────────────────────┘

pdqsort = Quicksort + Heapsort + Insertion Sort
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. QUICKSORT (Primary Algorithm)
┌────────────────────────────────────────────────────────────────┐
│  Used for: General case                                        │
│  Strategy: Partition around pivot                              │
│  Time: O(n log n) average                                      │
│                                                                │
│  [3, 7, 1, 9, 2, 5]                                           │
│          ↓                                                     │
│  Pivot: 5                                                      │
│  [3, 1, 2] [5] [7, 9]                                         │
│      ↓           ↓                                            │
│  Recurse      Recurse                                         │
└────────────────────────────────────────────────────────────────┘

2. HEAPSORT (Fallback for Bad Partitions)
┌────────────────────────────────────────────────────────────────┐
│  Used when: Quicksort degrades (poor pivot choices)           │
│  Strategy: Build heap, extract max repeatedly                 │
│  Time: O(n log n) guaranteed                                   │
│                                                                │
│  Detects "bad partitions" (unbalanced splits)                 │
│  Switches to heapsort to avoid O(n²) worst case              │
└────────────────────────────────────────────────────────────────┘

3. INSERTION SORT (Small Arrays)
┌────────────────────────────────────────────────────────────────┐
│  Used when: Array size < 12 elements                          │
│  Strategy: Insert each element in correct position            │
│  Time: O(n²) but faster for small n due to low overhead      │
│                                                                │
│  [3, 1, 2]                                                    │
│   ↓  ↓  ↓                                                     │
│  [1, 2, 3]  ← Simple, cache-friendly                         │
└────────────────────────────────────────────────────────────────┘

Pattern Detection:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

pdqsort detects and handles special patterns:

Already Sorted: [1, 2, 3, 4, 5]
  → Detected after few comparisons
  → Optimized path: O(n)

Reverse Sorted: [5, 4, 3, 2, 1]
  → Detected early
  → Reverse and done: O(n)

All Equal: [5, 5, 5, 5, 5]
  → Detected via pivot equality
  → Skip unnecessary work: O(n)

Few Unique Values: [1, 2, 1, 2, 1, 2]
  → 3-way partitioning
  → Efficient handling: O(n log k) where k = unique values
```

### Algorithm Selection Visualization

```
┌───────────────────────────────────────────────────────────────────────────┐
│              ALGORITHM SELECTION DURING SORTING                           │
└───────────────────────────────────────────────────────────────────────────┘

Input: Array of 1000 elements

┌────────────────────────────────┐
│   pdqsort Start                │
└───────────────┬────────────────┘
                │
                ↓
        ┌───────────────┐
        │ Size < 12?    │
        └───┬───────┬───┘
            │       │
          Yes       No
            │       │
            ↓       ↓
    ┌───────────┐  ┌────────────────────┐
    │Insertion  │  │  Choose Pivot      │
    │Sort       │  │  Partition         │
    │           │  └─────────┬──────────┘
    │O(n²) but  │            │
    │fast for   │            ↓
    │small n    │  ┌────────────────────┐
    └───────────┘  │ Good Partition?    │
                   └────┬────────────┬───┘
                        │            │
                      Yes           No
                        │            │
                        ↓            ↓
            ┌───────────────┐  ┌──────────────┐
            │ Recurse       │  │ Bad partition │
            │ Quicksort     │  │ counter++     │
            └───────────────┘  └──────┬────────┘
                    │                 │
                    │                 ↓
                    │        ┌────────────────┐
                    │        │ Too many bad?  │
                    │        └────┬───────┬───┘
                    │             │       │
                    │           Yes      No
                    │             │       │
                    │             ↓       │
                    │    ┌────────────┐  │
                    │    │ Switch to  │  │
                    │    │ Heapsort   │  │
                    │    │ O(n log n) │  │
                    │    │ guaranteed │  │
                    │    └────────────┘  │
                    │                    │
                    └────────────────────┘
                             │
                             ↓
                     ┌───────────────┐
                     │    Sorted!    │
                     └───────────────┘

Real-World Example:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Array: [50, 23, 9, 18, 61, 32, 5, 12, 48, 27, ...]  (1000 elements)

Execution:
  0ms:  pdqsort starts with quicksort
  5ms:  First partition around pivot 32
        Left: 498 elements, Right: 501 elements (good!)
  10ms: Recurse left partition
  15ms: Small subarray (8 elements) → insertion sort
  16ms: Continue with right partition
  25ms: Another good partition (250 vs 251)
  ...
  48ms: All partitions complete
  49ms: Final pass, verify sorted
  50ms: Done! ✓

No heapsort needed (all partitions were good)
Few insertion sorts for small subarrays
Result: O(n log n) = 1000 × log₂(1000) ≈ 10,000 comparisons
```

---

## Performance Analysis {#performance}

Understanding sorting performance characteristics.

### Benchmarking Sort Performance

```go
func benchmarkSorts() {
    sizes := []int{100, 1000, 10000, 100000}
    
    for _, size := range sizes {
        // Generate random data
        data := make([]int, size)
        for i := range data {
            data[i] = rand.Intn(size)
        }
        
        // Benchmark sort.Ints
        start := time.Now()
        sort.Ints(data)
        duration := time.Since(start)
        
        fmt.Printf("Size: %6d, Time: %v\n", size, duration)
    }
}

// Sample Output:
// Size:    100, Time: 12µs
// Size:   1000, Time: 158µs
// Size:  10000, Time: 2.1ms
// Size: 100000, Time: 26ms
```

**Performance Scaling**:

```
┌───────────────────────────────────────────────────────────────────────────┐
│              SORTING PERFORMANCE SCALING                                  │
└───────────────────────────────────────────────────────────────────────────┘

Time Complexity: O(n log n)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌────────────────────────────────────────────────────────────────┐
│  n        n log₂ n    Time (actual)   Per element             │
├────────────────────────────────────────────────────────────────┤
│  100      664         12µs             120ns                   │
│  1,000    9,966       158µs            158ns                   │
│  10,000   132,877     2.1ms            210ns                   │
│  100,000  1,660,964   26ms             260ns                   │
│  1,000,000 19,931,569 340ms            340ns                   │
└────────────────────────────────────────────────────────────────┘

Visual Scaling:
┌────────────────────────────────────────────────────────────────┐
│                                                                │
│ 400ms├                                                 ●       │
│      │                                               ╱         │
│ 300ms├                                             ╱           │
│      │                                           ╱             │
│ 200ms├                                         ╱               │
│      │                                       ╱                 │
│ 100ms├                                     ╱                   │
│      │                                   ●                     │
│  50ms├                                 ╱                       │
│      │                               ╱                         │
│  10ms├                             ●                           │
│      │                           ╱                             │
│   1ms├                         ●                               │
│      │                       ╱                                 │
│   0ms├─────────────────────●───────────────────────────────── │
│      0      100K    200K    500K    700K    900K    1M        │
│                       Array Size                              │
│                                                                │
│  Key Observation: Time grows slower than linear              │
│  10x size ≈ 13x time (not 100x!)                             │
└────────────────────────────────────────────────────────────────┘

Comparison Count:
┌────────────────────────────────────────────────────────────────┐
│  n = 1,000                                                     │
│  Comparisons ≈ n log₂ n = 1,000 × 10 = 10,000                │
│                                                                │
│  n = 1,000,000                                                 │
│  Comparisons ≈ n log₂ n = 1,000,000 × 20 = 20,000,000        │
│                                                                │
│  1000x more data → only 2000x more comparisons                │
└────────────────────────────────────────────────────────────────┘
```

### Sort vs Stable Sort

```go
type Person struct {
    Name string
    Age  int
}

func compareStability() {
    people := []Person{
        {"Alice", 25},
        {"Bob", 30},
        {"Charlie", 25},  // Same age as Alice
        {"David", 30},    // Same age as Bob
    }
    
    // Regular sort (may not preserve order)
    peopleCopy1 := make([]Person, len(people))
    copy(peopleCopy1, people)
    sort.Slice(peopleCopy1, func(i, j int) bool {
        return peopleCopy1[i].Age < peopleCopy1[j].Age
    })
    
    // Stable sort (preserves order of equal elements)
    peopleCopy2 := make([]Person, len(people))
    copy(peopleCopy2, people)
    sort.SliceStable(peopleCopy2, func(i, j int) bool {
        return peopleCopy2[i].Age < peopleCopy2[j].Age
    })
    
    fmt.Println("Unstable:", peopleCopy1)
    fmt.Println("Stable:", peopleCopy2)
}

// Possible outputs:
// Unstable: [{Charlie 25} {Alice 25} {Bob 30} {David 30}]  ← Order changed!
// Stable:   [{Alice 25} {Charlie 25} {Bob 30} {David 30}]  ← Order preserved
```

**Stability Visualization**:

```
┌───────────────────────────────────────────────────────────────────────────┐
│              STABLE VS UNSTABLE SORT                                      │
└───────────────────────────────────────────────────────────────────────────┘

Initial Order (by insertion):
┌────────────────────────────────────────────────────────────────┐
│  Position  Name      Age                                       │
│  ────────────────────────────────────────────────────────────  │
│  0         Alice     25  ◄─┐                                   │
│  1         Bob       30    │                                   │
│  2         Charlie   25  ◄─┼─ Same age, but Alice came first  │
│  3         David     30    │                                   │
└────────────────────────────────────────────────────────────────┘

After UNSTABLE Sort (by age):
┌────────────────────────────────────────────────────────────────┐
│  Position  Name      Age     Note                              │
│  ────────────────────────────────────────────────────────────  │
│  0         Charlie   25  ◄─┐ Order of 25s                      │
│  1         Alice     25  ◄─┘ may be reversed!                  │
│  2         David     30  ◄─┐ Order of 30s                      │
│  3         Bob       30  ◄─┘ may be reversed!                  │
└────────────────────────────────────────────────────────────────┘

After STABLE Sort (by age):
┌────────────────────────────────────────────────────────────────┐
│  Position  Name      Age     Note                              │
│  ────────────────────────────────────────────────────────────  │
│  0         Alice     25  ◄─┐ Alice came before Charlie         │
│  1         Charlie   25  ◄─┘ Order preserved!                  │
│  2         Bob       30  ◄─┐ Bob came before David             │
│  3         David     30  ◄─┘ Order preserved!                  │
└────────────────────────────────────────────────────────────────┘

When Stability Matters:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Use Case: Email Sorting
  1. First sort by date (newest first)
  2. Then stable sort by importance
  
  Result: Important emails in date order, then normal emails in date order
  
Use Case: Multi-pass Sorting
  1. Sort by country
  2. Stable sort by state (within countries)
  3. Stable sort by city (within states)
  
  Result: Hierarchical ordering preserved

Performance Cost:
┌────────────────────────────────────────────────────────────────┐
│  Unstable (sort.Slice):      O(n log n) time, O(log n) space  │
│  Stable (sort.SliceStable):  O(n log n) time, O(n) space      │
│                                                                │
│  Stable sort needs more memory (temporary array)              │
│  But time complexity is the same                              │
└────────────────────────────────────────────────────────────────┘
```

This covers the fundamentals, interface, algorithms, and performance. Would you like me to continue with advanced patterns and real-world use cases?

## Advanced Patterns {#advanced-patterns}

Complex sorting scenarios and optimizations.

### Partial Sorting (Top-K Elements)

Sometimes you don't need a full sort, just the top K elements.

```go
// Find top 5 highest salaries (without full sort)
func topKSalaries(employees []Employee, k int) []Employee {
    // Method 1: Full sort (less efficient)
    sort.Slice(employees, func(i, j int) bool {
        return employees[i].Salary > employees[j].Salary
    })
    return employees[:k]  // O(n log n)
    
    // Method 2: Using heap (more efficient for small k)
    // Build min-heap of size k
    // O(n log k) - better when k << n
}

// Using container/heap for efficient top-K
import "container/heap"

type SalaryHeap []Employee

func (h SalaryHeap) Len() int           { return len(h) }
func (h SalaryHeap) Less(i, j int) bool { return h[i].Salary < h[j].Salary } // Min-heap
func (h SalaryHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
func (h *SalaryHeap) Push(x interface{}) {
    *h = append(*h, x.(Employee))
}
func (h *SalaryHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

func topKWithHeap(employees []Employee, k int) []Employee {
    h := &SalaryHeap{}
    heap.Init(h)
    
    for _, emp := range employees {
        if h.Len() < k {
            heap.Push(h, emp)
        } else if emp.Salary > (*h)[0].Salary {
            heap.Pop(h)
            heap.Push(h, emp)
        }
    }
    
    return *h
}
```

**Top-K Complexity Comparison**:

```
┌───────────────────────────────────────────────────────────────────────────┐
│              TOP-K ELEMENT SELECTION: COMPLEXITY ANALYSIS                 │
└───────────────────────────────────────────────────────────────────────────┘

Scenario: Find top 10 salaries from 1,000,000 employees

Method 1: Full Sort
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
┌────────────────────────────────────────────────────────────────┐
│  1. Sort entire array: O(n log n)                             │
│     = 1,000,000 × log(1,000,000)                              │
│     = 1,000,000 × 20 = 20,000,000 comparisons                 │
│                                                                │
│  2. Take first k elements: O(k)                               │
│     = 10 elements                                             │
│                                                                │
│  Total: O(n log n) = 20,000,000 operations                    │
│  Time: ~340ms                                                  │
└────────────────────────────────────────────────────────────────┘

Method 2: Heap-based (Min-heap of size k)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
┌────────────────────────────────────────────────────────────────┐
│  1. Build initial heap: O(k log k)                            │
│     = 10 × log(10) = 10 × 3.3 = 33 operations                │
│                                                                │
│  2. Process remaining: O((n-k) log k)                         │
│     = 999,990 × log(10)                                       │
│     = 999,990 × 3.3 = 3,299,967 comparisons                  │
│                                                                │
│  Total: O(n log k) = 3,300,000 operations                     │
│  Time: ~56ms                                                   │
│                                                                │
│  Speedup: 6x faster!                                          │
└────────────────────────────────────────────────────────────────┘

Visualization:
┌────────────────────────────────────────────────────────────────┐
│  Full Sort:                                                    │
│  [─────────────Sort All 1M──────────────] Take 10             │
│  ████████████████████████████████████████  ▒                  │
│  20M operations                                                │
│                                                                │
│  Heap Method:                                                  │
│  [Keep heap of 10, scan all] Return heap                      │
│  █████████  ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒                     │
│  3.3M operations                                               │
│                                                                │
│  Most work wasted in full sort!                               │
└────────────────────────────────────────────────────────────────┘

When to use each:
┌────────────────────────────────────────────────────────────────┐
│  k < 100:            Heap method (O(n log k))                 │
│  k > n/2:            Full sort (O(n log n))                   │
│  Need all sorted:    Full sort                                │
│  Need only top k:    Heap method                              │
└────────────────────────────────────────────────────────────────┘
```

### Sorting with Binary Search

After sorting, you can use binary search for fast lookups.

```go
func sortAndSearch() {
    numbers := []int{42, 8, 15, 23, 4, 16, 108, 50}
    
    // Sort first
    sort.Ints(numbers)
    // Now: [4, 8, 15, 16, 23, 42, 50, 108]
    
    // Binary search
    target := 23
    index := sort.SearchInts(numbers, target)
    
    if index < len(numbers) && numbers[index] == target {
        fmt.Printf("Found %d at index %d\n", target, index)
    } else {
        fmt.Printf("%d not found\n", target)
    }
}
```

**Binary Search Visualization**:

```
┌───────────────────────────────────────────────────────────────────────────┐
│              BINARY SEARCH AFTER SORTING                                  │
└───────────────────────────────────────────────────────────────────────────┘

Sorted Array: [4, 8, 15, 16, 23, 42, 50, 108]
Searching for: 23

Step 1: Check middle
┌────────────────────────────────────────────────────────────────┐
│  [4, 8, 15, 16, 23, 42, 50, 108]                              │
│             └──┬──┘                                            │
│              Middle: 16                                        │
│              23 > 16  → Search right half                      │
└────────────────────────────────────────────────────────────────┘

Step 2: Check middle of right half
┌────────────────────────────────────────────────────────────────┐
│  [4, 8, 15, 16, | 23, 42, 50, 108]                           │
│                   └─┬─┘                                        │
│                   Middle: 42                                   │
│                   23 < 42  → Search left of 42                 │
└────────────────────────────────────────────────────────────────┘

Step 3: Check middle of remaining
┌────────────────────────────────────────────────────────────────┐
│  [4, 8, 15, 16, | 23, | 42, 50, 108]                         │
│                   └─┘                                          │
│                 Middle: 23                                     │
│                 23 = 23  → FOUND!                              │
└────────────────────────────────────────────────────────────────┘

Complexity:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Linear Search (unsorted):  O(n)
Binary Search (sorted):    O(log n)

For n = 1,000,000:
  Linear: 1,000,000 comparisons (worst case)
  Binary: 20 comparisons (worst case)
  
  Speedup: 50,000x faster!
```

### Custom Search Functions

```go
// Search for first person aged 25 or older
func searchFirstAdult(people []Person) int {
    // Assumes people sorted by age
    return sort.Search(len(people), func(i int) bool {
        return people[i].Age >= 25
    })
}

// Find insertion point for new employee by salary
func findInsertionPoint(employees []Employee, newSalary float64) int {
    // Assumes employees sorted by salary
    return sort.Search(len(employees), func(i int) bool {
        return employees[i].Salary >= newSalary
    })
}
```

**sort.Search Explained**:

```
┌───────────────────────────────────────────────────────────────────────────┐
│              sort.Search: FIND INSERTION POINT                            │
└───────────────────────────────────────────────────────────────────────────┘

sort.Search(n, func(i int) bool) finds the smallest index i where:
  - func(i) returns true
  - All elements before i: func returns false
  - All elements from i onward: func returns true

Example: Find first number >= 25
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Array: [5, 12, 18, 23, 30, 42, 58, 61]

Function: func(i int) bool { return arr[i] >= 25 }

┌────────────────────────────────────────────────────────────────┐
│  Index   0   1   2   3   4   5   6   7                        │
│  Value   5  12  18  23  30  42  58  61                        │
│  >=25?   F   F   F   F   T   T   T   T                        │
│                         ▲                                      │
│                         └─── Returns index 4                  │
│                              (first TRUE)                      │
└────────────────────────────────────────────────────────────────┘

Use Cases:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. Insertion Point
   ┌────────────────────────────────────────────────────────┐
   │  Sorted: [10, 20, 30, 40, 50]                         │
   │  Insert 35: search for first >= 35                    │
   │  Result: index 3                                      │
   │  Insert: [10, 20, 30, 35, 40, 50]                    │
   └────────────────────────────────────────────────────────┘

2. Range Queries
   ┌────────────────────────────────────────────────────────┐
   │  Find all values in range [25, 45]                    │
   │  start := search for first >= 25                      │
   │  end := search for first > 45                         │
   │  result := arr[start:end]                             │
   └────────────────────────────────────────────────────────┘

3. Partition Point
   ┌────────────────────────────────────────────────────────┐
   │  Array: [false, false, false, true, true, true]       │
   │  Find: Where does it become true?                     │
   │  Result: index 3                                      │
   └────────────────────────────────────────────────────────┘
```

---

## Real-World Use Cases {#use-cases}

Practical sorting scenarios.

### Use Case 1: E-commerce Product Listing

```go
type Product struct {
    ID       int
    Name     string
    Price    float64
    Rating   float64
    Reviews  int
    InStock  bool
    Category string
}

type SortOption string

const (
    SortByPriceAsc    SortOption = "price_asc"
    SortByPriceDesc   SortOption = "price_desc"
    SortByRating      SortOption = "rating"
    SortByPopularity  SortOption = "popularity"
    SortByRelevance   SortOption = "relevance"
)

func sortProducts(products []Product, option SortOption) {
    switch option {
    case SortByPriceAsc:
        sort.Slice(products, func(i, j int) bool {
            // In stock items first
            if products[i].InStock != products[j].InStock {
                return products[i].InStock
            }
            return products[i].Price < products[j].Price
        })
        
    case SortByRating:
        sort.Slice(products, func(i, j int) bool {
            // In stock first
            if products[i].InStock != products[j].InStock {
                return products[i].InStock
            }
            // Higher rating first
            if products[i].Rating != products[j].Rating {
                return products[i].Rating > products[j].Rating
            }
            // More reviews as tiebreaker
            return products[i].Reviews > products[j].Reviews
        })
        
    case SortByPopularity:
        sort.Slice(products, func(i, j int) bool {
            // Popularity = rating × log(reviews + 1)
            pop1 := products[i].Rating * math.Log(float64(products[i].Reviews+1))
            pop2 := products[j].Rating * math.Log(float64(products[j].Reviews+1))
            return pop1 > pop2
        })
    }
}
```

**E-commerce Sorting Visualization**:

```
┌───────────────────────────────────────────────────────────────────────────┐
│              E-COMMERCE SORTING STRATEGIES                                │
└───────────────────────────────────────────────────────────────────────────┘

Initial Products:
┌──────────────────────────────────────────────────────────────────┐
│  ID   Name        Price   Rating  Reviews  InStock              │
│  ────────────────────────────────────────────────────────────    │
│  1    Laptop      $1200   4.5     1500     Yes                  │
│  2    Mouse       $25     4.8     3200     Yes                  │
│  3    Keyboard    $80     4.2     890      No                   │
│  4    Monitor     $350    4.9     2100     Yes                  │
│  5    Headphones  $150    4.6     1800     No                   │
└──────────────────────────────────────────────────────────────────┘

Sorted by Price (Ascending):
┌──────────────────────────────────────────────────────────────────┐
│  ID   Name        Price   InStock                                │
│  ────────────────────────────────────────────────────────────    │
│  2    Mouse       $25     Yes   ◄─┐                             │
│  4    Monitor     $350    Yes   ◄─┼─ In stock first             │
│  1    Laptop      $1200   Yes   ◄─┘                             │
│  ─────────────────────────────────────                          │
│  3    Keyboard    $80     No    ◄─┐                             │
│  5    Headphones  $150    No    ◄─┘ Out of stock last           │
└──────────────────────────────────────────────────────────────────┘

Sorted by Rating:
┌──────────────────────────────────────────────────────────────────┐
│  ID   Name        Rating  Reviews  InStock                      │
│  ────────────────────────────────────────────────────────────    │
│  4    Monitor     4.9     2100     Yes   ◄─ Highest rated       │
│  2    Mouse       4.8     3200     Yes   ◄─ 2nd, more reviews   │
│  1    Laptop      4.5     1500     Yes                          │
│  ─────────────────────────────────────────                      │
│  5    Headphones  4.6     1800     No    ◄─ Out of stock last   │
│  3    Keyboard    4.2     890      No                           │
└──────────────────────────────────────────────────────────────────┘

Sorted by Popularity (rating × log(reviews)):
┌──────────────────────────────────────────────────────────────────┐
│  ID   Name        Score   Calculation                           │
│  ────────────────────────────────────────────────────────────    │
│  4    Monitor     15.3    4.9 × log(2101) = 4.9 × 3.13         │
│  2    Mouse       15.8    4.8 × log(3201) = 4.8 × 3.29 ◄─Best  │
│  1    Laptop      14.7    4.5 × log(1501) = 4.5 × 3.27         │
│  5    Headphones  14.8    4.6 × log(1801) = 4.6 × 3.22         │
│  3    Keyboard    13.1    4.2 × log(891)  = 4.2 × 2.95         │
└──────────────────────────────────────────────────────────────────┘
```

### Use Case 2: Log File Analysis

```go
type LogEntry struct {
    Timestamp time.Time
    Level     string  // ERROR, WARN, INFO
    Message   string
    Service   string
}

func analyzeLogsSorted(logs []LogEntry) {
    // Sort by timestamp (chronological order)
    sort.Slice(logs, func(i, j int) bool {
        return logs[i].Timestamp.Before(logs[j].Timestamp)
    })
    
    // Find all errors in last hour
    oneHourAgo := time.Now().Add(-time.Hour)
    
    // Binary search for first log after oneHourAgo
    startIdx := sort.Search(len(logs), func(i int) bool {
        return logs[i].Timestamp.After(oneHourAgo)
    })
    
    recentLogs := logs[startIdx:]
    
    // Group errors by service
    errorsByService := make(map[string]int)
    for _, log := range recentLogs {
        if log.Level == "ERROR" {
            errorsByService[log.Service]++
        }
    }
}
```

### Use Case 3: Meeting Room Scheduling

```go
type Meeting struct {
    Start time.Time
    End   time.Time
    Room  string
}

// Find if a new meeting can be scheduled
func canSchedule(existing []Meeting, newMeeting Meeting) bool {
    // Sort by start time
    sort.Slice(existing, func(i, j int) bool {
        return existing[i].Start.Before(existing[j].Start)
    })
    
    // Check for conflicts
    for _, meeting := range existing {
        if meeting.Room != newMeeting.Room {
            continue
        }
        
        // Check overlap
        if newMeeting.Start.Before(meeting.End) && 
           newMeeting.End.After(meeting.Start) {
            return false  // Conflict found
        }
        
        // Optimization: if meeting starts after new meeting ends, stop
        if meeting.Start.After(newMeeting.End) {
            break
        }
    }
    
    return true
}
```

**Meeting Scheduling Visualization**:

```
┌───────────────────────────────────────────────────────────────────────────┐
│              MEETING ROOM SCHEDULING WITH SORTED INTERVALS                │
└───────────────────────────────────────────────────────────────────────────┘

Timeline (Room A):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Existing Meetings (sorted by start time):
9:00                   12:00              15:00              18:00
├────────┬─────────────┬──────────────────┬──────────────────┤
│        │             │                  │                  │
│ M1     │    M2       │       M3         │       M4         │
│9:00-   │  11:00-     │     14:00-       │     16:30-       │
│10:30   │  12:30      │     15:30        │     17:30        │
└────────┘             │                  │                  │

New Meeting Request: 15:00-16:00
┌──────────────────────────────────────────────────────────────────┐
│                                                                  │
│  Check M1 (9:00-10:30):                                         │
│    New starts at 15:00, M1 ends at 10:30                       │
│    15:00 > 10:30  → No overlap ✓                               │
│                                                                  │
│  Check M2 (11:00-12:30):                                        │
│    New starts at 15:00, M2 ends at 12:30                       │
│    15:00 > 12:30  → No overlap ✓                               │
│                                                                  │
│  Check M3 (14:00-15:30):                                        │
│    New: 15:00-16:00                                             │
│    M3:  14:00-15:30                                             │
│    Overlap check:                                               │
│      15:00 < 15:30? Yes (new starts before M3 ends)            │
│      16:00 > 14:00? Yes (new ends after M3 starts)             │
│    → CONFLICT! Cannot schedule ✗                               │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘

Visual:
        M3: ════════════
            14:00  15:30
                    
       New:      ════════
                15:00  16:00
                    
            Overlap: ═══  ← Conflict region (15:00-15:30)

Alternative Request: 12:30-13:30
┌──────────────────────────────────────────────────────────────────┐
│  Fits between M2 and M3 ✓                                       │
│                                                                  │
│  M2: ════════════                                               │
│      11:00  12:30                                               │
│                    New: ════════                                │
│                        12:30  13:30                             │
│                                    M3: ════════════             │
│                                        14:00  15:30             │
│                                                                  │
│  No overlaps → Can schedule ✓                                  │
└──────────────────────────────────────────────────────────────────┘
```

### Use Case 4: Leaderboard System

```go
type Player struct {
    ID    int
    Name  string
    Score int
    Time  time.Time  // When score achieved
}

type Leaderboard struct {
    players []Player
    sorted  bool
}

func (l *Leaderboard) AddScore(player Player) {
    l.players = append(l.players, player)
    l.sorted = false  // Mark as needing sort
}

func (l *Leaderboard) GetTop(n int) []Player {
    if !l.sorted {
        // Sort: Higher score first, earlier time as tiebreaker
        sort.SliceStable(l.players, func(i, j int) bool {
            if l.players[i].Score != l.players[j].Score {
                return l.players[i].Score > l.players[j].Score
            }
            return l.players[i].Time.Before(l.players[j].Time)
        })
        l.sorted = true
    }
    
    if n > len(l.players) {
        n = len(l.players)
    }
    return l.players[:n]
}

func (l *Leaderboard) GetRank(playerID int) int {
    if !l.sorted {
        l.GetTop(len(l.players))  // Force sort
    }
    
    for i, player := range l.players {
        if player.ID == playerID {
            return i + 1  // Rank is 1-indexed
        }
    }
    return -1  // Not found
}
```

## Best Practices and Tips {#best-practices}

### Do's and Don'ts

```
┌───────────────────────────────────────────────────────────────────────────┐
│              SORTING BEST PRACTICES                                       │
└───────────────────────────────────────────────────────────────────────────┘

✓ DO:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. Sort once, search many
   ┌────────────────────────────────────────────────────────┐
   │  sort.Ints(arr)           // O(n log n) once           │
   │  for i := 0; i < 1000; i++ {                           │
   │      sort.SearchInts(arr, target)  // O(log n) each    │
   │  }                                                      │
   └────────────────────────────────────────────────────────┘

2. Use sort.Slice for simple cases
   ┌────────────────────────────────────────────────────────┐
   │  sort.Slice(items, func(i, j int) bool {               │
   │      return items[i].Price < items[j].Price            │
   │  })                                                     │
   │  // Clear, concise, performant                         │
   └────────────────────────────────────────────────────────┘

3. Implement sort.Interface for complex types
   ┌────────────────────────────────────────────────────────┐
   │  When you have multiple sort orders                    │
   │  When sort logic is reused                             │
   │  When you need stable sorting control                  │
   └────────────────────────────────────────────────────────┘

4. Check if already sorted
   ┌────────────────────────────────────────────────────────┐
   │  if !sort.IntsAreSorted(arr) {                         │
   │      sort.Ints(arr)                                    │
   │  }                                                      │
   │  // Avoid unnecessary work                             │
   └────────────────────────────────────────────────────────┘

5. Use stable sort when order matters
   ┌────────────────────────────────────────────────────────┐
   │  sort.SliceStable(employees, func(i, j int) bool {     │
   │      return employees[i].Dept < employees[j].Dept      │
   │  })                                                     │
   │  // Preserves relative order within departments        │
   └────────────────────────────────────────────────────────┘

✗ DON'T:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. Sort repeatedly in loops
   ┌────────────────────────────────────────────────────────┐
   │  for _, item := range items {                          │
   │      sort.Ints(arr)  // ✗ Sorting every iteration!     │
   │      // use arr...                                      │
   │  }                                                      │
   │  // Sort once before loop instead                      │
   └────────────────────────────────────────────────────────┘

2. Use sort when you only need min/max
   ┌────────────────────────────────────────────────────────┐
   │  sort.Ints(arr)     // O(n log n)                      │
   │  min := arr[0]      // Just to find min!              │
   │                                                         │
   │  // Better: O(n) linear scan                           │
   │  min := arr[0]                                         │
   │  for _, v := range arr {                               │
   │      if v < min { min = v }                            │
   │  }                                                      │
   └────────────────────────────────────────────────────────┘

3. Forget to handle edge cases
   ┌────────────────────────────────────────────────────────┐
   │  if len(arr) == 0 {  // ✓ Check for empty              │
   │      return                                            │
   │  }                                                      │
   │  sort.Ints(arr)                                        │
   └────────────────────────────────────────────────────────┘

4. Modify slice during sort
   ┌────────────────────────────────────────────────────────┐
   │  // ✗ DON'T DO THIS!                                   │
   │  sort.Slice(arr, func(i, j int) bool {                 │
   │      arr = append(arr, newElement)  // Undefined!      │
   │      return arr[i] < arr[j]                            │
   │  })                                                     │
   └────────────────────────────────────────────────────────┘

5. Use expensive comparisons in Less()
   ┌────────────────────────────────────────────────────────┐
   │  // ✗ Expensive: called O(n log n) times               │
   │  func (a ByComplex) Less(i, j int) bool {              │
   │      result1 := expensiveComputation(a[i])             │
   │      result2 := expensiveComputation(a[j])             │
   │      return result1 < result2                          │
   │  }                                                      │
   │                                                         │
   │  // ✓ Better: Precompute once                          │
   │  for i := range items {                                │
   │      items[i].cached = expensiveComputation(items[i])  │
   │  }                                                      │
   │  sort.Slice(items, func(i, j int) bool {               │
   │      return items[i].cached < items[j].cached          │
   │  })                                                     │
   └────────────────────────────────────────────────────────┘
```

### Performance Optimization Tips

```
┌───────────────────────────────────────────────────────────────────────────┐
│              SORTING PERFORMANCE OPTIMIZATION                             │
└───────────────────────────────────────────────────────────────────────────┘

1. Precompute sort keys
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
type CachedItem struct {
    Data     Item
    SortKey  float64  // Precomputed
}

// Precompute once
cached := make([]CachedItem, len(items))
for i, item := range items {
    cached[i] = CachedItem{
        Data:    item,
        SortKey: expensiveCalculation(item),  // Called n times
    }
}

// Sort using cached keys
sort.Slice(cached, func(i, j int) bool {
    return cached[i].SortKey < cached[j].SortKey  // Called n log n times
})

Savings: n × (n log n) expensive calls → just n calls!


2. Use indices for large structs
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// If struct is large (>64 bytes), sorting moves a lot of data

// Instead of sorting struct array:
sort.Slice(largeStructs, ...) // Moves entire structs

// Sort indices instead:
indices := make([]int, len(largeStructs))
for i := range indices {
    indices[i] = i
}
sort.Slice(indices, func(i, j int) bool {
    return largeStructs[indices[i]].Key < largeStructs[indices[j]].Key
})

// Access in sorted order:
for _, idx := range indices {
    process(largeStructs[idx])
}


3. Parallel sorting for large datasets
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// For arrays > 10M elements, consider parallel sort
// Split into chunks, sort in parallel, then merge

func parallelSort(arr []int) {
    numWorkers := runtime.NumCPU()
    chunkSize := len(arr) / numWorkers
    
    var wg sync.WaitGroup
    for i := 0; i < numWorkers; i++ {
        start := i * chunkSize
        end := start + chunkSize
        if i == numWorkers-1 {
            end = len(arr)
        }
        
        wg.Add(1)
        go func(chunk []int) {
            defer wg.Done()
            sort.Ints(chunk)
        }(arr[start:end])
    }
    wg.Wait()
    
    // Merge sorted chunks (k-way merge)
    mergeChunks(arr, numWorkers, chunkSize)
}
```

This completes the comprehensive guide on Go sorting! The guide covers fundamentals, interfaces, algorithms, performance, advanced patterns, and real-world use cases with extensive visualizations.