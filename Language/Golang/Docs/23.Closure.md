# The Complete Guide to Closures in Go

## Table of Contents

1. [Introduction to Closures](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#introduction)
2. [What Are Closures?](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#what-are-closures)
3. [Internal Architecture](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#internal-architecture)
4. [Memory Management](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#memory-management)
5. [Closure Patterns](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#closure-patterns)
6. [Closures in Goroutines](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#closures-goroutines)
7. [Practical Applications](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#practical-applications)
8. [Best Practices](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#best-practices)
9. [Common Pitfalls](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#pitfalls)
10. [Real-World Examples](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#real-world)

---

## Introduction to Closures {#introduction}

Closures are one of the most powerful and elegant features in Go. They allow functions to capture and remember their surrounding state, creating functions that "remember" their context. While they seem simple on the surface, understanding how closures work at a deep level - from memory allocation to variable capture - is crucial for writing efficient, correct Go code.

### Why Closures Matter

Imagine you're building a web server that needs to track request counts per endpoint. Without closures, you'd need global variables or complex state management:

```go
// Without closures - messy global state
var requestCounts = make(map[string]int)
var mu sync.Mutex

func trackRequest(endpoint string) {
    mu.Lock()
    requestCounts[endpoint]++
    mu.Unlock()
}
```

With closures, you can encapsulate state elegantly:

```go
// With closures - clean encapsulation
func makeCounter(endpoint string) func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

homeCounter := makeCounter("/home")
apiCounter := makeCounter("/api")

homeCounter() // 1
homeCounter() // 2
apiCounter()  // 1 (separate state!)
```

Closures are everywhere in Go:

- HTTP handlers and middleware
- Goroutine spawning
- Callback functions
- Event handlers
- Lazy evaluation
- State machines
- Iterators and generators

Understanding closures deeply helps you write better concurrent code, avoid memory leaks, and leverage Go's functional programming capabilities.

### The Journey Ahead

In this guide, we'll explore:

- What closures are and how they work conceptually
- The internal implementation: how Go represents closures in memory
- Variable capture mechanisms (by reference vs by value)
- The relationship between closures and goroutines
- Common patterns and anti-patterns
- Real-world examples from production systems

---

## What Are Closures? {#what-are-closures}

A closure is a function value that references variables from outside its body. The function "closes over" these variables, capturing them from the surrounding scope.

### Basic Closure Example

```go
func makeAdder(x int) func(int) int {
    // Inner function (closure) captures variable 'x'
    return func(y int) int {
        return x + y  // 'x' is from outer scope
    }
}

func main() {
    add5 := makeAdder(5)
    add10 := makeAdder(10)
    
    fmt.Println(add5(3))  // 8  (5 + 3)
    fmt.Println(add10(3)) // 13 (10 + 3)
}
```

Let's break down what happens:

```
Closure Lifecycle:

1. Call makeAdder(5):
   ┌────────────────────────────────┐
   │ Outer Function                 │
   │ x = 5                          │
   │   ↓                            │
   │ Create inner function          │
   │ Inner function captures 'x'    │
   │   ↓                            │
   │ Return inner function          │
   └────────────────────────────────┘
   
2. Variable 'add5' now holds:
   ┌────────────────────────────────┐
   │ Function                       │
   │ - Code: return x + y           │
   │ - Captured: x = 5              │
   └────────────────────────────────┘

3. Call add5(3):
   ┌────────────────────────────────┐
   │ Execute closure                │
   │ x = 5 (captured)               │
   │ y = 3 (parameter)              │
   │ Return: 5 + 3 = 8              │
   └────────────────────────────────┘

Key Point: 'x' survives even after makeAdder returns!
This is the magic of closures.
```

### Closures vs Regular Functions

**Regular Function**:

```go
func add(x, y int) int {
    return x + y
}
// All data comes from parameters
// No captured state
```

**Closure**:

```go
func makeAdder(x int) func(int) int {
    return func(y int) int {
        return x + y  // 'x' captured from outer scope
    }
}
// Function + captured environment
```

The difference:

```
Regular Function:
┌────────────────────────────────┐
│ Function Code                  │
│ - Parameters: x, y             │
│ - Local variables only         │
└────────────────────────────────┘

Closure:
┌────────────────────────────────┐
│ Function Code                  │
│ - Parameters: y                │
│ - Captured variables: x        │
│ - Closed over environment      │
└────────────────────────────────┘
```

### Multiple Variables Captured

Closures can capture any number of variables:

```go
func makeGreeter(greeting, name string) func() string {
    count := 0
    return func() string {
        count++
        return fmt.Sprintf("%s, %s! (call #%d)", greeting, name, count)
    }
}

func main() {
    greet := makeGreeter("Hello", "Alice")
    
    fmt.Println(greet()) // Hello, Alice! (call #1)
    fmt.Println(greet()) // Hello, Alice! (call #2)
    fmt.Println(greet()) // Hello, Alice! (call #3)
}
```

**What's captured**:

- `greeting` - captured by value (string)
- `name` - captured by value (string)
- `count` - captured by reference (can be modified)

### Closure Scope Rules

Variables are captured from the closest enclosing scope:

```go
func outer() func() int {
    x := 1  // Outer scope
    
    func() {
        x := 2  // Middle scope (shadows outer x)
        
        return func() int {
            x := 3  // Inner scope (shadows middle x)
            return x  // Returns 3 (innermost x)
        }
    }()
    
    return func() int {
        return x  // Returns 1 (captures outer x)
    }
}
```

Scope visualization:

```
Scope Hierarchy:

┌─────────────────────────────────────┐  Outer Scope
│ x := 1                              │
│                                     │
│  ┌──────────────────────────────┐  │  Middle Scope
│  │ x := 2                       │  │
│  │                              │  │
│  │  ┌───────────────────────┐  │  │  Inner Scope
│  │  │ x := 3                │  │  │
│  │  │ return x  (returns 3) │  │  │
│  │  └───────────────────────┘  │  │
│  │                              │  │
│  └──────────────────────────────┘  │
│                                     │
│  return func() { return x }        │
│  (captures x from outer = 1)       │
└─────────────────────────────────────┘
```

---

## Internal Architecture {#internal-architecture}

Now let's dive into how Go implements closures at the lowest level - from compiler representation to memory layout.

### Function Values in Go

In Go, functions are first-class values. They can be:

- Assigned to variables
- Passed as parameters
- Returned from functions
- Stored in data structures

```go
// Function value
var fn func(int) int

fn = func(x int) int {
    return x * 2
}

result := fn(5) // 10
```

**Internal representation of a function value**:

```
Function Value in Memory:

┌──────────────────────────────────┐
│ Function Value (16 bytes on 64-bit)│
├──────────────────────────────────┤
│ Code Pointer (8 bytes)           │ ──→ Points to executable code
│ Context Pointer (8 bytes)        │ ──→ Points to closure context (nil for non-closures)
└──────────────────────────────────┘
```

For a regular function:

- Code pointer: Points to the function's machine code
- Context pointer: `nil` (no captured variables)

For a closure:

- Code pointer: Points to the function's machine code
- Context pointer: Points to a heap-allocated structure containing captured variables

### Closure Context Structure

When you create a closure, Go allocates a context structure on the heap:

```go
func makeCounter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}
```

**What happens internally**:

```
Step 1: makeCounter is called
┌────────────────────────────────────┐
│ Stack Frame (makeCounter)          │
│ - count: 0                         │
└────────────────────────────────────┘

Step 2: Closure is created
┌────────────────────────────────────┐
│ Heap allocation                    │
│ Closure Context:                   │
│ ┌────────────────────────────────┐ │
│ │ count: pointer to 'count' var  │ │
│ └────────────────────────────────┘ │
└────────────────────────────────────┘
        ↑
        │
┌───────┴────────────────────────────┐
│ Function Value                     │
│ - Code: closure function code      │
│ - Context: → closure context       │
└────────────────────────────────────┘

Step 3: makeCounter returns
┌────────────────────────────────────┐
│ Stack Frame (destroyed)            │
│ count variable moved to heap! ────┐│
└───────────────────────────────────┼┘
                                    │
                                    ↓
                            ┌────────────────┐
                            │ Heap           │
                            │ count: 0       │
                            └────────────────┘
```

**Key insight**: The `count` variable is "promoted" from the stack to the heap because it's captured by a closure. This is called **escape analysis**.

### Escape Analysis

The Go compiler performs escape analysis to determine if a variable should be allocated on the stack or heap:

```go
func noEscape() {
    x := 10
    fmt.Println(x)
    // x doesn't escape - allocated on stack
}

func doesEscape() func() int {
    x := 10
    return func() int {
        return x  // x escapes! Must live after function returns
    }
    // x allocated on heap
}
```

**Check escape analysis**:

```bash
go build -gcflags="-m" main.go
```

Output:

```
./main.go:6:2: moved to heap: x
./main.go:7:9: func literal escapes to heap
```

### Memory Layout Deep Dive

Let's see the exact memory layout with a more complex example:

```go
func makeCalculator(multiplier int) func(int) int {
    offset := 10
    count := 0
    
    return func(x int) int {
        count++
        return x*multiplier + offset
    }
}

calc := makeCalculator(5)
```

**Memory layout**:

```
Heap Memory:

Address 0x1000: Closure Context Structure
┌─────────────────────────────────────┐
│ multiplier: 5                       │  8 bytes (int)
│ offset: 10                          │  8 bytes (int)
│ count: 0                            │  8 bytes (int)
└─────────────────────────────────────┘
Total: 24 bytes (on 64-bit system)

Stack Memory (main function):

Address 0x2000: calc variable
┌─────────────────────────────────────┐
│ Code pointer: 0x3000                │  8 bytes
│ Context pointer: 0x1000             │  8 bytes (points to heap)
└─────────────────────────────────────┘
Total: 16 bytes

Code Memory:

Address 0x3000: Closure executable code
┌─────────────────────────────────────┐
│ func(x int) int {                   │
│   ctx := get_context()              │  Load context pointer
│   ctx.count++                       │  Increment count
│   return x*ctx.multiplier +         │  Compute result
│          ctx.offset                 │
│ }                                   │
└─────────────────────────────────────┘
```

When you call `calc(3)`:

```
Execution Flow:

1. Load function value from stack (0x2000)
2. Extract code pointer (0x3000) and context pointer (0x1000)
3. Jump to code at 0x3000
4. Load context from 0x1000
5. Execute with:
   - x = 3 (parameter)
   - multiplier = 5 (from context)
   - offset = 10 (from context)
   - count++ (modifies context)
6. Return 3*5 + 10 = 25
```

### Variable Capture: By Reference

**Critical concept**: Go captures variables by reference, not by value!

```go
func main() {
    x := 1
    
    fn := func() {
        fmt.Println(x)  // Captures reference to x
    }
    
    x = 2  // Modify x
    fn()   // Prints 2, not 1!
}
```

**What happens**:

```
Memory Layout:

Stack (main):
┌────────────────────────────────────┐
│ x: 1  (address 0x1000)             │
└────────────────────────────────────┘

Closure created:
┌────────────────────────────────────┐
│ Closure Context (heap)             │
│ - Pointer to x: 0x1000             │  Points to x on stack!
└────────────────────────────────────┘

x modified to 2:
┌────────────────────────────────────┐
│ x: 2  (address 0x1000)             │  Same address
└────────────────────────────────────┘

Closure called:
- Dereferences pointer 0x1000
- Reads value: 2
- Prints: 2
```

### Multiple Closures Sharing State

Multiple closures can share the same captured variables:

```go
func makeCounters() (func(), func() int) {
    count := 0
    
    increment := func() {
        count++
    }
    
    getCount := func() int {
        return count
    }
    
    return increment, getCount
}

inc, get := makeCounters()
inc()           // count = 1
inc()           // count = 2
fmt.Println(get()) // 2
```

**Memory layout**:

```
Heap:
┌────────────────────────────────────┐
│ Shared Closure Context             │
│ count: 0 → 1 → 2                   │
└────────────────────────────────────┘
        ↑               ↑
        │               │
    ┌───┴──┐       ┌───┴──┐
    │ inc  │       │ get  │
    │ func │       │ func │
    └──────┘       └──────┘

Both functions point to the SAME context!
They share the 'count' variable.
```

### Compiler Optimization: Closure Inlining

The Go compiler can sometimes inline closures for optimization:

```go
// Simple closure that might be inlined
func process(items []int) {
    fn := func(x int) int {
        return x * 2
    }
    
    for _, item := range items {
        result := fn(item)
        // Use result
    }
}
```

**Without inlining**:

- Closure allocated on heap
- Function call overhead for each iteration

**With inlining**:

- Closure code inlined directly into loop
- No heap allocation
- No function call overhead

Check if inlining happens:

```bash
go build -gcflags="-m -m" main.go
```

### CPU-Level Execution

At the CPU level, calling a closure involves:

```assembly
; Calling calc(3)

MOV  RAX, [calc]         ; Load function value (16 bytes)
MOV  RDX, [RAX+8]        ; Load context pointer
MOV  RDI, 3              ; First parameter (x = 3)
MOV  RSI, RDX            ; Second parameter (context)
CALL [RAX]               ; Call function via code pointer

; Inside closure
MOV  RAX, RSI            ; Load context pointer
MOV  RBX, [RAX]          ; Load multiplier (offset 0)
MOV  RCX, [RAX+8]        ; Load offset (offset 8)
ADD  QWORD PTR [RAX+16], 1  ; Increment count (offset 16)
IMUL RDI, RBX            ; x * multiplier
ADD  RDI, RCX            ; + offset
MOV  RAX, RDI            ; Return value in RAX
RET
```

---

## Memory Management {#memory-management}

Understanding memory management is crucial for avoiding leaks and writing efficient closure code.

### Stack vs Heap Allocation

**Stack allocation** (fast):

- Variables that don't escape
- Automatically cleaned up when function returns
- No GC pressure

**Heap allocation** (slower):

- Variables that escape (captured by closures)
- Must be garbage collected
- Can cause GC pressure

```go
// Stack allocation
func stackExample() {
    x := 10
    y := 20
    // x and y on stack
}  // Automatically cleaned up

// Heap allocation
func heapExample() func() int {
    x := 10  // Escapes to heap!
    return func() int {
        return x
    }
}  // x survives on heap
```

### Garbage Collection and Closures

Closures keep captured variables alive as long as the closure exists:

```go
func createHugeArray() func() int {
    // 1GB array!
    data := make([]int, 125_000_000)
    
    return func() int {
        return data[0]  // Entire array kept alive!
    }
}

fn := createHugeArray()
// 1GB stays in memory as long as 'fn' exists!
```

**Memory leak scenario**:

```
Timeline:

T=0: createHugeArray() called
┌────────────────────────────────────┐
│ Heap: 1GB array allocated          │
└────────────────────────────────────┘

T=1: Function returns closure
┌────────────────────────────────────┐
│ Heap: 1GB array                    │
│ Closure context: → array           │
└────────────────────────────────────┘

T=2: Closure assigned to 'fn'
┌────────────────────────────────────┐
│ fn holds closure                   │
│ Closure keeps array alive          │
│ 1GB still in memory                │
└────────────────────────────────────┘

T=3: Program runs for hours
┌────────────────────────────────────┐
│ fn still in scope                  │
│ 1GB STILL in memory!               │
│ Can't be garbage collected         │
└────────────────────────────────────┘

Solution: fn = nil  (allows GC)
```

### Fixing the Memory Leak

Only capture what you need:

```go
// Bad - captures entire array
func createHugeArray() func() int {
    data := make([]int, 125_000_000)
    return func() int {
        return data[0]
    }
}

// Good - copy only needed value
func createHugeArray() func() int {
    data := make([]int, 125_000_000)
    firstValue := data[0]  // Copy the value we need
    return func() int {
        return firstValue  // Only captures int, not array
    }
}
```

**Memory comparison**:

```
Bad Version:
┌────────────────────────────────────┐
│ Closure captures: 1GB array        │
│ Memory used: 1GB                   │
└────────────────────────────────────┘

Good Version:
┌────────────────────────────────────┐
│ Closure captures: int              │
│ Memory used: 8 bytes               │
└────────────────────────────────────┘

Memory saved: 1GB - 8 bytes ≈ 1GB!
```

### Reference Counting Pattern

Closures don't use reference counting, but you can implement it:

```go
type Resource struct {
    data    []byte
    refCount int
    mu      sync.Mutex
}

func (r *Resource) Acquire() func() {
    r.mu.Lock()
    r.refCount++
    r.mu.Unlock()
    
    // Return release closure
    return func() {
        r.mu.Lock()
        defer r.mu.Unlock()
        
        r.refCount--
        if r.refCount == 0 {
            // Clean up resource
            r.data = nil
        }
    }
}

// Usage
resource := &Resource{data: make([]byte, 1024*1024)}
release := resource.Acquire()
defer release()
```

### Closure Size Calculation

Calculate the memory footprint of a closure:

```go
func closureSize() {
    // Each captured variable adds to closure context
    
    a := 1              // 8 bytes (int on 64-bit)
    b := "hello"        // 16 bytes (string header)
    c := make([]int, 5) // 24 bytes (slice header)
    d := struct {       // Size of struct fields
        x int
        y int
    }{1, 2}             // 16 bytes
    
    fn := func() {
        _, _, _, _ = a, b, c, d
    }
    
    // Closure context size: 8 + 16 + 24 + 16 = 64 bytes
    // Plus function value overhead: 16 bytes
    // Total: 80 bytes
    
    _ = fn
}
```

**General formula**:

```
Closure Memory = 
    16 bytes (function value)
    + Sum of captured variables
    + Padding for alignment
```

## Closure Patterns {#closure-patterns}

Closures enable powerful programming patterns. Let's explore the most common and useful ones.

### Pattern 1: Factory Functions

Create functions with embedded configuration:

```go
package main

import (
    "fmt"
    "strings"
)

// Create validators with specific rules
func makeValidator(minLength, maxLength int, required bool) func(string) error {
    return func(value string) error {
        if required && value == "" {
            return fmt.Errorf("value is required")
        }
        
        if len(value) < minLength {
            return fmt.Errorf("value must be at least %d characters", minLength)
        }
        
        if len(value) > maxLength {
            return fmt.Errorf("value must be at most %d characters", maxLength)
        }
        
        return nil
    }
}

// Create formatters with specific styling
func makeFormatter(prefix, suffix string, uppercase bool) func(string) string {
    return func(text string) string {
        result := text
        if uppercase {
            result = strings.ToUpper(result)
        }
        return prefix + result + suffix
    }
}

func main() {
    // Create specialized validators
    usernameValidator := makeValidator(3, 20, true)
    passwordValidator := makeValidator(8, 128, true)
    bioValidator := makeValidator(0, 500, false)
    
    // Validate inputs
    fmt.Println(usernameValidator("ab"))        // Error: too short
    fmt.Println(usernameValidator("alice"))     // OK
    fmt.Println(passwordValidator("secret"))    // Error: too short
    
    // Create specialized formatters
    boldFormatter := makeFormatter("<b>", "</b>", false)
    shoutFormatter := makeFormatter("", "!!!", true)
    
    fmt.Println(boldFormatter("hello"))         // <b>hello</b>
    fmt.Println(shoutFormatter("hello"))        // HELLO!!!
}
```

### Pattern 2: Encapsulation and Private State

Create objects with private state using closures:

```go
type Counter interface {
    Increment()
    Decrement()
    Value() int
    Reset()
}

func NewCounter(initial int) Counter {
    // Private state
    value := initial
    
    // Return struct with methods as closures
    return &counter{
        increment: func() { value++ },
        decrement: func() { value-- },
        getValue:  func() int { return value },
        reset:     func() { value = initial },
    }
}

type counter struct {
    increment func()
    decrement func()
    getValue  func() int
    reset     func()
}

func (c *counter) Increment() { c.increment() }
func (c *counter) Decrement() { c.decrement() }
func (c *counter) Value() int { return c.getValue() }
func (c *counter) Reset()     { c.reset() }

func main() {
    c := NewCounter(10)
    
    c.Increment()
    c.Increment()
    fmt.Println(c.Value()) // 12
    
    c.Reset()
    fmt.Println(c.Value()) // 10
    
    // 'value' is completely private - no way to access directly!
}
```

**Why this works**:

```
Encapsulation through Closures:

┌────────────────────────────────────┐
│ NewCounter creates closure context │
│                                    │
│ Private State (heap):              │
│ ┌──────────────────┐              │
│ │ value: 10        │ ← Inaccessible│
│ │ initial: 10      │   from outside│
│ └──────────────────┘              │
│         ↑                          │
│         │                          │
│ All methods close over this        │
└────────────────────────────────────┘

True encapsulation - no reflection or
unsafe tricks can access 'value'!
```

### Pattern 3: Iterators and Generators

Create custom iteration patterns:

```go
package main

import "fmt"

// Generate Fibonacci numbers
func fibonacci() func() int {
    a, b := 0, 1
    
    return func() int {
        result := a
        a, b = b, a+b
        return result
    }
}

// Generate infinite sequence
func counter(start int) func() int {
    n := start
    return func() int {
        result := n
        n++
        return result
    }
}

// Filter iterator
func filter(iter func() (int, bool), predicate func(int) bool) func() (int, bool) {
    return func() (int, bool) {
        for {
            value, ok := iter()
            if !ok {
                return 0, false
            }
            if predicate(value) {
                return value, true
            }
        }
    }
}

// Map iterator
func mapIter(iter func() (int, bool), transform func(int) int) func() (int, bool) {
    return func() (int, bool) {
        value, ok := iter()
        if !ok {
            return 0, false
        }
        return transform(value), true
    }
}

func main() {
    // Fibonacci sequence
    fib := fibonacci()
    for i := 0; i < 10; i++ {
        fmt.Printf("%d ", fib())
    }
    fmt.Println() // 0 1 1 2 3 5 8 13 21 34
    
    // Counter
    count := counter(1)
    for i := 0; i < 5; i++ {
        fmt.Printf("%d ", count())
    }
    fmt.Println() // 1 2 3 4 5
}
```

### Pattern 4: Memoization (Caching)

Cache expensive computations:

```go
package main

import (
    "fmt"
    "time"
)

// Expensive function to memoize
func expensiveComputation(n int) int {
    time.Sleep(100 * time.Millisecond) // Simulate expensive work
    return n * n
}

// Memoize wraps a function with caching
func memoize(fn func(int) int) func(int) int {
    cache := make(map[int]int)
    
    return func(n int) int {
        // Check cache
        if result, found := cache[n]; found {
            fmt.Printf("Cache hit for %d\n", n)
            return result
        }
        
        // Compute and cache
        fmt.Printf("Computing %d...\n", n)
        result := fn(n)
        cache[n] = result
        return result
    }
}

func main() {
    memoized := memoize(expensiveComputation)
    
    start := time.Now()
    
    fmt.Println(memoized(5))  // Computing 5... → 25 (100ms)
    fmt.Println(memoized(5))  // Cache hit for 5 → 25 (instant!)
    fmt.Println(memoized(10)) // Computing 10... → 100 (100ms)
    fmt.Println(memoized(5))  // Cache hit for 5 → 25 (instant!)
    
    fmt.Printf("Total time: %v\n", time.Since(start)) // ~200ms instead of 400ms
}
```

**Memory layout with memoization**:

```
Memoization Closure Context:

┌────────────────────────────────────┐
│ Heap: Closure Context              │
│                                    │
│ cache: map[int]int                 │
│ ┌──────────────────────────────┐  │
│ │ 5  → 25                      │  │
│ │ 10 → 100                     │  │
│ │ 15 → 225                     │  │
│ └──────────────────────────────┘  │
│                                    │
│ fn: pointer to expensiveComputation│
└────────────────────────────────────┘

Cache grows over time!
Watch memory usage.
```

### Pattern 5: Partial Application

Create specialized functions from general ones:

```go
package main

import "fmt"

// General function
func multiply(a, b, c int) int {
    return a * b * c
}

// Partial application
func partial1(fn func(int, int, int) int, a int) func(int, int) int {
    return func(b, c int) int {
        return fn(a, b, c)
    }
}

func partial2(fn func(int, int, int) int, a, b int) func(int) int {
    return func(c int) int {
        return fn(a, b, c)
    }
}

func main() {
    // Specialize by fixing first argument
    multiplyBy2 := partial1(multiply, 2)
    fmt.Println(multiplyBy2(3, 4)) // 2 * 3 * 4 = 24
    
    // Specialize by fixing first two arguments
    multiplyBy2And3 := partial2(multiply, 2, 3)
    fmt.Println(multiplyBy2And3(4)) // 2 * 3 * 4 = 24
}
```

### Pattern 6: Decorator Pattern

Wrap functions with additional behavior:

```go
package main

import (
    "fmt"
    "log"
    "time"
)

// Function signature we want to decorate
type Operation func(int) int

// Decorator: Add timing
func withTiming(name string) func(Operation) Operation {
    return func(op Operation) Operation {
        return func(n int) int {
            start := time.Now()
            result := op(n)
            duration := time.Since(start)
            log.Printf("%s took %v", name, duration)
            return result
        }
    }
}

// Decorator: Add logging
func withLogging(op Operation) Operation {
    return func(n int) int {
        log.Printf("Calling with input: %d", n)
        result := op(n)
        log.Printf("Result: %d", result)
        return result
    }
}

// Decorator: Add caching
func withCaching(op Operation) Operation {
    cache := make(map[int]int)
    
    return func(n int) int {
        if result, found := cache[n]; found {
            log.Printf("Cache hit for %d", n)
            return result
        }
        result := op(n)
        cache[n] = result
        return result
    }
}

func expensiveOperation(n int) int {
    time.Sleep(100 * time.Millisecond)
    return n * n
}

func main() {
    // Stack decorators
    decorated := withTiming("expensiveOp")(
        withLogging(
            withCaching(expensiveOperation)))
    
    fmt.Println(decorated(5))  // Computes and caches
    fmt.Println(decorated(5))  // Cache hit
    fmt.Println(decorated(10)) // Computes and caches
}
```

**Decorator stack visualization**:

```
Decorator Chain:

Input: 5
    ↓
┌─────────────────────────────────┐
│ withTiming                      │ ← Outermost
│   Start timer                   │
│   ↓                             │
│ ┌─────────────────────────────┐ │
│ │ withLogging                 │ │
│ │   Log input                 │ │
│ │   ↓                         │ │
│ │ ┌─────────────────────────┐ │ │
│ │ │ withCaching             │ │ │
│ │ │   Check cache           │ │ │
│ │ │   ↓                     │ │ │
│ │ │ ┌─────────────────────┐ │ │ │
│ │ │ │ expensiveOperation  │ │ │ │ ← Innermost
│ │ │ │   Compute result    │ │ │ │
│ │ │ └─────────────────────┘ │ │ │
│ │ │   Cache result          │ │ │
│ │ └─────────────────────────┘ │ │
│ │   Log result                │ │
│ └─────────────────────────────┘ │
│   Stop timer, log duration      │
└─────────────────────────────────┘
    ↓
Output: 25
```

---

## Closures in Goroutines {#closures-goroutines}

Closures and goroutines are often used together, but this combination can be tricky. Understanding the interaction is crucial.

### The Classic Loop Variable Bug

This is the most common closure mistake in Go:

```go
// WRONG - Bug!
func printNumbers() {
    for i := 0; i < 5; i++ {
        go func() {
            fmt.Println(i)
        }()
    }
    time.Sleep(time.Second)
}

// Output: Might print 5 5 5 5 5!
```

**Why this happens**:

```
Timeline of Bug:

T=0: Loop starts, i = 0
┌────────────────────────────────────┐
│ Goroutine 1 spawned                │
│ Closure captures reference to 'i'  │
└────────────────────────────────────┘

T=1: i = 1
┌────────────────────────────────────┐
│ Goroutine 2 spawned                │
│ Closure captures reference to 'i'  │
└────────────────────────────────────┘

T=2: i = 2
T=3: i = 3
T=4: i = 4
T=5: Loop ends, i = 5

T=6: Goroutines start executing
┌────────────────────────────────────┐
│ All goroutines read 'i'            │
│ i = 5 for all of them!             │
│ Print: 5 5 5 5 5                   │
└────────────────────────────────────┘

Problem: All closures share the SAME 'i' variable!
By the time they run, loop has finished.
```

**Memory diagram**:

```
Shared Variable Problem:

Stack (printNumbers):
┌────────────────────────────────────┐
│ i: 0 → 1 → 2 → 3 → 4 → 5          │
└────────────────────────────────────┘
  ↑   ↑   ↑   ↑   ↑   ↑
  │   │   │   │   │   │
  └───┴───┴───┴───┴───┘
      All goroutines
      point here!
```

### Solution 1: Pass as Parameter

```go
// CORRECT - Pass value
func printNumbers() {
    for i := 0; i < 5; i++ {
        go func(n int) {
            fmt.Println(n)
        }(i)  // Pass i as argument
    }
    time.Sleep(time.Second)
}

// Output: 0 1 2 3 4 (in some order)
```

**What happens**:

```
Value Passing:

T=0: i = 0
┌────────────────────────────────────┐
│ go func(n int) { ... }(0)          │
│ Goroutine 1 receives n = 0         │
│ n is a COPY of i                   │
└────────────────────────────────────┘

T=1: i = 1
┌────────────────────────────────────┐
│ go func(n int) { ... }(1)          │
│ Goroutine 2 receives n = 1         │
│ n is a COPY of i                   │
└────────────────────────────────────┘

Each goroutine has its own copy!
```

### Solution 2: Shadow Variable

```go
// CORRECT - Shadow in loop
func printNumbers() {
    for i := 0; i < 5; i++ {
        i := i  // Create new variable (shadows outer i)
        go func() {
            fmt.Println(i)
        }()
    }
    time.Sleep(time.Second)
}
```

**What happens**:

```
Variable Shadowing:

Iteration 0:
┌────────────────────────────────────┐
│ Outer i: 0                         │
│ Inner i: 0 (copy) ← Goroutine 1   │
└────────────────────────────────────┘

Iteration 1:
┌────────────────────────────────────┐
│ Outer i: 1                         │
│ Inner i: 1 (copy) ← Goroutine 2   │
└────────────────────────────────────┘

Each iteration creates a NEW inner 'i'!
```

### Worker Pool Pattern

Common pattern using closures and goroutines:

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type Job struct {
    ID   int
    Data string
}

type Result struct {
    Job    Job
    Output string
}

func worker(id int, jobs <-chan Job, results chan<- Result, wg *sync.WaitGroup) {
    defer wg.Done()
    
    // Closure captures worker ID
    process := func(job Job) Result {
        // Simulate work
        time.Sleep(100 * time.Millisecond)
        return Result{
            Job:    job,
            Output: fmt.Sprintf("Worker %d processed: %s", id, job.Data),
        }
    }
    
    for job := range jobs {
        results <- process(job)
    }
}

func main() {
    jobs := make(chan Job, 10)
    results := make(chan Result, 10)
    
    var wg sync.WaitGroup
    
    // Start 3 workers
    for i := 1; i <= 3; i++ {
        wg.Add(1)
        go worker(i, jobs, results, &wg)
    }
    
    // Send jobs
    for i := 1; i <= 5; i++ {
        jobs <- Job{ID: i, Data: fmt.Sprintf("Task %d", i)}
    }
    close(jobs)
    
    // Close results when done
    go func() {
        wg.Wait()
        close(results)
    }()
    
    // Collect results
    for result := range results {
        fmt.Println(result.Output)
    }
}
```

### Goroutine Leak with Closures

Closures can cause goroutine leaks if not careful:

```go
// LEAKY - Goroutine never exits!
func leakyFunction() {
    data := make([]byte, 1024*1024) // 1MB
    
    go func() {
        for {
            // Closure keeps 'data' alive
            // Goroutine never exits
            // 1MB leaked!
            time.Sleep(time.Second)
            processData(data)
        }
    }()
}

// FIXED - Proper cleanup
func fixedFunction() context.Context {
    ctx, cancel := context.WithCancel(context.Background())
    data := make([]byte, 1024*1024)
    
    go func() {
        for {
            select {
            case <-ctx.Done():
                return  // Exit goroutine
            case <-time.After(time.Second):
                processData(data)
            }
        }
    }()
    
    return ctx
}

// Usage
ctx := fixedFunction()
// Later, when done:
cancel()  // Goroutine exits, 'data' can be GC'd
```

---

## Practical Applications {#practical-applications}

Let's see how closures are used in real-world scenarios.

### Application 1: HTTP Middleware

```go
package main

import (
    "fmt"
    "log"
    "net/http"
    "time"
)

// Middleware type
type Middleware func(http.HandlerFunc) http.HandlerFunc

// Logging middleware
func withLogging(handler http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // Create wrapped response writer to capture status code
        wrapped := &responseWriter{ResponseWriter: w, statusCode: 200}
        
        handler(wrapped, r)
        
        log.Printf("%s %s %d %v",
            r.Method,
            r.URL.Path,
            wrapped.statusCode,
            time.Since(start))
    }
}

type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}

// Authentication middleware
func withAuth(requiredRole string) Middleware {
    return func(handler http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            // Closure captures requiredRole
            userRole := r.Header.Get("X-User-Role")
            
            if userRole != requiredRole {
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
            }
            
            handler(w, r)
        }
    }
}

// Rate limiting middleware
func withRateLimit(requestsPerSecond int) Middleware {
    // Closure captures rate limiter
    limiter := time.NewTicker(time.Second / time.Duration(requestsPerSecond))
    
    return func(handler http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            <-limiter.C  // Wait for token
            handler(w, r)
        }
    }
}

// Chain middleware
func chain(handler http.HandlerFunc, middleware ...Middleware) http.HandlerFunc {
    for i := len(middleware) - 1; i >= 0; i-- {
        handler = middleware[i](handler)
    }
    return handler
}

func main() {
    // Handler
    handler := func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Hello, World!")
    }
    
    // Apply middleware
    protected := chain(handler,
        withLogging,
        withAuth("admin"),
        withRateLimit(10))
    
    http.HandleFunc("/api", protected)
    http.ListenAndServe(":8080", nil)
}
```

### Application 2: Event System

```go
package main

import (
    "fmt"
    "sync"
)

type EventType string

const (
    UserCreated EventType = "user.created"
    UserDeleted EventType = "user.deleted"
    OrderPlaced EventType = "order.placed"
)

type Event struct {
    Type EventType
    Data interface{}
}

type EventHandler func(Event)

type EventBus struct {
    mu       sync.RWMutex
    handlers map[EventType][]EventHandler
}

func NewEventBus() *EventBus {
    return &EventBus{
        handlers: make(map[EventType][]EventHandler),
    }
}

// Subscribe with closure
func (eb *EventBus) Subscribe(eventType EventType, handler EventHandler) func() {
    eb.mu.Lock()
    defer eb.mu.Unlock()
    
    eb.handlers[eventType] = append(eb.handlers[eventType], handler)
    
    // Return unsubscribe closure
    return func() {
        eb.mu.Lock()
        defer eb.mu.Unlock()
        
        handlers := eb.handlers[eventType]
        for i, h := range handlers {
            // Compare function pointers
            if &h == &handler {
                eb.handlers[eventType] = append(handlers[:i], handlers[i+1:]...)
                return
            }
        }
    }
}

func (eb *EventBus) Publish(event Event) {
    eb.mu.RLock()
    handlers := eb.handlers[event.Type]
    eb.mu.RUnlock()
    
    for _, handler := range handlers {
        go handler(event)  // Async
    }
}

func main() {
    bus := NewEventBus()
    
    // Subscribe with closures
    userCount := 0
    unsubscribe1 := bus.Subscribe(UserCreated, func(e Event) {
        userCount++
        fmt.Printf("User created! Total: %d\n", userCount)
    })
    
    unsubscribe2 := bus.Subscribe(UserCreated, func(e Event) {
        fmt.Printf("Send welcome email to: %v\n", e.Data)
    })
    
    // Publish events
    bus.Publish(Event{Type: UserCreated, Data: "alice@example.com"})
    bus.Publish(Event{Type: UserCreated, Data: "bob@example.com"})
    
    // Unsubscribe
    unsubscribe1()
    unsubscribe2()
}
```

### Application 3: State Machine

```go
package main

import (
    "fmt"
)

type State string

const (
    StatePending   State = "pending"
    StateApproved  State = "approved"
    StateRejected  State = "rejected"
    StateCompleted State = "completed"
)

type Event string

const (
    EventApprove  Event = "approve"
    EventReject   Event = "reject"
    EventComplete Event = "complete"
)

type StateMachine struct {
    current State
    transitions map[State]map[Event]State
    callbacks   map[State][]func()
}

func NewStateMachine(initial State) *StateMachine {
    return &StateMachine{
        current:     initial,
        transitions: make(map[State]map[Event]State),
        callbacks:   make(map[State][]func()),
    }
}

func (sm *StateMachine) AddTransition(from State, event Event, to State) {
    if sm.transitions[from] == nil {
        sm.transitions[from] = make(map[Event]State)
    }
    sm.transitions[from][event] = to
}

func (sm *StateMachine) OnEnter(state State, callback func()) {
    sm.callbacks[state] = append(sm.callbacks[state], callback)
}

func (sm *StateMachine) Trigger(event Event) error {
    to, ok := sm.transitions[sm.current][event]
    if !ok {
        return fmt.Errorf("invalid transition: %s -> %s", sm.current, event)
    }
    
    sm.current = to
    
    // Execute callbacks
    for _, cb := range sm.callbacks[to] {
        cb()
    }
    
    return nil
}

func main() {
    // Create order state machine
    sm := NewStateMachine(StatePending)
    
    // Define transitions
    sm.AddTransition(StatePending, EventApprove, StateApproved)
    sm.AddTransition(StatePending, EventReject, StateRejected)
    sm.AddTransition(StateApproved, EventComplete, StateCompleted)
    
    // Add callbacks with closures
    orderID := "ORD-123"
    
    sm.OnEnter(StateApproved, func() {
        fmt.Printf("Order %s approved - processing payment\n", orderID)
    })
    
    sm.OnEnter(StateRejected, func() {
        fmt.Printf("Order %s rejected - notifying customer\n", orderID)
    })
    
    sm.OnEnter(StateCompleted, func() {
        fmt.Printf("Order %s completed - shipping\n", orderID)
    })
    
    // Trigger events
    sm.Trigger(EventApprove)  // Order ORD-123 approved
    sm.Trigger(EventComplete) // Order ORD-123 completed
}
```

## Best Practices {#best-practices}

Let's explore the best practices for using closures effectively and safely.

### Practice 1: Keep Closures Small and Focused

```go
// Bad - Too much captured state
func makeComplexHandler() http.HandlerFunc {
    db := connectDatabase()
    cache := newCache()
    logger := newLogger()
    metrics := newMetrics()
    validator := newValidator()
    // ... many more
    
    return func(w http.ResponseWriter, r *http.Request) {
        // Handler captures everything above
        // Large closure context
    }
}

// Good - Capture only what's needed
func makeSimpleHandler(db *Database, cache *Cache) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // Captures only db and cache
        // Small closure context
    }
}
```

### Practice 2: Be Explicit About Captured Variables

```go
// Bad - Unclear what's captured
func processItems(items []Item) {
    total := 0
    errors := []error{}
    processed := 0
    
    for _, item := range items {
        go func() {
            // What does this capture? Unclear!
            result := process(item)
            total += result
            processed++
        }()
    }
}

// Good - Explicit parameters
func processItems(items []Item) {
    total := 0
    errors := []error{}
    processed := 0
    var mu sync.Mutex
    
    for _, item := range items {
        go func(item Item) {  // Explicit parameter
            result := process(item)
            
            mu.Lock()
            total += result
            processed++
            mu.Unlock()
        }(item)  // Explicit argument
    }
}
```

### Practice 3: Document Closure Lifetime

```go
// Good - Clear lifetime documentation
type Server struct {
    // cleanup functions are called during shutdown
    cleanupFns []func()
}

// RegisterCleanup registers a cleanup function that will be called
// when the server shuts down. The closure will capture any state
// needed for cleanup and keep it alive until shutdown.
func (s *Server) RegisterCleanup(fn func()) {
    s.cleanupFns = append(s.cleanupFns, fn)
}

// Usage
server.RegisterCleanup(func() {
    // This closure keeps the database connection alive
    // until server shutdown
    db.Close()
})
```

### Practice 4: Avoid Capturing Large Data Structures

```go
// Bad - Captures entire slice
func findProcessor(records []Record) func(string) *Record {
    return func(id string) *Record {
        // Entire slice kept alive!
        for i := range records {
            if records[i].ID == id {
                return &records[i]
            }
        }
        return nil
    }
}

// Good - Convert to map, capture only what's needed
func findProcessor(records []Record) func(string) *Record {
    index := make(map[string]*Record)
    for i := range records {
        index[records[i].ID] = &records[i]
    }
    
    return func(id string) *Record {
        // Only captures map, not original slice
        return index[id]
    }
}
```

### Practice 5: Use Closures for Cleanup

```go
// Pattern: Return cleanup function
func setupResource() func() {
    resource := acquireResource()
    
    // Return cleanup closure
    return func() {
        resource.Release()
    }
}

// Usage
cleanup := setupResource()
defer cleanup()

// Better: Multiple cleanups
func setupResources() (func(), error) {
    cleanups := []func(){}
    
    db, err := openDatabase()
    if err != nil {
        return nil, err
    }
    cleanups = append(cleanups, func() { db.Close() })
    
    cache, err := openCache()
    if err != nil {
        db.Close()  // Clean up what we opened
        return nil, err
    }
    cleanups = append(cleanups, func() { cache.Close() })
    
    // Return combined cleanup
    return func() {
        for i := len(cleanups) - 1; i >= 0; i-- {
            cleanups[i]()
        }
    }, nil
}
```

### Practice 6: Prefer Explicit State Over Closures

Sometimes explicit state is clearer:

```go
// Closure approach
func makeCounter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

// Explicit state approach (sometimes better)
type Counter struct {
    count int
}

func (c *Counter) Next() int {
    c.count++
    return c.count
}

// Use closures when:
// - State is truly private
// - Lifetime is clear
// - Logic is simple

// Use structs when:
// - Multiple methods needed
// - State should be inspectable
// - More complex logic
```

---

## Common Pitfalls {#pitfalls}

Let's examine common mistakes and how to avoid them.

### Pitfall 1: Loop Variable Capture (The Classic Bug)

We covered this before, but it's so common it's worth repeating:

```go
// WRONG
for i := 0; i < 5; i++ {
    go func() {
        fmt.Println(i)  // ❌ Captures loop variable
    }()
}

// CORRECT - Solution 1: Pass as parameter
for i := 0; i < 5; i++ {
    go func(n int) {
        fmt.Println(n)  // ✓ Each goroutine has its own copy
    }(i)
}

// CORRECT - Solution 2: Shadow variable
for i := 0; i < 5; i++ {
    i := i  // ✓ Creates new variable each iteration
    go func() {
        fmt.Println(i)
    }()
}
```

**Go 1.22+ Update**: In Go 1.22 and later, loop variables are scoped per-iteration by default, fixing this issue!

```go
// Go 1.22+: This is now safe!
for i := 0; i < 5; i++ {
    go func() {
        fmt.Println(i)  // ✓ Each iteration has separate 'i'
    }()
}
```

### Pitfall 2: Capturing Pointers

```go
// Dangerous - Pointer to stack variable
func makeGetter() func() int {
    x := 10
    return func() int {
        return x  // OK - 'x' moved to heap
    }
}

// Very dangerous - Pointer to loop variable
func makeGetters() []func() int {
    var getters []func() int
    
    for i := 0; i < 5; i++ {
        getters = append(getters, func() int {
            return i  // ❌ All point to same variable!
        })
    }
    
    return getters
}

// After loop, all closures return 5!
```

### Pitfall 3: Closure Leaks

```go
// Memory leak - closure keeps large object alive
type Server struct {
    data []byte  // 100MB
}

func (s *Server) makeHandler() http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // Closure captures entire Server struct
        // 100MB kept alive for each handler!
        fmt.Fprintf(w, "Data size: %d", len(s.data))
    }
}

// Fix - copy only what's needed
func (s *Server) makeHandler() http.HandlerFunc {
    dataSize := len(s.data)  // Copy only size
    
    return func(w http.ResponseWriter, r *http.Request) {
        // Only captures int, not 100MB slice
        fmt.Fprintf(w, "Data size: %d", dataSize)
    }
}
```

### Pitfall 4: Concurrent Access Without Synchronization

```go
// Bug - Race condition
func makeCounter() func() int {
    count := 0
    return func() int {
        count++  // ❌ Not thread-safe!
        return count
    }
}

// Fix - Add mutex
func makeCounter() func() int {
    var mu sync.Mutex
    count := 0
    
    return func() int {
        mu.Lock()
        defer mu.Unlock()
        
        count++  // ✓ Thread-safe
        return count
    }
}

// Better - Use atomic
func makeCounter() func() int {
    var count int64
    
    return func() int {
        return int(atomic.AddInt64(&count, 1))  // ✓ Thread-safe, faster
    }
}
```

### Pitfall 5: Nil Closure Panic

```go
// Dangerous - nil closure
var handler func() = nil

func setup() {
    if someCondition {
        handler = func() {
            fmt.Println("Hello")
        }
    }
}

func main() {
    setup()
    handler()  // ❌ Panic if someCondition was false!
}

// Fix - Always check or provide default
func main() {
    setup()
    if handler != nil {
        handler()  // ✓ Safe
    }
}

// Better - Never leave nil
var handler = func() {
    // Default no-op
}
```

### Pitfall 6: Closure in defer

```go
// Subtle bug
func processFiles(files []string) {
    for _, file := range files {
        f, _ := os.Open(file)
        
        defer f.Close()  // ❌ All defers run at function end!
        
        // Process file
    }
    // All files still open until here!
}

// Fix - Use closure
func processFiles(files []string) {
    for _, file := range files {
        func() {
            f, _ := os.Open(file)
            defer f.Close()  // ✓ Runs at closure end
            
            // Process file
        }()  // Immediate invocation
    }
}

// Better - Explicit function
func processFiles(files []string) {
    for _, file := range files {
        processFile(file)
    }
}

func processFile(filename string) {
    f, _ := os.Open(filename)
    defer f.Close()
    
    // Process file
}
```

---

## Real-World Examples {#real-world}

Let's build complete, production-ready examples using closures.

### Example 1: Database Connection Pool

```go
package main

import (
    "errors"
    "fmt"
    "sync"
    "time"
)

type Connection struct {
    ID        int
    CreatedAt time.Time
    lastUsed  time.Time
}

type Pool struct {
    mu          sync.Mutex
    connections []*Connection
    available   []*Connection
    maxSize     int
    createConn  func() (*Connection, error)
    closeConn   func(*Connection) error
    idCounter   int
}

func NewPool(maxSize int, creator func() (*Connection, error), closer func(*Connection) error) *Pool {
    return &Pool{
        connections: make([]*Connection, 0, maxSize),
        available:   make([]*Connection, 0, maxSize),
        maxSize:     maxSize,
        createConn:  creator,
        closeConn:   closer,
    }
}

// Acquire returns a connection and a cleanup closure
func (p *Pool) Acquire() (*Connection, func(), error) {
    p.mu.Lock()
    defer p.mu.Unlock()
    
    // Try to get from available
    if len(p.available) > 0 {
        conn := p.available[len(p.available)-1]
        p.available = p.available[:len(p.available)-1]
        conn.lastUsed = time.Now()
        
        // Return connection and cleanup closure
        return conn, func() {
            p.Release(conn)
        }, nil
    }
    
    // Create new if under limit
    if len(p.connections) < p.maxSize {
        p.idCounter++
        conn := &Connection{
            ID:        p.idCounter,
            CreatedAt: time.Now(),
            lastUsed:  time.Now(),
        }
        
        p.connections = append(p.connections, conn)
        
        return conn, func() {
            p.Release(conn)
        }, nil
    }
    
    return nil, nil, errors.New("pool exhausted")
}

func (p *Pool) Release(conn *Connection) {
    p.mu.Lock()
    defer p.mu.Unlock()
    
    p.available = append(p.available, conn)
}

func (p *Pool) Close() error {
    p.mu.Lock()
    defer p.mu.Unlock()
    
    for _, conn := range p.connections {
        if p.closeConn != nil {
            p.closeConn(conn)
        }
    }
    
    p.connections = nil
    p.available = nil
    
    return nil
}

func main() {
    // Create pool with closures
    pool := NewPool(
        10,
        func() (*Connection, error) {
            fmt.Println("Creating new connection")
            return &Connection{}, nil
        },
        func(c *Connection) error {
            fmt.Printf("Closing connection %d\n", c.ID)
            return nil
        },
    )
    defer pool.Close()
    
    // Use connection with cleanup closure
    conn, release, err := pool.Acquire()
    if err != nil {
        panic(err)
    }
    defer release()  // Cleanup closure
    
    fmt.Printf("Using connection %d\n", conn.ID)
}
```

### Example 2: Circuit Breaker

```go
package main

import (
    "errors"
    "fmt"
    "sync"
    "time"
)

type State int

const (
    StateClosed State = iota
    StateOpen
    StateHalfOpen
)

type CircuitBreaker struct {
    mu            sync.Mutex
    state         State
    failures      int
    lastFailTime  time.Time
    threshold     int
    timeout       time.Duration
    onStateChange func(State, State)
}

func NewCircuitBreaker(threshold int, timeout time.Duration) *CircuitBreaker {
    return &CircuitBreaker{
        state:     StateClosed,
        threshold: threshold,
        timeout:   timeout,
    }
}

// OnStateChange registers a callback for state transitions
func (cb *CircuitBreaker) OnStateChange(fn func(old, new State)) {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    cb.onStateChange = fn
}

func (cb *CircuitBreaker) Call(fn func() error) error {
    cb.mu.Lock()
    
    // Check if we should transition from Open to HalfOpen
    if cb.state == StateOpen {
        if time.Since(cb.lastFailTime) > cb.timeout {
            cb.setState(StateHalfOpen)
        } else {
            cb.mu.Unlock()
            return errors.New("circuit breaker is open")
        }
    }
    
    cb.mu.Unlock()
    
    // Execute function
    err := fn()
    
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    if err != nil {
        cb.failures++
        cb.lastFailTime = time.Now()
        
        if cb.failures >= cb.threshold {
            cb.setState(StateOpen)
        }
        
        return err
    }
    
    // Success
    if cb.state == StateHalfOpen {
        cb.setState(StateClosed)
    }
    cb.failures = 0
    
    return nil
}

func (cb *CircuitBreaker) setState(newState State) {
    oldState := cb.state
    cb.state = newState
    
    if cb.onStateChange != nil && oldState != newState {
        // Call closure in goroutine to avoid blocking
        go cb.onStateChange(oldState, newState)
    }
}

func main() {
    cb := NewCircuitBreaker(3, 5*time.Second)
    
    // Register state change handler with closure
    cb.OnStateChange(func(old, new State) {
        fmt.Printf("Circuit breaker: %v -> %v\n", old, new)
    })
    
    // Simulate failing calls
    for i := 0; i < 5; i++ {
        err := cb.Call(func() error {
            return errors.New("service unavailable")
        })
        
        if err != nil {
            fmt.Printf("Call %d failed: %v\n", i+1, err)
        }
        
        time.Sleep(time.Second)
    }
}
```

### Example 3: Retry Logic with Exponential Backoff

```go
package main

import (
    "fmt"
    "math"
    "time"
)

type RetryConfig struct {
    MaxAttempts int
    InitialDelay time.Duration
    MaxDelay     time.Duration
    Multiplier   float64
    OnRetry      func(attempt int, err error)
}

// Retry creates a retry wrapper with closures
func Retry(config RetryConfig, fn func() error) error {
    var lastErr error
    delay := config.InitialDelay
    
    for attempt := 1; attempt <= config.MaxAttempts; attempt++ {
        err := fn()
        
        if err == nil {
            return nil  // Success!
        }
        
        lastErr = err
        
        if attempt < config.MaxAttempts {
            // Call retry callback
            if config.OnRetry != nil {
                config.OnRetry(attempt, err)
            }
            
            // Sleep with exponential backoff
            time.Sleep(delay)
            
            // Calculate next delay
            delay = time.Duration(float64(delay) * config.Multiplier)
            if delay > config.MaxDelay {
                delay = config.MaxDelay
            }
        }
    }
    
    return fmt.Errorf("failed after %d attempts: %w", 
        config.MaxAttempts, lastErr)
}

// RetryWithContext creates a configurable retry function
func RetryWithContext(maxAttempts int, initialDelay time.Duration) func(func() error) error {
    config := RetryConfig{
        MaxAttempts:  maxAttempts,
        InitialDelay: initialDelay,
        MaxDelay:     30 * time.Second,
        Multiplier:   2.0,
    }
    
    // Return closure that captures config
    return func(fn func() error) error {
        return Retry(config, fn)
    }
}

func main() {
    // Create retry function with specific configuration
    retry := RetryWithContext(5, 1*time.Second)
    
    attempts := 0
    err := retry(func() error {
        attempts++
        fmt.Printf("Attempt %d\n", attempts)
        
        if attempts < 3 {
            return fmt.Errorf("temporary failure")
        }
        
        return nil  // Success on 3rd attempt
    })
    
    if err != nil {
        fmt.Printf("Failed: %v\n", err)
    } else {
        fmt.Println("Success!")
    }
}
```

### Example 4: Rate Limiter with Token Bucket

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type RateLimiter struct {
    tokens      int
    maxTokens   int
    refillRate  time.Duration
    mu          sync.Mutex
    lastRefill  time.Time
}

func NewRateLimiter(maxTokens int, refillRate time.Duration) *RateLimiter {
    rl := &RateLimiter{
        tokens:     maxTokens,
        maxTokens:  maxTokens,
        refillRate: refillRate,
        lastRefill: time.Now(),
    }
    
    // Start refill goroutine with closure
    go func() {
        ticker := time.NewTicker(refillRate)
        defer ticker.Stop()
        
        for range ticker.C {
            rl.refill()
        }
    }()
    
    return rl
}

func (rl *RateLimiter) refill() {
    rl.mu.Lock()
    defer rl.mu.Unlock()
    
    if rl.tokens < rl.maxTokens {
        rl.tokens++
    }
    rl.lastRefill = time.Now()
}

func (rl *RateLimiter) Allow() bool {
    rl.mu.Lock()
    defer rl.mu.Unlock()
    
    if rl.tokens > 0 {
        rl.tokens--
        return true
    }
    
    return false
}

// Wrap creates a rate-limited version of a function
func (rl *RateLimiter) Wrap(fn func()) func() error {
    return func() error {
        if !rl.Allow() {
            return fmt.Errorf("rate limit exceeded")
        }
        
        fn()
        return nil
    }
}

func main() {
    // 5 tokens, refill 1 per second
    limiter := NewRateLimiter(5, time.Second)
    
    // Wrap function with rate limiting
    limitedFunc := limiter.Wrap(func() {
        fmt.Println("Function executed")
    })
    
    // Try to call 10 times
    for i := 0; i < 10; i++ {
        err := limitedFunc()
        if err != nil {
            fmt.Printf("Call %d: %v\n", i+1, err)
        }
    }
}
```

---

## Summary

Closures are a powerful feature in Go that enables elegant solutions to common programming problems. Let's recap the key points:

**Core Concepts**:

- Closures capture variables from enclosing scope by reference
- Captured variables are moved to heap (escape analysis)
- Multiple closures can share captured state
- Closures consist of code pointer + context pointer

**Internal Architecture**:

- Function values are 16 bytes (2 pointers on 64-bit)
- Closure context allocated on heap
- Variables promoted from stack to heap when captured
- Compiler performs escape analysis and optimizations

**Memory Management**:

- Closures keep captured variables alive
- Can cause memory leaks if not careful
- Only capture what you need
- Use explicit cleanup closures for resources

**Common Patterns**:

- Factory functions
- Private state encapsulation
- Iterators and generators
- Memoization
- Partial application
- Decorators
- Middleware

**With Goroutines**:

- Loop variable capture is the classic bug
- Pass as parameter or shadow variable
- Watch for race conditions
- Prevent goroutine leaks
- Go 1.22+ fixes loop variable issue

**Best Practices**:

- Keep closures small and focused
- Be explicit about captured variables
- Document closure lifetime
- Avoid capturing large structures
- Use for cleanup functions
- Prefer explicit state when appropriate

**Common Pitfalls**:

- Loop variable capture
- Capturing pointers incorrectly
- Memory leaks
- Race conditions
- Nil closure panics
- defer with closures in loops

Closures make Go code more expressive, maintainable, and powerful. Master them, and you'll write better Go code!