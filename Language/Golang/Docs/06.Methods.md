# The Complete Guide to Go Methods - Part 1 of 2

## From Necessity to Advanced Patterns with Structs

---

## Table of Contents - Complete Guide

### Part 1 (This Document)

1. [Introduction: Why Methods Exist](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#introduction-why-methods-exist)
2. [The Necessity of Methods](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#the-necessity-of-methods)
3. [Methods vs Functions](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#methods-vs-functions)
4. [Real-World Use Cases](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#real-world-use-cases)
5. [Method Fundamentals](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#method-fundamentals)

### Part 2

6. Memory Architecture of Methods
7. Value vs Pointer Receivers - Deep Dive
8. Method Sets and Interfaces
9. Advanced Patterns and Techniques
10. Practical Backend Examples
11. Performance and Best Practices

---

## Introduction: Why Methods Exist

Imagine you're building a user management system. You have a `User` struct and need various operations on it—validation, authentication, profile updates, permission checks. Without methods, you'd write separate functions:

```go
type User struct {
    ID       int64
    Username string
    Email    string
    Password string
    Role     string
    Active   bool
}

// Without methods - separate functions
func ValidateUser(u User) error {
    if len(u.Username) < 3 {
        return errors.New("username too short")
    }
    if !strings.Contains(u.Email, "@") {
        return errors.New("invalid email")
    }
    return nil
}

func AuthenticateUser(u User, password string) bool {
    return u.Password == hashPassword(password)
}

func UpdateUserEmail(u *User, email string) error {
    if !strings.Contains(email, "@") {
        return errors.New("invalid email")
    }
    u.Email = email
    return nil
}

func UserHasPermission(u User, permission string) bool {
    // Complex permission logic
    return u.Role == "admin" || checkPermission(u.Role, permission)
}

// Usage becomes verbose
user := User{Username: "alice", Email: "alice@example.com"}
if err := ValidateUser(user); err != nil {
    log.Fatal(err)
}
if AuthenticateUser(user, "password123") {
    if UserHasPermission(user, "write") {
        // Do something
    }
}
```

This approach has several problems:

**1. Namespace Pollution** Every function needs a unique name prefixed with the type name. This clutters the global namespace and makes related operations scattered.

**2. No Logical Grouping** Functions related to `User` are disconnected from the type itself. When reading code, the relationship isn't immediately clear.

**3. Difficult Discoverability** IDE autocomplete can't help—you must remember function names. There's no natural way to discover what operations a type supports.

**4. Package Organization Issues** Where do these functions live? In the same package as `User`? Spread across multiple packages? No clear answer.

Methods solve these problems by attaching operations directly to types:

```go
// With methods - operations attached to the type
type User struct {
    ID       int64
    Username string
    Email    string
    Password string
    Role     string
    Active   bool
}

func (u User) Validate() error {
    if len(u.Username) < 3 {
        return errors.New("username too short")
    }
    if !strings.Contains(u.Email, "@") {
        return errors.New("invalid email")
    }
    return nil
}

func (u User) Authenticate(password string) bool {
    return u.Password == hashPassword(password)
}

func (u *User) UpdateEmail(email string) error {
    if !strings.Contains(email, "@") {
        return errors.New("invalid email")
    }
    u.Email = email
    return nil
}

func (u User) HasPermission(permission string) bool {
    return u.Role == "admin" || checkPermission(u.Role, permission)
}

// Usage becomes intuitive
user := User{Username: "alice", Email: "alice@example.com"}
if err := user.Validate(); err != nil {
    log.Fatal(err)
}
if user.Authenticate("password123") {
    if user.HasPermission("write") {
        // Do something
    }
}
```

**The Benefits:**

```
Conceptual Grouping:

Without Methods:
Global Namespace
├─ ValidateUser()
├─ AuthenticateUser()
├─ UpdateUserEmail()
├─ UserHasPermission()
├─ ValidateProduct()
├─ UpdateProduct()
└─ ... (cluttered)

With Methods:
User Type
├─ Validate()
├─ Authenticate()
├─ UpdateEmail()
└─ HasPermission()

Product Type
├─ Validate()
└─ Update()

Clean, organized, discoverable!
```

Methods create a natural namespace per type. Operations belong to the data they operate on. This is the essence of object-oriented programming in Go—not inheritance or classes, but methods that give behavior to types.

---

## The Necessity of Methods

Methods aren't just syntactic sugar—they're necessary for solving fundamental problems in software design. Let's explore why through concrete scenarios.

### The Encapsulation Problem

Data and the operations on that data should be closely coupled. Without methods, this coupling is weak and error-prone.

**Problem: Scattered Logic**

```go
// Without methods - validation logic scattered
type BankAccount struct {
    AccountNumber string
    Balance       float64
    Currency      string
    Frozen        bool
}

// Global functions - no encapsulation
func ValidateAccountNumber(number string) error {
    if len(number) != 10 {
        return errors.New("account number must be 10 digits")
    }
    return nil
}

func CanWithdraw(account BankAccount, amount float64) bool {
    return !account.Frozen && account.Balance >= amount
}

func Withdraw(account *BankAccount, amount float64) error {
    // Easy to forget validation!
    if account.Frozen {
        return errors.New("account is frozen")
    }
    if account.Balance < amount {
        return errors.New("insufficient funds")
    }
    account.Balance -= amount
    return nil
}

// Problem: Anyone can modify balance directly
account.Balance = 1000000  // No validation, no checks!
```

This design has critical flaws:

1. **No Encapsulation**: Direct field access bypasses all validation
2. **Easy to Forget Checks**: Developers must remember to call validation functions
3. **Inconsistent State**: Account can be in invalid states
4. **Security Risk**: Balance manipulation without audit trail

**Solution: Methods with Encapsulation**

```go
// With methods - proper encapsulation
type BankAccount struct {
    accountNumber string  // Unexported - encapsulated
    balance       float64 // Unexported - encapsulated
    currency      string  // Unexported - encapsulated
    frozen        bool    // Unexported - encapsulated
}

// Constructor ensures valid creation
func NewBankAccount(accountNumber, currency string) (*BankAccount, error) {
    if len(accountNumber) != 10 {
        return nil, errors.New("account number must be 10 digits")
    }
    
    return &BankAccount{
        accountNumber: accountNumber,
        balance:       0,
        currency:      currency,
        frozen:        false,
    }, nil
}

// Methods enforce invariants
func (ba *BankAccount) Withdraw(amount float64) error {
    if ba.frozen {
        return errors.New("account is frozen")
    }
    
    if amount <= 0 {
        return errors.New("withdrawal amount must be positive")
    }
    
    if ba.balance < amount {
        return errors.New("insufficient funds")
    }
    
    ba.balance -= amount
    logTransaction("withdraw", ba.accountNumber, amount)
    return nil
}

func (ba *BankAccount) Deposit(amount float64) error {
    if ba.frozen {
        return errors.New("account is frozen")
    }
    
    if amount <= 0 {
        return errors.New("deposit amount must be positive")
    }
    
    ba.balance += amount
    logTransaction("deposit", ba.accountNumber, amount)
    return nil
}

func (ba BankAccount) GetBalance() float64 {
    return ba.balance  // Read-only access
}

func (ba *BankAccount) Freeze() {
    ba.frozen = true
    logTransaction("freeze", ba.accountNumber, 0)
}

// Usage - safe and validated
account, err := NewBankAccount("1234567890", "USD")
if err != nil {
    log.Fatal(err)
}

account.Deposit(1000)
account.Withdraw(100)
balance := account.GetBalance()  // Can only read, not write

// account.balance = 1000000  // Compile error - unexported field!
```

Methods enable true encapsulation by:

- Hiding internal state (unexported fields)
- Enforcing invariants in all operations
- Preventing invalid state transitions
- Providing controlled access to data

### The Type Association Problem

Operations should be clearly associated with the types they operate on. Without methods, this association is implicit and fragile.

**Problem: Unclear Ownership**

```go
// Without methods - unclear ownership
type Order struct {
    ID         int64
    CustomerID int64
    Items      []OrderItem
    Total      float64
    Status     string
}

type OrderItem struct {
    ProductID int64
    Quantity  int
    Price     float64
}

// Where do these functions belong?
// In "order" package? "business" package? "calculation" package?
func CalculateOrderTotal(o Order) float64 {
    total := 0.0
    for _, item := range o.Items {
        total += float64(item.Quantity) * item.Price
    }
    return total
}

func ValidateOrder(o Order) error {
    if len(o.Items) == 0 {
        return errors.New("order must have items")
    }
    return nil
}

func CanCancelOrder(o Order) bool {
    return o.Status == "pending" || o.Status == "processing"
}

// When someone reads the Order struct, they have NO IDEA
// what operations are available. They must search the codebase.
```

**Solution: Methods Make Association Explicit**

```go
// With methods - clear ownership
type Order struct {
    ID         int64
    CustomerID int64
    Items      []OrderItem
    Total      float64
    Status     string
}

// Methods clearly belong to Order
func (o *Order) CalculateTotal() float64 {
    total := 0.0
    for _, item := range o.Items {
        total += float64(item.Quantity) * item.Price
    }
    o.Total = total  // Can update internal state
    return total
}

func (o Order) Validate() error {
    if len(o.Items) == 0 {
        return errors.New("order must have items")
    }
    if o.Total <= 0 {
        return errors.New("order total must be positive")
    }
    return nil
}

func (o Order) CanCancel() bool {
    return o.Status == "pending" || o.Status == "processing"
}

func (o *Order) Cancel() error {
    if !o.CanCancel() {
        return errors.New("order cannot be cancelled")
    }
    o.Status = "cancelled"
    return nil
}

func (o *Order) AddItem(item OrderItem) {
    o.Items = append(o.Items, item)
    o.CalculateTotal()  // Automatically recalculate
}

// Now when someone sees Order, they type "order." and IDE shows:
// - order.CalculateTotal()
// - order.Validate()
// - order.CanCancel()
// - order.Cancel()
// - order.AddItem()
// All operations are discoverable!
```

Methods create a clear namespace per type. Every operation on `Order` is an `Order` method. This makes code self-documenting and discoverable.

### The State Mutation Problem

Some operations need to modify the receiver, others don't. This distinction is critical and must be clear.

**Problem: Unclear Mutation Semantics**

```go
// Without methods - mutation is unclear
type Counter struct {
    value int
}

// Does this modify the counter? You must read the implementation!
func IncrementCounter(c Counter) Counter {
    c.value++
    return c  // Returns new counter, original unchanged
}

// Or maybe it modifies in place?
func IncrementCounterPtr(c *Counter) {
    c.value++  // Modifies original
}

// User must guess which function to use
counter := Counter{value: 0}
counter = IncrementCounter(counter)  // Reassign needed?
IncrementCounterPtr(&counter)        // Or pass pointer?
```

**Solution: Receiver Type Makes Mutation Clear**

```go
// With methods - mutation is explicit
type Counter struct {
    value int
}

// Value receiver - DOES NOT modify original
func (c Counter) NextValue() int {
    return c.value + 1  // Returns next value, c unchanged
}

// Pointer receiver - MODIFIES original
func (c *Counter) Increment() {
    c.value++  // Modifies c in place
}

// Value receiver - immutable operation
func (c Counter) IsZero() bool {
    return c.value == 0
}

// Usage - clear semantics
counter := Counter{value: 5}

next := counter.NextValue()    // counter still 5, next is 6
fmt.Println(counter.value)     // 5 (unchanged)

counter.Increment()            // counter modified
fmt.Println(counter.value)     // 6 (changed)

if counter.IsZero() {          // Read-only check
    // ...
}
```

The receiver type (value vs pointer) communicates intent:

- **Value receiver**: "This method reads but doesn't modify"
- **Pointer receiver**: "This method may modify the receiver"

This convention makes code self-documenting and prevents accidental mutations.

### The Interface Satisfaction Problem

Go interfaces are satisfied implicitly—a type automatically implements an interface if it has the required methods. This requires methods (functions don't count).

**Problem: Functions Don't Satisfy Interfaces**

```go
// Interface definition
type Writer interface {
    Write(p []byte) (n int, err error)
}

// Type with function
type FileLogger struct {
    filename string
}

// Function - DOES NOT satisfy Writer interface!
func WriteToFile(fl FileLogger, p []byte) (int, error) {
    // Write implementation
    return len(p), nil
}

// Cannot use FileLogger as Writer
var w Writer = FileLogger{}  // Compile error!
// FileLogger doesn't have Write method
```

**Solution: Methods Satisfy Interfaces**

```go
// Type with method
type FileLogger struct {
    filename string
}

// Method - SATISFIES Writer interface!
func (fl FileLogger) Write(p []byte) (n int, err error) {
    file, err := os.OpenFile(fl.filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
    if err != nil {
        return 0, err
    }
    defer file.Close()
    
    return file.Write(p)
}

// Now FileLogger automatically implements Writer
var w Writer = FileLogger{filename: "app.log"}
w.Write([]byte("Hello, World!"))

// Can use FileLogger anywhere Writer is expected
func LogMessage(w Writer, message string) {
    w.Write([]byte(message))
}

LogMessage(FileLogger{filename: "app.log"}, "System started")
```

Methods are the ONLY way to satisfy interfaces in Go. This is fundamental to Go's type system and enables polymorphism without inheritance.

### The Code Organization Problem

Methods naturally organize code by type, making large codebases maintainable.

**Problem: Scattered Functions**

```go
// user_validation.go
func ValidateUser(u User) error { ... }
func ValidateUsername(username string) error { ... }

// user_authentication.go  
func AuthenticateUser(u User, password string) bool { ... }
func HashUserPassword(password string) string { ... }

// user_permissions.go
func UserHasPermission(u User, perm string) bool { ... }
func UserCanAccess(u User, resource string) bool { ... }

// user_update.go
func UpdateUserEmail(u *User, email string) error { ... }
func UpdateUserPassword(u *User, password string) error { ... }

// Spread across multiple files, hard to find related operations
```

**Solution: Methods Keep Related Code Together**

```go
// user.go - all User methods in one place
type User struct {
    ID       int64
    Username string
    Email    string
    Password string
    Role     string
}

// Validation methods
func (u User) Validate() error { ... }
func (u User) ValidatePassword(password string) error { ... }

// Authentication methods
func (u User) Authenticate(password string) bool { ... }
func (u User) HashPassword() string { ... }

// Permission methods
func (u User) HasPermission(perm string) bool { ... }
func (u User) CanAccess(resource string) bool { ... }

// Update methods
func (u *User) UpdateEmail(email string) error { ... }
func (u *User) UpdatePassword(password string) error { ... }

// Everything related to User is in one place, easy to find
```

Methods organize code naturally. All operations on a type are methods on that type. This makes codebases navigable and maintainable.

---

## Methods vs Functions

Understanding when to use methods versus functions is crucial for good Go design.

### Syntactic Differences

```go
// Function syntax
func FunctionName(receiver Type, param1 Type1) ReturnType {
    // Implementation
}

// Method syntax
func (receiver Type) MethodName(param1 Type1) ReturnType {
    // Implementation
}
```

The key difference: methods have a **receiver** (the type they're attached to) specified between `func` and the method name.

### Semantic Differences

**Functions:**

- Operate on parameters passed to them
- Global scope (package-level)
- No type association
- Cannot satisfy interfaces
- Used for general-purpose operations

**Methods:**

- Operate on a receiver (the instance)
- Associated with a specific type
- Can satisfy interfaces
- Enable encapsulation
- Used for type-specific operations

### When to Use Functions

**1. General-Purpose Utilities**

Operations that don't logically belong to any particular type:

```go
// General utilities - functions
func Min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func Max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func Contains(slice []string, item string) bool {
    for _, s := range slice {
        if s == item {
            return true
        }
    }
    return false
}
```

**2. Operations on Multiple Types**

When an operation treats multiple types equally:

```go
// Compares any two comparable values - function
func Equal[T comparable](a, b T) bool {
    return a == b
}

// Merges two maps - function
func MergeMaps[K comparable, V any](m1, m2 map[K]V) map[K]V {
    result := make(map[K]V)
    for k, v := range m1 {
        result[k] = v
    }
    for k, v := range m2 {
        result[k] = v
    }
    return result
}
```

**3. Package-Level Operations**

Operations that coordinate multiple types:

```go
// Package-level initialization - function
func InitializeDatabase(config Config) (*DB, error) {
    db, err := sql.Open(config.Driver, config.DSN)
    if err != nil {
        return nil, err
    }
    
    if err := db.Ping(); err != nil {
        return nil, err
    }
    
    return &DB{conn: db}, nil
}

// Coordinates multiple types - function
func TransferBetweenAccounts(from, to *BankAccount, amount float64) error {
    if err := from.Withdraw(amount); err != nil {
        return err
    }
    
    if err := to.Deposit(amount); err != nil {
        from.Deposit(amount)  // Rollback
        return err
    }
    
    return nil
}
```

### When to Use Methods

**1. Type-Specific Operations**

Operations that operate primarily on one type:

```go
type User struct {
    ID       int64
    Username string
    Email    string
}

// Type-specific - method
func (u User) IsValid() bool {
    return len(u.Username) >= 3 && strings.Contains(u.Email, "@")
}

// Type-specific - method
func (u User) GetDisplayName() string {
    return fmt.Sprintf("%s (%s)", u.Username, u.Email)
}
```

**2. State Modifications**

Operations that modify the receiver:

```go
type Counter struct {
    value int
}

// Modifies state - method with pointer receiver
func (c *Counter) Increment() {
    c.value++
}

func (c *Counter) Reset() {
    c.value = 0
}
```

**3. Interface Implementation**

When you need to satisfy an interface:

```go
// Interface
type Stringer interface {
    String() string
}

type Point struct {
    X, Y int
}

// Must be a method to satisfy interface
func (p Point) String() string {
    return fmt.Sprintf("(%d, %d)", p.X, p.Y)
}
```

**4. Encapsulation**

When you need controlled access to internal state:

```go
type Account struct {
    balance float64  // unexported
}

// Methods provide controlled access
func (a Account) GetBalance() float64 {
    return a.balance
}

func (a *Account) Deposit(amount float64) error {
    if amount <= 0 {
        return errors.New("amount must be positive")
    }
    a.balance += amount
    return nil
}
```

### Conversion Examples

Let's see how to convert between functions and methods:

**Function to Method:**

```go
// Function version
func CalculateDiscount(product Product, percentage float64) float64 {
    return product.Price * (percentage / 100)
}

// Method version
func (p Product) CalculateDiscount(percentage float64) float64 {
    return p.Price * (percentage / 100)
}

// Usage comparison
discount := CalculateDiscount(product, 10)  // Function
discount := product.CalculateDiscount(10)   // Method (more intuitive)
```

**Method to Function:**

```go
// Method version
func (u User) Validate() error {
    if len(u.Username) < 3 {
        return errors.New("username too short")
    }
    return nil
}

// Function version
func ValidateUser(u User) error {
    if len(u.Username) < 3 {
        return errors.New("username too short")
    }
    return nil
}

// Both work, but method is more idiomatic for type-specific operations
```

### Decision Tree

```
Should this be a function or method?

Does it operate primarily on ONE type?
├─ Yes → Does it need to satisfy an interface?
│  ├─ Yes → MUST be a method
│  └─ No → Does it modify the receiver?
│     ├─ Yes → Should be a method (with pointer receiver)
│     └─ No → Could be method or function
│        └─ Is it type-specific behavior?
│           ├─ Yes → Method (for better organization)
│           └─ No → Function
│
└─ No → Does it coordinate multiple types?
   ├─ Yes → Function
   └─ No → Is it a general utility?
      ├─ Yes → Function
      └─ No → Reconsider design
```

---

## Real-World Use Cases

Let's explore concrete backend scenarios where methods are essential, demonstrating their power in production systems.

### Use Case 1: Domain Model with Business Logic

E-commerce order management with complex business rules:

```go
type Order struct {
    ID          int64
    CustomerID  int64
    Items       []OrderItem
    Subtotal    float64
    Tax         float64
    Shipping    float64
    Total       float64
    Status      string
    CreatedAt   time.Time
    UpdatedAt   time.Time
}

type OrderItem struct {
    ProductID int64
    Quantity  int
    Price     float64
    Discount  float64
}

// Calculation methods
func (o *Order) CalculateSubtotal() {
    subtotal := 0.0
    for _, item := range o.Items {
        itemTotal := float64(item.Quantity) * item.Price
        itemTotal -= itemTotal * (item.Discount / 100)
        subtotal += itemTotal
    }
    o.Subtotal = subtotal
    o.UpdatedAt = time.Now()
}

func (o *Order) CalculateTax(taxRate float64) {
    o.Tax = o.Subtotal * (taxRate / 100)
    o.UpdatedAt = time.Now()
}

func (o *Order) CalculateShipping() {
    // Free shipping over $100
    if o.Subtotal >= 100 {
        o.Shipping = 0
    } else if o.Subtotal >= 50 {
        o.Shipping = 5.99
    } else {
        o.Shipping = 9.99
    }
    o.UpdatedAt = time.Now()
}

func (o *Order) CalculateTotal() {
    o.CalculateSubtotal()
    o.CalculateTax(8.5)  // 8.5% tax
    o.CalculateShipping()
    o.Total = o.Subtotal + o.Tax + o.Shipping
    o.UpdatedAt = time.Now()
}

// Validation methods
func (o Order) Validate() error {
    if o.CustomerID <= 0 {
        return errors.New("invalid customer ID")
    }
    
    if len(o.Items) == 0 {
        return errors.New("order must have at least one item")
    }
    
    for i, item := range o.Items {
        if item.Quantity <= 0 {
            return fmt.Errorf("item %d: invalid quantity", i)
        }
        if item.Price < 0 {
            return fmt.Errorf("item %d: invalid price", i)
        }
    }
    
    return nil
}

// State management methods
func (o Order) CanCancel() bool {
    return o.Status == "pending" || o.Status == "processing"
}

func (o Order) CanShip() bool {
    return o.Status == "processing"
}

func (o Order) CanComplete() bool {
    return o.Status == "shipped"
}

func (o *Order) Cancel() error {
    if !o.CanCancel() {
        return fmt.Errorf("order in status '%s' cannot be cancelled", o.Status)
    }
    o.Status = "cancelled"
    o.UpdatedAt = time.Now()
    return nil
}

func (o *Order) MarkAsProcessing() error {
    if o.Status != "pending" {
        return fmt.Errorf("only pending orders can be marked as processing")
    }
    o.Status = "processing"
    o.UpdatedAt = time.Now()
    return nil
}

func (o *Order) Ship() error {
    if !o.CanShip() {
        return fmt.Errorf("order in status '%s' cannot be shipped", o.Status)
    }
    o.Status = "shipped"
    o.UpdatedAt = time.Now()
    return nil
}

func (o *Order) Complete() error {
    if !o.CanComplete() {
        return fmt.Errorf("order in status '%s' cannot be completed", o.Status)
    }
    o.Status = "completed"
    o.UpdatedAt = time.Now()
    return nil
}

// Item management methods
func (o *Order) AddItem(item OrderItem) {
    o.Items = append(o.Items, item)
    o.CalculateTotal()
}

func (o *Order) RemoveItem(productID int64) bool {
    for i, item := range o.Items {
        if item.ProductID == productID {
            o.Items = append(o.Items[:i], o.Items[i+1:]...)
            o.CalculateTotal()
            return true
        }
    }
    return false
}

func (o *Order) UpdateItemQuantity(productID int64, quantity int) error {
    for i, item := range o.Items {
        if item.ProductID == productID {
            if quantity <= 0 {
                return errors.New("quantity must be positive")
            }
            o.Items[i].Quantity = quantity
            o.CalculateTotal()
            return nil
        }
    }
    return errors.New("item not found")
}

// Query methods
func (o Order) GetItemCount() int {
    count := 0
    for _, item := range o.Items {
        count += item.Quantity
    }
    return count
}

func (o Order) HasItem(productID int64) bool {
    for _, item := range o.Items {
        if item.ProductID == productID {
            return true
        }
    }
    return false
}

func (o Order) GetDiscountTotal() float64 {
    discount := 0.0
    for _, item := range o.Items {
        itemDiscount := float64(item.Quantity) * item.Price * (item.Discount / 100)
        discount += itemDiscount
    }
    return discount
}

// Usage in application
func processNewOrder(customerID int64, items []OrderItem) error {
    order := &Order{
        CustomerID: customerID,
        Items:      items,
        Status:     "pending",
        CreatedAt:  time.Now(),
        UpdatedAt:  time.Now(),
    }
    
    // Validate order
    if err := order.Validate(); err != nil {
        return fmt.Errorf("invalid order: %w", err)
    }
    
    // Calculate totals
    order.CalculateTotal()
    
    // Save to database
    if err := saveOrder(order); err != nil {
        return err
    }
    
    // Process payment
    if err := processPayment(order); err != nil {
        order.Cancel()
        saveOrder(order)
        return err
    }
    
    // Mark as processing
    order.MarkAsProcessing()
    saveOrder(order)
    
    return nil
}
```

This example demonstrates:

- **Business logic encapsulation** in methods
- **State management** with validation
- **Automatic recalculation** when state changes
- **Clear separation** between read and write operations
- **Fluent API** for working with domain objects

### Use Case 2: Repository Pattern with Methods

Database access layer with CRUD operations:

```go
type User struct {
    ID        int64
    Username  string
    Email     string
    Password  string
    CreatedAt time.Time
    UpdatedAt time.Time
}

// Validation methods
func (u User) Validate() error {
    if len(u.Username) < 3 {
        return errors.New("username must be at least 3 characters")
    }
    
    if !strings.Contains(u.Email, "@") {
        return errors.New("invalid email address")
    }
    
    if len(u.Password) < 8 {
        return errors.New("password must be at least 8 characters")
    }
    
    return nil
}

// Transformation methods
func (u *User) HashPassword() error {
    if u.Password == "" {
        return errors.New("password is required")
    }
    
    hashed, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
    if err != nil {
        return err
    }
    
    u.Password = string(hashed)
    return nil
}

func (u User) VerifyPassword(password string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password))
    return err == nil
}

// Serialization methods
func (u User) ToJSON() ([]byte, error) {
    // Exclude password from JSON
    type UserJSON struct {
        ID        int64     `json:"id"`
        Username  string    `json:"username"`
        Email     string    `json:"email"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
    }
    
    return json.Marshal(UserJSON{
        ID:        u.ID,
        Username:  u.Username,
        Email:     u.Email,
        CreatedAt: u.CreatedAt,
        UpdatedAt: u.UpdatedAt,
    })
}

// Repository pattern with methods
type UserRepository struct {
    db *sql.DB
}

func NewUserRepository(db *sql.DB) *UserRepository {
    return &UserRepository{db: db}
}

func (r *UserRepository) Create(user *User) error {
    // Validate before creating
    if err := user.Validate(); err != nil {
        return err
    }
    
    // Hash password
    if err := user.HashPassword(); err != nil {
        return err
    }
    
    // Set timestamps
    now := time.Now()
    user.CreatedAt = now
    user.UpdatedAt = now
    
    // Insert into database
    query := `
        INSERT INTO users (username, email, password, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id
    `
    
    err := r.db.QueryRow(
        query,
        user.Username,
        user.Email,
        user.Password,
        user.CreatedAt,
        user.UpdatedAt,
    ).Scan(&user.ID)
    
    return err
}

func (r *UserRepository) FindByID(id int64) (*User, error) {
    user := &User{}
    
    query := `
        SELECT id, username, email, password, created_at, updated_at
        FROM users
        WHERE id = $1
    `
    
    err := r.db.QueryRow(query, id).Scan(
        &user.ID,
        &user.Username,
        &user.Email,
        &user.Password,
        &user.CreatedAt,
        &user.UpdatedAt,
    )
    
    if err == sql.ErrNoRows {
        return nil, errors.New("user not found")
    }
    
    return user, err
}

func (r *UserRepository) FindByEmail(email string) (*User, error) {
    user := &User{}
    
    query := `
        SELECT id, username, email, password, created_at, updated_at
        FROM users
        WHERE email = $1
    `
    
    err := r.db.QueryRow(query, email).Scan(
        &user.ID,
        &user.Username,
        &user.Email,
        &user.Password,
        &user.CreatedAt,
        &user.UpdatedAt,
    )
    
    if err == sql.ErrNoRows {
        return nil, errors.New("user not found")
    }
    
    return user, err
}

func (r *UserRepository) Update(user *User) error {
    if err := user.Validate(); err != nil {
        return err
    }
    
    user.UpdatedAt = time.Now()
    
    query := `
        UPDATE users
        SET username = $1, email = $2, updated_at = $3
        WHERE id = $4
    `
    
    result, err := r.db.Exec(
        query,
        user.Username,
        user.Email,
        user.UpdatedAt,
        user.ID,
    )
    
    if err != nil {
        return err
    }
    
    rows, err := result.RowsAffected()
    if err != nil {
        return err
    }
    
    if rows == 0 {
        return errors.New("user not found")
    }
    
    return nil
}

func (r *UserRepository) Delete(id int64) error {
    query := `DELETE FROM users WHERE id = $1`
    
    result, err := r.db.Exec(query, id)
    if err != nil {
        return err
    }
    
    rows, err := result.RowsAffected()
    if err != nil {
        return err
    }
    
    if rows == 0 {
        return errors.New("user not found")
    }
    
    return nil
}

func (r *UserRepository) List(limit, offset int) ([]*User, error) {
    query := `
        SELECT id, username, email, password, created_at, updated_at
        FROM users
        ORDER BY created_at DESC
        LIMIT $1 OFFSET $2
    `
    
    rows, err := r.db.Query(query, limit, offset)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    users := []*User{}
    
    for rows.Next() {
        user := &User{}
        err := rows.Scan(
            &user.ID,
            &user.Username,
            &user.Email,
            &user.Password,
            &user.CreatedAt,
            &user.UpdatedAt,
        )
        if err != nil {
            return nil, err
        }
        users = append(users, user)
    }
    
    return users, rows.Err()
}

// Usage in application
func registerUser(repo *UserRepository, username, email, password string) error {
    user := &User{
        Username: username,
        Email:    email,
        Password: password,
    }
    
    if err := repo.Create(user); err != nil {
        return err
    }
    
    log.Printf("User created: ID=%d, Username=%s", user.ID, user.Username)
    return nil
}

func authenticateUser(repo *UserRepository, email, password string) (*User, error) {
    user, err := repo.FindByEmail(email)
    if err != nil {
        return nil, err
    }
    
    if !user.VerifyPassword(password) {
        return nil, errors.New("invalid credentials")
    }
    
    return user, nil
}
```

This repository pattern demonstrates:

- **Separation of concerns**: Domain logic in `User`, persistence in `UserRepository`
- **Method-based CRUD operations** on repository
- **Validation and transformation** methods on domain model
- **Encapsulation** of database operations
- **Clean API** for application code

This completes Part 1. Continue to Part 2 for:

- Memory Architecture of Methods
- Value vs Pointer Receivers - Deep Dive
- Method Sets and Interfaces
- Advanced Patterns
- Performance Optimization