# The Complete Guide to Go HTTP Servers: From Basics to Production

## Table of Contents

1. [Introduction - Building Web Services in Go](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#introduction)
2. [HTTP Server Fundamentals](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#fundamentals)
3. [The net/http Package Architecture](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#net-http-architecture)
4. [How Go Servers Handle Requests](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#request-handling)
5. [Handlers and Handler Functions](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#handlers)
6. [Routing and Multiplexers](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#routing)
7. [Middleware Pattern](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#middleware)
8. [Request and Response](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#request-response)
9. [Concurrency in Go Servers](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#concurrency)
10. [Real-World Server Patterns](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#server-patterns)
11. [Performance and Optimization](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#performance)
12. [Production Best Practices](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#best-practices)

---

## Introduction - Building Web Services in Go {#introduction}

Imagine you're running a restaurant. Customers (clients) arrive and make requests (HTTP requests): "I'd like a burger," "Can I get the menu?", "What's the soup of the day?" Your staff (the server) needs to:

**Receive requests**: Listen for customers entering and understand what they want **Route requests**: Direct each customer to the right station (appetizers to the appetizer chef, drinks to the bar) **Process requests**: Actually prepare what was requested **Send responses**: Deliver the food/drink back to the customer **Handle many customers**: Do all this for hundreds of customers simultaneously

A Go HTTP server does exactly this for web requests. It listens for incoming HTTP requests (customers), routes them to appropriate handlers (chefs/stations), processes them (prepares the food), and sends back responses (delivers to table).

What makes Go servers special:

**Goroutine Per Request**: Each incoming request is handled by its own goroutine. With 10,000 concurrent requests, you have 10,000 goroutines working simultaneously. This is like having 10,000 chefs who appear instantly when needed and disappear when done - impossible in a real kitchen, trivial in Go.

**Built-in Concurrency**: You don't need to think about thread pools or async/await. Go's runtime automatically handles thousands of concurrent requests efficiently.

**Standard Library Power**: The `net/http` package provides a production-ready HTTP server out of the box. No need for external frameworks (though many exist and are great).

**Simplicity**: A complete HTTP server in 5 lines of code:

```go
http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, World!")
})
log.Fatal(http.ListenAndServe(":8080", nil))
```

Yet this simple server can handle thousands of concurrent connections, automatically parallelizes across CPU cores, and is production-ready.

---

## HTTP Server Fundamentals {#fundamentals}

Before diving into Go specifics, let's understand what an HTTP server fundamentally does.

### The HTTP Request-Response Cycle

HTTP (Hypertext Transfer Protocol) is a request-response protocol. A client sends a request, the server sends back a response.

**HTTP Request Structure**:

```
GET /users/123 HTTP/1.1                    ← Request Line
Host: api.example.com                      ← Headers
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
                                           ← Blank line
{"update": "new data"}                     ← Body (for POST/PUT)
```

**HTTP Response Structure**:

```
HTTP/1.1 200 OK                            ← Status Line
Content-Type: application/json             ← Headers
Content-Length: 45
                                           ← Blank line
{"id": 123, "name": "John", "email": "..."}  ← Body
```

### What an HTTP Server Must Do

**1. Listen on a Port**: Bind to a network port (e.g., 8080) and wait for incoming TCP connections.

**2. Accept Connections**: When a client connects, accept the TCP connection.

**3. Read Request**: Read the HTTP request from the connection (request line, headers, body).

**4. Parse Request**: Parse the raw bytes into a structured format (method, URL, headers, body).

**5. Route Request**: Determine which handler should process this request based on the URL path and method.

**6. Execute Handler**: Run the appropriate handler function, which generates a response.

**7. Write Response**: Write the HTTP response (status, headers, body) back to the client.

**8. Close Connection**: Close the connection (or keep it alive for reuse with HTTP keep-alive).

**9. Repeat**: Go back to step 2 for the next connection.

In traditional servers (like those in C or Java), you'd implement all these steps manually and manage concurrency explicitly (thread pools, connection limits, etc.). In Go, the `net/http` package handles all of this automatically.

### TCP vs HTTP

HTTP sits on top of TCP. Let's visualize the layers:

```
┌─────────────────────────────────────────────────────────┐
│                   Application Layer                     │
│              (Your Go Handler Code)                     │
│   "Process this request and return a response"          │
└─────────────────────┬───────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────┐
│                   HTTP Layer                            │
│            (net/http package)                           │
│   "Parse HTTP requests, format HTTP responses"          │
└─────────────────────┬───────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────┐
│                   TCP Layer                             │
│            (net package, OS)                            │
│   "Reliable byte stream, connection management"         │
└─────────────────────┬───────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────┐
│                   IP Layer                              │
│               (Operating System)                        │
│   "Routing packets across networks"                     │
└─────────────────────────────────────────────────────────┘
```

When you call `http.ListenAndServe(":8080", nil)`:

1. Go opens a TCP socket on port 8080 (TCP layer)
2. Go listens for incoming TCP connections
3. For each connection, Go reads bytes and parses them as HTTP (HTTP layer)
4. Go routes the request to your handler (Application layer)
5. Your handler processes and writes a response
6. Go formats the response as HTTP and writes it to the TCP connection

All of this is abstracted - you just write handler functions.

---

## The net/http Package Architecture {#net-http-architecture}

The `net/http` package is the heart of Go's HTTP server capabilities. Let's understand its architecture.

### Core Types

**http.Server**: The server configuration and lifecycle manager.

```go
type Server struct {
    Addr           string        // Address to listen on (":8080")
    Handler        Handler       // Root handler (usually a multiplexer)
    ReadTimeout    time.Duration // Timeout for reading request
    WriteTimeout   time.Duration // Timeout for writing response
    MaxHeaderBytes int           // Max bytes for request headers
    // ... many other fields
}
```

**http.Handler**: The interface that processes requests.

```go
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
```

Any type implementing `ServeHTTP` can handle HTTP requests. This is the core abstraction.

**http.ResponseWriter**: Interface for writing HTTP responses.

```go
type ResponseWriter interface {
    Header() Header              // Get/set response headers
    Write([]byte) (int, error)   // Write response body
    WriteHeader(statusCode int)  // Write status code
}
```

**http.Request**: The incoming HTTP request.

```go
type Request struct {
    Method     string      // GET, POST, PUT, DELETE, etc.
    URL        *url.URL    // Parsed URL
    Proto      string      // "HTTP/1.1"
    Header     Header      // Request headers
    Body       io.ReadCloser  // Request body
    RemoteAddr string      // Client's address
    Context    context.Context  // Request context
    // ... many other fields
}
```

### Architecture Visualization

```
┌─────────────────────────────────────────────────────────────────┐
│                    Go HTTP Server Architecture                  │
└─────────────────────────────────────────────────────────────────┘

                        Internet (Clients)
                               │
                               │ TCP Connections
                               ↓
                        ┌─────────────┐
                        │   Listener  │  (net.Listener)
                        │  Port 8080  │  Listening on TCP port
                        └──────┬──────┘
                               │
                    ┌──────────┴──────────┐
                    │  Accept Connections │
                    │  For each connection,│
                    │  spawn a goroutine  │
                    └──────────┬──────────┘
                               │
                    ┌──────────▼──────────────────────────┐
                    │  Connection Goroutines              │
                    │  (one per active connection)        │
                    │                                     │
                    │  ┌──────────┐  ┌──────────┐       │
                    │  │Goroutine1│  │Goroutine2│ ...   │
                    │  │          │  │          │       │
                    │  │ Reads    │  │ Reads    │       │
                    │  │ HTTP     │  │ HTTP     │       │
                    │  │ Request  │  │ Request  │       │
                    │  └────┬─────┘  └────┬─────┘       │
                    └───────┼─────────────┼─────────────┘
                            │             │
                            ↓             ↓
                    ┌────────────────────────────┐
                    │      Server Handler        │
                    │    (Routing/Muxing)        │
                    │  e.g., http.ServeMux       │
                    └────────┬───────────────────┘
                             │
              ┌──────────────┼──────────────┬──────────────┐
              │              │              │              │
              ↓              ↓              ↓              ↓
        ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐
        │ Handler  │   │ Handler  │   │ Handler  │   │ Handler  │
        │ for /    │   │ for /api │   │for /user │   │for /admin│
        └──────────┘   └──────────┘   └──────────┘   └──────────┘
            │               │               │               │
            └───────────────┴───────────────┴───────────────┘
                                   │
                                   ↓
                        ┌──────────────────┐
                        │ Response Written │
                        │ to Connection    │
                        └──────────────────┘
                                   │
                                   ↓
                          Back to Client
```

**Key Points**:

**One Goroutine Per Connection**: Each accepted TCP connection gets its own goroutine. This goroutine reads requests and writes responses for that connection's lifetime.

**Handler Chain**: Requests flow through the handler chain. The `Server` calls the root `Handler` (usually a mux), which routes to the appropriate handler.

**Automatic Concurrency**: With 1,000 concurrent connections, you have 1,000 goroutines automatically. No thread pool configuration needed.

---

## How Go Servers Handle Requests {#request-handling}

Let's trace a request from connection to response, step by step.

### Step-by-Step Request Handling

**Step 1: Client Connects**

A client (browser, curl, another program) opens a TCP connection to your server:

```
Client                                    Server
  │                                         │
  │ ──── TCP SYN (connect request) ──────→ │
  │                                         │
  │ ←─── TCP SYN-ACK (acknowledge) ─────── │
  │                                         │
  │ ──── TCP ACK (connection established) → │
  │                                         │
  │ ═══════ Connection Established ═══════ │
```

Your Go server's listener accepts this connection. The `http.Server` spawns a new goroutine to handle this connection:

```go
// Inside net/http (simplified)
for {
    conn, err := listener.Accept()  // Blocks until connection arrives
    if err != nil {
        // Handle error
        continue
    }
    
    // Spawn goroutine for this connection
    go serveConnection(conn)  // Each connection gets a goroutine
}
```

**Step 2: Read HTTP Request**

The connection goroutine reads from the TCP connection:

```go
// Inside the connection goroutine
func serveConnection(conn net.Conn) {
    // Create buffered reader for efficiency
    reader := bufio.NewReader(conn)
    
    // Read request line: "GET /users/123 HTTP/1.1\r\n"
    requestLine, err := reader.ReadString('\n')
    
    // Parse method, path, version
    method, path, version := parseRequestLine(requestLine)
    
    // Read headers
    headers := make(http.Header)
    for {
        line, _ := reader.ReadString('\n')
        if line == "\r\n" {
            break  // Empty line signals end of headers
        }
        key, value := parseHeader(line)
        headers.Add(key, value)
    }
    
    // Read body (if present, based on Content-Length header)
    body := readBody(reader, headers.Get("Content-Length"))
    
    // Build http.Request object
    request := &http.Request{
        Method: method,
        URL:    parseURL(path),
        Header: headers,
        Body:   ioutil.NopCloser(bytes.NewReader(body)),
        // ... other fields
    }
}
```

This is simplified - the actual code handles many edge cases, HTTP/2, chunked encoding, etc. But conceptually, it's reading bytes and parsing them into an `http.Request`.

**Step 3: Route to Handler**

The server calls the root handler's `ServeHTTP` method:

```go
// Server calls root handler (usually http.ServeMux)
server.Handler.ServeHTTP(responseWriter, request)
```

The mux (multiplexer) examines the request URL and routes to the appropriate handler:

```go
// Inside http.ServeMux (simplified)
func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
    handler, pattern := mux.match(r.URL.Path)
    
    if handler == nil {
        http.NotFound(w, r)  // 404
        return
    }
    
    handler.ServeHTTP(w, r)  // Call matched handler
}
```

**Step 4: Execute Handler**

Your handler code runs:

```go
func userHandler(w http.ResponseWriter, r *http.Request) {
    // Extract user ID from URL
    id := extractID(r.URL.Path)
    
    // Fetch user from database
    user, err := database.GetUser(id)
    if err != nil {
        http.Error(w, "User not found", http.StatusNotFound)
        return
    }
    
    // Encode as JSON
    json, _ := json.Marshal(user)
    
    // Set headers
    w.Header().Set("Content-Type", "application/json")
    
    // Write response
    w.Write(json)
}
```

**Step 5: Write Response**

When you call `w.Write()`, the `ResponseWriter` formats an HTTP response:

```go
// Inside ResponseWriter (simplified)
func (w *responseWriter) Write(data []byte) (int, error) {
    // If WriteHeader hasn't been called, call it with 200
    if !w.wroteHeader {
        w.WriteHeader(http.StatusOK)
    }
    
    // Write data to connection
    return w.conn.Write(data)
}

func (w *responseWriter) WriteHeader(code int) {
    if w.wroteHeader {
        return  // Already wrote header
    }
    w.wroteHeader = true
    
    // Format status line
    fmt.Fprintf(w.conn, "HTTP/1.1 %d %s\r\n", code, statusText(code))
    
    // Write headers
    for key, values := range w.headers {
        for _, value := range values {
            fmt.Fprintf(w.conn, "%s: %s\r\n", key, value)
        }
    }
    
    // Empty line separates headers from body
    fmt.Fprintf(w.conn, "\r\n")
}
```

**Step 6: Connection Handling**

After the response is written:

**HTTP/1.0**: Connection is typically closed.

**HTTP/1.1**: Connection is kept alive (if `Connection: keep-alive` header). The goroutine loops back to step 2, reading the next request on the same connection. This is more efficient - no need to establish a new TCP connection for each request.

**HTTP/2**: Multiplexes multiple requests over a single connection. Much more complex but handled transparently by `net/http`.

### Timeline Visualization

```
┌─────────────────────────────────────────────────────────────────┐
│         Request Handling Timeline (Single Request)             │
└─────────────────────────────────────────────────────────────────┘

Time   Client                  Connection Goroutine           Your Handler
│
0ms    TCP Connect ──────────→ Accept Connection
       │                        Spawn Goroutine
       │                        ↓
       │                        │
10ms   Send HTTP Request ────→ Read Request Line
       GET /users/123            │
       Host: api.com             │
       ...                       │
       │                        ↓
       │                        Read Headers
       │                         │
       │                         ↓
       │                        Parse into http.Request
       │                         │
       │                         ↓
       │                        Route to Handler
       │                         │
20ms   │                        ↓
       │                        ─────────────────────────→ userHandler()
       │                                                      │
       │                                                      ↓
       │                                                   Extract ID
       │                                                      │
       │                                                      ↓
30ms   │                                                   DB Query
       │                                                   (Goroutine blocks)
       │                                                      │
       │                          (Goroutine parked,         │
       │                           CPU does other work)      │
       │                                                      │
80ms   │                                                   DB Returns
       │                                                      │
       │                                                      ↓
       │                                                   Marshal JSON
       │                                                      │
       │                                                      ↓
       │                                                   w.Write(json)
       │                        ←─────────────────────────────┘
       │                        │
       │                        ↓
       │                        Format HTTP Response
       │                         │
90ms   │                        ↓
       │                        Write to TCP Connection
       │                         │
       ←── Receive Response ────┘
       │
       │ HTTP/1.1 200 OK
       │ Content-Type: application/json
       │ {"id":123, "name":"John"}
       │
100ms  Connection kept alive for next request (HTTP/1.1)
       │
       (or connection closes if HTTP/1.0 or no keep-alive)
```

**Key Observations**:

**Total Time**: 100ms, but the connection goroutine only used CPU for ~20ms (reading request, parsing, writing response). The other 60ms, it was blocked on the database query, allowing other goroutines to use the CPU.

**Concurrency**: While this goroutine was blocked on DB, the server processed hundreds of other requests using the same CPU cores.

**Automatic**: You didn't write any async/await code or manage callbacks. You wrote a simple synchronous function, and Go's runtime handled the concurrency.

---

## Handlers and Handler Functions {#handlers}

Handlers are functions that process HTTP requests. Let's explore handlers deeply.

### The Handler Interface

```go
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
```

Any type implementing `ServeHTTP` is a handler. The simplest handler:

```go
type HelloHandler struct{}

func (h HelloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, World!")
}

// Usage:
http.Handle("/hello", HelloHandler{})
```

Most of the time, you don't create types. You use `http.HandlerFunc` to convert functions to handlers.

### HandlerFunc Adapter

`http.HandlerFunc` is a type that converts a function into a `Handler`:

```go
type HandlerFunc func(ResponseWriter, *Request)

func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)  // Calls the function
}
```

This allows any function with the right signature to be used as a handler:

```go
func helloHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, World!")
}

// Convert function to Handler
http.Handle("/hello", http.HandlerFunc(helloHandler))

// Or use shortcut:
http.HandleFunc("/hello", helloHandler)
```

`http.HandleFunc` is just `http.Handle` with the `HandlerFunc` conversion applied automatically.

### Handler Examples

**Simple Text Response**:

```go
func homeHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "text/plain")
    fmt.Fprintf(w, "Welcome to the home page!")
}
```

**JSON Response**:

```go
func userHandler(w http.ResponseWriter, r *http.Request) {
    user := User{ID: 123, Name: "John", Email: "john@example.com"}
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}
```

**Reading Request Body**:

```go
func createUserHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        http.Error(w, "Only POST allowed", http.StatusMethodNotAllowed)
        return
    }
    
    var user User
    if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
        http.Error(w, "Invalid JSON", http.StatusBadRequest)
        return
    }
    defer r.Body.Close()
    
    // Save user to database
    // ...
    
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(user)
}
```

**URL Parameters**:

```go
func userDetailHandler(w http.ResponseWriter, r *http.Request) {
    // Extract ID from URL path: /users/123
    path := r.URL.Path  // "/users/123"
    id := strings.TrimPrefix(path, "/users/")  // "123"
    
    // Fetch user by ID
    user := database.GetUser(id)
    
    json.NewEncoder(w).Encode(user)
}
```

**Query Parameters**:

```go
func searchHandler(w http.ResponseWriter, r *http.Request) {
    // URL: /search?q=golang&limit=10
    query := r.URL.Query()
    
    searchTerm := query.Get("q")      // "golang"
    limit := query.Get("limit")       // "10"
    
    results := database.Search(searchTerm, limit)
    
    json.NewEncoder(w).Encode(results)
}
```

## Routing and Multiplexers {#routing}

Routing maps HTTP requests to handlers based on URL paths and methods. Go's `http.ServeMux` provides basic routing, but let's understand routing deeply.

### http.ServeMux - The Default Router

```go
mux := http.NewServeMux()

mux.HandleFunc("/", homeHandler)
mux.HandleFunc("/users", usersHandler)
mux.HandleFunc("/users/", userDetailHandler)  // Note the trailing slash
mux.HandleFunc("/api/products", productsHandler)

http.ListenAndServe(":8080", mux)
```

**How ServeMux Matches**:

ServeMux uses **longest prefix matching**. For a request to `/users/123`:

- Check `/users/` (matches, 7 characters)
- Check `/users` (matches, 6 characters)
- Check `/` (matches, 1 character)
- Pick `/users/` (longest match)

**Trailing Slash Matters**:

- `/users` matches **only** `/users` (exact match)
- `/users/` matches `/users/`, `/users/123`, `/users/123/posts`, etc. (prefix match)

**Example**:

```
Registered:      Request:           Matched:
/                /                  /
/                /about             / (default)
/users           /users             /users
/users           /users/            / (users doesn't match /users/)
/users/          /users/            /users/
/users/          /users/123         /users/
/users/          /users/123/posts   /users/
/api/v1/         /api/v1/products   /api/v1/
```

### Limitations of http.ServeMux

1. **No Method-Based Routing**: Can't register separate handlers for GET vs POST on the same path
2. **No URL Parameters**: Can't extract `/users/:id` style parameters
3. **No Regex Matching**: Can't match patterns like `/users/\d+`
4. **Manual Extraction**: Must parse URL paths manually

### Third-Party Routers

Many routers exist to address these limitations. Let's look at common patterns:

**gorilla/mux** (Most popular):

```go
import "github.com/gorilla/mux"

r := mux.NewRouter()

// Method-specific routing
r.HandleFunc("/users", getUsers).Methods("GET")
r.HandleFunc("/users", createUser).Methods("POST")

// URL parameters
r.HandleFunc("/users/{id}", getUserByID).Methods("GET")
r.HandleFunc("/users/{id}", updateUser).Methods("PUT")
r.HandleFunc("/users/{id}", deleteUser).Methods("DELETE")

// Extract parameters in handler:
func getUserByID(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id := vars["id"]  // Extracted from URL
    
    user := database.GetUser(id)
    json.NewEncoder(w).Encode(user)
}
```

**chi** (Lightweight, composable):

```go
import "github.com/go-chi/chi/v5"

r := chi.NewRouter()

// Nested routing
r.Route("/users", func(r chi.Router) {
    r.Get("/", listUsers)       // GET /users
    r.Post("/", createUser)     // POST /users
    
    r.Route("/{id}", func(r chi.Router) {
        r.Get("/", getUser)     // GET /users/123
        r.Put("/", updateUser)  // PUT /users/123
        r.Delete("/", deleteUser)  // DELETE /users/123
    })
})
```

**httprouter** (Fastest):

```go
import "github.com/julienschmidt/httprouter"

router := httprouter.New()

router.GET("/users/:id", func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
    id := ps.ByName("id")
    // Handle request
})
```

### Routing Visualization

```
┌─────────────────────────────────────────────────────────────────┐
│                   HTTP Router (Multiplexer)                     │
└─────────────────────────────────────────────────────────────────┘

                        Incoming Request
                      GET /users/123/posts
                              │
                              ↓
                     ┌─────────────────┐
                     │  Router (Mux)   │
                     │  Pattern Match  │
                     └────────┬─────────┘
                              │
              ┌───────────────┼───────────────┬───────────────┐
              │               │               │               │
         Does it match?  Does it match?  Does it match?  Does it match?
         Pattern: /      Pattern:/users  Pattern:/users/ Pattern:/api
              │               │               │               │
            Yes(1)          Yes(6)        Yes(7) ✓          No
              │               │           Longest            │
              └───────────────┴─────────────┘                │
                              │                              │
                              ↓                              │
                    Handler: userDetailHandler               │
                    for /users/ pattern                      │
                              │                              │
                              ↓                              │
                    Handler extracts "123/posts"             │
                    from remaining path                      │

Matching Priority:
1. Exact match first: /users/123 exactly
2. Longest prefix: /users/ (7 chars) beats /users (6 chars) beats / (1 char)
3. If no match, 404
```

---

## Middleware Pattern {#middleware}

Middleware wraps handlers to add cross-cutting concerns (logging, authentication, CORS, etc.) without modifying handler code.

### Middleware Concept

Middleware is a function that takes a handler and returns a new handler that wraps the original:

```go
func middleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Before handler
        // (authentication, logging, etc.)
        
        next.ServeHTTP(w, r)  // Call original handler
        
        // After handler
        // (cleanup, metrics, etc.)
    })
}
```

**Visualization**:

```
┌─────────────────────────────────────────────────────────────────┐
│                  Middleware Chain Execution                     │
└─────────────────────────────────────────────────────────────────┘

Request from Client
       │
       ↓
┌──────────────────┐
│  Middleware 1    │  (Logging)
│  ┌────────────┐  │
│  │ Log start  │  │
│  └─────┬──────┘  │
│        ↓         │
│  ┌──────────────────┐
│  │  Middleware 2    │  (Authentication)
│  │  ┌────────────┐  │
│  │  │ Check auth │  │
│  │  └─────┬──────┘  │
│  │        ↓         │
│  │  ┌──────────────────┐
│  │  │  Middleware 3    │  (CORS)
│  │  │  ┌────────────┐  │
│  │  │  │ Set headers│  │
│  │  │  └─────┬──────┘  │
│  │  │        ↓         │
│  │  │  ┌────────────────┐
│  │  │  │ Actual Handler │
│  │  │  │ (Your code)    │
│  │  │  │ Process request│
│  │  │  └─────┬──────────┘
│  │  │        ↓         │
│  │  │  Response flows back through stack
│  │  │        │         │
│  │  │  ┌─────▼──────┐  │
│  │  │  │ CORS after │  │
│  │  │  └─────┬──────┘  │
│  │  │        ↓         │
│  │  └────────┘         │
│  │  ┌─────▼──────┐     │
│  │  │Auth cleanup│     │
│  │  └─────┬──────┘     │
│  │        ↓            │
│  └────────┘            │
│  ┌─────▼──────┐        │
│  │ Log end    │        │
│  └─────┬──────┘        │
│        ↓               │
└────────┘               │
       │
       ↓
Response to Client
```

### Common Middleware Examples

**Logging Middleware**:

```go
func loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // Log request
        log.Printf("Started %s %s", r.Method, r.URL.Path)
        
        // Call next handler
        next.ServeHTTP(w, r)
        
        // Log duration
        duration := time.Since(start)
        log.Printf("Completed %s %s in %v", r.Method, r.URL.Path, duration)
    })
}
```

**Authentication Middleware**:

```go
func authMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Check for auth token
        token := r.Header.Get("Authorization")
        
        if token == "" {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return  // Don't call next handler
        }
        
        // Validate token
        user, err := validateToken(token)
        if err != nil {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }
        
        // Add user to context
        ctx := context.WithValue(r.Context(), "user", user)
        r = r.WithContext(ctx)
        
        // Call next handler with modified request
        next.ServeHTTP(w, r)
    })
}
```

**CORS Middleware**:

```go
func corsMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Set CORS headers
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
        
        // Handle preflight
        if r.Method == http.MethodOptions {
            w.WriteHeader(http.StatusOK)
            return  // Don't call next handler for OPTIONS
        }
        
        next.ServeHTTP(w, r)
    })
}
```

**Recovery Middleware** (Catch Panics):

```go
func recoveryMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                log.Printf("Panic: %v", err)
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
            }
        }()
        
        next.ServeHTTP(w, r)
    })
}
```

### Chaining Middleware

**Manual Chaining**:

```go
handler := myHandler()
handler = loggingMiddleware(handler)
handler = authMiddleware(handler)
handler = corsMiddleware(handler)

http.Handle("/api/users", handler)
```

**Helper Function**:

```go
func chain(handler http.Handler, middlewares ...func(http.Handler) http.Handler) http.Handler {
    for i := len(middlewares) - 1; i >= 0; i-- {
        handler = middlewares[i](handler)
    }
    return handler
}

// Usage:
http.Handle("/api/users", chain(
    myHandler(),
    loggingMiddleware,
    authMiddleware,
    corsMiddleware,
))
```

**Using chi (Built-in Support)**:

```go
r := chi.NewRouter()

// Global middleware (applies to all routes)
r.Use(loggingMiddleware)
r.Use(corsMiddleware)
r.Use(recoveryMiddleware)

// Route-specific middleware
r.Group(func(r chi.Router) {
    r.Use(authMiddleware)  // Only for routes in this group
    
    r.Get("/api/users", listUsers)
    r.Post("/api/users", createUser)
})
```

---

## Request and Response {#request-response}

Let's deeply understand the `http.Request` and `http.ResponseWriter`.

### http.Request Deep Dive

```go
type Request struct {
    Method string       // GET, POST, PUT, DELETE, PATCH, etc.
    URL    *url.URL     // Parsed URL (scheme, host, path, query)
    
    // Headers
    Header Header       // map[string][]string
    
    // Body
    Body io.ReadCloser  // Request body (POST/PUT data)
    
    // Context
    Context context.Context  // Request-scoped context
    
    // Client info
    RemoteAddr string   // Client's IP:port
    Host       string   // Requested host
    
    // Metadata
    ContentLength int64
    TransferEncoding []string
    Close bool         // Close connection after response
    
    // ... many other fields
}
```

**URL Parsing**:

```go
// Request: GET /users/123?limit=10&offset=20
func handler(w http.ResponseWriter, r *http.Request) {
    // Full URL
    fmt.Println(r.URL.String())  // "/users/123?limit=10&offset=20"
    
    // Path only
    fmt.Println(r.URL.Path)  // "/users/123"
    
    // Query parameters
    query := r.URL.Query()
    limit := query.Get("limit")    // "10"
    offset := query.Get("offset")  // "20"
    
    // Multiple values for same key: ?tags=go&tags=web
    tags := query["tags"]  // []string{"go", "web"}
}
```

**Reading Request Body**:

```go
func createUserHandler(w http.ResponseWriter, r *http.Request) {
    // ALWAYS close the body
    defer r.Body.Close()
    
    // Read all bytes (not recommended for large bodies)
    body, err := ioutil.ReadAll(r.Body)
    if err != nil {
        http.Error(w, "Can't read body", http.StatusBadRequest)
        return
    }
    
    // Or decode JSON directly (recommended)
    var user User
    if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
        http.Error(w, "Invalid JSON", http.StatusBadRequest)
        return
    }
    
    // Process user...
}
```

**Reading Form Data**:

```go
func formHandler(w http.ResponseWriter, r *http.Request) {
    // Parse form (for URL-encoded or multipart forms)
    if err := r.ParseForm(); err != nil {
        http.Error(w, "Can't parse form", http.StatusBadRequest)
        return
    }
    
    // Access form values
    username := r.FormValue("username")
    email := r.FormValue("email")
    
    // Or access directly from Form map
    username := r.Form.Get("username")
    
    // Multiple values: ?hobbies=reading&hobbies=coding
    hobbies := r.Form["hobbies"]  // []string{"reading", "coding"}
}
```

**File Upload**:

```go
func uploadHandler(w http.ResponseWriter, r *http.Request) {
    // Parse multipart form (max 10MB in memory)
    if err := r.ParseMultipartForm(10 << 20); err != nil {
        http.Error(w, "Can't parse form", http.StatusBadRequest)
        return
    }
    
    // Get file
    file, handler, err := r.FormFile("file")
    if err != nil {
        http.Error(w, "Can't get file", http.StatusBadRequest)
        return
    }
    defer file.Close()
    
    // File info
    fmt.Printf("Uploaded file: %s\n", handler.Filename)
    fmt.Printf("File size: %d\n", handler.Size)
    
    // Save file
    dst, err := os.Create("/uploads/" + handler.Filename)
    if err != nil {
        http.Error(w, "Can't save file", http.StatusInternalServerError)
        return
    }
    defer dst.Close()
    
    io.Copy(dst, file)
    
    w.WriteHeader(http.StatusCreated)
}
```

### http.ResponseWriter Deep Dive

```go
type ResponseWriter interface {
    Header() Header              // Get headers to set
    Write([]byte) (int, error)   // Write response body
    WriteHeader(statusCode int)  // Write status code
}
```

**Setting Headers**:

```go
func handler(w http.ResponseWriter, r *http.Request) {
    // IMPORTANT: Headers must be set BEFORE WriteHeader or Write
    w.Header().Set("Content-Type", "application/json")
    w.Header().Set("X-Custom-Header", "value")
    
    // Add header (doesn't replace existing)
    w.Header().Add("Set-Cookie", "session=abc123")
    w.Header().Add("Set-Cookie", "user=john")
    
    // Remove header
    w.Header().Del("X-Custom-Header")
    
    // Write body (implicitly calls WriteHeader(200) if not called)
    w.Write([]byte(`{"status":"ok"}`))
}
```

**Status Codes**:

```go
func handler(w http.ResponseWriter, r *http.Request) {
    // Explicit status code
    w.WriteHeader(http.StatusCreated)  // 201
    
    // If you write without calling WriteHeader, defaults to 200
    w.Write([]byte("Created"))
    
    // Common status codes:
    // 200 OK
    // 201 Created
    // 204 No Content
    // 400 Bad Request
    // 401 Unauthorized
    // 403 Forbidden
    // 404 Not Found
    // 500 Internal Server Error
    // 503 Service Unavailable
}
```

**Error Responses**:

```go
func handler(w http.ResponseWriter, r *http.Request) {
    if someError {
        // Helper function: sets status and writes message
        http.Error(w, "Something went wrong", http.StatusInternalServerError)
        return
    }
    
    // Or manually:
    w.WriteHeader(http.StatusBadRequest)
    w.Write([]byte("Invalid request"))
}
```

**Redirects**:

```go
func handler(w http.ResponseWriter, r *http.Request) {
    // Permanent redirect (301)
    http.Redirect(w, r, "/new-url", http.StatusMovedPermanently)
    
    // Temporary redirect (302)
    http.Redirect(w, r, "/temporary", http.StatusFound)
    
    // See Other (303, POST -> GET redirect)
    http.Redirect(w, r, "/result", http.StatusSeeOther)
}
```

---

## Concurrency in Go Servers {#concurrency}

This is where Go truly shines. Let's understand how Go servers handle thousands of concurrent requests.

### One Goroutine Per Connection

When a client connects, Go spawns a goroutine:

```
┌─────────────────────────────────────────────────────────────────┐
│          Concurrent Connection Handling                         │
└─────────────────────────────────────────────────────────────────┘

                        Server (8 CPU cores)
                                │
                        ┌───────┴───────┐
                        │   Listener    │
                        │   Port 8080   │
                        └───────┬───────┘
                                │
                   ┌────────────┼────────────┬───────────┬─────────
                   │            │            │           │
            ┌──────▼────┐ ┌────▼─────┐ ┌───▼──────┐ ┌─▼────────┐
            │Connection │ │Connection│ │Connection│ │Connection│ ... (1000s more)
            │Goroutine 1│ │Goroutine2│ │Goroutine3│ │Goroutine4│
            │           │ │          │ │          │ │          │
            │Client A   │ │Client B  │ │Client C  │ │Client D  │
            └───────────┘ └──────────┘ └──────────┘ └──────────┘
                 │              │            │            │
                 ↓              ↓            ↓            ↓
            Reads request  Reads request  Reads request  Reads request
            Calls handler  Calls handler  Calls handler  Calls handler
            Writes response Writes response Writes response Writes response
            
Execution on CPU Cores:

Core 0          Core 1          Core 2          Core 3
  │               │               │               │
Goroutine 1   Goroutine 5   Goroutine 9   Goroutine 13
  (running)      (running)      (running)      (running)
  │               │               │               │
Goroutine 2   Goroutine 6   Goroutine 10  Goroutine 14
  (waiting I/O)  (running)      (waiting DB)   (running)
  │               │               │               │
Goroutine 3   Goroutine 7   Goroutine 11  Goroutine 15
  (running)      (waiting I/O)  (running)      (waiting I/O)
  ... and so on

Key Points:
- 1000s of connection goroutines
- Only 8 can execute simultaneously (8 cores)
- Goroutines waiting on I/O don't consume CPU
- Scheduler automatically balances load
```

### Handling Concurrent Requests - Timeline

```
┌─────────────────────────────────────────────────────────────────┐
│     100 Concurrent Requests Arriving Simultaneously             │
└─────────────────────────────────────────────────────────────────┘

Time   Server State                                CPU Utilization
│
0ms    100 TCP connections arrive                  
       100 goroutines spawned                      ▓▓▓▓▓▓▓▓ (100%)
       All start reading requests                  
       │                                           
5ms    All 100 requests parsed                     
       Routing to handlers...                      ▓▓▓▓▓▓▓▓ (100%)
       │                                           
10ms   Handlers start processing                   
       50 make DB queries (blocking)               ▓▓▓▓░░░░ (50%)
       50 doing CPU work                           
       │                                           
50ms   DB queries complete                          
       50 goroutines resume                        ▓▓▓▓▓▓▓▓ (100%)
       All 100 processing responses                
       │                                           
80ms   All responses written                       
       100 connections closing/kept alive          ▓▓▓▓░░░░ (50%)
       │                                           
100ms  All requests complete                       
       Waiting for new connections                 ░░░░░░░░ (0%)

Legend:
▓ = CPU active
░ = CPU idle or waiting

Total Throughput:
- 100 requests processed in 100ms
- 1000 requests/second
- With 8 cores, utilizing ~70% average
- No manual thread pool management
- No async/await complexity
- Just straightforward synchronous code
```

### Concurrent Access to Shared Data

When multiple goroutines access shared data, you need synchronization:

**Problem - Race Condition**:

```go
var counter int  // Shared across all handler goroutines

func handler(w http.ResponseWriter, r *http.Request) {
    counter++  // RACE CONDITION!
    fmt.Fprintf(w, "Request count: %d", counter)
}
```

With 1000 concurrent requests, `counter++` isn't atomic. Multiple goroutines read/write simultaneously, losing counts.

**Solution 1 - Atomic Operations**:

```go
var counter int64

func handler(w http.ResponseWriter, r *http.Request) {
    count := atomic.AddInt64(&counter, 1)
    fmt.Fprintf(w, "Request count: %d", count)
}
```

**Solution 2 - Mutex**:

```go
var (
    counter int
    mu      sync.Mutex
)

func handler(w http.ResponseWriter, r *http.Request) {
    mu.Lock()
    counter++
    count := counter
    mu.Unlock()
    
    fmt.Fprintf(w, "Request count: %d", count)
}
```

**Solution 3 - Channel (Serialization)**:

```go
var counterChan = make(chan int)

func counterService() {
    count := 0
    for {
        counterChan <- count
        count++
    }
}

func init() {
    go counterService()
}

func handler(w http.ResponseWriter, r *http.Request) {
    count := <-counterChan
    fmt.Fprintf(w, "Request count: %d", count)
}
```

## Real-World Server Patterns {#server-patterns}

Let's build complete, production-ready server patterns.

### Pattern 1: RESTful API Server

A complete REST API with proper structure:

```go
type Server struct {
    router   *chi.Mux
    db       *sql.DB
    config   Config
}

func NewServer(db *sql.DB, config Config) *Server {
    s := &Server{
        router: chi.NewRouter(),
        db:     db,
        config: config,
    }
    
    s.routes()
    return s
}

func (s *Server) routes() {
    // Global middleware
    s.router.Use(middleware.Logger)
    s.router.Use(middleware.Recoverer)
    s.router.Use(corsMiddleware)
    
    // Public routes
    s.router.Group(func(r chi.Router) {
        r.Post("/auth/login", s.handleLogin())
        r.Post("/auth/register", s.handleRegister())
    })
    
    // Protected routes (require authentication)
    s.router.Group(func(r chi.Router) {
        r.Use(s.authMiddleware)
        
        // Users
        r.Route("/users", func(r chi.Router) {
            r.Get("/", s.handleListUsers())
            r.Post("/", s.handleCreateUser())
            
            r.Route("/{userID}", func(r chi.Router) {
                r.Get("/", s.handleGetUser())
                r.Put("/", s.handleUpdateUser())
                r.Delete("/", s.handleDeleteUser())
            })
        })
        
        // Posts
        r.Route("/posts", func(r chi.Router) {
            r.Get("/", s.handleListPosts())
            r.Post("/", s.handleCreatePost())
            r.Get("/{postID}", s.handleGetPost())
        })
    })
}

// Handler example with proper error handling
func (s *Server) handleGetUser() http.HandlerFunc {
    type response struct {
        User *User `json:"user"`
    }
    
    return func(w http.ResponseWriter, r *http.Request) {
        userID := chi.URLParam(r, "userID")
        
        user, err := s.db.GetUser(r.Context(), userID)
        if err != nil {
            if errors.Is(err, sql.ErrNoRows) {
                http.Error(w, "User not found", http.StatusNotFound)
                return
            }
            log.Printf("Error getting user: %v", err)
            http.Error(w, "Internal server error", http.StatusInternalServerError)
            return
        }
        
        respondJSON(w, http.StatusOK, response{User: user})
    }
}

// Helper functions
func respondJSON(w http.ResponseWriter, status int, data interface{}) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(status)
    json.NewEncoder(w).Encode(data)
}

func (s *Server) Start() error {
    srv := &http.Server{
        Addr:         s.config.Addr,
        Handler:      s.router,
        ReadTimeout:  15 * time.Second,
        WriteTimeout: 15 * time.Second,
        IdleTimeout:  60 * time.Second,
    }
    
    return srv.ListenAndServe()
}
```

**Structure Visualization**:

```
┌─────────────────────────────────────────────────────────────────┐
│                    RESTful API Server Structure                 │
└─────────────────────────────────────────────────────────────────┘

                              Request
                                 │
                                 ↓
                    ┌─────────────────────┐
                    │  Global Middleware  │
                    │  - Logging          │
                    │  - Recovery         │
                    │  - CORS             │
                    └──────────┬──────────┘
                               │
                ┌──────────────┴──────────────┐
                │                             │
         ┌──────▼──────┐              ┌──────▼──────┐
         │   Public     │              │  Protected  │
         │   Routes     │              │   Routes    │
         │              │              │ (+ Auth MW) │
         └──────┬───────┘              └──────┬──────┘
                │                             │
         ┌──────▼───────┐           ┌────────┴────────┬──────────┐
         │ /auth/login  │           │ /users          │ /posts   │
         │ /auth/register│          │  GET /          │  GET /   │
         └──────────────┘           │  POST /         │  POST /  │
                                    │  GET /{id}      │  GET /{id}│
                                    │  PUT /{id}      └──────────┘
                                    │  DELETE /{id}
                                    └─────────────
                                          │
                                    ┌─────▼──────┐
                                    │  Handler   │
                                    │  Function  │
                                    │  - Extract │
                                    │  - Validate│
                                    │  - Process │
                                    │  - Respond │
                                    └────────────┘
```

### Pattern 2: Server with Graceful Shutdown

Handle shutdown signals gracefully, finishing in-flight requests:

```go
func main() {
    server := NewServer()
    
    // Server in goroutine
    go func() {
        log.Printf("Server starting on :8080")
        if err := server.Start(); err != nil && err != http.ErrServerClosed {
            log.Fatalf("Server error: %v", err)
        }
    }()
    
    // Wait for interrupt signal
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, os.Interrupt, syscall.SIGTERM)
    <-quit
    
    log.Println("Server shutting down...")
    
    // Create shutdown context with timeout
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    // Graceful shutdown
    if err := server.Shutdown(ctx); err != nil {
        log.Printf("Server forced to shutdown: %v", err)
    }
    
    log.Println("Server exited")
}

type Server struct {
    httpServer *http.Server
    // ... other fields
}

func (s *Server) Shutdown(ctx context.Context) error {
    return s.httpServer.Shutdown(ctx)
}
```

**Graceful Shutdown Timeline**:

```
┌─────────────────────────────────────────────────────────────────┐
│                  Graceful Shutdown Process                      │
└─────────────────────────────────────────────────────────────────┘

Time   Server State                          Active Requests
│
0s     Normal operation                      100 requests in-flight
       Receiving new connections             
       │                                     
       │ SIGTERM received                    
       ↓                                     
1s     Shutdown initiated                    100 requests (completing)
       Stop accepting new connections        No new requests accepted
       │                                     
5s     Finishing in-flight requests          50 requests (still working)
       │                                     
10s    More requests completing               20 requests (still working)
       │                                     
15s    Almost done                            5 requests (still working)
       │                                     
18s    All requests complete                  0 requests
       Server exits gracefully               
       │
       Or if timeout (30s) reached:
30s    Force shutdown                         (Any remaining killed)
       Server exits

Benefits:
- No requests dropped
- Clients get complete responses
- Database connections closed properly
- Resources cleaned up
```

### Pattern 3: Server with Health Checks

Provide health and readiness endpoints for orchestration (Kubernetes, load balancers):

```go
type Server struct {
    router  *chi.Mux
    db      *sql.DB
    healthy int32  // atomic flag
}

func (s *Server) routes() {
    // Health check endpoints (no auth required)
    s.router.Get("/health", s.handleHealth())
    s.router.Get("/ready", s.handleReady())
    
    // ... other routes
}

// Liveness probe - is server alive?
func (s *Server) handleHealth() http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("OK"))
    }
}

// Readiness probe - is server ready to serve traffic?
func (s *Server) handleReady() http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // Check if server is ready (DB connected, etc.)
        if atomic.LoadInt32(&s.healthy) == 1 {
            w.WriteHeader(http.StatusOK)
            w.Write([]byte("Ready"))
            return
        }
        
        w.WriteHeader(http.StatusServiceUnavailable)
        w.Write([]byte("Not ready"))
    }
}

// Background health checking
func (s *Server) monitorHealth() {
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        // Check dependencies
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        if err := s.db.PingContext(ctx); err != nil {
            log.Printf("DB unhealthy: %v", err)
            atomic.StoreInt32(&s.healthy, 0)
        } else {
            atomic.StoreInt32(&s.healthy, 1)
        }
        cancel()
    }
}
```

### Pattern 4: Server with Request Timeout

Prevent slow requests from tying up resources:

```go
func timeoutMiddleware(timeout time.Duration) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            ctx, cancel := context.WithTimeout(r.Context(), timeout)
            defer cancel()
            
            r = r.WithContext(ctx)
            
            // Channel to signal completion
            done := make(chan struct{})
            
            go func() {
                next.ServeHTTP(w, r)
                close(done)
            }()
            
            select {
            case <-done:
                // Request completed
            case <-ctx.Done():
                // Timeout
                http.Error(w, "Request timeout", http.StatusRequestTimeout)
            }
        })
    }
}

// Usage
r := chi.NewRouter()
r.Use(timeoutMiddleware(10 * time.Second))  // 10s timeout for all routes
```

### Pattern 5: Server with Rate Limiting

Protect server from abuse:

```go
import "golang.org/x/time/rate"

func rateLimitMiddleware(requestsPerSecond int) func(http.Handler) http.Handler {
    limiter := rate.NewLimiter(rate.Limit(requestsPerSecond), requestsPerSecond)
    
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            if !limiter.Allow() {
                http.Error(w, "Too many requests", http.StatusTooManyRequests)
                return
            }
            
            next.ServeHTTP(w, r)
        })
    }
}

// Per-IP rate limiting
type perIPLimiter struct {
    limiters map[string]*rate.Limiter
    mu       sync.Mutex
    rate     rate.Limit
    burst    int
}

func newPerIPLimiter(r rate.Limit, burst int) *perIPLimiter {
    return &perIPLimiter{
        limiters: make(map[string]*rate.Limiter),
        rate:     r,
        burst:    burst,
    }
}

func (l *perIPLimiter) getLimiter(ip string) *rate.Limiter {
    l.mu.Lock()
    defer l.mu.Unlock()
    
    limiter, exists := l.limiters[ip]
    if !exists {
        limiter = rate.NewLimiter(l.rate, l.burst)
        l.limiters[ip] = limiter
    }
    
    return limiter
}

func (l *perIPLimiter) middleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        ip := getIP(r)
        limiter := l.getLimiter(ip)
        
        if !limiter.Allow() {
            http.Error(w, "Too many requests", http.StatusTooManyRequests)
            return
        }
        
        next.ServeHTTP(w, r)
    })
}
```

---

## Performance and Optimization {#performance}

Let's understand how to make Go servers fast and efficient.

### Performance Characteristics

**Go's HTTP Server is Fast**:

- **~50,000 requests/second** on a single core for simple endpoints
- **~500,000 requests/second** on 8 cores with proper optimization
- **Sub-millisecond** latency for simple operations
- **Efficient memory usage**: ~4KB per connection (goroutine stack + connection buffer)

### Optimization 1: Connection Pooling (Database)

Database connections are expensive. Pool them:

```go
func setupDB() (*sql.DB, error) {
    db, err := sql.Open("postgres", connString)
    if err != nil {
        return nil, err
    }
    
    // Set connection pool parameters
    db.SetMaxOpenConns(25)                 // Max open connections
    db.SetMaxIdleConns(25)                 // Max idle connections
    db.SetConnMaxLifetime(5 * time.Minute) // Max connection lifetime
    
    return db, nil
}
```

**Why This Matters**:

Without pooling, each request opens and closes a DB connection - very expensive. With pooling, connections are reused across requests. 25 connections can serve thousands of requests/second.

### Optimization 2: Response Buffering

Writing small chunks to `ResponseWriter` is inefficient. Buffer responses:

```go
// Bad: Multiple small writes
func badHandler(w http.ResponseWriter, r *http.Request) {
    w.Write([]byte("<html>"))
    w.Write([]byte("<body>"))
    w.Write([]byte("Hello"))
    w.Write([]byte("</body>"))
    w.Write([]byte("</html>"))
}

// Good: Buffer then write once
func goodHandler(w http.ResponseWriter, r *http.Request) {
    var buf bytes.Buffer
    buf.WriteString("<html>")
    buf.WriteString("<body>")
    buf.WriteString("Hello")
    buf.WriteString("</body>")
    buf.WriteString("</html>")
    
    w.Write(buf.Bytes())
}

// Or use template execution (buffered internally)
func templateHandler(w http.ResponseWriter, r *http.Request) {
    tmpl.Execute(w, data)  // Efficient
}
```

### Optimization 3: JSON Encoding Optimization

Use efficient JSON encoding:

```go
// Standard (allocates)
func standardJSON(w http.ResponseWriter, data interface{}) {
    json.NewEncoder(w).Encode(data)
}

// Optimized with pool
var encoderPool = sync.Pool{
    New: func() interface{} {
        return json.NewEncoder(nil)
    },
}

func optimizedJSON(w http.ResponseWriter, data interface{}) {
    encoder := encoderPool.Get().(*json.Encoder)
    encoder.Reset(w)
    encoder.Encode(data)
    encoderPool.Put(encoder)
}

// Or use faster libraries like jsoniter or easyjson
```

### Optimization 4: Keep-Alive Connections

HTTP/1.1 keep-alive reuses TCP connections:

```go
server := &http.Server{
    Addr:         ":8080",
    Handler:      handler,
    ReadTimeout:  15 * time.Second,
    WriteTimeout: 15 * time.Second,
    IdleTimeout:  60 * time.Second,  // Keep connections alive for 60s
}
```

One TCP connection serves multiple requests, avoiding connection setup overhead.

### Optimization 5: Minimize Allocations

Allocations cause GC pressure. Reuse objects:

```go
var bufferPool = sync.Pool{
    New: func() interface{} {
        return new(bytes.Buffer)
    },
}

func handler(w http.ResponseWriter, r *http.Request) {
    buf := bufferPool.Get().(*bytes.Buffer)
    buf.Reset()
    defer bufferPool.Put(buf)
    
    // Use buf
    buf.WriteString("Hello, World!")
    w.Write(buf.Bytes())
}
```

### Performance Benchmarking

Use `wrk` or `ab` to benchmark:

```bash
# Apache Bench
ab -n 100000 -c 100 http://localhost:8080/

# wrk
wrk -t12 -c400 -d30s http://localhost:8080/
```

Profile with pprof:

```go
import _ "net/http/pprof"

func main() {
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    
    // Your server
}

// Visit http://localhost:6060/debug/pprof/
// CPU profile: http://localhost:6060/debug/pprof/profile?seconds=30
// Memory profile: http://localhost:6060/debug/pprof/heap
```

---

## Production Best Practices {#best-practices}

Essential guidelines for production Go servers.

### Practice 1: Always Set Timeouts

```go
server := &http.Server{
    Addr:         ":8080",
    Handler:      handler,
    ReadTimeout:  15 * time.Second,  // Time to read request
    WriteTimeout: 15 * time.Second,  // Time to write response
    IdleTimeout:  60 * time.Second,  // Keep-alive timeout
}
```

Without timeouts, slow clients can tie up connections indefinitely.

### Practice 2: Use Structured Logging

```go
import "go.uber.org/zap"

logger, _ := zap.NewProduction()
defer logger.Sync()

func handler(w http.ResponseWriter, r *http.Request) {
    logger.Info("Request received",
        zap.String("method", r.Method),
        zap.String("path", r.URL.Path),
        zap.String("remote", r.RemoteAddr),
    )
    
    // Handle request
}
```

Structured logs are machine-readable (JSON) and easy to query.

### Practice 3: Handle Panics

```go
func recoveryMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                log.Printf("Panic recovered: %v", err)
                debug.PrintStack()
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
            }
        }()
        
        next.ServeHTTP(w, r)
    })
}
```

One handler panicking shouldn't crash the entire server.

### Practice 4: Use Context for Cancellation

```go
func handler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    // Long-running operation
    result, err := doWork(ctx)
    if err != nil {
        if errors.Is(err, context.Canceled) {
            // Client disconnected
            return
        }
        http.Error(w, "Error", http.StatusInternalServerError)
        return
    }
    
    json.NewEncoder(w).Encode(result)
}

func doWork(ctx context.Context) (Result, error) {
    select {
    case <-ctx.Done():
        return Result{}, ctx.Err()
    case result := <-processData():
        return result, nil
    }
}
```

If the client disconnects, stop processing their request immediately.

### Practice 5: Validate Input

```go
func createUserHandler(w http.ResponseWriter, r *http.Request) {
    var req struct {
        Email    string `json:"email"`
        Password string `json:"password"`
        Name     string `json:"name"`
    }
    
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, "Invalid JSON", http.StatusBadRequest)
        return
    }
    
    // Validate
    if req.Email == "" || !isValidEmail(req.Email) {
        http.Error(w, "Invalid email", http.StatusBadRequest)
        return
    }
    
    if len(req.Password) < 8 {
        http.Error(w, "Password too short", http.StatusBadRequest)
        return
    }
    
    // Process valid request
}
```

Never trust client input. Always validate.

### Practice 6: Use HTTPS in Production

```go
// Development
http.ListenAndServe(":8080", handler)

// Production
http.ListenAndServeTLS(":443", "cert.pem", "key.pem", handler)
```

Or use reverse proxy (nginx, Caddy) to handle TLS.

---

## Summary: Building Production-Ready Go Servers

Go's HTTP server capabilities are powerful yet simple:

**Built-in Concurrency**: One goroutine per connection. Thousands of concurrent requests with no configuration.

**Standard Library**: `net/http` provides everything needed for production servers.

**Middleware Pattern**: Compose functionality (logging, auth, CORS) cleanly.

**Performance**: Fast by default. Optimizations available when needed.

**Production Features**: Timeouts, graceful shutdown, health checks, all straightforward to implement.

**The Go Way**: Write simple, synchronous code. Let the runtime handle concurrency.

A Go HTTP server combines simplicity for developers with high performance and scalability for production. This is why Go is the language of choice for web services, APIs, and microservices in modern cloud-native architectures.