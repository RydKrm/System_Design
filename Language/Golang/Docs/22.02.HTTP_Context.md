# The Complete Guide to Context in Go

## Table of Contents

1. [Introduction to Context](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#introduction)
2. [The Problem Context Solves](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#problem)
3. [Context Internal Architecture](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#internal-architecture)
4. [Context Types and Creation](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#context-types)
5. [Context with HTTP Client](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#http-client)
6. [Context with HTTP Server](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#http-server)
7. [Context Propagation](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#propagation)
8. [Best Practices and Patterns](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#best-practices)
9. [Common Pitfalls](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#pitfalls)
10. [Real-World Examples](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#real-world)

---

## Introduction to Context {#introduction}

Context is one of Go's most powerful and misunderstood features. At its core, context provides a way to carry deadlines, cancellation signals, and request-scoped values across API boundaries and between processes. It's essential for building robust, well-behaved distributed systems.

### Why Context Matters

Imagine you're building an e-commerce API. A user clicks "Place Order" on their phone app. This triggers a chain of operations:

1. HTTP request to your API server
2. Validate user session (calls auth service)
3. Check inventory (calls inventory service)
4. Process payment (calls payment gateway)
5. Create order record (database write)
6. Send confirmation email (calls email service)

Now, what happens if the user's network drops after 2 seconds? Without context:

- Your server keeps running all operations
- Makes unnecessary external API calls
- Wastes database connections
- Sends emails for failed orders
- Consumes CPU and memory for nothing

With context:

- The cancellation signal propagates immediately
- All operations stop gracefully
- Resources are freed
- The system stays healthy

This is what context enables: **coordinated cancellation** and **deadline propagation** across your entire request chain.

### The Context Interface

At its heart, context is an interface:

```go
type Context interface {
    // Deadline returns the time when work done on behalf of this context
    // should be canceled. Returns ok==false when no deadline is set.
    Deadline() (deadline time.Time, ok bool)
    
    // Done returns a channel that's closed when work done on behalf of this
    // context should be canceled. Done may return nil if this context can
    // never be canceled.
    Done() <-chan struct{}
    
    // Err returns nil if Done is not yet closed.
    // If Done is closed, Err returns a non-nil error explaining why:
    // Canceled if the context was canceled
    // DeadlineExceeded if the context's deadline passed.
    Err() error
    
    // Value returns the value associated with this context for key, or nil
    // if no value is associated with key.
    Value(key interface{}) interface{}
}
```

Let's break down each method:

**Deadline()**: Returns when this context will automatically be canceled. Think of it as an alarm clock for your operation. If you're making an API call that should complete in 5 seconds, the deadline is "now + 5 seconds".

**Done()**: Returns a channel that gets closed when the context is canceled. This is how you detect cancellation. When the channel closes, you stop your work immediately.

**Err()**: Tells you WHY the context was canceled. Was it explicitly canceled? Or did it hit its deadline? This helps with debugging and logging.

**Value()**: Allows passing request-scoped data through the context. This is controversial and should be used sparingly (we'll discuss when and when not to use it).

---

## The Problem Context Solves {#problem}

Before context existed, Go programs had no standard way to handle these critical scenarios:

### Problem 1: Cascading Timeouts

```
Without Context:

HTTP Request (timeout: 30s)
    ↓
Database Query (timeout: 60s)  ← Problem: Longer than parent!
    ↓
External API (timeout: 45s)    ← Problem: Still running after HTTP timeout!
    ↓
Email Send (timeout: 30s)      ← Problem: Parent already failed!

Result: Resources leaked, operations continue after client disconnected
```

With context, you can create a hierarchy:

```
With Context:

HTTP Request (timeout: 30s) ─────┐
    ↓                            │
Database Query (inherits 30s) ←──┤ All inherit parent timeout
    ↓                            │
External API (inherits 30s)   ←──┤
    ↓                            │
Email Send (inherits 30s)     ←──┘

Result: All operations stop at 30s maximum
```

### Problem 2: Manual Cancellation Propagation

Without context, you'd need manual channels everywhere:

```go
// Without context - messy and error-prone
func processRequest(cancel <-chan struct{}) error {
    dbDone := make(chan error)
    go func() {
        dbDone <- queryDatabase(cancel)
    }()
    
    apiDone := make(chan error)
    go func() {
        apiDone <- callAPI(cancel)
    }()
    
    for i := 0; i < 2; i++ {
        select {
        case <-cancel:
            return errors.New("canceled")
        case err := <-dbDone:
            if err != nil {
                return err
            }
        case err := <-apiDone:
            if err != nil {
                return err
            }
        }
    }
    return nil
}
```

With context, it's clean:

```go
// With context - clean and standard
func processRequest(ctx context.Context) error {
    if err := queryDatabase(ctx); err != nil {
        return err
    }
    if err := callAPI(ctx); err != nil {
        return err
    }
    return nil
}
```

### Problem 3: Request-Scoped Values

Before context, passing request IDs, user info, and other request-scoped data required:

- Adding parameters to every function (verbose)
- Using global variables (not thread-safe)
- Creating custom structs (lots of boilerplate)

Context provides a standard way to carry this data.

---

## Context Internal Architecture {#internal-architecture}

Now let's dive deep into how context actually works under the hood. Understanding the implementation helps you use it effectively.

### The Context Tree Structure

Contexts form a tree structure, where each child inherits from its parent:

```
Context Tree:

context.Background() (root)
    │
    ├─ WithTimeout (30s)
    │   │
    │   ├─ WithCancel
    │   │   │
    │   │   └─ WithValue("userID", 123)
    │   │       │
    │   │       └─ WithTimeout (5s) ← Inherits parent's 30s limit
    │   │
    │   └─ WithValue("requestID", "abc-123")
    │
    └─ WithCancel
        │
        └─ WithTimeout (10s)

Key Properties:
- Child never outlives parent
- Canceling parent cancels all children
- Children can have shorter timeouts than parent
- Values are immutable and inherited
```

### emptyCtx: The Root

The root contexts (`Background()` and `TODO()`) are implemented as:

```go
type emptyCtx int

func (*emptyCtx) Deadline() (deadline time.Time, ok bool) {
    return // No deadline
}

func (*emptyCtx) Done() <-chan struct{} {
    return nil // Never canceled
}

func (*emptyCtx) Err() error {
    return nil
}

func (*emptyCtx) Value(key interface{}) interface{} {
    return nil
}
```

This is an empty implementation. It's never canceled and holds no values. It's the foundation of the tree.

### cancelCtx: Cancellation Implementation

The `cancelCtx` is the core of cancellation:

```go
type cancelCtx struct {
    Context // Embedded parent context
    
    mu       sync.Mutex
    done     atomic.Value // chan struct{}, created lazily
    children map[canceler]struct{} // set to nil by first cancel call
    err      error
}
```

Let's understand each field:

**Context (embedded)**: The parent context. This creates the tree relationship.

**mu**: Mutex to protect internal state during concurrent access.

**done**: An atomic value containing a channel. Why atomic? The channel is created lazily on first access to save memory.

**children**: A map of all child contexts. When this context is canceled, all children are canceled too.

**err**: The error explaining why cancellation happened.

### How Cancellation Works

Let's trace what happens when you cancel a context:

```go
ctx, cancel := context.WithCancel(parent)

// Later...
cancel()
```

Internal execution:

```
Step-by-Step Cancellation:

1. cancel() called
   ┌────────────────────────────────────┐
   │ func (c *cancelCtx) cancel(        │
   │     removeFromParent bool,         │
   │     err error                      │
   │ )                                  │
   └────────────────────────────────────┘

2. Acquire lock
   ┌────────────────────────────────────┐
   │ c.mu.Lock()                        │
   │ defer c.mu.Unlock()                │
   └────────────────────────────────────┘

3. Check if already canceled
   ┌────────────────────────────────────┐
   │ if c.err != nil {                  │
   │     return // Already canceled     │
   │ }                                  │
   └────────────────────────────────────┘

4. Set error
   ┌────────────────────────────────────┐
   │ c.err = err                        │
   └────────────────────────────────────┘

5. Close done channel
   ┌────────────────────────────────────┐
   │ if d := c.done.Load(); d != nil { │
   │     close(d.(chan struct{}))       │
   │ }                                  │
   └────────────────────────────────────┘
   This wakes up all goroutines waiting on Done()!

6. Cancel all children
   ┌────────────────────────────────────┐
   │ for child := range c.children {   │
   │     child.cancel(false, err)       │
   │ }                                  │
   │ c.children = nil                   │
   └────────────────────────────────────┘
   Recursive cancellation down the tree!

7. Remove from parent
   ┌────────────────────────────────────┐
   │ if removeFromParent {              │
   │     removeChild(c.Context, c)      │
   │ }                                  │
   └────────────────────────────────────┘
```

### timerCtx: Deadline Implementation

The `timerCtx` adds timeout functionality:

```go
type timerCtx struct {
    cancelCtx // Embedded for cancellation
    timer *time.Timer
    deadline time.Time
}
```

**How it works**:

```
WithTimeout/WithDeadline creates timerCtx:

1. Calculate deadline:
   ┌────────────────────────────────────┐
   │ deadline := time.Now().Add(timeout)│
   └────────────────────────────────────┘

2. Check parent deadline:
   ┌────────────────────────────────────┐
   │ if parent.Deadline() < deadline {  │
   │     // Parent will cancel first    │
   │     // Just use parent's deadline  │
   │     return WithCancel(parent)      │
   │ }                                  │
   └────────────────────────────────────┘
   Optimization: Don't create timer if parent expires first!

3. Create timer:
   ┌────────────────────────────────────┐
   │ timer := time.AfterFunc(timeout,   │
   │     func() {                        │
   │         c.cancel(true,              │
   │             context.DeadlineExceeded)│
   │     })                              │
   └────────────────────────────────────┘

4. Timer fires at deadline:
   ┌────────────────────────────────────┐
   │ Timer expires                      │
   │     ↓                              │
   │ Callback executes                  │
   │     ↓                              │
   │ c.cancel() called automatically    │
   │     ↓                              │
   │ Done channel closed                │
   └────────────────────────────────────┘
```

**Memory optimization**: If you cancel before the deadline, the timer is stopped and can be garbage collected:

```go
ctx, cancel := context.WithTimeout(parent, 10*time.Second)
defer cancel() // Stops timer if request finishes early

// Do work...
// If work finishes in 2 seconds, timer is stopped
// Saves 8 seconds of timer overhead
```

### valueCtx: Value Storage

The `valueCtx` stores request-scoped data:

```go
type valueCtx struct {
    Context // Parent
    key, val interface{}
}
```

It's a simple linked list:

```
Value Lookup Process:

ctx = WithValue(WithValue(WithValue(Background(), "a", 1), "b", 2), "c", 3)

Structure:
┌──────────────────┐
│ valueCtx         │
│ key: "c"         │
│ val: 3           │
│ parent: ────────┐│
└─────────────────┼┘
                  │
                  ↓
┌──────────────────┐
│ valueCtx         │
│ key: "b"         │
│ val: 2           │
│ parent: ────────┐│
└─────────────────┼┘
                  │
                  ↓
┌──────────────────┐
│ valueCtx         │
│ key: "a"         │
│ val: 1           │
│ parent: ────────┐│
└─────────────────┼┘
                  │
                  ↓
          Background()

Lookup ctx.Value("b"):
1. Check current node: "c" != "b", continue
2. Check parent: "b" == "b", found! Return 2

Time Complexity: O(n) where n = number of values
This is why you shouldn't store many values!
```

### Memory Layout in RAM

Let's see how contexts are laid out in memory:

```
Memory Layout of Context Tree:

Parent Context (cancelCtx):
┌────────────────────────────────────┐  Address: 0x1000
│ vtable pointer                     │
│ parent context pointer: 0x0000     │  (nil = Background)
│ mu: sync.Mutex                     │
│ done: atomic.Value (0x2000)        │  Points to channel
│ children: map pointer (0x3000)     │  Points to children map
│ err: nil                           │
└────────────────────────────────────┘

Done Channel:
┌────────────────────────────────────┐  Address: 0x2000
│ chan struct{}                      │
│ buffer: nil                        │
│ sendq: (waiting senders)           │
│ recvq: (waiting receivers)         │
└────────────────────────────────────┘

Children Map:
┌────────────────────────────────────┐  Address: 0x3000
│ map[canceler]struct{}              │
│ 0x4000 -> {}                       │  Child 1
│ 0x5000 -> {}                       │  Child 2
└────────────────────────────────────┘

Child Context 1 (timerCtx):
┌────────────────────────────────────┐  Address: 0x4000
│ vtable pointer                     │
│ cancelCtx (embedded)               │
│   parent: 0x1000                   │  Points to parent
│   mu: sync.Mutex                   │
│   done: atomic.Value (0x6000)      │
│   children: nil                    │
│   err: nil                         │
│ timer: *time.Timer (0x7000)        │
│ deadline: 2024-01-15 10:30:00      │
└────────────────────────────────────┘

Total memory:
- cancelCtx: ~100 bytes
- Channel: ~100 bytes (lazily created)
- Map overhead: ~50 bytes + entries
- timerCtx: ~150 bytes
- Timer: ~100 bytes

For a typical request with 3-4 nested contexts: ~500-600 bytes
```

---

## Context Types and Creation {#context-types}

Go provides several functions to create contexts. Let's understand each one deeply.

### context.Background()

```go
ctx := context.Background()
```

**What it is**: The root of all context trees. It's never canceled and carries no values.

**When to use**:

- Main function entry point
- Top-level HTTP handlers
- Top-level background operations
- Tests

**Example**:

```go
func main() {
    // Background is the root context
    ctx := context.Background()
    
    // Create server with background context
    server := NewServer(ctx)
    server.Start()
}
```

**Implementation**:

```go
var (
    background = new(emptyCtx)
)

func Background() Context {
    return background
}
```

It's a singleton - there's only one instance in the entire program!

### context.TODO()

```go
ctx := context.TODO()
```

**What it is**: Identical to `Background()` but semantically different.

**When to use**:

- When you're not sure which context to use
- As a placeholder during refactoring
- When you plan to add proper context later

**Example**:

```go
func legacyFunction() {
    // TODO: Receive context from caller
    ctx := context.TODO()
    
    doSomething(ctx)
}
```

### context.WithCancel()

```go
ctx, cancel := context.WithCancel(parent)
defer cancel() // Always defer cancel to prevent leaks
```

**What it is**: Creates a cancelable context. You get a cancel function that you can call anytime.

**When to use**:

- Manual cancellation control
- Worker pools
- Background goroutines you might need to stop

**Complete Example**:

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func worker(ctx context.Context, id int, results chan<- int) {
    for i := 0; ; i++ {
        select {
        case <-ctx.Done():
            // Context canceled, stop working
            fmt.Printf("Worker %d: stopping (completed %d tasks)\n", id, i)
            return
        case results <- i * id:
            // Do work
            time.Sleep(100 * time.Millisecond)
        }
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    results := make(chan int)
    
    // Start 3 workers
    for i := 1; i <= 3; i++ {
        go worker(ctx, i, results)
    }
    
    // Collect results for 1 second
    time.Sleep(1 * time.Second)
    
    // Cancel all workers
    cancel()
    
    // Wait a bit for graceful shutdown
    time.Sleep(200 * time.Millisecond)
    
    fmt.Println("All workers stopped")
}
```

**What happens internally**:

```
Worker Cancellation Flow:

T=0ms: Workers start
┌────────────────────────────────────┐
│ Worker 1: Running                  │
│ Worker 2: Running                  │
│ Worker 3: Running                  │
└────────────────────────────────────┘

T=1000ms: cancel() called
┌────────────────────────────────────┐
│ Main: cancel() called              │
│   ↓                                │
│ cancelCtx.cancel() executes        │
│   ↓                                │
│ close(done channel)                │
└────────────────────────────────────┘

T=1001ms: Workers detect cancellation
┌────────────────────────────────────┐
│ Worker 1: <-ctx.Done() receives   │
│   ↓                                │
│ Worker 1: return (exit)            │
│                                    │
│ Worker 2: <-ctx.Done() receives   │
│   ↓                                │
│ Worker 2: return (exit)            │
│                                    │
│ Worker 3: <-ctx.Done() receives   │
│   ↓                                │
│ Worker 3: return (exit)            │
└────────────────────────────────────┘

All goroutines cleaned up!
```

### context.WithTimeout()

```go
ctx, cancel := context.WithTimeout(parent, 5*time.Second)
defer cancel()
```

**What it is**: Creates a context that automatically cancels after a duration.

**When to use**:

- API calls with time limits
- Database queries
- Any operation that shouldn't run forever

**Complete Example**:

```go
func fetchUserData(userID string) (*User, error) {
    // Create 5-second timeout
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    // Create HTTP request with context
    req, err := http.NewRequestWithContext(ctx, "GET", 
        fmt.Sprintf("https://api.example.com/users/%s", userID), nil)
    if err != nil {
        return nil, err
    }
    
    // Make request - will be canceled after 5 seconds
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        if ctx.Err() == context.DeadlineExceeded {
            return nil, fmt.Errorf("request timeout: %w", err)
        }
        return nil, err
    }
    defer resp.Body.Close()
    
    var user User
    if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
        return nil, err
    }
    
    return &user, nil
}
```

**Timeout Hierarchy**:

```
Parent timeout > Child timeout:

Parent (30s timeout)
    │
    ├─ Child A (10s timeout)  ← Will timeout at 10s
    │
    └─ Child B (45s timeout)  ← Will timeout at 30s (parent's limit)

Parent enforces maximum!
```

### context.WithDeadline()

```go
deadline := time.Now().Add(10 * time.Second)
ctx, cancel := context.WithDeadline(parent, deadline)
defer cancel()
```

**What it is**: Like `WithTimeout` but you specify an absolute time instead of a duration.

**When to use**:

- When you have an absolute deadline (e.g., "operation must complete by 3:00 PM")
- SLA enforcement
- Batch job scheduling

**Example**:

```go
func processBatchByDeadline(deadline time.Time) error {
    ctx, cancel := context.WithDeadline(context.Background(), deadline)
    defer cancel()
    
    for {
        select {
        case <-ctx.Done():
            if ctx.Err() == context.DeadlineExceeded {
                return fmt.Errorf("batch processing deadline exceeded")
            }
            return ctx.Err()
        default:
            // Process next item
            if err := processItem(ctx); err != nil {
                return err
            }
        }
    }
}

// Usage
deadline := time.Date(2024, 1, 15, 15, 0, 0, 0, time.UTC) // 3:00 PM UTC
if err := processBatchByDeadline(deadline); err != nil {
    log.Printf("Batch failed: %v", err)
}
```

### context.WithValue()

```go
ctx := context.WithValue(parent, key, value)
```

**What it is**: Stores a key-value pair in the context.

**When to use** (sparingly!):

- Request IDs for tracing
- User authentication info
- Request-scoped data that crosses API boundaries

**When NOT to use**:

- Function parameters (pass explicitly instead)
- Optional parameters
- Large data structures
- Frequently accessed data

**Example** (good use):

```go
type contextKey string

const (
    requestIDKey contextKey = "requestID"
    userIDKey    contextKey = "userID"
)

// Middleware adds request ID
func RequestIDMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        requestID := generateRequestID()
        ctx := context.WithValue(r.Context(), requestIDKey, requestID)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// Deep in your code, extract for logging
func processOrder(ctx context.Context, order *Order) error {
    requestID := ctx.Value(requestIDKey).(string)
    log.Printf("[%s] Processing order %s", requestID, order.ID)
    
    // ... process order
}
```

**Type-safe context values**:

```go
// Define custom type for key (prevents collisions)
type contextKey int

const (
    userIDKey contextKey = iota
    requestIDKey
)

// Helper functions for type safety
func WithUserID(ctx context.Context, userID string) context.Context {
    return context.WithValue(ctx, userIDKey, userID)
}

func GetUserID(ctx context.Context) (string, bool) {
    userID, ok := ctx.Value(userIDKey).(string)
    return userID, ok
}

// Usage
ctx = WithUserID(ctx, "user-123")
if userID, ok := GetUserID(ctx); ok {
    fmt.Println("User:", userID)
}
```

## Context with HTTP Client {#http-client}

Context is deeply integrated with Go's HTTP client. Let's understand how they work together.

### Request Creation with Context

```go
// Old way (deprecated)
req, _ := http.NewRequest("GET", url, nil)

// New way (always use this)
ctx := context.Background()
req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
```

**What happens internally when you add context**:

```
HTTP Request with Context:

1. Request Creation:
   ┌────────────────────────────────────┐
   │ req := &Request{                   │
   │   ctx: ctx,                        │
   │   // ... other fields              │
   │ }                                  │
   └────────────────────────────────────┘

2. Transport's RoundTrip:
   ┌────────────────────────────────────┐
   │ Start monitoring ctx.Done()        │
   │ Goroutine A: Make request          │
   │ Goroutine B: Watch context         │
   └────────────────────────────────────┘

3. If context canceled:
   ┌────────────────────────────────────┐
   │ Close network connection           │
   │ Return error                       │
   └────────────────────────────────────┘
```

### Complete HTTP Client Example with Timeout

```go
package main

import (
    "context"
    "fmt"
    "io"
    "net/http"
    "time"
)

func fetchWithTimeout(url string, timeout time.Duration) ([]byte, error) {
    // Create context with timeout
    ctx, cancel := context.WithTimeout(context.Background(), timeout)
    defer cancel()
    
    // Create request with context
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, fmt.Errorf("create request: %w", err)
    }
    
    // Make request
    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        // Check if timeout
        if ctx.Err() == context.DeadlineExceeded {
            return nil, fmt.Errorf("request timeout after %v: %w", timeout, err)
        }
        return nil, fmt.Errorf("request failed: %w", err)
    }
    defer resp.Body.Close()
    
    // Check status code
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("unexpected status: %d", resp.StatusCode)
    }
    
    // Read response body (also respects context)
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("read body: %w", err)
    }
    
    return body, nil
}

func main() {
    // Fast endpoint - completes in time
    data, err := fetchWithTimeout("https://httpbin.org/delay/1", 3*time.Second)
    if err != nil {
        fmt.Printf("Error: %v\n", err)
    } else {
        fmt.Printf("Success: received %d bytes\n", len(data))
    }
    
    // Slow endpoint - will timeout
    data, err = fetchWithTimeout("https://httpbin.org/delay/10", 2*time.Second)
    if err != nil {
        fmt.Printf("Error: %v\n", err) // Will print timeout error
    }
}
```

### What Happens When Context Times Out

Let's trace the complete flow:

```
HTTP Request Timeout Flow:

T=0ms: Request starts
┌────────────────────────────────────┐
│ ctx, cancel := WithTimeout(2s)     │
│ req := NewRequestWithContext(ctx)  │
│ client.Do(req) called              │
└────────────────────────────────────┘
         ↓
┌────────────────────────────────────┐
│ Transport starts request           │
│ - DNS lookup                       │
│ - TCP connect                      │
│ - TLS handshake                    │
│ - Send HTTP request                │
└────────────────────────────────────┘

T=2000ms: Context timeout!
┌────────────────────────────────────┐
│ Timer fires in timerCtx            │
│   ↓                                │
│ cancelCtx.cancel() called          │
│   ↓                                │
│ ctx.Done() channel closed          │
└────────────────────────────────────┘
         ↓
┌────────────────────────────────────┐
│ Transport detects cancellation     │
│ select {                           │
│   case <-ctx.Done():               │
│     conn.Close()  ← Connection killed│
│     return ctx.Err()               │
│ }                                  │
└────────────────────────────────────┘
         ↓
┌────────────────────────────────────┐
│ client.Do(req) returns             │
│ err: context deadline exceeded     │
└────────────────────────────────────┘
         ↓
┌────────────────────────────────────┐
│ Deferred cancel() executes         │
│ (Stops timer, cleanup)             │
└────────────────────────────────────┘
```

### Parallel Requests with Context

Using context to manage multiple concurrent requests:

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "sync"
    "time"
)

type Result struct {
    URL  string
    Body []byte
    Err  error
}

func fetchAll(urls []string, timeout time.Duration) []Result {
    // Create parent context with timeout
    ctx, cancel := context.WithTimeout(context.Background(), timeout)
    defer cancel()
    
    results := make([]Result, len(urls))
    var wg sync.WaitGroup
    
    for i, url := range urls {
        wg.Add(1)
        go func(i int, url string) {
            defer wg.Done()
            
            // Each request shares the parent context
            req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
            if err != nil {
                results[i] = Result{URL: url, Err: err}
                return
            }
            
            resp, err := http.DefaultClient.Do(req)
            if err != nil {
                results[i] = Result{URL: url, Err: err}
                return
            }
            defer resp.Body.Close()
            
            body, err := io.ReadAll(resp.Body)
            results[i] = Result{URL: url, Body: body, Err: err}
        }(i, url)
    }
    
    wg.Wait()
    return results
}

func main() {
    urls := []string{
        "https://httpbin.org/delay/1",
        "https://httpbin.org/delay/2",
        "https://httpbin.org/delay/3",
    }
    
    results := fetchAll(urls, 5*time.Second)
    
    for _, result := range results {
        if result.Err != nil {
            fmt.Printf("%s: ERROR - %v\n", result.URL, result.Err)
        } else {
            fmt.Printf("%s: SUCCESS - %d bytes\n", result.URL, len(result.Body))
        }
    }
}
```

**Key Points**:

- All goroutines share the parent context
- When parent times out, ALL requests are canceled
- WaitGroup ensures we wait for all goroutines
- Each goroutine handles its own result

### Cancel on First Success

Common pattern: make multiple requests, use the first successful response:

```go
func fetchFirstSuccess(ctx context.Context, urls []string) ([]byte, error) {
    // Create cancelable context
    ctx, cancel := context.WithCancel(ctx)
    defer cancel()
    
    type result struct {
        data []byte
        err  error
    }
    
    resultChan := make(chan result, len(urls))
    
    // Launch all requests
    for _, url := range urls {
        go func(url string) {
            req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
            if err != nil {
                resultChan <- result{err: err}
                return
            }
            
            resp, err := http.DefaultClient.Do(req)
            if err != nil {
                resultChan <- result{err: err}
                return
            }
            defer resp.Body.Close()
            
            if resp.StatusCode != http.StatusOK {
                resultChan <- result{err: fmt.Errorf("status %d", resp.StatusCode)}
                return
            }
            
            body, err := io.ReadAll(resp.Body)
            resultChan <- result{data: body, err: err}
        }(url)
    }
    
    // Wait for first success
    var lastErr error
    for i := 0; i < len(urls); i++ {
        r := <-resultChan
        if r.err == nil {
            // Success! Cancel others and return
            cancel()
            return r.data, nil
        }
        lastErr = r.err
    }
    
    return nil, fmt.Errorf("all requests failed: %w", lastErr)
}
```

---

## Context with HTTP Server {#http-server}

Every HTTP request in a Go server has a context attached. Let's see how to use it effectively.

### Request Context Access

```go
func handler(w http.ResponseWriter, r *http.Request) {
    // Get the request's context
    ctx := r.Context()
    
    // Use it for downstream operations
    data, err := fetchData(ctx, "user-123")
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    json.NewEncoder(w).Encode(data)
}
```

**What's in the request context**:

```
HTTP Request Context Contents:

┌────────────────────────────────────┐
│ Request Context                    │
├────────────────────────────────────┤
│ 1. Cancellation on connection close│
│    - Client disconnects            │
│    - Network error                 │
│                                    │
│ 2. Server timeouts                 │
│    - ReadTimeout                   │
│    - WriteTimeout                  │
│    - IdleTimeout                   │
│                                    │
│ 3. Middleware values               │
│    - Request ID                    │
│    - User session                  │
│    - Trace context                 │
└────────────────────────────────────┘
```

### Automatic Cancellation on Client Disconnect

The server automatically cancels the context when the client disconnects:

```go
func slowHandler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    // Simulate long operation
    for i := 0; i < 10; i++ {
        select {
        case <-ctx.Done():
            // Client disconnected!
            log.Println("Client disconnected, stopping work")
            return
        case <-time.After(1 * time.Second):
            log.Printf("Working... %d/10\n", i+1)
        }
    }
    
    fmt.Fprintf(w, "Completed!")
}
```

**Scenario**:

```
Client Disconnect Detection:

T=0s: Client makes request
┌────────────────────────────────────┐
│ curl http://localhost:8080/slow    │
└────────────────────────────────────┘
         ↓
┌────────────────────────────────────┐
│ Server: Handler starts             │
│ Working... 1/10                    │
│ Working... 2/10                    │
└────────────────────────────────────┘

T=3s: Client presses Ctrl+C
┌────────────────────────────────────┐
│ TCP connection closed              │
│   ↓                                │
│ Server detects connection close    │
│   ↓                                │
│ Request context canceled           │
│   ↓                                │
│ ctx.Done() fires                   │
└────────────────────────────────────┘
         ↓
┌────────────────────────────────────┐
│ Handler: "Client disconnected"     │
│ Handler: return (stops work)       │
│ Resources freed                    │
└────────────────────────────────────┘

Without context: Handler would continue for 7 more seconds!
With context: Stops immediately, saves resources
```

### Adding Values to Request Context

Middleware pattern for adding context values:

```go
package main

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "time"
)

type contextKey int

const (
    requestIDKey contextKey = iota
    startTimeKey
)

// Middleware: Add request ID
func RequestIDMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        requestID := fmt.Sprintf("req_%d", time.Now().UnixNano())
        ctx := context.WithValue(r.Context(), requestIDKey, requestID)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// Middleware: Add start time for duration tracking
func TimingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        ctx := context.WithValue(r.Context(), startTimeKey, time.Now())
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// Middleware: Logging
func LoggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        requestID := r.Context().Value(requestIDKey).(string)
        log.Printf("[%s] %s %s", requestID, r.Method, r.URL.Path)
        
        next.ServeHTTP(w, r)
        
        startTime := r.Context().Value(startTimeKey).(time.Time)
        duration := time.Since(startTime)
        log.Printf("[%s] Completed in %v", requestID, duration)
    })
}

// Handler
func userHandler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    requestID := ctx.Value(requestIDKey).(string)
    
    // Simulate database query with context
    user, err := queryUser(ctx, "user-123")
    if err != nil {
        log.Printf("[%s] Error: %v", requestID, err)
        http.Error(w, "Internal error", http.StatusInternalServerError)
        return
    }
    
    fmt.Fprintf(w, "User: %s\n", user.Name)
}

func queryUser(ctx context.Context, userID string) (*User, error) {
    // Use context for cancellation
    select {
    case <-ctx.Done():
        return nil, ctx.Err()
    case <-time.After(100 * time.Millisecond):
        // Simulate query
        return &User{ID: userID, Name: "John Doe"}, nil
    }
}

type User struct {
    ID   string
    Name string
}

func main() {
    mux := http.NewServeMux()
    mux.HandleFunc("/user", userHandler)
    
    // Chain middleware
    handler := RequestIDMiddleware(
        TimingMiddleware(
            LoggingMiddleware(mux)))
    
    log.Println("Server starting on :8080")
    http.ListenAndServe(":8080", handler)
}
```

### Server Timeouts with Context

Configure server timeouts to prevent resource exhaustion:

```go
server := &http.Server{
    Addr:         ":8080",
    Handler:      handler,
    
    // ReadTimeout: Max time to read request (headers + body)
    ReadTimeout:  5 * time.Second,
    
    // WriteTimeout: Max time to write response
    WriteTimeout: 10 * time.Second,
    
    // IdleTimeout: Max time to wait for next request (keep-alive)
    IdleTimeout:  60 * time.Second,
    
    // ReadHeaderTimeout: Max time to read request headers
    ReadHeaderTimeout: 2 * time.Second,
}
```

**How timeouts affect context**:

```
Request Lifecycle with Timeouts:

T=0: Request arrives
┌────────────────────────────────────┐
│ Client connects                    │
│ Context created                    │
└────────────────────────────────────┘

T=0 to T=2s: Reading headers
┌────────────────────────────────────┐
│ ReadHeaderTimeout: 2s              │
│ If exceeded: context canceled      │
└────────────────────────────────────┘

T=2s to T=5s: Reading body
┌────────────────────────────────────┐
│ ReadTimeout: 5s (total)            │
│ If exceeded: context canceled      │
└────────────────────────────────────┘

T=5s to T=15s: Handler execution + response
┌────────────────────────────────────┐
│ WriteTimeout: 10s                  │
│ If exceeded: context canceled      │
│ Connection closed                  │
└────────────────────────────────────┘
```

---

## Context Propagation {#propagation}

Context should flow through your entire application. Let's see how to do this properly.

### Context Propagation Pattern

```
Context Flow in Microservices:

HTTP Request
    ↓ (extract context)
Handler
    ↓ (pass context)
Service Layer
    ↓ (pass context)
Repository Layer
    ↓ (pass context)
Database Query

Each layer receives and passes context!
```

### Complete Example: Multi-Layer Application

```go
package main

import (
    "context"
    "database/sql"
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "time"
)

// Domain Model
type User struct {
    ID    string `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

// Repository Layer (Database access)
type UserRepository struct {
    db *sql.DB
}

func (r *UserRepository) GetUser(ctx context.Context, userID string) (*User, error) {
    // Use context for query timeout
    query := "SELECT id, name, email FROM users WHERE id = $1"
    
    row := r.db.QueryRowContext(ctx, query, userID)
    
    var user User
    err := row.Scan(&user.ID, &user.Name, &user.Email)
    if err != nil {
        if err == sql.ErrNoRows {
            return nil, fmt.Errorf("user not found")
        }
        return nil, fmt.Errorf("query failed: %w", err)
    }
    
    return &user, nil
}

func (r *UserRepository) ListUsers(ctx context.Context, limit int) ([]*User, error) {
    query := "SELECT id, name, email FROM users LIMIT $1"
    
    rows, err := r.db.QueryContext(ctx, query, limit)
    if err != nil {
        return nil, fmt.Errorf("query failed: %w", err)
    }
    defer rows.Close()
    
    var users []*User
    for rows.Next() {
        // Check context cancellation during iteration
        if ctx.Err() != nil {
            return nil, ctx.Err()
        }
        
        var user User
        if err := rows.Scan(&user.ID, &user.Name, &user.Email); err != nil {
            return nil, err
        }
        users = append(users, &user)
    }
    
    return users, nil
}

// Service Layer (Business logic)
type UserService struct {
    repo *UserRepository
}

func (s *UserService) GetUserWithDetails(ctx context.Context, userID string) (*User, error) {
    // Add timeout for this specific operation
    ctx, cancel := context.WithTimeout(ctx, 2*time.Second)
    defer cancel()
    
    // Get user from repository (passes context)
    user, err := s.repo.GetUser(ctx, userID)
    if err != nil {
        return nil, fmt.Errorf("failed to get user: %w", err)
    }
    
    // Additional business logic here...
    
    return user, nil
}

func (s *UserService) SearchUsers(ctx context.Context, limit int) ([]*User, error) {
    // Context flows from parent request
    users, err := s.repo.ListUsers(ctx, limit)
    if err != nil {
        return nil, fmt.Errorf("failed to list users: %w", err)
    }
    
    // Filter or transform results...
    
    return users, nil
}

// HTTP Handler Layer
type UserHandler struct {
    service *UserService
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
    // Extract context from request
    ctx := r.Context()
    
    // Get user ID from URL
    userID := r.URL.Query().Get("id")
    if userID == "" {
        http.Error(w, "user ID required", http.StatusBadRequest)
        return
    }
    
    // Call service (passes context)
    user, err := h.service.GetUserWithDetails(ctx, userID)
    if err != nil {
        if ctx.Err() == context.Canceled {
            // Client disconnected
            log.Println("Client disconnected")
            return
        }
        if ctx.Err() == context.DeadlineExceeded {
            http.Error(w, "Request timeout", http.StatusGatewayTimeout)
            return
        }
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    // Return response
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}

func (h *UserHandler) ListUsers(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    // Call service
    users, err := h.service.SearchUsers(ctx, 100)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(users)
}

func main() {
    // Setup (mock database for example)
    db, _ := sql.Open("postgres", "connection-string")
    defer db.Close()
    
    // Build layers
    repo := &UserRepository{db: db}
    service := &UserService{repo: repo}
    handler := &UserHandler{service: service}
    
    // Register routes
    http.HandleFunc("/user", handler.GetUser)
    http.HandleFunc("/users", handler.ListUsers)
    
    // Start server with timeouts
    server := &http.Server{
        Addr:         ":8080",
        ReadTimeout:  5 * time.Second,
        WriteTimeout: 10 * time.Second,
    }
    
    log.Println("Server starting on :8080")
    log.Fatal(server.ListenAndServe())
}
```

**Context Flow Diagram**:

```
Request Flow with Context:

1. HTTP Request arrives
   ┌────────────────────────────────────┐
   │ ctx = r.Context()                  │
   │ Contains:                          │
   │ - Connection state                 │
   │ - Server timeouts                  │
   │ - Middleware values                │
   └────────────────────────────────────┘

2. Handler Layer
   ┌────────────────────────────────────┐
   │ handler.GetUser(ctx)               │
   │ - Adds request ID to context       │
   │ - Passes to service layer          │
   └────────────────────────────────────┘

3. Service Layer
   ┌────────────────────────────────────┐
   │ service.GetUserWithDetails(ctx)    │
   │ - Adds 2s timeout to context       │
   │ - Passes to repository layer       │
   └────────────────────────────────────┘

4. Repository Layer
   ┌────────────────────────────────────┐
   │ repo.GetUser(ctx)                  │
   │ - Uses context for DB query        │
   │ - Query respects all timeouts      │
   │ - Query canceled if client disconnects│
   └────────────────────────────────────┘

Benefits:
- Single cancellation signal
- Coordinated timeouts
- Automatic cleanup on errors
- No resource leaks
```

### Cross-Service Context Propagation

When calling external services, propagate context:

```go
type ExternalService struct {
    client *http.Client
    baseURL string
}

func (s *ExternalService) GetData(ctx context.Context, id string) ([]byte, error) {
    // Create request with context
    url := fmt.Sprintf("%s/api/data/%s", s.baseURL, id)
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, err
    }
    
    // Propagate trace headers if present
    if traceID := ctx.Value("trace-id"); traceID != nil {
        req.Header.Set("X-Trace-ID", traceID.(string))
    }
    
    // Make request (respects parent context)
    resp, err := s.client.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    return io.ReadAll(resp.Body)
}
```

## Best Practices and Patterns {#best-practices}

Let's explore the best practices for using context effectively in production systems.

### Rule 1: Context as First Parameter

**Always** pass context as the first parameter, named `ctx`:

```go
// Good
func ProcessOrder(ctx context.Context, orderID string) error {
    // ...
}

// Bad
func ProcessOrder(orderID string, ctx context.Context) error {
    // ...
}

// Bad
func ProcessOrder(orderID string, c context.Context) error {
    // ...
}
```

**Why**: Consistency across the Go ecosystem. Every Go developer expects `ctx context.Context` as the first parameter.

### Rule 2: Never Store Context in Structs

```go
// Bad - Don't do this!
type Server struct {
    ctx context.Context  // ❌ Never store context in struct
}

// Good - Pass context to methods
type Server struct {
    config Config
}

func (s *Server) ProcessRequest(ctx context.Context) error {
    // ✓ Context passed as parameter
}
```

**Why storing context in structs is wrong**:

1. **Unclear Lifetime**: When does the context expire? When the struct is created? When a method is called?
    
2. **Shared Cancellation**: All methods share the same context. If one operation cancels, all operations using that struct are affected.
    
3. **Violates Go Convention**: Contexts should have clear scope and lifetime.
    

**Exception**: It's okay to store context temporarily in very short-lived objects like HTTP request handlers, but even then, it's better to pass it as a parameter.

### Rule 3: Always Defer cancel()

```go
// Good
func doWork() error {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()  // ✓ Always defer
    
    return longOperation(ctx)
}

// Bad
func doWork() error {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    // ❌ Forgot to call cancel - timer leaks!
    
    return longOperation(ctx)
}
```

**Why**: Even if the operation completes before the timeout, you need to call `cancel()` to:

- Stop the timer (free resources)
- Remove context from parent's children list
- Allow garbage collection

**Memory leak without cancel()**:

```
Memory Growth Over Time Without cancel():

T=0s: 1000 requests/sec, each creates context
┌────────────────────────────────────┐
│ 1000 timerCtx objects              │
│ 1000 time.Timer objects            │
│ Memory: 150KB                      │
└────────────────────────────────────┘

T=60s: 60,000 leaked contexts
┌────────────────────────────────────┐
│ 60,000 timerCtx objects            │
│ 60,000 time.Timer objects          │
│ Memory: 9MB (leaked!)              │
└────────────────────────────────────┘

T=3600s: 3,600,000 leaked contexts
┌────────────────────────────────────┐
│ 3,600,000 timerCtx objects         │
│ 3,600,000 time.Timer objects       │
│ Memory: 540MB (leaked!)            │
│ Eventually: Out of memory!         │
└────────────────────────────────────┘
```

### Rule 4: Don't Pass nil Context

```go
// Bad
func doWork() {
    someFunction(nil)  // ❌ Never pass nil context
}

// Good
func doWork() {
    someFunction(context.Background())  // ✓ Use Background or TODO
}
```

**Why**: Passing `nil` can cause panics if the function tries to call context methods.

### Rule 5: Context Values for Request-Scoped Data Only

```go
// Good use - Request-scoped data
ctx = context.WithValue(ctx, requestIDKey, "req-123")
ctx = context.WithValue(ctx, userIDKey, "user-456")

// Bad use - Function parameters disguised as context
ctx = context.WithValue(ctx, "retryCount", 3)      // ❌ Use function parameter
ctx = context.WithValue(ctx, "timeout", 5*time.Second)  // ❌ Use WithTimeout
ctx = context.WithValue(ctx, "config", cfg)        // ❌ Pass as parameter
```

**Good candidates for context values**:

- Request IDs for tracing
- Authentication tokens
- User session information
- Trace/span IDs for distributed tracing

**Bad candidates for context values**:

- Configuration
- Optional function parameters
- Feature flags
- Counters or state

### Rule 6: Use Type-Safe Keys for Context Values

```go
// Bad - String keys can collide
ctx = context.WithValue(ctx, "userID", "123")
ctx = context.WithValue(ctx, "userID", "456")  // Collision!

// Good - Type-safe keys
type contextKey int

const (
    userIDKey contextKey = iota
    requestIDKey
)

ctx = context.WithValue(ctx, userIDKey, "123")

// Even better - Helper functions
func WithUserID(ctx context.Context, userID string) context.Context {
    return context.WithValue(ctx, userIDKey, userID)
}

func GetUserID(ctx context.Context) (string, bool) {
    userID, ok := ctx.Value(userIDKey).(string)
    return userID, ok
}
```

### Rule 7: Check Context Before Expensive Operations

```go
func processItems(ctx context.Context, items []Item) error {
    for _, item := range items {
        // Check context before each iteration
        if ctx.Err() != nil {
            return ctx.Err()
        }
        
        // Expensive operation
        if err := processItem(ctx, item); err != nil {
            return err
        }
    }
    return nil
}
```

**Why**: Allows fast cancellation without waiting for the current operation to complete.

### Rule 8: Propagate Context Through Call Chain

```go
// Good - Context flows through all layers
func HandleRequest(ctx context.Context) error {
    data, err := FetchData(ctx)
    if err != nil {
        return err
    }
    return ProcessData(ctx, data)
}

func FetchData(ctx context.Context) ([]byte, error) {
    return QueryDatabase(ctx, "SELECT ...")
}

func ProcessData(ctx context.Context, data []byte) error {
    return SaveResult(ctx, data)
}

// Bad - Context lost in middle layers
func HandleRequest(ctx context.Context) error {
    data, err := FetchData()  // ❌ Context not passed
    if err != nil {
        return err
    }
    return ProcessData(data)  // ❌ Context not passed
}
```

---

## Common Pitfalls {#pitfalls}

Let's examine common mistakes and how to avoid them.

### Pitfall 1: Context Leak

**Problem**: Not calling `cancel()` causes memory leaks.

```go
// Leaky code
func leakyFunction() {
    for i := 0; i < 1000000; i++ {
        ctx, cancel := context.WithTimeout(context.Background(), 1*time.Hour)
        // Missing: defer cancel()
        doQuickWork(ctx)  // Finishes in 1ms
    }
    // 1,000,000 timers still running!
}

// Fixed
func fixedFunction() {
    for i := 0; i < 1000000; i++ {
        ctx, cancel := context.WithTimeout(context.Background(), 1*time.Hour)
        defer cancel()  // ✓ Cleaned up
        doQuickWork(ctx)
    }
}
```

### Pitfall 2: Using Context.Value for Optional Parameters

**Problem**: Context values make function signatures unclear.

```go
// Bad - Hidden dependencies
func QueryUsers(ctx context.Context) ([]*User, error) {
    limit := ctx.Value("limit").(int)  // ❌ Magic value
    orderBy := ctx.Value("orderBy").(string)  // ❌ Magic value
    
    // Query with limit and orderBy
}

// Good - Explicit parameters
func QueryUsers(ctx context.Context, limit int, orderBy string) ([]*User, error) {
    // Query with limit and orderBy
}
```

### Pitfall 3: Ignoring Context Cancellation

**Problem**: Not checking context in long-running operations.

```go
// Bad - Ignores cancellation
func processLargeFile(ctx context.Context, filename string) error {
    data, _ := os.ReadFile(filename)
    
    for _, line := range strings.Split(string(data), "\n") {
        // Long-running operation that ignores ctx
        processLine(line)  // ❌ Context not checked or passed
    }
    return nil
}

// Good - Respects cancellation
func processLargeFile(ctx context.Context, filename string) error {
    data, _ := os.ReadFile(filename)
    
    for _, line := range strings.Split(string(data), "\n") {
        // Check context
        if ctx.Err() != nil {
            return ctx.Err()
        }
        
        // Pass context to child operations
        if err := processLine(ctx, line); err != nil {
            return err
        }
    }
    return nil
}
```

### Pitfall 4: Creating New Context Instead of Using Parent

**Problem**: Breaking the context chain.

```go
// Bad - Creates new root context
func serviceMethod(ctx context.Context) error {
    // ❌ Ignores parent context!
    newCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    return databaseQuery(newCtx)
}

// Good - Derives from parent
func serviceMethod(ctx context.Context) error {
    // ✓ Inherits parent's cancellation and deadline
    newCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()
    
    return databaseQuery(newCtx)
}
```

### Pitfall 5: Timeout Longer Than Parent

**Problem**: Child timeout exceeds parent's.

```go
// Bad - Child outlives parent
func handler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()  // Has 30s timeout from server
    
    // ❌ Tries to set 60s timeout, but parent cancels at 30s
    dbCtx, cancel := context.WithTimeout(ctx, 60*time.Second)
    defer cancel()
    
    queryDatabase(dbCtx)  // Will still timeout at 30s
}

// Good - Child timeout is shorter
func handler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()  // Has 30s timeout from server
    
    // ✓ Sets 5s timeout (less than parent's 30s)
    dbCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()
    
    queryDatabase(dbCtx)
}
```

### Pitfall 6: Storing Context in Long-Lived Objects

**Problem**: Context outlives its intended scope.

```go
// Bad - Context in long-lived struct
type UserCache struct {
    ctx context.Context  // ❌ Don't store context
    data map[string]*User
}

func NewUserCache(ctx context.Context) *UserCache {
    cache := &UserCache{
        ctx:  ctx,
        data: make(map[string]*User),
    }
    go cache.refreshLoop()  // Uses stored ctx
    return cache
}

func (c *UserCache) refreshLoop() {
    ticker := time.NewTicker(1 * time.Minute)
    for {
        select {
        case <-c.ctx.Done():  // ❌ When does this fire?
            return
        case <-ticker.C:
            c.refresh()
        }
    }
}

// Good - Pass context to methods
type UserCache struct {
    data map[string]*User
}

func NewUserCache() *UserCache {
    return &UserCache{
        data: make(map[string]*User),
    }
}

func (c *UserCache) RefreshLoop(ctx context.Context) {
    ticker := time.NewTicker(1 * time.Minute)
    for {
        select {
        case <-ctx.Done():  // ✓ Clear when context expires
            return
        case <-ticker.C:
            c.refresh()
        }
    }
}
```

---

## Real-World Examples {#real-world}

Let's build complete, production-ready examples using context.

### Example 1: API Gateway with Circuit Breaker

```go
package main

import (
    "context"
    "errors"
    "fmt"
    "net/http"
    "sync"
    "time"
)

// Circuit Breaker states
type State int

const (
    StateClosed State = iota
    StateOpen
    StateHalfOpen
)

// CircuitBreaker protects against cascading failures
type CircuitBreaker struct {
    mu           sync.RWMutex
    state        State
    failures     int
    lastAttempt  time.Time
    threshold    int
    timeout      time.Duration
}

func NewCircuitBreaker(threshold int, timeout time.Duration) *CircuitBreaker {
    return &CircuitBreaker{
        state:     StateClosed,
        threshold: threshold,
        timeout:   timeout,
    }
}

func (cb *CircuitBreaker) Call(ctx context.Context, fn func(context.Context) error) error {
    cb.mu.Lock()
    
    // Check if circuit is open
    if cb.state == StateOpen {
        if time.Since(cb.lastAttempt) < cb.timeout {
            cb.mu.Unlock()
            return errors.New("circuit breaker is open")
        }
        // Try to close after timeout
        cb.state = StateHalfOpen
        cb.failures = 0
    }
    
    cb.lastAttempt = time.Now()
    cb.mu.Unlock()
    
    // Execute function with context
    err := fn(ctx)
    
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    if err != nil {
        cb.failures++
        if cb.failures >= cb.threshold {
            cb.state = StateOpen
        }
        return err
    }
    
    // Success - reset
    cb.failures = 0
    cb.state = StateClosed
    return nil
}

// APIGateway handles requests with circuit breaker
type APIGateway struct {
    client  *http.Client
    breaker *CircuitBreaker
}

func NewAPIGateway() *APIGateway {
    return &APIGateway{
        client: &http.Client{
            Timeout: 10 * time.Second,
        },
        breaker: NewCircuitBreaker(5, 30*time.Second),
    }
}

func (g *APIGateway) FetchUserData(ctx context.Context, userID string) ([]byte, error) {
    // Add timeout for this specific operation
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()
    
    var result []byte
    var fetchErr error
    
    // Use circuit breaker
    err := g.breaker.Call(ctx, func(ctx context.Context) error {
        url := fmt.Sprintf("https://api.example.com/users/%s", userID)
        
        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil {
            return err
        }
        
        resp, err := g.client.Do(req)
        if err != nil {
            return err
        }
        defer resp.Body.Close()
        
        if resp.StatusCode != http.StatusOK {
            return fmt.Errorf("unexpected status: %d", resp.StatusCode)
        }
        
        result, fetchErr = io.ReadAll(resp.Body)
        return fetchErr
    })
    
    if err != nil {
        return nil, fmt.Errorf("circuit breaker: %w", err)
    }
    
    return result, nil
}

func (g *APIGateway) Handler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    userID := r.URL.Query().Get("id")
    
    data, err := g.FetchUserData(ctx, userID)
    if err != nil {
        if ctx.Err() == context.DeadlineExceeded {
            http.Error(w, "Request timeout", http.StatusGatewayTimeout)
            return
        }
        if ctx.Err() == context.Canceled {
            return  // Client disconnected
        }
        http.Error(w, err.Error(), http.StatusServiceUnavailable)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    w.Write(data)
}

func main() {
    gateway := NewAPIGateway()
    
    http.HandleFunc("/user", gateway.Handler)
    
    server := &http.Server{
        Addr:         ":8080",
        ReadTimeout:  5 * time.Second,
        WriteTimeout: 10 * time.Second,
    }
    
    fmt.Println("API Gateway starting on :8080")
    server.ListenAndServe()
}
```

### Example 2: Background Job Processor with Graceful Shutdown

```go
package main

import (
    "context"
    "fmt"
    "log"
    "os"
    "os/signal"
    "sync"
    "syscall"
    "time"
)

type Job struct {
    ID   string
    Data interface{}
}

type JobProcessor struct {
    workers int
    queue   chan Job
}

func NewJobProcessor(workers int, queueSize int) *JobProcessor {
    return &JobProcessor{
        workers: workers,
        queue:   make(chan Job, queueSize),
    }
}

// Start begins processing with graceful shutdown support
func (p *JobProcessor) Start(ctx context.Context) {
    var wg sync.WaitGroup
    
    // Start worker goroutines
    for i := 0; i < p.workers; i++ {
        wg.Add(1)
        go func(workerID int) {
            defer wg.Done()
            p.worker(ctx, workerID)
        }(i)
    }
    
    // Wait for context cancellation
    <-ctx.Done()
    log.Println("Shutdown signal received, draining queue...")
    
    // Close queue (no more jobs accepted)
    close(p.queue)
    
    // Wait for all workers to finish
    wg.Wait()
    log.Println("All workers stopped gracefully")
}

func (p *JobProcessor) worker(ctx context.Context, workerID int) {
    log.Printf("Worker %d started\n", workerID)
    
    for {
        select {
        case <-ctx.Done():
            // Context canceled, but finish current job
            log.Printf("Worker %d: context canceled, finishing current job\n", workerID)
            return
            
        case job, ok := <-p.queue:
            if !ok {
                // Queue closed, finish and exit
                log.Printf("Worker %d: queue closed, exiting\n", workerID)
                return
            }
            
            // Process job with timeout
            if err := p.processJob(ctx, job); err != nil {
                log.Printf("Worker %d: failed to process job %s: %v\n", 
                    workerID, job.ID, err)
            } else {
                log.Printf("Worker %d: completed job %s\n", workerID, job.ID)
            }
        }
    }
}

func (p *JobProcessor) processJob(ctx context.Context, job Job) error {
    // Create timeout for individual job
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()
    
    // Simulate job processing
    select {
    case <-ctx.Done():
        return ctx.Err()
    case <-time.After(time.Duration(job.ID[0]%3) * time.Second):
        // Job completed
        return nil
    }
}

func (p *JobProcessor) Submit(job Job) error {
    select {
    case p.queue <- job:
        return nil
    default:
        return fmt.Errorf("queue full")
    }
}

func main() {
    // Create context that cancels on SIGTERM or SIGINT
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    // Setup signal handling
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)
    
    go func() {
        sig := <-sigChan
        log.Printf("Received signal: %v\n", sig)
        cancel()  // Cancel context to trigger graceful shutdown
    }()
    
    // Create and start processor
    processor := NewJobProcessor(3, 100)
    
    // Start processor in background
    go processor.Start(ctx)
    
    // Simulate job submission
    go func() {
        for i := 0; i < 20; i++ {
            job := Job{
                ID:   fmt.Sprintf("job-%d", i),
                Data: fmt.Sprintf("data-%d", i),
            }
            
            if err := processor.Submit(job); err != nil {
                log.Printf("Failed to submit job: %v\n", err)
            }
            
            time.Sleep(500 * time.Millisecond)
        }
    }()
    
    // Wait for context to be canceled
    <-ctx.Done()
    log.Println("Main: shutting down...")
}
```

### Example 3: Distributed Tracing with Context

```go
package main

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "time"
)

// Trace context keys
type contextKey int

const (
    traceIDKey contextKey = iota
    spanIDKey
)

// TraceInfo holds tracing information
type TraceInfo struct {
    TraceID string
    SpanID  string
    Start   time.Time
}

// WithTrace adds trace information to context
func WithTrace(ctx context.Context, traceID, spanID string) context.Context {
    ctx = context.WithValue(ctx, traceIDKey, traceID)
    ctx = context.WithValue(ctx, spanIDKey, spanID)
    return ctx
}

// GetTraceID extracts trace ID from context
func GetTraceID(ctx context.Context) string {
    if traceID, ok := ctx.Value(traceIDKey).(string); ok {
        return traceID
    }
    return ""
}

// GetSpanID extracts span ID from context
func GetSpanID(ctx context.Context) string {
    if spanID, ok := ctx.Value(spanIDKey).(string); ok {
        return spanID
    }
    return ""
}

// StartSpan creates a new span for tracing
func StartSpan(ctx context.Context, operation string) (context.Context, func()) {
    traceID := GetTraceID(ctx)
    if traceID == "" {
        traceID = generateID()
    }
    
    spanID := generateID()
    parentSpanID := GetSpanID(ctx)
    
    start := time.Now()
    
    log.Printf("[Trace: %s] [Span: %s] [Parent: %s] Operation '%s' started",
        traceID, spanID, parentSpanID, operation)
    
    // Create new context with span info
    newCtx := WithTrace(ctx, traceID, spanID)
    
    // Return finish function
    finish := func() {
        duration := time.Since(start)
        log.Printf("[Trace: %s] [Span: %s] Operation '%s' completed in %v",
            traceID, spanID, operation, duration)
    }
    
    return newCtx, finish
}

func generateID() string {
    return fmt.Sprintf("%d", time.Now().UnixNano())
}

// Example handlers with tracing
func orderHandler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    // Start span for the entire request
    ctx, finishRequest := StartSpan(ctx, "orderHandler")
    defer finishRequest()
    
    // Validate order
    ctx, finishValidation := StartSpan(ctx, "validateOrder")
    time.Sleep(50 * time.Millisecond)  // Simulate work
    finishValidation()
    
    // Process payment
    ctx, finishPayment := StartSpan(ctx, "processPayment")
    if err := processPayment(ctx, "order-123"); err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    finishPayment()
    
    // Create order record
    ctx, finishCreate := StartSpan(ctx, "createOrderRecord")
    time.Sleep(30 * time.Millisecond)  // Simulate work
    finishCreate()
    
    fmt.Fprintf(w, "Order created successfully")
}

func processPayment(ctx context.Context, orderID string) error {
    ctx, finish := StartSpan(ctx, "processPayment.callPaymentGateway")
    defer finish()
    
    // Simulate payment gateway call
    time.Sleep(100 * time.Millisecond)
    
    return nil
}

// Middleware to inject trace ID from headers or create new one
func TracingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        ctx := r.Context()
        
        // Check for existing trace ID in headers
        traceID := r.Header.Get("X-Trace-ID")
        if traceID == "" {
            traceID = generateID()
        }
        
        // Add trace ID to context
        ctx = WithTrace(ctx, traceID, "")
        
        // Add trace ID to response headers
        w.Header().Set("X-Trace-ID", traceID)
        
        // Continue with updated context
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

func main() {
    mux := http.NewServeMux()
    mux.HandleFunc("/order", orderHandler)
    
    // Wrap with tracing middleware
    handler := TracingMiddleware(mux)
    
    server := &http.Server{
        Addr:    ":8080",
        Handler: handler,
    }
    
    log.Println("Server with tracing starting on :8080")
    server.ListenAndServe()
}
```

---

## Summary

Context is a powerful tool for managing cancellation, deadlines, and request-scoped values in Go applications. Here are the key takeaways:

**Core Concepts**:

- Context forms a tree structure with parent-child relationships
- Canceling a parent cancels all children
- Children can have shorter timeouts than parents
- Context should flow through your entire call chain

**Best Practices**:

- Always pass context as the first parameter
- Never store context in structs
- Always defer cancel() to prevent leaks
- Use context for cancellation, not optional parameters
- Check context before expensive operations
- Propagate context through all layers

**Common Pitfalls to Avoid**:

- Forgetting to call cancel() (causes leaks)
- Using context.Value for function parameters
- Ignoring context cancellation in loops
- Creating new root contexts instead of deriving from parent
- Storing context in long-lived objects

**Real-World Applications**:

- HTTP request timeouts
- Database query cancellation
- Graceful shutdown of background workers
- Circuit breakers and retry logic
- Distributed tracing
- Request-scoped logging

Context makes Go programs more robust, responsive, and resource-efficient. Master it, and you'll write better concurrent code!