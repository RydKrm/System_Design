# The Complete Guide to Object-Oriented Programming in Go

## Table of Contents

1. [Introduction - OOP in Go](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#introduction)
2. [Encapsulation](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#encapsulation)
3. [Composition Over Inheritance](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#composition)
4. [Polymorphism through Interfaces](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#polymorphism)
5. [Abstraction](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#abstraction)
6. [Method Receivers](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#method-receivers)
7. [Interface Segregation](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#interface-segregation)
8. [Dependency Injection](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#dependency-injection)
9. [Design Patterns](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#design-patterns)
10. [Real-World Examples](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#real-world)

---

## Introduction - OOP in Go {#introduction}

Go is not a traditional object-oriented language like Java, C++, or Python. It doesn't have classes, inheritance, or traditional OOP keywords. However, Go supports all major OOP principles through a different, more pragmatic approach. In fact, many argue that Go's approach to OOP is superior because it encourages composition over inheritance and favors simplicity over complexity.

### Go's OOP Philosophy

**Traditional OOP Languages (Java, C++):**

- Classes and objects
- Inheritance hierarchies
- Virtual methods
- Abstract classes
- Multiple inheritance (sometimes)

**Go's Approach:**

- Structs and methods
- Composition (embedding)
- Interfaces (implicit implementation)
- No inheritance
- Duck typing

### Why Go's Approach is Better

**Problem with Traditional OOP:**

```
Classic Inheritance Hierarchy (Java/C++):

Animal
  ├─ Mammal
  │    ├─ Dog
  │    ├─ Cat
  │    └─ Whale
  └─ Bird
       ├─ Eagle
       └─ Penguin ← Can't fly! Breaks Liskov Substitution

Issues:
- Rigid hierarchies
- Fragile base class problem
- Diamond problem (multiple inheritance)
- Deep inheritance = hard to understand
```

**Go's Solution:**

```
Composition (Go):

Dog struct {
    Animal   // Embedded
    Mammal   // Embedded
}

Penguin struct {
    Bird     // Embedded
    Swimmer  // Embedded
    // No Flyer - penguins don't fly!
}

Benefits:
- Flexible composition
- Clear dependencies
- Easy to test
- No inheritance complexity
```

### The Four Pillars of OOP in Go

Let's see how Go implements each pillar:

**1. Encapsulation** → Packages and exported/unexported identifiers **2. Abstraction** → Interfaces **3. Inheritance** → Composition/Embedding **4. Polymorphism** → Interfaces and duck typing

---

## Encapsulation {#encapsulation}

Encapsulation is hiding internal implementation details and exposing only what's necessary. Go achieves this through package-level access control.

### Exported vs Unexported

```go
package user

import "errors"

// User is exported (starts with capital letter)
type User struct {
    ID       int       // Exported field
    Username string    // Exported field
    email    string    // Unexported field (private)
    password string    // Unexported field (private)
}

// NewUser is an exported constructor
func NewUser(username, email, password string) (*User, error) {
    if err := validateEmail(email); err != nil {
        return nil, err
    }
    
    return &User{
        Username: username,
        email:    email,
        password: hashPassword(password),
    }, nil
}

// Email is an exported getter
func (u *User) Email() string {
    return u.email
}

// SetEmail is an exported setter with validation
func (u *User) SetEmail(email string) error {
    if err := validateEmail(email); err != nil {
        return err
    }
    u.email = email
    return nil
}

// ValidatePassword is an exported method
func (u *User) ValidatePassword(password string) bool {
    return checkPassword(u.password, password)
}

// validateEmail is unexported (private)
func validateEmail(email string) error {
    if !strings.Contains(email, "@") {
        return errors.New("invalid email")
    }
    return nil
}

// hashPassword is unexported (private)
func hashPassword(password string) string {
    // Hash implementation
    return "hashed_" + password
}

// checkPassword is unexported (private)
func checkPassword(hashed, plain string) bool {
    return hashPassword(plain) == hashed
}
```

**Encapsulation Rules:**

```
Package Visibility:

┌────────────────────────────────────────┐
│ package user                           │
│                                        │
│ Exported (Public):                     │
│ ┌────────────────────────────────────┐│
│ │ User           (Capital U)         ││
│ │ NewUser()      (Capital N)         ││
│ │ Email()        (Capital E)         ││
│ │ SetEmail()     (Capital S)         ││
│ └────────────────────────────────────┘│
│                                        │
│ Unexported (Private):                  │
│ ┌────────────────────────────────────┐│
│ │ email          (lowercase)         ││
│ │ password       (lowercase)         ││
│ │ validateEmail() (lowercase)        ││
│ │ hashPassword()  (lowercase)        ││
│ └────────────────────────────────────┘│
└────────────────────────────────────────┘

Other packages can only access Exported items!
```

### Complete Encapsulation Example: Bank Account

```go
package bank

import (
    "errors"
    "sync"
    "time"
)

// Account represents a bank account with encapsulated state
type Account struct {
    // Unexported fields - complete encapsulation
    mu            sync.RWMutex
    accountNumber string
    balance       float64
    owner         string
    createdAt     time.Time
    transactions  []transaction
}

// transaction is unexported - implementation detail
type transaction struct {
    amount    float64
    timestamp time.Time
    txType    string
}

// NewAccount creates a new account (constructor)
func NewAccount(accountNumber, owner string, initialBalance float64) (*Account, error) {
    if initialBalance < 0 {
        return nil, errors.New("initial balance cannot be negative")
    }
    
    return &Account{
        accountNumber: accountNumber,
        balance:       initialBalance,
        owner:         owner,
        createdAt:     time.Now(),
        transactions:  make([]transaction, 0),
    }, nil
}

// Deposit adds money (exported method)
func (a *Account) Deposit(amount float64) error {
    if amount <= 0 {
        return errors.New("deposit amount must be positive")
    }
    
    a.mu.Lock()
    defer a.mu.Unlock()
    
    a.balance += amount
    a.recordTransaction(amount, "deposit")
    
    return nil
}

// Withdraw removes money (exported method)
func (a *Account) Withdraw(amount float64) error {
    if amount <= 0 {
        return errors.New("withdrawal amount must be positive")
    }
    
    a.mu.Lock()
    defer a.mu.Unlock()
    
    if amount > a.balance {
        return errors.New("insufficient funds")
    }
    
    a.balance -= amount
    a.recordTransaction(-amount, "withdrawal")
    
    return nil
}

// Balance returns current balance (getter)
func (a *Account) Balance() float64 {
    a.mu.RLock()
    defer a.mu.RUnlock()
    
    return a.balance
}

// AccountNumber returns account number (getter)
func (a *Account) AccountNumber() string {
    return a.accountNumber
}

// Owner returns owner name (getter)
func (a *Account) Owner() string {
    return a.owner
}

// TransactionHistory returns copy of transactions
func (a *Account) TransactionHistory() []Transaction {
    a.mu.RLock()
    defer a.mu.RUnlock()
    
    // Return copy, not internal slice
    history := make([]Transaction, len(a.transactions))
    for i, tx := range a.transactions {
        history[i] = Transaction{
            Amount:    tx.amount,
            Timestamp: tx.timestamp,
            Type:      tx.txType,
        }
    }
    
    return history
}

// Transaction is exported for returning history
type Transaction struct {
    Amount    float64
    Timestamp time.Time
    Type      string
}

// recordTransaction is unexported (private helper)
func (a *Account) recordTransaction(amount float64, txType string) {
    a.transactions = append(a.transactions, transaction{
        amount:    amount,
        timestamp: time.Now(),
        txType:    txType,
    })
}

// Transfer money between accounts
func Transfer(from, to *Account, amount float64) error {
    if amount <= 0 {
        return errors.New("transfer amount must be positive")
    }
    
    // Lock both accounts (always lock in same order to avoid deadlock)
    if from.accountNumber < to.accountNumber {
        from.mu.Lock()
        defer from.mu.Unlock()
        to.mu.Lock()
        defer to.mu.Unlock()
    } else {
        to.mu.Lock()
        defer to.mu.Unlock()
        from.mu.Lock()
        defer from.mu.Unlock()
    }
    
    if from.balance < amount {
        return errors.New("insufficient funds")
    }
    
    from.balance -= amount
    to.balance += amount
    
    from.recordTransaction(-amount, "transfer_out")
    to.recordTransaction(amount, "transfer_in")
    
    return nil
}
```

**Usage:**

```go
package main

import (
    "fmt"
    "yourapp/bank"
)

func main() {
    // Create accounts
    acc1, _ := bank.NewAccount("ACC001", "Alice", 1000.0)
    acc2, _ := bank.NewAccount("ACC002", "Bob", 500.0)
    
    // Can't access internal fields
    // fmt.Println(acc1.balance) // ❌ Compile error!
    
    // Must use public methods
    fmt.Println(acc1.Balance())  // ✓ 1000.0
    
    // Operations are safe and validated
    acc1.Deposit(500.0)
    fmt.Println(acc1.Balance())  // 1500.0
    
    acc1.Withdraw(200.0)
    fmt.Println(acc1.Balance())  // 1300.0
    
    // Transfer between accounts
    bank.Transfer(acc1, acc2, 300.0)
    fmt.Println(acc1.Balance())  // 1000.0
    fmt.Println(acc2.Balance())  // 800.0
    
    // Get transaction history
    for _, tx := range acc1.TransactionHistory() {
        fmt.Printf("%s: %.2f at %v\n", tx.Type, tx.Amount, tx.Timestamp)
    }
}
```

### Encapsulation with Internal Packages

Go also has an `internal` package convention:

```
Project Structure:

myapp/
├── cmd/
│   └── main.go
├── pkg/
│   └── public/      ← Public API
│       └── api.go
└── internal/        ← Internal only
    ├── database/
    │   └── db.go
    └── config/
        └── config.go

internal/ packages can only be imported by:
- Same module
- Parent directories

This enforces encapsulation at a higher level!
```

---

## Composition Over Inheritance {#composition}

Go doesn't have inheritance. Instead, it uses composition through embedding. This is more flexible and avoids many OOP pitfalls.

### Struct Embedding (Composition)

```go
package main

import "fmt"

// Base functionality
type Engine struct {
    Horsepower int
    Type       string
}

func (e *Engine) Start() {
    fmt.Printf("Starting %s engine with %d HP\n", e.Type, e.Horsepower)
}

func (e *Engine) Stop() {
    fmt.Println("Engine stopped")
}

// Another component
type GPS struct {
    Latitude  float64
    Longitude float64
}

func (g *GPS) Navigate(destination string) {
    fmt.Printf("Navigating to %s from (%.2f, %.2f)\n", 
        destination, g.Latitude, g.Longitude)
}

// Car composes Engine and GPS
type Car struct {
    Engine          // Embedded (anonymous field)
    GPS             // Embedded
    Brand    string
    Model    string
}

func (c *Car) Drive() {
    c.Start()  // Promoted method from Engine
    fmt.Printf("Driving %s %s\n", c.Brand, c.Model)
}

func main() {
    car := Car{
        Engine: Engine{
            Horsepower: 300,
            Type:       "V8",
        },
        GPS: GPS{
            Latitude:  40.7128,
            Longitude: -74.0060,
        },
        Brand: "Tesla",
        Model: "Model S",
    }
    
    // Access embedded fields and methods directly
    car.Start()                    // From Engine
    car.Navigate("Home")           // From GPS
    car.Drive()                    // Car's own method
    fmt.Println(car.Horsepower)    // Promoted field from Engine
}
```

**How Embedding Works:**

```
Memory Layout:

car (Car struct):
┌─────────────────────────────────────┐
│ Engine (embedded)                   │
│ ┌─────────────────────────────────┐│
│ │ Horsepower: 300                 ││
│ │ Type: "V8"                      ││
│ └─────────────────────────────────┘│
│                                     │
│ GPS (embedded)                      │
│ ┌─────────────────────────────────┐│
│ │ Latitude: 40.7128               ││
│ │ Longitude: -74.0060             ││
│ └─────────────────────────────────┘│
│                                     │
│ Brand: "Tesla"                      │
│ Model: "Model S"                    │
└─────────────────────────────────────┘

Method Promotion:
car.Start()  →  car.Engine.Start()
car.Navigate() → car.GPS.Navigate()

Fields are promoted to outer type!
```

### Complete Composition Example: Employee Management

```go
package main

import (
    "fmt"
    "time"
)

// Basic person information
type Person struct {
    FirstName string
    LastName  string
    BirthDate time.Time
}

func (p *Person) FullName() string {
    return p.FirstName + " " + p.LastName
}

func (p *Person) Age() int {
    return time.Now().Year() - p.BirthDate.Year()
}

// Contact information
type ContactInfo struct {
    Email string
    Phone string
}

func (c *ContactInfo) SendEmail(subject, body string) {
    fmt.Printf("Sending email to %s: %s\n", c.Email, subject)
}

// Address information
type Address struct {
    Street  string
    City    string
    State   string
    ZipCode string
}

func (a *Address) FullAddress() string {
    return fmt.Sprintf("%s, %s, %s %s", a.Street, a.City, a.State, a.ZipCode)
}

// Salary information
type Salary struct {
    BaseSalary float64
    Bonus      float64
    Currency   string
}

func (s *Salary) TotalSalary() float64 {
    return s.BaseSalary + s.Bonus
}

func (s *Salary) GiveRaise(percentage float64) {
    s.BaseSalary *= (1 + percentage/100)
}

// Employee composes all above types
type Employee struct {
    Person                  // Embedded
    ContactInfo             // Embedded
    Address                 // Embedded
    Salary                  // Embedded
    EmployeeID    string
    Department    string
    Position      string
    StartDate     time.Time
}

func (e *Employee) YearsOfService() int {
    return time.Now().Year() - e.StartDate.Year()
}

func (e *Employee) Promote(newPosition string, salaryIncrease float64) {
    e.Position = newPosition
    e.GiveRaise(salaryIncrease)
    fmt.Printf("%s promoted to %s with %.0f%% raise\n", 
        e.FullName(), newPosition, salaryIncrease)
}

func (e *Employee) PrintDetails() {
    fmt.Println("=== Employee Details ===")
    fmt.Printf("Name: %s\n", e.FullName())
    fmt.Printf("Age: %d\n", e.Age())
    fmt.Printf("Employee ID: %s\n", e.EmployeeID)
    fmt.Printf("Department: %s\n", e.Department)
    fmt.Printf("Position: %s\n", e.Position)
    fmt.Printf("Email: %s\n", e.Email)
    fmt.Printf("Phone: %s\n", e.Phone)
    fmt.Printf("Address: %s\n", e.FullAddress())
    fmt.Printf("Salary: %.2f %s\n", e.TotalSalary(), e.Currency)
    fmt.Printf("Years of Service: %d\n", e.YearsOfService())
}

// Manager extends Employee with team management
type Manager struct {
    Employee                // Embedded
    Team     []Employee
    Budget   float64
}

func (m *Manager) HireEmployee(emp Employee) {
    m.Team = append(m.Team, emp)
    fmt.Printf("%s hired %s\n", m.FullName(), emp.FullName())
}

func (m *Manager) TeamSize() int {
    return len(m.Team)
}

func (m *Manager) TotalTeamSalary() float64 {
    total := m.TotalSalary() // Manager's salary
    for _, emp := range m.Team {
        total += emp.TotalSalary()
    }
    return total
}

func main() {
    // Create employee
    emp := Employee{
        Person: Person{
            FirstName: "John",
            LastName:  "Doe",
            BirthDate: time.Date(1990, 5, 15, 0, 0, 0, 0, time.UTC),
        },
        ContactInfo: ContactInfo{
            Email: "john.doe@company.com",
            Phone: "+1-555-0100",
        },
        Address: Address{
            Street:  "123 Main St",
            City:    "New York",
            State:   "NY",
            ZipCode: "10001",
        },
        Salary: Salary{
            BaseSalary: 80000,
            Bonus:      5000,
            Currency:   "USD",
        },
        EmployeeID: "E001",
        Department: "Engineering",
        Position:   "Software Engineer",
        StartDate:  time.Date(2020, 1, 1, 0, 0, 0, 0, time.UTC),
    }
    
    emp.PrintDetails()
    emp.Promote("Senior Software Engineer", 15)
    
    // Create manager
    manager := Manager{
        Employee: Employee{
            Person: Person{
                FirstName: "Jane",
                LastName:  "Smith",
                BirthDate: time.Date(1985, 8, 20, 0, 0, 0, 0, time.UTC),
            },
            ContactInfo: ContactInfo{
                Email: "jane.smith@company.com",
                Phone: "+1-555-0200",
            },
            Address: Address{
                Street:  "456 Park Ave",
                City:    "New York",
                State:   "NY",
                ZipCode: "10002",
            },
            Salary: Salary{
                BaseSalary: 120000,
                Bonus:      15000,
                Currency:   "USD",
            },
            EmployeeID: "M001",
            Department: "Engineering",
            Position:   "Engineering Manager",
            StartDate:  time.Date(2015, 3, 1, 0, 0, 0, 0, time.UTC),
        },
        Budget: 1000000,
    }
    
    manager.HireEmployee(emp)
    fmt.Printf("Team size: %d\n", manager.TeamSize())
    fmt.Printf("Total team salary: %.2f %s\n", 
        manager.TotalTeamSalary(), manager.Currency)
}
```

### Composition vs Inheritance Comparison

**Traditional Inheritance (Java-style):**

```java
// Java/C++ style
class Animal {
    String name;
    void eat() { }
    void sleep() { }
}

class Mammal extends Animal {
    void giveBirth() { }
}

class Dog extends Mammal {
    void bark() { }
}

// Problems:
// - Rigid hierarchy
// - Can't change after defined
// - Diamond problem with multiple inheritance
// - Fragile base class
```

**Go's Composition:**

```go
// Go style
type Eater interface {
    Eat()
}

type Sleeper interface {
    Sleep()
}

type Birther interface {
    GiveBirth()
}

type Barker interface {
    Bark()
}

// Behavior implementations
type EatingBehavior struct{}
func (e *EatingBehavior) Eat() { /* ... */ }

type SleepingBehavior struct{}
func (s *SleepingBehavior) Sleep() { /* ... */ }

type MammalBehavior struct{}
func (m *MammalBehavior) GiveBirth() { /* ... */ }

// Compose exactly what you need
type Dog struct {
    EatingBehavior
    SleepingBehavior
    MammalBehavior
    Name string
}

func (d *Dog) Bark() {
    fmt.Println("Woof!")
}

// Benefits:
// - Flexible composition
// - Mix and match behaviors
// - No hierarchy
// - Easy to test
```

### Multiple Composition

```go
package main

import "fmt"

// Multiple small interfaces
type Drawer interface {
    Draw()
}

type Saver interface {
    Save(filename string)
}

type Loader interface {
    Load(filename string)
}

type Printer interface {
    Print()
}

// Components implementing interfaces
type DrawingEngine struct{}
func (d *DrawingEngine) Draw() { fmt.Println("Drawing...") }

type FileManager struct{}
func (f *FileManager) Save(filename string) { 
    fmt.Printf("Saving to %s\n", filename) 
}
func (f *FileManager) Load(filename string) { 
    fmt.Printf("Loading from %s\n", filename) 
}

type PrintManager struct{}
func (p *PrintManager) Print() { fmt.Println("Printing...") }

// Compose multiple components
type Document struct {
    DrawingEngine
    FileManager
    PrintManager
    Content string
}

// Document automatically implements Drawer, Saver, Loader, and Printer!

func main() {
    doc := Document{
        DrawingEngine: DrawingEngine{},
        FileManager:   FileManager{},
        PrintManager:  PrintManager{},
        Content:       "Hello, World!",
    }
    
    // All methods available
    doc.Draw()
    doc.Save("document.txt")
    doc.Load("document.txt")
    doc.Print()
}
```

## Polymorphism through Interfaces {#polymorphism}

Polymorphism is the ability to treat different types uniformly. Go achieves this through interfaces - one of Go's most powerful features.

### Interface Basics

```go
package main

import "fmt"

// Interface defines behavior
type Shape interface {
    Area() float64
    Perimeter() float64
}

// Rectangle implements Shape
type Rectangle struct {
    Width  float64
    Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

// Circle implements Shape
type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return 3.14159 * c.Radius * c.Radius
}

func (c Circle) Perimeter() float64 {
    return 2 * 3.14159 * c.Radius
}

// Triangle implements Shape
type Triangle struct {
    Base   float64
    Height float64
    Side1  float64
    Side2  float64
    Side3  float64
}

func (t Triangle) Area() float64 {
    return 0.5 * t.Base * t.Height
}

func (t Triangle) Perimeter() float64 {
    return t.Side1 + t.Side2 + t.Side3
}

// Polymorphic function - works with any Shape
func PrintShapeInfo(s Shape) {
    fmt.Printf("Area: %.2f, Perimeter: %.2f\n", s.Area(), s.Perimeter())
}

// Calculate total area of multiple shapes
func TotalArea(shapes []Shape) float64 {
    total := 0.0
    for _, shape := range shapes {
        total += shape.Area()
    }
    return total
}

func main() {
    // Different types, same interface
    rect := Rectangle{Width: 10, Height: 5}
    circle := Circle{Radius: 7}
    triangle := Triangle{Base: 6, Height: 8, Side1: 6, Side2: 8, Side3: 10}
    
    // Polymorphism in action
    PrintShapeInfo(rect)     // Works!
    PrintShapeInfo(circle)   // Works!
    PrintShapeInfo(triangle) // Works!
    
    // Collection of different types
    shapes := []Shape{rect, circle, triangle}
    fmt.Printf("Total area: %.2f\n", TotalArea(shapes))
}
```

**Key Points:**

- No explicit "implements" keyword
- If a type has all methods, it implements the interface (duck typing)
- Implicit implementation = loose coupling

### Interface Implementation is Implicit

```
Traditional OOP (Java):

┌────────────────────────────────────┐
│ interface Shape {                  │
│     double area();                 │
│ }                                  │
└────────────────────────────────────┘
         ↑
         │ implements
         │
┌────────────────────────────────────┐
│ class Circle implements Shape {    │
│     public double area() { ... }   │
│ }                                  │
└────────────────────────────────────┘

Explicit: Must declare "implements Shape"


Go:

┌────────────────────────────────────┐
│ type Shape interface {             │
│     Area() float64                 │
│ }                                  │
└────────────────────────────────────┘
         ↑
         │ automatic!
         │
┌────────────────────────────────────┐
│ type Circle struct { ... }         │
│                                    │
│ func (c Circle) Area() float64 {  │
│     ...                            │
│ }                                  │
└────────────────────────────────────┘

Implicit: If it has the method, it's a Shape!
```

### Complete Polymorphism Example: Payment Processing

```go
package main

import (
    "errors"
    "fmt"
    "time"
)

// PaymentProcessor interface
type PaymentProcessor interface {
    ProcessPayment(amount float64) error
    RefundPayment(transactionID string, amount float64) error
    GetProviderName() string
}

// PaymentResult for tracking
type PaymentResult struct {
    Success       bool
    TransactionID string
    Provider      string
    Amount        float64
    Timestamp     time.Time
    Error         error
}

// CreditCardProcessor implementation
type CreditCardProcessor struct {
    CardNumber string
    CVV        string
    ExpiryDate string
}

func (cc *CreditCardProcessor) ProcessPayment(amount float64) error {
    fmt.Printf("Processing credit card payment: $%.2f\n", amount)
    
    // Simulate validation
    if len(cc.CardNumber) != 16 {
        return errors.New("invalid card number")
    }
    
    // Simulate payment processing
    fmt.Println("Contacting payment gateway...")
    time.Sleep(100 * time.Millisecond)
    
    fmt.Printf("Credit card payment successful: $%.2f\n", amount)
    return nil
}

func (cc *CreditCardProcessor) RefundPayment(transactionID string, amount float64) error {
    fmt.Printf("Refunding $%.2f to credit card (TX: %s)\n", amount, transactionID)
    return nil
}

func (cc *CreditCardProcessor) GetProviderName() string {
    return "Credit Card"
}

// PayPalProcessor implementation
type PayPalProcessor struct {
    Email    string
    Password string
}

func (pp *PayPalProcessor) ProcessPayment(amount float64) error {
    fmt.Printf("Processing PayPal payment: $%.2f\n", amount)
    
    if pp.Email == "" {
        return errors.New("PayPal email required")
    }
    
    fmt.Println("Authenticating with PayPal...")
    time.Sleep(150 * time.Millisecond)
    
    fmt.Printf("PayPal payment successful: $%.2f\n", amount)
    return nil
}

func (pp *PayPalProcessor) RefundPayment(transactionID string, amount float64) error {
    fmt.Printf("Refunding $%.2f via PayPal (TX: %s)\n", amount, transactionID)
    return nil
}

func (pp *PayPalProcessor) GetProviderName() string {
    return "PayPal"
}

// CryptoProcessor implementation
type CryptoProcessor struct {
    WalletAddress string
    Currency      string
}

func (cp *CryptoProcessor) ProcessPayment(amount float64) error {
    fmt.Printf("Processing cryptocurrency payment: $%.2f in %s\n", 
        amount, cp.Currency)
    
    if cp.WalletAddress == "" {
        return errors.New("wallet address required")
    }
    
    fmt.Println("Broadcasting transaction to blockchain...")
    time.Sleep(200 * time.Millisecond)
    
    fmt.Printf("Crypto payment successful: $%.2f %s\n", amount, cp.Currency)
    return nil
}

func (cp *CryptoProcessor) RefundPayment(transactionID string, amount float64) error {
    fmt.Printf("Refunding $%.2f in %s (TX: %s)\n", 
        amount, cp.Currency, transactionID)
    return nil
}

func (cp *CryptoProcessor) GetProviderName() string {
    return "Cryptocurrency (" + cp.Currency + ")"
}

// PaymentService uses polymorphism
type PaymentService struct {
    processors []PaymentProcessor
}

func NewPaymentService() *PaymentService {
    return &PaymentService{
        processors: make([]PaymentProcessor, 0),
    }
}

func (ps *PaymentService) RegisterProcessor(processor PaymentProcessor) {
    ps.processors = append(ps.processors, processor)
}

// ProcessWithFallback tries processors until one succeeds
func (ps *PaymentService) ProcessWithFallback(amount float64) PaymentResult {
    for _, processor := range ps.processors {
        err := processor.ProcessPayment(amount)
        if err == nil {
            return PaymentResult{
                Success:       true,
                TransactionID: generateTxID(),
                Provider:      processor.GetProviderName(),
                Amount:        amount,
                Timestamp:     time.Now(),
            }
        }
        
        fmt.Printf("Failed with %s: %v. Trying next...\n", 
            processor.GetProviderName(), err)
    }
    
    return PaymentResult{
        Success: false,
        Error:   errors.New("all payment processors failed"),
    }
}

func generateTxID() string {
    return fmt.Sprintf("TX%d", time.Now().UnixNano())
}

func main() {
    service := NewPaymentService()
    
    // Register multiple payment processors (polymorphism!)
    service.RegisterProcessor(&CreditCardProcessor{
        CardNumber: "1234567890123456",
        CVV:        "123",
        ExpiryDate: "12/25",
    })
    
    service.RegisterProcessor(&PayPalProcessor{
        Email:    "user@example.com",
        Password: "secret",
    })
    
    service.RegisterProcessor(&CryptoProcessor{
        WalletAddress: "0x1234567890abcdef",
        Currency:      "BTC",
    })
    
    // Process payment with fallback
    result := service.ProcessWithFallback(99.99)
    
    if result.Success {
        fmt.Printf("\nPayment successful!\n")
        fmt.Printf("Provider: %s\n", result.Provider)
        fmt.Printf("Transaction ID: %s\n", result.TransactionID)
        fmt.Printf("Amount: $%.2f\n", result.Amount)
    } else {
        fmt.Printf("\nPayment failed: %v\n", result.Error)
    }
}
```

### Empty Interface (interface{})

The empty interface accepts any type:

```go
package main

import "fmt"

// Any type can be passed as interface{}
func PrintAnything(val interface{}) {
    fmt.Printf("Value: %v, Type: %T\n", val, val)
}

// Type assertion to get concrete type
func ProcessValue(val interface{}) {
    switch v := val.(type) {
    case int:
        fmt.Printf("Integer: %d\n", v)
    case string:
        fmt.Printf("String: %s\n", v)
    case bool:
        fmt.Printf("Boolean: %v\n", v)
    case []int:
        fmt.Printf("Int slice: %v\n", v)
    default:
        fmt.Printf("Unknown type: %T\n", v)
    }
}

// Generic container using interface{}
type Container struct {
    items []interface{}
}

func (c *Container) Add(item interface{}) {
    c.items = append(c.items, item)
}

func (c *Container) Get(index int) interface{} {
    if index >= 0 && index < len(c.items) {
        return c.items[index]
    }
    return nil
}

func main() {
    PrintAnything(42)
    PrintAnything("hello")
    PrintAnything(true)
    PrintAnything([]int{1, 2, 3})
    
    fmt.Println()
    
    ProcessValue(42)
    ProcessValue("hello")
    ProcessValue(true)
    
    fmt.Println()
    
    // Container can hold any type
    container := &Container{}
    container.Add(10)
    container.Add("text")
    container.Add(true)
    
    fmt.Println(container.Get(0)) // 10
    fmt.Println(container.Get(1)) // text
    fmt.Println(container.Get(2)) // true
}
```

**Note**: Go 1.18+ has generics, which are better than `interface{}` for type-safe generic code.

---

## Abstraction {#abstraction}

Abstraction hides complexity and exposes only essential features. Go achieves this through interfaces and encapsulation.

### Abstraction Layers Example: Database

```go
package main

import (
    "errors"
    "fmt"
)

// Abstract interface - hides database implementation
type Database interface {
    Connect() error
    Disconnect() error
    Query(query string) ([]map[string]interface{}, error)
    Execute(query string) error
}

// PostgreSQL implementation
type PostgreSQL struct {
    host     string
    port     int
    user     string
    password string
    dbname   string
    connected bool
}

func NewPostgreSQL(host string, port int, user, password, dbname string) *PostgreSQL {
    return &PostgreSQL{
        host:     host,
        port:     port,
        user:     user,
        password: password,
        dbname:   dbname,
    }
}

func (pg *PostgreSQL) Connect() error {
    fmt.Printf("Connecting to PostgreSQL at %s:%d...\n", pg.host, pg.port)
    pg.connected = true
    return nil
}

func (pg *PostgreSQL) Disconnect() error {
    fmt.Println("Disconnecting from PostgreSQL...")
    pg.connected = false
    return nil
}

func (pg *PostgreSQL) Query(query string) ([]map[string]interface{}, error) {
    if !pg.connected {
        return nil, errors.New("not connected to database")
    }
    
    fmt.Printf("PostgreSQL executing query: %s\n", query)
    // Simulate query result
    return []map[string]interface{}{
        {"id": 1, "name": "Alice"},
        {"id": 2, "name": "Bob"},
    }, nil
}

func (pg *PostgreSQL) Execute(query string) error {
    if !pg.connected {
        return errors.New("not connected to database")
    }
    
    fmt.Printf("PostgreSQL executing: %s\n", query)
    return nil
}

// MongoDB implementation
type MongoDB struct {
    uri       string
    database  string
    connected bool
}

func NewMongoDB(uri, database string) *MongoDB {
    return &MongoDB{
        uri:      uri,
        database: database,
    }
}

func (m *MongoDB) Connect() error {
    fmt.Printf("Connecting to MongoDB at %s...\n", m.uri)
    m.connected = true
    return nil
}

func (m *MongoDB) Disconnect() error {
    fmt.Println("Disconnecting from MongoDB...")
    m.connected = false
    return nil
}

func (m *MongoDB) Query(query string) ([]map[string]interface{}, error) {
    if !m.connected {
        return nil, errors.New("not connected to database")
    }
    
    fmt.Printf("MongoDB executing query: %s\n", query)
    // Simulate query result
    return []map[string]interface{}{
        {"_id": "1", "name": "Charlie"},
        {"_id": "2", "name": "Diana"},
    }, nil
}

func (m *MongoDB) Execute(query string) error {
    if !m.connected {
        return errors.New("not connected to database")
    }
    
    fmt.Printf("MongoDB executing: %s\n", query)
    return nil
}

// Application layer - uses abstraction
type UserRepository struct {
    db Database // Abstract database, not concrete type
}

func NewUserRepository(db Database) *UserRepository {
    return &UserRepository{db: db}
}

func (ur *UserRepository) GetAllUsers() ([]map[string]interface{}, error) {
    return ur.db.Query("SELECT * FROM users")
}

func (ur *UserRepository) CreateUser(name, email string) error {
    query := fmt.Sprintf("INSERT INTO users (name, email) VALUES ('%s', '%s')", 
        name, email)
    return ur.db.Execute(query)
}

// Application doesn't care about database implementation!
func main() {
    // Can use PostgreSQL
    pgDB := NewPostgreSQL("localhost", 5432, "user", "pass", "mydb")
    
    repo1 := NewUserRepository(pgDB)
    pgDB.Connect()
    users, _ := repo1.GetAllUsers()
    fmt.Println("PostgreSQL users:", users)
    pgDB.Disconnect()
    
    fmt.Println()
    
    // Or switch to MongoDB - same code!
    mongoDB := NewMongoDB("mongodb://localhost:27017", "mydb")
    
    repo2 := NewUserRepository(mongoDB)
    mongoDB.Connect()
    users, _ = repo2.GetAllUsers()
    fmt.Println("MongoDB users:", users)
    mongoDB.Disconnect()
}
```

**Benefits of Abstraction:**

- Application code doesn't depend on concrete database
- Easy to switch databases
- Easy to test (use mock database)
- Loose coupling

---

## Method Receivers {#method-receivers}

Go has two types of method receivers: value receivers and pointer receivers. Understanding when to use each is crucial for OOP in Go.

### Value Receivers vs Pointer Receivers

```go
package main

import "fmt"

type Counter struct {
    Count int
}

// Value receiver - receives a copy
func (c Counter) IncrementValue() {
    c.Count++ // Modifies the copy, not original!
}

// Pointer receiver - receives a pointer
func (c *Counter) IncrementPointer() {
    c.Count++ // Modifies the original!
}

// Value receiver for read-only
func (c Counter) GetCount() int {
    return c.Count
}

func main() {
    counter := Counter{Count: 0}
    
    fmt.Println("Initial:", counter.Count) // 0
    
    counter.IncrementValue()
    fmt.Println("After value receiver:", counter.Count) // Still 0!
    
    counter.IncrementPointer()
    fmt.Println("After pointer receiver:", counter.Count) // 1
    
    counter.IncrementPointer()
    fmt.Println("After pointer receiver:", counter.Count) // 2
}
```

**Memory diagram:**

```
Value Receiver:

counter (original)
┌────────────────┐
│ Count: 0       │
└────────────────┘
        │
        │ Copy created
        ↓
┌────────────────┐
│ Count: 0 → 1   │ ← Method modifies copy
└────────────────┘

Original unchanged!


Pointer Receiver:

counter (original)
┌────────────────┐
│ Count: 0 → 1   │ ← Method modifies original
└────────────────┘
        ↑
        │ Pointer passed
        │
Method receives pointer to original
```

### When to Use Each

```go
package main

import "fmt"

// Small struct - value receiver OK
type Point struct {
    X, Y int
}

func (p Point) Add(other Point) Point {
    return Point{X: p.X + other.X, Y: p.Y + other.Y}
}

// Large struct - pointer receiver better
type LargeData struct {
    Data [1000000]int
}

func (ld *LargeData) Process() { // Pointer to avoid copying 8MB!
    // Process data
}

// Mutating method - must use pointer receiver
type BankAccount struct {
    Balance float64
}

func (ba *BankAccount) Deposit(amount float64) {
    ba.Balance += amount // Must use pointer to modify
}

// Read-only - value receiver is fine
func (ba BankAccount) GetBalance() float64 {
    return ba.Balance
}

// Consistency - if some methods use pointer, all should
type Person struct {
    Name string
    Age  int
}

func (p *Person) SetName(name string) {
    p.Name = name
}

func (p *Person) SetAge(age int) {
    p.Age = age
}

// Use pointer receiver for consistency, even for read-only
func (p *Person) GetName() string {
    return p.Name
}

func main() {
    // Point - small, value receiver
    p1 := Point{X: 1, Y: 2}
    p2 := Point{X: 3, Y: 4}
    p3 := p1.Add(p2)
    fmt.Println(p3) // {4 6}
    
    // BankAccount - pointer receiver for mutation
    account := &BankAccount{Balance: 100}
    account.Deposit(50)
    fmt.Println(account.GetBalance()) // 150
    
    // Person - pointer receiver for consistency
    person := &Person{Name: "Alice", Age: 30}
    person.SetAge(31)
    fmt.Println(person.GetName()) // Alice
}
```

**Rules of thumb:**

```
Use Pointer Receiver When:

1. Method modifies the receiver
   ✓ func (c *Counter) Increment()

2. Struct is large (>= 100 bytes)
   ✓ func (ld *LargeData) Process()

3. Consistency - if one method uses pointer, all should
   ✓ All methods on same type

4. Receiver contains sync.Mutex or similar
   ✓ func (c *Cache) Get(key string)


Use Value Receiver When:

1. Struct is small (a few fields)
   ✓ func (p Point) Add(other Point)

2. Method doesn't modify receiver
   ✓ func (p Point) Distance()

3. Receiver is immutable type
   ✓ func (t Time) Format()

4. Receiver is map, func, or chan
   ✓ These are already reference types
```

### Complete Example: Different Receiver Types

```go
package main

import (
    "fmt"
    "math"
)

// Immutable type - value receivers
type Vec2D struct {
    X, Y float64
}

func (v Vec2D) Add(other Vec2D) Vec2D {
    return Vec2D{X: v.X + other.X, Y: v.Y + other.Y}
}

func (v Vec2D) Scale(factor float64) Vec2D {
    return Vec2D{X: v.X * factor, Y: v.Y * factor}
}

func (v Vec2D) Length() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

// Mutable type - pointer receivers
type Wallet struct {
    balance float64
    owner   string
}

func NewWallet(owner string, initial float64) *Wallet {
    return &Wallet{owner: owner, balance: initial}
}

func (w *Wallet) Deposit(amount float64) {
    w.balance += amount
}

func (w *Wallet) Withdraw(amount float64) error {
    if amount > w.balance {
        return fmt.Errorf("insufficient funds")
    }
    w.balance -= amount
    return nil
}

func (w *Wallet) Balance() float64 {
    return w.balance
}

func (w *Wallet) Owner() string {
    return w.owner
}

func main() {
    // Vec2D - immutable operations
    v1 := Vec2D{X: 3, Y: 4}
    v2 := v1.Scale(2)        // Returns new Vec2D
    v3 := v1.Add(Vec2D{X: 1, Y: 1})
    
    fmt.Printf("v1: %+v (length: %.2f)\n", v1, v1.Length())
    fmt.Printf("v2: %+v\n", v2)
    fmt.Printf("v3: %+v\n", v3)
    
    // Wallet - mutable operations
    wallet := NewWallet("Alice", 100)
    wallet.Deposit(50)
    wallet.Withdraw(30)
    
    fmt.Printf("Owner: %s, Balance: %.2f\n", 
        wallet.Owner(), wallet.Balance())
}
```

## Interface Segregation {#interface-segregation}

The Interface Segregation Principle states that clients shouldn't be forced to depend on interfaces they don't use. Go's small interfaces naturally encourage this.

### Small, Focused Interfaces

```go
package main

import (
    "fmt"
    "io"
    "strings"
)

// Bad - Fat interface
type BadDataStore interface {
    Read() ([]byte, error)
    Write(data []byte) error
    Delete() error
    Backup() error
    Restore() error
    Compress() error
    Encrypt() error
    Decrypt() error
}

// Good - Segregated interfaces
type Reader interface {
    Read() ([]byte, error)
}

type Writer interface {
    Write(data []byte) error
}

type Deleter interface {
    Delete() error
}

type Backuper interface {
    Backup() error
    Restore() error
}

type Compressor interface {
    Compress() error
}

type Encryptor interface {
    Encrypt() error
    Decrypt() error
}

// Compose interfaces as needed
type ReadWriter interface {
    Reader
    Writer
}

type SecureStorage interface {
    Reader
    Writer
    Encryptor
}

// Implementation can implement multiple small interfaces
type FileStorage struct {
    filename string
    data     []byte
}

func (fs *FileStorage) Read() ([]byte, error) {
    return fs.data, nil
}

func (fs *FileStorage) Write(data []byte) error {
    fs.data = data
    return nil
}

func (fs *FileStorage) Delete() error {
    fs.data = nil
    return nil
}

// Function only needs Reader, not entire DataStore
func ProcessData(r Reader) error {
    data, err := r.Read()
    if err != nil {
        return err
    }
    fmt.Printf("Processing %d bytes\n", len(data))
    return nil
}

// Function only needs Writer
func SaveData(w Writer, data []byte) error {
    return w.Write(data)
}

func main() {
    storage := &FileStorage{filename: "data.txt"}
    
    // Can pass to functions needing only specific capabilities
    ProcessData(storage) // Uses only Reader interface
    SaveData(storage, []byte("Hello")) // Uses only Writer interface
}
```

### Standard Library Examples

Go's standard library demonstrates excellent interface segregation:

```go
package main

import (
    "bytes"
    "fmt"
    "io"
    "strings"
)

// io.Reader - single method interface
// type Reader interface {
//     Read(p []byte) (n int, err error)
// }

// io.Writer - single method interface
// type Writer interface {
//     Write(p []byte) (n int, err error)
// }

// io.Closer - single method interface
// type Closer interface {
//     Close() error
// }

// Composed interfaces
// type ReadWriter interface {
//     Reader
//     Writer
// }

// type ReadCloser interface {
//     Reader
//     Closer
// }

func main() {
    // strings.Reader implements io.Reader
    reader := strings.NewReader("Hello, World!")
    
    // bytes.Buffer implements io.Reader and io.Writer
    buffer := &bytes.Buffer{}
    
    // io.Copy works with any Reader and Writer
    io.Copy(buffer, reader)
    
    fmt.Println(buffer.String())
}
```

### Real-World Example: Logger Interfaces

```go
package main

import (
    "fmt"
    "os"
    "time"
)

// Small, focused interfaces
type InfoLogger interface {
    Info(message string)
}

type ErrorLogger interface {
    Error(message string)
}

type DebugLogger interface {
    Debug(message string)
}

type WarningLogger interface {
    Warning(message string)
}

// Compose as needed
type Logger interface {
    InfoLogger
    ErrorLogger
    DebugLogger
    WarningLogger
}

// Simple implementation
type ConsoleLogger struct {
    prefix string
}

func NewConsoleLogger(prefix string) *ConsoleLogger {
    return &ConsoleLogger{prefix: prefix}
}

func (cl *ConsoleLogger) Info(message string) {
    fmt.Printf("[%s] INFO: %s\n", cl.prefix, message)
}

func (cl *ConsoleLogger) Error(message string) {
    fmt.Fprintf(os.Stderr, "[%s] ERROR: %s\n", cl.prefix, message)
}

func (cl *ConsoleLogger) Debug(message string) {
    fmt.Printf("[%s] DEBUG: %s\n", cl.prefix, message)
}

func (cl *ConsoleLogger) Warning(message string) {
    fmt.Printf("[%s] WARNING: %s\n", cl.prefix, message)
}

// File logger implementation
type FileLogger struct {
    filename string
}

func NewFileLogger(filename string) *FileLogger {
    return &FileLogger{filename: filename}
}

func (fl *FileLogger) Info(message string) {
    fl.writeToFile(fmt.Sprintf("INFO: %s", message))
}

func (fl *FileLogger) Error(message string) {
    fl.writeToFile(fmt.Sprintf("ERROR: %s", message))
}

func (fl *FileLogger) Debug(message string) {
    fl.writeToFile(fmt.Sprintf("DEBUG: %s", message))
}

func (fl *FileLogger) Warning(message string) {
    fl.writeToFile(fmt.Sprintf("WARNING: %s", message))
}

func (fl *FileLogger) writeToFile(message string) {
    timestamp := time.Now().Format("2006-01-02 15:04:05")
    fullMessage := fmt.Sprintf("[%s] %s\n", timestamp, message)
    // In real implementation, write to file
    fmt.Printf("Writing to %s: %s", fl.filename, fullMessage)
}

// Function only needs ErrorLogger
func HandleError(logger ErrorLogger, err error) {
    if err != nil {
        logger.Error(err.Error())
    }
}

// Function only needs InfoLogger
func LogProgress(logger InfoLogger, step string) {
    logger.Info(fmt.Sprintf("Completed: %s", step))
}

func main() {
    // Both loggers implement all interfaces
    consoleLogger := NewConsoleLogger("APP")
    fileLogger := NewFileLogger("app.log")
    
    // Functions accept only what they need
    HandleError(consoleLogger, fmt.Errorf("connection failed"))
    LogProgress(consoleLogger, "database migration")
    
    HandleError(fileLogger, fmt.Errorf("disk full"))
    LogProgress(fileLogger, "cache warmed up")
}
```

---

## Dependency Injection {#dependency-injection}

Dependency Injection is providing dependencies from outside rather than creating them inside. This is key to testable, maintainable OOP code.

### Constructor Injection

```go
package main

import (
    "fmt"
)

// Interfaces
type Database interface {
    Query(query string) ([]string, error)
    Execute(query string) error
}

type Cache interface {
    Get(key string) (string, bool)
    Set(key string, value string)
}

type Logger interface {
    Log(message string)
}

// Service with dependencies
type UserService struct {
    db     Database
    cache  Cache
    logger Logger
}

// Constructor injection
func NewUserService(db Database, cache Cache, logger Logger) *UserService {
    return &UserService{
        db:     db,
        cache:  cache,
        logger: logger,
    }
}

func (us *UserService) GetUser(id string) (string, error) {
    us.logger.Log(fmt.Sprintf("Getting user %s", id))
    
    // Check cache first
    if cached, found := us.cache.Get(id); found {
        us.logger.Log("Cache hit")
        return cached, nil
    }
    
    // Query database
    results, err := us.db.Query(fmt.Sprintf("SELECT * FROM users WHERE id = '%s'", id))
    if err != nil {
        us.logger.Log(fmt.Sprintf("Database error: %v", err))
        return "", err
    }
    
    if len(results) > 0 {
        us.cache.Set(id, results[0])
        return results[0], nil
    }
    
    return "", fmt.Errorf("user not found")
}

// Mock implementations for testing
type MockDatabase struct {
    data map[string]string
}

func (m *MockDatabase) Query(query string) ([]string, error) {
    return []string{"mock_user"}, nil
}

func (m *MockDatabase) Execute(query string) error {
    return nil
}

type MockCache struct {
    data map[string]string
}

func NewMockCache() *MockCache {
    return &MockCache{data: make(map[string]string)}
}

func (m *MockCache) Get(key string) (string, bool) {
    val, ok := m.data[key]
    return val, ok
}

func (m *MockCache) Set(key string, value string) {
    m.data[key] = value
}

type MockLogger struct{}

func (m *MockLogger) Log(message string) {
    // Silent logger for tests
}

func main() {
    // Production: inject real implementations
    // service := NewUserService(realDB, realCache, realLogger)
    
    // Testing: inject mocks
    mockDB := &MockDatabase{}
    mockCache := NewMockCache()
    mockLogger := &MockLogger{}
    
    service := NewUserService(mockDB, mockCache, mockLogger)
    
    user, err := service.GetUser("123")
    if err != nil {
        fmt.Printf("Error: %v\n", err)
    } else {
        fmt.Printf("User: %s\n", user)
    }
}
```

### Complete DI Example: E-commerce Order System

```go
package main

import (
    "errors"
    "fmt"
    "time"
)

// Interfaces for dependencies
type PaymentGateway interface {
    ProcessPayment(amount float64, customerID string) (string, error)
}

type InventoryService interface {
    ReserveItems(items []string) error
    ReleaseItems(items []string) error
}

type NotificationService interface {
    SendEmail(to, subject, body string) error
    SendSMS(phone, message string) error
}

type AuditLogger interface {
    LogEvent(event, details string)
}

// Order system with injected dependencies
type OrderSystem struct {
    payment      PaymentGateway
    inventory    InventoryService
    notification NotificationService
    audit        AuditLogger
}

func NewOrderSystem(
    payment PaymentGateway,
    inventory InventoryService,
    notification NotificationService,
    audit AuditLogger,
) *OrderSystem {
    return &OrderSystem{
        payment:      payment,
        inventory:    inventory,
        notification: notification,
        audit:        audit,
    }
}

type Order struct {
    OrderID    string
    CustomerID string
    Email      string
    Phone      string
    Items      []string
    Total      float64
}

func (os *OrderSystem) PlaceOrder(order Order) error {
    os.audit.LogEvent("ORDER_STARTED", fmt.Sprintf("Order %s", order.OrderID))
    
    // Step 1: Reserve inventory
    if err := os.inventory.ReserveItems(order.Items); err != nil {
        os.audit.LogEvent("ORDER_FAILED", "Inventory reservation failed")
        return fmt.Errorf("inventory reservation failed: %w", err)
    }
    
    // Step 2: Process payment
    txID, err := os.payment.ProcessPayment(order.Total, order.CustomerID)
    if err != nil {
        // Rollback inventory
        os.inventory.ReleaseItems(order.Items)
        os.audit.LogEvent("ORDER_FAILED", "Payment failed")
        return fmt.Errorf("payment failed: %w", err)
    }
    
    os.audit.LogEvent("PAYMENT_SUCCESS", fmt.Sprintf("TX: %s", txID))
    
    // Step 3: Send confirmation
    emailBody := fmt.Sprintf("Your order %s has been placed. Total: $%.2f", 
        order.OrderID, order.Total)
    
    if err := os.notification.SendEmail(order.Email, "Order Confirmation", emailBody); err != nil {
        // Log but don't fail the order
        os.audit.LogEvent("NOTIFICATION_FAILED", "Email failed")
    }
    
    smsMessage := fmt.Sprintf("Order %s confirmed. Total: $%.2f", 
        order.OrderID, order.Total)
    
    if err := os.notification.SendSMS(order.Phone, smsMessage); err != nil {
        os.audit.LogEvent("NOTIFICATION_FAILED", "SMS failed")
    }
    
    os.audit.LogEvent("ORDER_COMPLETED", fmt.Sprintf("Order %s", order.OrderID))
    
    return nil
}

// Real implementations
type StripePaymentGateway struct{}

func (s *StripePaymentGateway) ProcessPayment(amount float64, customerID string) (string, error) {
    fmt.Printf("Processing $%.2f payment via Stripe for customer %s\n", 
        amount, customerID)
    return fmt.Sprintf("stripe_tx_%d", time.Now().Unix()), nil
}

type WarehouseInventory struct{}

func (w *WarehouseInventory) ReserveItems(items []string) error {
    fmt.Printf("Reserving items: %v\n", items)
    return nil
}

func (w *WarehouseInventory) ReleaseItems(items []string) error {
    fmt.Printf("Releasing items: %v\n", items)
    return nil
}

type EmailSMSService struct{}

func (e *EmailSMSService) SendEmail(to, subject, body string) error {
    fmt.Printf("Sending email to %s: %s\n", to, subject)
    return nil
}

func (e *EmailSMSService) SendSMS(phone, message string) error {
    fmt.Printf("Sending SMS to %s: %s\n", phone, message)
    return nil
}

type DatabaseAuditLogger struct{}

func (d *DatabaseAuditLogger) LogEvent(event, details string) {
    fmt.Printf("[AUDIT] %s: %s\n", event, details)
}

// Mock implementations for testing
type MockPaymentGateway struct {
    ShouldFail bool
}

func (m *MockPaymentGateway) ProcessPayment(amount float64, customerID string) (string, error) {
    if m.ShouldFail {
        return "", errors.New("payment declined")
    }
    return "mock_tx_123", nil
}

type MockInventory struct {
    ShouldFail bool
}

func (m *MockInventory) ReserveItems(items []string) error {
    if m.ShouldFail {
        return errors.New("out of stock")
    }
    return nil
}

func (m *MockInventory) ReleaseItems(items []string) error {
    return nil
}

type MockNotification struct{}

func (m *MockNotification) SendEmail(to, subject, body string) error {
    return nil
}

func (m *MockNotification) SendSMS(phone, message string) error {
    return nil
}

type MockAuditLogger struct {
    Events []string
}

func (m *MockAuditLogger) LogEvent(event, details string) {
    m.Events = append(m.Events, fmt.Sprintf("%s: %s", event, details))
}

func main() {
    // Production setup
    fmt.Println("=== Production Order ===")
    productionSystem := NewOrderSystem(
        &StripePaymentGateway{},
        &WarehouseInventory{},
        &EmailSMSService{},
        &DatabaseAuditLogger{},
    )
    
    order := Order{
        OrderID:    "ORD-001",
        CustomerID: "CUST-123",
        Email:      "customer@example.com",
        Phone:      "+1-555-0100",
        Items:      []string{"ITEM-1", "ITEM-2"},
        Total:      99.99,
    }
    
    if err := productionSystem.PlaceOrder(order); err != nil {
        fmt.Printf("Order failed: %v\n", err)
    }
    
    fmt.Println("\n=== Test with Mocks ===")
    // Testing setup with mocks
    mockAudit := &MockAuditLogger{}
    testSystem := NewOrderSystem(
        &MockPaymentGateway{ShouldFail: false},
        &MockInventory{ShouldFail: false},
        &MockNotification{},
        mockAudit,
    )
    
    testOrder := Order{
        OrderID:    "TEST-001",
        CustomerID: "TEST-CUST",
        Email:      "test@example.com",
        Phone:      "+1-555-0200",
        Items:      []string{"TEST-ITEM"},
        Total:      50.00,
    }
    
    if err := testSystem.PlaceOrder(testOrder); err != nil {
        fmt.Printf("Test order failed: %v\n", err)
    }
    
    fmt.Println("\nAudit trail:")
    for _, event := range mockAudit.Events {
        fmt.Println(event)
    }
}
```

---

## Design Patterns {#design-patterns}

Let's implement classic OOP design patterns in Go's idiomatic way.

### Factory Pattern

```go
package main

import (
    "fmt"
)

// Product interface
type Database interface {
    Connect() error
    Query(query string) ([]string, error)
}

// Concrete products
type MySQL struct {
    host string
    port int
}

func (m *MySQL) Connect() error {
    fmt.Printf("Connecting to MySQL at %s:%d\n", m.host, m.port)
    return nil
}

func (m *MySQL) Query(query string) ([]string, error) {
    return []string{"mysql_result"}, nil
}

type PostgreSQL struct {
    host string
    port int
}

func (p *PostgreSQL) Connect() error {
    fmt.Printf("Connecting to PostgreSQL at %s:%d\n", p.host, p.port)
    return nil
}

func (p *PostgreSQL) Query(query string) ([]string, error) {
    return []string{"postgres_result"}, nil
}

// Factory function
func NewDatabase(dbType string, host string, port int) (Database, error) {
    switch dbType {
    case "mysql":
        return &MySQL{host: host, port: port}, nil
    case "postgres":
        return &PostgreSQL{host: host, port: port}, nil
    default:
        return nil, fmt.Errorf("unknown database type: %s", dbType)
    }
}

func main() {
    db1, _ := NewDatabase("mysql", "localhost", 3306)
    db1.Connect()
    
    db2, _ := NewDatabase("postgres", "localhost", 5432)
    db2.Connect()
}
```

### Singleton Pattern

```go
package main

import (
    "fmt"
    "sync"
)

type Config struct {
    AppName string
    Version string
    Debug   bool
}

var (
    instance *Config
    once     sync.Once
)

// GetConfig returns singleton instance
func GetConfig() *Config {
    once.Do(func() {
        fmt.Println("Creating singleton instance")
        instance = &Config{
            AppName: "MyApp",
            Version: "1.0.0",
            Debug:   true,
        }
    })
    return instance
}

func main() {
    config1 := GetConfig()
    config2 := GetConfig()
    
    fmt.Printf("Same instance: %v\n", config1 == config2) // true
    fmt.Printf("Config: %+v\n", config1)
}
```

### Strategy Pattern

```go
package main

import "fmt"

// Strategy interface
type PaymentStrategy interface {
    Pay(amount float64) error
}

// Concrete strategies
type CreditCardPayment struct {
    cardNumber string
}

func (c *CreditCardPayment) Pay(amount float64) error {
    fmt.Printf("Paid $%.2f with credit card ending in %s\n", 
        amount, c.cardNumber[len(c.cardNumber)-4:])
    return nil
}

type PayPalPayment struct {
    email string
}

func (p *PayPalPayment) Pay(amount float64) error {
    fmt.Printf("Paid $%.2f with PayPal account %s\n", amount, p.email)
    return nil
}

type BitcoinPayment struct {
    walletAddress string
}

func (b *BitcoinPayment) Pay(amount float64) error {
    fmt.Printf("Paid $%.2f with Bitcoin to %s\n", amount, b.walletAddress)
    return nil
}

// Context
type ShoppingCart struct {
    items           []string
    total           float64
    paymentStrategy PaymentStrategy
}

func (sc *ShoppingCart) SetPaymentStrategy(strategy PaymentStrategy) {
    sc.paymentStrategy = strategy
}

func (sc *ShoppingCart) Checkout() error {
    if sc.paymentStrategy == nil {
        return fmt.Errorf("no payment method selected")
    }
    return sc.paymentStrategy.Pay(sc.total)
}

func main() {
    cart := &ShoppingCart{
        items: []string{"Item1", "Item2"},
        total: 99.99,
    }
    
    // Use different strategies
    cart.SetPaymentStrategy(&CreditCardPayment{cardNumber: "1234567890123456"})
    cart.Checkout()
    
    cart.SetPaymentStrategy(&PayPalPayment{email: "user@example.com"})
    cart.Checkout()
    
    cart.SetPaymentStrategy(&BitcoinPayment{walletAddress: "1A2B3C4D5E6F"})
    cart.Checkout()
}
```

### Observer Pattern

```go
package main

import "fmt"

// Observer interface
type Observer interface {
    Update(event string, data interface{})
}

// Subject
type EventManager struct {
    observers map[string][]Observer
}

func NewEventManager() *EventManager {
    return &EventManager{
        observers: make(map[string][]Observer),
    }
}

func (em *EventManager) Subscribe(event string, observer Observer) {
    em.observers[event] = append(em.observers[event], observer)
}

func (em *EventManager) Notify(event string, data interface{}) {
    for _, observer := range em.observers[event] {
        observer.Update(event, data)
    }
}

// Concrete observers
type EmailNotifier struct {
    email string
}

func (e *EmailNotifier) Update(event string, data interface{}) {
    fmt.Printf("Sending email to %s about %s: %v\n", e.email, event, data)
}

type SMSNotifier struct {
    phone string
}

func (s *SMSNotifier) Update(event string, data interface{}) {
    fmt.Printf("Sending SMS to %s about %s: %v\n", s.phone, event, data)
}

type LogNotifier struct{}

func (l *LogNotifier) Update(event string, data interface{}) {
    fmt.Printf("Logging event %s: %v\n", event, data)
}

func main() {
    manager := NewEventManager()
    
    // Subscribe observers
    manager.Subscribe("order_placed", &EmailNotifier{email: "customer@example.com"})
    manager.Subscribe("order_placed", &SMSNotifier{phone: "+1-555-0100"})
    manager.Subscribe("order_placed", &LogNotifier{})
    
    // Trigger event
    manager.Notify("order_placed", map[string]interface{}{
        "order_id": "ORD-123",
        "total":    99.99,
    })
}
```

### Decorator Pattern

```go
package main

import "fmt"

// Component interface
type Coffee interface {
    Cost() float64
    Description() string
}

// Concrete component
type SimpleCoffee struct{}

func (s *SimpleCoffee) Cost() float64 {
    return 2.0
}

func (s *SimpleCoffee) Description() string {
    return "Simple coffee"
}

// Decorator base
type CoffeeDecorator struct {
    coffee Coffee
}

// Concrete decorators
type MilkDecorator struct {
    CoffeeDecorator
}

func (m *MilkDecorator) Cost() float64 {
    return m.coffee.Cost() + 0.5
}

func (m *MilkDecorator) Description() string {
    return m.coffee.Description() + ", milk"
}

type SugarDecorator struct {
    CoffeeDecorator
}

func (s *SugarDecorator) Cost() float64 {
    return s.coffee.Cost() + 0.2
}

func (s *SugarDecorator) Description() string {
    return s.coffee.Description() + ", sugar"
}

type WhipDecorator struct {
    CoffeeDecorator
}

func (w *WhipDecorator) Cost() float64 {
    return w.coffee.Cost() + 0.7
}

func (w *WhipDecorator) Description() string {
    return w.coffee.Description() + ", whipped cream"
}

func main() {
    // Simple coffee
    coffee := &SimpleCoffee{}
    fmt.Printf("%s: $%.2f\n", coffee.Description(), coffee.Cost())
    
    // Coffee with milk
    milkCoffee := &MilkDecorator{CoffeeDecorator{coffee: coffee}}
    fmt.Printf("%s: $%.2f\n", milkCoffee.Description(), milkCoffee.Cost())
    
    // Coffee with milk and sugar
    sweetMilkCoffee := &SugarDecorator{CoffeeDecorator{coffee: milkCoffee}}
    fmt.Printf("%s: $%.2f\n", sweetMilkCoffee.Description(), sweetMilkCoffee.Cost())
    
    // Coffee with everything
    fancyCoffee := &WhipDecorator{CoffeeDecorator{coffee: sweetMilkCoffee}}
    fmt.Printf("%s: $%.2f\n", fancyCoffee.Description(), fancyCoffee.Cost())
}
```

---

## Real-World Examples {#real-world}

Let's build complete, production-ready examples combining all OOP concepts.

### Example: Complete REST API Service

```go
package main

import (
    "encoding/json"
    "fmt"
    "net/http"
    "sync"
)

// Domain model
type User struct {
    ID       string `json:"id"`
    Username string `json:"username"`
    Email    string `json:"email"`
}

// Repository interface (abstraction)
type UserRepository interface {
    Create(user *User) error
    GetByID(id string) (*User, error)
    GetAll() ([]*User, error)
    Update(user *User) error
    Delete(id string) error
}

// In-memory implementation (dependency injection)
type InMemoryUserRepository struct {
    mu    sync.RWMutex
    users map[string]*User
}

func NewInMemoryUserRepository() *InMemoryUserRepository {
    return &InMemoryUserRepository{
        users: make(map[string]*User),
    }
}

func (r *InMemoryUserRepository) Create(user *User) error {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    if _, exists := r.users[user.ID]; exists {
        return fmt.Errorf("user already exists")
    }
    
    r.users[user.ID] = user
    return nil
}

func (r *InMemoryUserRepository) GetByID(id string) (*User, error) {
    r.mu.RLock()
    defer r.mu.RUnlock()
    
    user, exists := r.users[id]
    if !exists {
        return nil, fmt.Errorf("user not found")
    }
    
    return user, nil
}

func (r *InMemoryUserRepository) GetAll() ([]*User, error) {
    r.mu.RLock()
    defer r.mu.RUnlock()
    
    users := make([]*User, 0, len(r.users))
    for _, user := range r.users {
        users = append(users, user)
    }
    
    return users, nil
}

func (r *InMemoryUserRepository) Update(user *User) error {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    if _, exists := r.users[user.ID]; !exists {
        return fmt.Errorf("user not found")
    }
    
    r.users[user.ID] = user
    return nil
}

func (r *InMemoryUserRepository) Delete(id string) error {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    if _, exists := r.users[id]; !exists {
        return fmt.Errorf("user not found")
    }
    
    delete(r.users, id)
    return nil
}

// Service layer (business logic)
type UserService struct {
    repo UserRepository
}

func NewUserService(repo UserRepository) *UserService {
    return &UserService{repo: repo}
}

func (s *UserService) CreateUser(user *User) error {
    // Business validation
    if user.Username == "" || user.Email == "" {
        return fmt.Errorf("username and email required")
    }
    
    return s.repo.Create(user)
}

func (s *UserService) GetUser(id string) (*User, error) {
    return s.repo.GetByID(id)
}

func (s *UserService) GetAllUsers() ([]*User, error) {
    return s.repo.GetAll()
}

func (s *UserService) UpdateUser(user *User) error {
    return s.repo.Update(user)
}

func (s *UserService) DeleteUser(id string) error {
    return s.repo.Delete(id)
}

// HTTP handler layer
type UserHandler struct {
    service *UserService
}

func NewUserHandler(service *UserService) *UserHandler {
    return &UserHandler{service: service}
}

func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
    var user User
    if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    if err := h.service.CreateUser(&user); err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(user)
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
    id := r.URL.Query().Get("id")
    
    user, err := h.service.GetUser(id)
    if err != nil {
        http.Error(w, err.Error(), http.StatusNotFound)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}

func (h *UserHandler) GetAllUsers(w http.ResponseWriter, r *http.Request) {
    users, err := h.service.GetAllUsers()
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(users)
}

func main() {
    // Dependency injection setup
    repo := NewInMemoryUserRepository()
    service := NewUserService(repo)
    handler := NewUserHandler(service)
    
    // Register routes
    http.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
        switch r.Method {
        case http.MethodPost:
            handler.CreateUser(w, r)
        case http.MethodGet:
            if r.URL.Query().Get("id") != "" {
                handler.GetUser(w, r)
            } else {
                handler.GetAllUsers(w, r)
            }
        default:
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }
    })
    
    fmt.Println("Server starting on :8080")
    http.ListenAndServe(":8080", nil)
}
```

## Summary

Go supports all major OOP concepts through its unique approach:

**Encapsulation** → Package-level access control (exported/unexported) **Inheritance** → Composition and embedding (not traditional inheritance) **Polymorphism** → Interfaces with implicit implementation **Abstraction** → Interfaces hide implementation details

**Key Takeaways:**

- Go prefers composition over inheritance
- Interfaces are implicit and small
- Dependency injection through interfaces
- All classic design patterns are possible
- Code is more testable and maintainable
- Less complexity than traditional OOP

Go's approach to OOP is simpler, more flexible, and arguably better than traditional class-based OOP!