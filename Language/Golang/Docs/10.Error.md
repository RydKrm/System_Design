# The Complete Guide to Go Error Handling - Part 1 of 2

## From Basic Errors to Custom Error Types and Best Practices

---

## Table of Contents - Complete Guide

### Part 1 (This Document)

1. [Introduction: Why Error Handling Matters](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#introduction-why-error-handling-matters)
2. [The Necessity of Proper Error Handling](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#the-necessity-of-proper-error-handling)
3. [Error Fundamentals in Go](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#error-fundamentals-in-go)
4. [Custom Error Types](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#custom-error-types)
5. [Error Wrapping and Unwrapping](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#error-wrapping-and-unwrapping)
6. [Real-World Use Cases](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#real-world-use-cases)

### Part 2

7. Error Handling Patterns and Best Practices
8. Sentinel Errors and Error Types
9. Global Error Handling Strategies
10. Error Handling in HTTP Services
11. Error Handling in gRPC Services
12. Advanced Error Patterns
13. Testing Error Handling
14. Production Error Management

---

## Introduction: Why Error Handling Matters

Imagine you're building a payment processing system. Without proper error handling, you might face these scenarios:

```go
// BAD: No error handling - disaster waiting to happen
func ProcessPayment(amount float64, cardNumber string) {
    // What if validation fails?
    card := ValidateCard(cardNumber)
    
    // What if charge fails?
    transaction := ChargeCard(card, amount)
    
    // What if database is down?
    SaveTransaction(transaction)
    
    // What if notification service is down?
    SendConfirmation(transaction.CustomerEmail)
    
    fmt.Println("Payment processed!")
    // User sees success, but ANY of the above could have failed silently!
}
```

**The Problems:**

1. **Silent Failures**: Operations fail but program continues
2. **Data Corruption**: Partial transactions leave inconsistent state
3. **Lost Money**: Payment charged but not recorded
4. **Poor User Experience**: Users see success when operation actually failed
5. **Impossible Debugging**: No information about what went wrong

With proper error handling:

```go
// GOOD: Comprehensive error handling
func ProcessPayment(amount float64, cardNumber string) error {
    // Validate card
    card, err := ValidateCard(cardNumber)
    if err != nil {
        return fmt.Errorf("card validation failed: %w", err)
    }
    
    // Charge card
    transaction, err := ChargeCard(card, amount)
    if err != nil {
        return fmt.Errorf("payment charge failed: %w", err)
    }
    
    // Save to database
    if err := SaveTransaction(transaction); err != nil {
        // Critical: Refund the charge!
        RefundCard(transaction)
        return fmt.Errorf("failed to save transaction: %w", err)
    }
    
    // Send confirmation (non-critical)
    if err := SendConfirmation(transaction.CustomerEmail); err != nil {
        // Log but don't fail the payment
        log.Printf("Warning: failed to send confirmation: %v", err)
    }
    
    return nil
}

// Usage with proper error handling
if err := ProcessPayment(99.99, "4111111111111111"); err != nil {
    log.Printf("Payment failed: %v", err)
    http.Error(w, "Payment processing failed", http.StatusInternalServerError)
    return
}

fmt.Println("Payment processed successfully!")
```

**The Benefits:**

```
Error Handling Flow:

Without Error Handling:
ValidateCard() ✗ fails silently
    ↓
ChargeCard() executes anyway
    ↓
SaveTransaction() fails silently
    ↓
SendConfirmation() fails silently
    ↓
"Success!" (but everything failed!)

With Error Handling:
ValidateCard() ✗ returns error
    ↓
Error returned immediately
    ↓
User sees failure message
    ↓
No charge, no database corruption
    ↓
System remains consistent
```

Proper error handling is the difference between a reliable system and a catastrophic one. In Go, errors are values—first-class citizens that you check explicitly. This makes error handling visible, predictable, and robust.

---

## The Necessity of Proper Error Handling

Error handling isn't optional—it's fundamental to building reliable software. Let's explore why through concrete problems.

### The Silent Failure Problem

Without error handling, failures are invisible until they cause catastrophic problems.

**Problem: No Error Propagation**

```go
// Dangerous: Ignoring errors
func SaveUserData(user *User) {
    json, _ := json.Marshal(user)  // Ignoring error!
    
    file, _ := os.Create("user.json")  // Ignoring error!
    defer file.Close()
    
    file.Write(json)  // Ignoring error!
    
    // Function returns successfully even if everything failed!
}

// Caller has no idea if it worked
SaveUserData(user)
fmt.Println("User saved!")  // Maybe... maybe not...
```

**Consequences:**

```
Timeline of Disaster:

Day 1: SaveUserData() silently fails
       → User data not saved
       → No error reported
       → Application continues

Day 2: User logs in
       → Expects their data
       → Finds empty profile
       → Contacts support

Day 3: Investigation begins
       → No error logs
       → No indication of failure
       → Can't reproduce issue
       → Data lost forever
```

**Solution: Explicit Error Handling**

```go
// Safe: Proper error handling
func SaveUserData(user *User) error {
    json, err := json.Marshal(user)
    if err != nil {
        return fmt.Errorf("failed to marshal user: %w", err)
    }
    
    file, err := os.Create("user.json")
    if err != nil {
        return fmt.Errorf("failed to create file: %w", err)
    }
    defer file.Close()
    
    if _, err := file.Write(json); err != nil {
        return fmt.Errorf("failed to write file: %w", err)
    }
    
    return nil
}

// Caller knows if it worked
if err := SaveUserData(user); err != nil {
    log.Printf("ERROR: Failed to save user: %v", err)
    http.Error(w, "Failed to save user data", http.StatusInternalServerError)
    return
}

fmt.Println("User saved successfully!")
```

### The Context Loss Problem

Errors without context make debugging impossible.

**Problem: Generic Errors**

```go
func ProcessOrder(orderID int64) error {
    order, err := GetOrder(orderID)
    if err != nil {
        return err  // What failed? GetOrder? Database? Network?
    }
    
    items, err := GetOrderItems(orderID)
    if err != nil {
        return err  // Same error message - which call failed?
    }
    
    if err := ChargeCustomer(order.CustomerID, order.Total); err != nil {
        return err  // No context about what amount or customer
    }
    
    return nil
}

// Error received: "connection refused"
// Which connection? To what? For which order?
// No way to know!
```

**Solution: Contextual Errors**

```go
func ProcessOrder(orderID int64) error {
    order, err := GetOrder(orderID)
    if err != nil {
        return fmt.Errorf("failed to get order %d: %w", orderID, err)
    }
    
    items, err := GetOrderItems(orderID)
    if err != nil {
        return fmt.Errorf("failed to get items for order %d: %w", orderID, err)
    }
    
    if err := ChargeCustomer(order.CustomerID, order.Total); err != nil {
        return fmt.Errorf(
            "failed to charge customer %d amount %.2f for order %d: %w",
            order.CustomerID, order.Total, orderID, err,
        )
    }
    
    return nil
}

// Error received: "failed to charge customer 123 amount 99.99 for order 456: connection refused"
// Now we know exactly what failed and all relevant context!
```

### The Error Type Problem

Different errors require different handling, but generic errors don't distinguish.

**Problem: Can't Distinguish Error Types**

```go
func FetchUserData(userID int64) (*User, error) {
    user, err := db.GetUser(userID)
    if err != nil {
        return nil, err
    }
    return user, nil
}

// Caller can't distinguish errors
user, err := FetchUserData(123)
if err != nil {
    // Is it "user not found" (404) or database error (500)?
    // Can't tell - must return generic 500
    http.Error(w, "Error", http.StatusInternalServerError)
    return
}
```

**Solution: Typed Errors**

```go
// Define error types
type NotFoundError struct {
    Resource string
    ID       int64
}

func (e *NotFoundError) Error() string {
    return fmt.Sprintf("%s not found: %d", e.Resource, e.ID)
}

type DatabaseError struct {
    Operation string
    Err       error
}

func (e *DatabaseError) Error() string {
    return fmt.Sprintf("database %s failed: %v", e.Operation, e.Err)
}

func FetchUserData(userID int64) (*User, error) {
    user, err := db.GetUser(userID)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, &NotFoundError{Resource: "user", ID: userID}
        }
        return nil, &DatabaseError{Operation: "get user", Err: err}
    }
    return user, nil
}

// Caller can distinguish errors and respond appropriately
user, err := FetchUserData(123)
if err != nil {
    var notFoundErr *NotFoundError
    if errors.As(err, &notFoundErr) {
        // User not found - return 404
        http.Error(w, "User not found", http.StatusNotFound)
        return
    }
    
    var dbErr *DatabaseError
    if errors.As(err, &dbErr) {
        // Database error - return 500 and alert ops
        log.Printf("DATABASE ERROR: %v", dbErr)
        http.Error(w, "Internal server error", http.StatusInternalServerError)
        return
    }
    
    // Unknown error - return 500
    http.Error(w, "Internal server error", http.StatusInternalServerError)
    return
}
```

### The Partial Failure Problem

Operations can fail partway through, leaving inconsistent state.

**Problem: No Rollback on Error**

```go
func CreateUserAccount(username, email, password string) error {
    // Create user in database
    user := &User{Username: username, Email: email}
    if err := db.CreateUser(user); err != nil {
        return err
    }
    
    // Create profile
    profile := &Profile{UserID: user.ID}
    if err := db.CreateProfile(profile); err != nil {
        // ERROR: User created but profile failed!
        // Database now inconsistent - user with no profile
        return err
    }
    
    // Send welcome email
    if err := SendWelcomeEmail(email); err != nil {
        // ERROR: User and profile created but email failed!
        // User exists but won't get welcome email
        return err
    }
    
    return nil
}

// Result: Database full of orphaned users and profiles!
```

**Solution: Transactional Error Handling**

```go
func CreateUserAccount(username, email, password string) error {
    // Start transaction
    tx, err := db.Begin()
    if err != nil {
        return fmt.Errorf("failed to start transaction: %w", err)
    }
    
    // Ensure transaction is handled
    defer func() {
        if p := recover(); p != nil {
            tx.Rollback()
            panic(p)
        }
    }()
    
    // Create user in transaction
    user := &User{Username: username, Email: email}
    if err := tx.CreateUser(user); err != nil {
        tx.Rollback()
        return fmt.Errorf("failed to create user: %w", err)
    }
    
    // Create profile in transaction
    profile := &Profile{UserID: user.ID}
    if err := tx.CreateProfile(profile); err != nil {
        tx.Rollback()
        return fmt.Errorf("failed to create profile: %w", err)
    }
    
    // Commit transaction
    if err := tx.Commit(); err != nil {
        tx.Rollback()
        return fmt.Errorf("failed to commit transaction: %w", err)
    }
    
    // Non-transactional: Send email after commit
    // If this fails, user account is still valid
    if err := SendWelcomeEmail(email); err != nil {
        // Log but don't fail - account is created
        log.Printf("Warning: failed to send welcome email to %s: %v", email, err)
    }
    
    return nil
}
```

---

## Error Fundamentals in Go

Go treats errors as values, not exceptions. Understanding this fundamental difference is key to effective error handling.

### The Error Interface

In Go, `error` is a built-in interface:

```go
type error interface {
    Error() string
}
```

Any type that implements an `Error() string` method satisfies the error interface.

**Basic Error Creation:**

```go
// Using errors.New()
err := errors.New("something went wrong")

// Using fmt.Errorf()
err := fmt.Errorf("failed to process user %d", userID)

// Both create error values with a message
```

### Creating Errors

**Method 1: errors.New()**

```go
import "errors"

func ValidateAge(age int) error {
    if age < 0 {
        return errors.New("age cannot be negative")
    }
    if age > 150 {
        return errors.New("age is unrealistic")
    }
    return nil
}
```

**Method 2: fmt.Errorf()**

```go
import "fmt"

func GetUser(id int64) (*User, error) {
    if id <= 0 {
        return nil, fmt.Errorf("invalid user ID: %d", id)
    }
    
    // Query database...
    if userNotFound {
        return nil, fmt.Errorf("user not found with ID: %d", id)
    }
    
    return user, nil
}
```

**Method 3: Custom Error Type**

```go
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation failed for %s: %s", e.Field, e.Message)
}

func ValidateUser(user *User) error {
    if user.Username == "" {
        return &ValidationError{
            Field:   "username",
            Message: "cannot be empty",
        }
    }
    return nil
}
```

### Error Checking Patterns

**Pattern 1: Immediate Check**

```go
result, err := SomeOperation()
if err != nil {
    // Handle error
    return err
}
// Use result
```

**Pattern 2: Multiple Operations**

```go
func ProcessData() error {
    data, err := ReadData()
    if err != nil {
        return fmt.Errorf("failed to read data: %w", err)
    }
    
    processed, err := TransformData(data)
    if err != nil {
        return fmt.Errorf("failed to transform data: %w", err)
    }
    
    if err := SaveData(processed); err != nil {
        return fmt.Errorf("failed to save data: %w", err)
    }
    
    return nil
}
```

**Pattern 3: Deferred Error Handling**

```go
func WriteFile(filename string, data []byte) (err error) {
    f, err := os.Create(filename)
    if err != nil {
        return fmt.Errorf("failed to create file: %w", err)
    }
    
    defer func() {
        if closeErr := f.Close(); closeErr != nil && err == nil {
            err = fmt.Errorf("failed to close file: %w", closeErr)
        }
    }()
    
    if _, err = f.Write(data); err != nil {
        return fmt.Errorf("failed to write file: %w", err)
    }
    
    return nil
}
```

### Error vs Panic

Go has two mechanisms for signaling failures: errors and panics.

**Errors - For Expected Failures:**

```go
func ParseInt(s string) (int, error) {
    n, err := strconv.Atoi(s)
    if err != nil {
        return 0, fmt.Errorf("invalid integer: %s", s)
    }
    return n, nil
}

// Caller expects this might fail
n, err := ParseInt("abc")
if err != nil {
    // Handle gracefully
    log.Printf("Parse failed: %v", err)
}
```

**Panics - For Unexpected, Unrecoverable Failures:**

```go
func GetConfig() *Config {
    config, err := LoadConfig("config.yaml")
    if err != nil {
        // Configuration is required - cannot continue
        panic(fmt.Sprintf("Failed to load config: %v", err))
    }
    return config
}

// Or let panic propagate from nil dereference
func MustGetUser(id int64) *User {
    user, err := GetUser(id)
    if err != nil {
        panic(fmt.Sprintf("Failed to get user %d: %v", id, err))
    }
    return user
}
```

**When to Use Each:**

```
Use ERRORS when:
✓ Failure is expected or possible (network issues, file not found, invalid input)
✓ Caller can handle the failure
✓ Multiple errors are possible
✓ Operation is part of normal flow

Use PANIC when:
✓ Failure indicates programmer error (array out of bounds, nil pointer)
✓ System is in unrecoverable state
✓ During initialization (configuration missing)
✓ Internal consistency violation

Example Decision Tree:
- File not found? → Error (expected)
- Invalid user input? → Error (expected)
- Network timeout? → Error (expected)
- Array index out of bounds? → Panic (programmer error)
- Nil pointer dereference? → Panic (programmer error)
- Config file missing at startup? → Panic (cannot continue)
```

---

## Custom Error Types

Custom error types enable rich error information and type-based error handling.

### Basic Custom Error

```go
type ValidationError struct {
    Field   string
    Value   interface{}
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation failed: %s=%v: %s", e.Field, e.Value, e.Message)
}

// Usage
func ValidateEmail(email string) error {
    if !strings.Contains(email, "@") {
        return &ValidationError{
            Field:   "email",
            Value:   email,
            Message: "must contain @",
        }
    }
    return nil
}

// Checking error type
err := ValidateEmail("invalid")
if err != nil {
    var valErr *ValidationError
    if errors.As(err, &valErr) {
        fmt.Printf("Field: %s, Value: %v, Message: %s\n",
            valErr.Field, valErr.Value, valErr.Message)
    }
}
```

### Multi-Field Validation Error

```go
type ValidationErrors struct {
    Errors []FieldError
}

type FieldError struct {
    Field   string
    Value   interface{}
    Message string
}

func (ve *ValidationErrors) Error() string {
    var messages []string
    for _, err := range ve.Errors {
        messages = append(messages, fmt.Sprintf("%s: %s", err.Field, err.Message))
    }
    return strings.Join(messages, "; ")
}

func (ve *ValidationErrors) Add(field string, value interface{}, message string) {
    ve.Errors = append(ve.Errors, FieldError{
        Field:   field,
        Value:   value,
        Message: message,
    })
}

func (ve *ValidationErrors) HasErrors() bool {
    return len(ve.Errors) > 0
}

// Usage
func ValidateUser(user *User) error {
    errs := &ValidationErrors{}
    
    if user.Username == "" {
        errs.Add("username", user.Username, "cannot be empty")
    }
    
    if len(user.Username) < 3 {
        errs.Add("username", user.Username, "must be at least 3 characters")
    }
    
    if !strings.Contains(user.Email, "@") {
        errs.Add("email", user.Email, "must be valid email")
    }
    
    if len(user.Password) < 8 {
        errs.Add("password", "***", "must be at least 8 characters")
    }
    
    if errs.HasErrors() {
        return errs
    }
    
    return nil
}

// Handler can extract all errors
err := ValidateUser(user)
if err != nil {
    var valErrs *ValidationErrors
    if errors.As(err, &valErrs) {
        // Return all validation errors to client
        response := make(map[string]string)
        for _, fieldErr := range valErrs.Errors {
            response[fieldErr.Field] = fieldErr.Message
        }
        json.NewEncoder(w).Encode(response)
        return
    }
}
```

### Error with HTTP Status Code

```go
type HTTPError struct {
    StatusCode int
    Message    string
    Internal   error  // Wrapped error with more details
}

func (e *HTTPError) Error() string {
    if e.Internal != nil {
        return fmt.Sprintf("%s: %v", e.Message, e.Internal)
    }
    return e.Message
}

func (e *HTTPError) Unwrap() error {
    return e.Internal
}

// Constructor functions
func NewNotFoundError(message string, err error) *HTTPError {
    return &HTTPError{
        StatusCode: http.StatusNotFound,
        Message:    message,
        Internal:   err,
    }
}

func NewBadRequestError(message string, err error) *HTTPError {
    return &HTTPError{
        StatusCode: http.StatusBadRequest,
        Message:    message,
        Internal:   err,
    }
}

func NewInternalError(message string, err error) *HTTPError {
    return &HTTPError{
        StatusCode: http.StatusInternalServerError,
        Message:    message,
        Internal:   err,
    }
}

// Usage in handler
func GetUserHandler(w http.ResponseWriter, r *http.Request) {
    id, err := strconv.ParseInt(r.URL.Query().Get("id"), 10, 64)
    if err != nil {
        sendError(w, NewBadRequestError("invalid user ID", err))
        return
    }
    
    user, err := GetUser(id)
    if err != nil {
        sendError(w, err)
        return
    }
    
    json.NewEncoder(w).Encode(user)
}

func sendError(w http.ResponseWriter, err error) {
    var httpErr *HTTPError
    if errors.As(err, &httpErr) {
        http.Error(w, httpErr.Message, httpErr.StatusCode)
        
        // Log internal error if present
        if httpErr.Internal != nil {
            log.Printf("Internal error: %v", httpErr.Internal)
        }
    } else {
        http.Error(w, "Internal server error", http.StatusInternalServerError)
        log.Printf("Unexpected error: %v", err)
    }
}

func GetUser(id int64) (*User, error) {
    user, err := db.QueryUser(id)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, NewNotFoundError("user not found", err)
        }
        return nil, NewInternalError("database error", err)
    }
    return user, nil
}
```

### Error with Stack Trace

```go
type ErrorWithStack struct {
    Message string
    Err     error
    Stack   []byte
}

func (e *ErrorWithStack) Error() string {
    return e.Message
}

func (e *ErrorWithStack) Unwrap() error {
    return e.Err
}

func (e *ErrorWithStack) StackTrace() string {
    return string(e.Stack)
}

func NewErrorWithStack(message string, err error) *ErrorWithStack {
    stack := make([]byte, 4096)
    n := runtime.Stack(stack, false)
    
    return &ErrorWithStack{
        Message: message,
        Err:     err,
        Stack:   stack[:n],
    }
}

// Usage
func ProcessCriticalOperation() error {
    if err := performOperation(); err != nil {
        return NewErrorWithStack("critical operation failed", err)
    }
    return nil
}

// In error handler
if err != nil {
    var stackErr *ErrorWithStack
    if errors.As(err, &stackErr) {
        log.Printf("Error: %v\nStack trace:\n%s", err, stackErr.StackTrace())
    }
}
```

### Temporary Error (Retryable)

```go
type TemporaryError struct {
    Err       error
    Retryable bool
}

func (e *TemporaryError) Error() string {
    return e.Err.Error()
}

func (e *TemporaryError) Unwrap() error {
    return e.Err
}

func (e *TemporaryError) Temporary() bool {
    return e.Retryable
}

// Check if error is temporary
func IsTemporary(err error) bool {
    type temporary interface {
        Temporary() bool
    }
    
    te, ok := err.(temporary)
    return ok && te.Temporary()
}

// Usage with retry logic
func CallExternalAPI() error {
    maxRetries := 3
    var lastErr error
    
    for i := 0; i < maxRetries; i++ {
        err := makeAPICall()
        if err == nil {
            return nil
        }
        
        lastErr = err
        
        // Retry only if temporary
        if !IsTemporary(err) {
            return err
        }
        
        time.Sleep(time.Second * time.Duration(i+1))
    }
    
    return fmt.Errorf("failed after %d retries: %w", maxRetries, lastErr)
}

func makeAPICall() error {
    // Network timeout - temporary
    if networkTimeout {
        return &TemporaryError{
            Err:       errors.New("network timeout"),
            Retryable: true,
        }
    }
    
    // Authentication error - not temporary
    if authFailed {
        return errors.New("authentication failed")
    }
    
    return nil
}
```

---

## Error Wrapping and Unwrapping

Go 1.13 introduced error wrapping, enabling error chains with context at each level.

### Basic Wrapping with %w

```go
func ReadConfig(filename string) (*Config, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        // Wrap error with context using %w
        return nil, fmt.Errorf("failed to read config file %s: %w", filename, err)
    }
    
    var config Config
    if err := json.Unmarshal(data, &config); err != nil {
        return nil, fmt.Errorf("failed to parse config file %s: %w", filename, err)
    }
    
    return &config, nil
}

// Error chain:
// "failed to parse config file app.yaml: invalid character '{' at line 5"
//                                         └─ Original error wrapped
```

### The %v vs %w Difference

```go
// %v - Does NOT wrap (loses error identity)
err1 := fmt.Errorf("operation failed: %v", originalErr)

// Can't check original error
if errors.Is(err1, originalErr) {  // false!
}

// %w - DOES wrap (preserves error identity)
err2 := fmt.Errorf("operation failed: %w", originalErr)

// Can check original error
if errors.Is(err2, originalErr) {  // true!
}
```

**When to Use Each:**

```go
// Use %w when:
// - Caller might need to check error type
// - Error should be inspectable
// - Building error chain for debugging

err := DoSomething()
if err != nil {
    return fmt.Errorf("context: %w", err)  // Wrap
}

// Use %v when:
// - Hiding implementation details
// - Error is logged but not returned
// - Want to break error chain intentionally

err := internalOperation()
if err != nil {
    log.Printf("Internal error: %v", err)  // Log details
    return errors.New("operation failed")  // Generic error to caller
}
```

### errors.Is() - Checking Wrapped Errors

```go
var ErrNotFound = errors.New("not found")

func GetUser(id int64) (*User, error) {
    user, err := db.Query(id)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, fmt.Errorf("user %d: %w", id, ErrNotFound)
        }
        return nil, err
    }
    return user, nil
}

// Caller can check for ErrNotFound even when wrapped
user, err := GetUser(123)
if err != nil {
    if errors.Is(err, ErrNotFound) {
        // Handle not found case
        http.Error(w, "User not found", http.StatusNotFound)
        return
    }
    
    // Handle other errors
    http.Error(w, "Internal error", http.StatusInternalServerError)
    return
}
```

**How errors.Is() Works:**

```
Error Chain:
"failed to fetch user 123: user 123: not found"
                            └─ wraps ErrNotFound

errors.Is(err, ErrNotFound) checks:
1. Is err == ErrNotFound? No
2. Unwrap err, check again
3. Is unwrapped == ErrNotFound? No
4. Unwrap again, check again
5. Is unwrapped == ErrNotFound? Yes! → return true
```

### errors.As() - Type Assertions on Wrapped Errors

```go
type ValidationError struct {
    Field string
    Value string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation failed: %s = %s", e.Field, e.Value)
}

func ProcessInput(input string) error {
    if input == "" {
        return &ValidationError{Field: "input", Value: input}
    }
    
    if err := saveInput(input); err != nil {
        // Wrap ValidationError with context
        return fmt.Errorf("failed to save: %w", err)
    }
    
    return nil
}

// Caller can extract ValidationError even when wrapped
err := ProcessInput("")
if err != nil {
    var valErr *ValidationError
    if errors.As(err, &valErr) {
        // Got the ValidationError!
        fmt.Printf("Field: %s, Value: %s\n", valErr.Field, valErr.Value)
        return
    }
    
    // Different error type
    fmt.Printf("Unknown error: %v\n", err)
}
```

**How errors.As() Works:**

```
Error Chain:
"failed to save: validation failed: input = ''"
                 └─ wraps *ValidationError

errors.As(err, &valErr) checks:
1. Can err be assigned to *ValidationError? No
2. Unwrap err, check again
3. Can unwrapped be assigned to *ValidationError? Yes!
4. Assign valErr = unwrapped
5. Return true
```

### Building Error Chains

```go
// Layer 1: Database
func (db *DB) QueryUser(id int64) (*User, error) {
    row := db.conn.QueryRow("SELECT * FROM users WHERE id = $1", id)
    
    var user User
    if err := row.Scan(&user.ID, &user.Username); err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, fmt.Errorf("user ID %d: %w", id, ErrNotFound)
        }
        return nil, fmt.Errorf("database query failed: %w", err)
    }
    
    return &user, nil
}

// Layer 2: Repository
func (r *UserRepository) GetUser(id int64) (*User, error) {
    user, err := r.db.QueryUser(id)
    if err != nil {
        return nil, fmt.Errorf("repository get user: %w", err)
    }
    return user, nil
}

// Layer 3: Service
func (s *UserService) GetUserProfile(id int64) (*UserProfile, error) {
    user, err := s.repo.GetUser(id)
    if err != nil {
        return nil, fmt.Errorf("service get profile: %w", err)
    }
    
    // Build profile...
    return profile, nil
}

// Layer 4: Handler
func GetProfileHandler(w http.ResponseWriter, r *http.Request) {
    id := getIDFromRequest(r)
    
    profile, err := service.GetUserProfile(id)
    if err != nil {
        // Full error chain for logging
        log.Printf("ERROR: %v", err)
        // Output: "ERROR: service get profile: repository get user: user ID 123: not found"
        
        // Check error type for response
        if errors.Is(err, ErrNotFound) {
            http.Error(w, "User not found", http.StatusNotFound)
        } else {
            http.Error(w, "Internal error", http.StatusInternalServerError)
        }
        return
    }
    
    json.NewEncoder(w).Encode(profile)
}
```

### Custom Unwrap Implementation

```go
type MultiError struct {
    Errors []error
}

func (me *MultiError) Error() string {
    var messages []string
    for _, err := range me.Errors {
        messages = append(messages, err.Error())
    }
    return strings.Join(messages, "; ")
}

// Custom Unwrap returns first error
func (me *MultiError) Unwrap() error {
    if len(me.Errors) == 0 {
        return nil
    }
    return me.Errors[0]
}

// Or implement Is/As for more control
func (me *MultiError) Is(target error) bool {
    for _, err := range me.Errors {
        if errors.Is(err, target) {
            return true
        }
    }
    return false
}

func (me *MultiError) As(target interface{}) bool {
    for _, err := range me.Errors {
        if errors.As(err, target) {
            return true
        }
    }
    return false
}
```

---

## Real-World Use Cases

Let's explore comprehensive error handling in production scenarios.

### Use Case 1: REST API with Comprehensive Error Handling

```go
// Custom error types
type APIError struct {
    StatusCode int              `json:"-"`
    Code       string           `json:"code"`
    Message    string           `json:"message"`
    Details    map[string]string `json:"details,omitempty"`
    Internal   error            `json:"-"`
}

func (e *APIError) Error() string {
    if e.Internal != nil {
        return fmt.Sprintf("%s: %v", e.Message, e.Internal)
    }
    return e.Message
}

func (e *APIError) Unwrap() error {
    return e.Internal
}

// Error constructors
func NewBadRequest(message string, details map[string]string) *APIError {
    return &APIError{
        StatusCode: http.StatusBadRequest,
        Code:       "BAD_REQUEST",
        Message:    message,
        Details:    details,
    }
}

func NewNotFound(resource string, id interface{}) *APIError {
    return &APIError{
        StatusCode: http.StatusNotFound,
        Code:       "NOT_FOUND",
        Message:    fmt.Sprintf("%s not found: %v", resource, id),
    }
}

func NewInternalError(message string, err error) *APIError {
    return &APIError{
        StatusCode: http.StatusInternalServerError,
        Code:       "INTERNAL_ERROR",
        Message:    message,
        Internal:   err,
    }
}

// User service with error handling
type UserService struct {
    repo UserRepository
}

func (s *UserService) CreateUser(input *CreateUserInput) (*User, error) {
    // Validate input
    if err := s.validateCreateInput(input); err != nil {
        return nil, err
    }
    
    // Check if email exists
    existing, err := s.repo.FindByEmail(input.Email)
    if err != nil && !errors.Is(err, ErrNotFound) {
        return nil, NewInternalError("failed to check existing user", err)
    }
    
    if existing != nil {
        return nil, NewBadRequest("email already registered", map[string]string{
            "email": "already in use",
        })
    }
    
    // Create user
    user := &User{
        Username: input.Username,
        Email:    input.Email,
        Password: hashPassword(input.Password),
    }
    
    if err := s.repo.Create(user); err != nil {
        return nil, NewInternalError("failed to create user", err)
    }
    
    return user, nil
}

func (s *UserService) validateCreateInput(input *CreateUserInput) error {
    details := make(map[string]string)
    
    if input.Username == "" {
        details["username"] = "required"
    } else if len(input.Username) < 3 {
        details["username"] = "must be at least 3 characters"
    }
    
    if input.Email == "" {
        details["email"] = "required"
    } else if !strings.Contains(input.Email, "@") {
        details["email"] = "invalid format"
    }
    
    if input.Password == "" {
        details["password"] = "required"
    } else if len(input.Password) < 8 {
        details["password"] = "must be at least 8 characters"
    }
    
    if len(details) > 0 {
        return NewBadRequest("validation failed", details)
    }
    
    return nil
}

// HTTP Handler
func CreateUserHandler(service *UserService) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        var input CreateUserInput
        if err := json.NewDecoder(r.Body).Decode(&input); err != nil {
            sendAPIError(w, NewBadRequest("invalid JSON", nil))
            return
        }
        
        user, err := service.CreateUser(&input)
        if err != nil {
            sendAPIError(w, err)
            return
        }
        
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(user)
    }
}

func sendAPIError(w http.ResponseWriter, err error) {
    var apiErr *APIError
    if !errors.As(err, &apiErr) {
        // Not an APIError - create one
        apiErr = NewInternalError("unexpected error", err)
    }
    
    // Log internal errors
    if apiErr.Internal != nil {
        log.Printf("API Error: %v | Internal: %v", apiErr.Message, apiErr.Internal)
    }
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(apiErr.StatusCode)
    json.NewEncoder(w).Encode(apiErr)
}
```

This completes Part 1. Continue to Part 2 for:

- Global error handling strategies
- Error handling in HTTP and gRPC services
- Advanced patterns (circuit breakers, retry logic)
- Production error management
- Testing error handling

# The Complete Guide to Go Error Handling - Part 2 of 2

## Global Error Handling, Advanced Patterns, and Production Strategies

---

## Global Error Handling Strategies

Global error handling provides centralized error management across your application.

### Strategy 1: Centralized Error Handler Middleware

```go
// Global error handler for HTTP applications
type ErrorHandler struct {
    logger Logger
    debug  bool
}

func NewErrorHandler(logger Logger, debug bool) *ErrorHandler {
    return &ErrorHandler{
        logger: logger,
        debug:  debug,
    }
}

// Middleware wraps handlers and catches errors
func (eh *ErrorHandler) Middleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Create custom response writer to capture status
        rw := &responseWriter{
            ResponseWriter: w,
            statusCode:     http.StatusOK,
        }
        
        // Recover from panics
        defer func() {
            if err := recover(); err != nil {
                eh.handlePanic(rw, r, err)
            }
        }()
        
        // Call next handler
        next.ServeHTTP(rw, r)
        
        // Log successful requests
        if rw.statusCode < 400 {
            eh.logger.Info("request completed",
                "method", r.Method,
                "path", r.URL.Path,
                "status", rw.statusCode,
            )
        }
    })
}

func (eh *ErrorHandler) handlePanic(w http.ResponseWriter, r *http.Request, recovered interface{}) {
    // Get stack trace
    stack := make([]byte, 4096)
    n := runtime.Stack(stack, false)
    
    // Log panic with full context
    eh.logger.Error("panic recovered",
        "error", recovered,
        "method", r.Method,
        "path", r.URL.Path,
        "stack", string(stack[:n]),
    )
    
    // Send error response
    response := ErrorResponse{
        Code:    "INTERNAL_ERROR",
        Message: "Internal server error",
    }
    
    if eh.debug {
        response.Debug = &DebugInfo{
            Panic: fmt.Sprintf("%v", recovered),
            Stack: string(stack[:n]),
        }
    }
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusInternalServerError)
    json.NewEncoder(w).Encode(response)
}

type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}

// Error response structure
type ErrorResponse struct {
    Code    string                 `json:"code"`
    Message string                 `json:"message"`
    Details map[string]interface{} `json:"details,omitempty"`
    Debug   *DebugInfo            `json:"debug,omitempty"`
}

type DebugInfo struct {
    Panic string `json:"panic,omitempty"`
    Stack string `json:"stack,omitempty"`
}
```

### Strategy 2: Application-Wide Error Handler

```go
// Global error handler singleton
type GlobalErrorHandler struct {
    logger      Logger
    alerter     Alerter
    metrics     MetricsCollector
    rateLimiter *RateLimiter
}

var (
    globalHandler *GlobalErrorHandler
    once          sync.Once
)

func InitGlobalErrorHandler(logger Logger, alerter Alerter, metrics MetricsCollector) {
    once.Do(func() {
        globalHandler = &GlobalErrorHandler{
            logger:      logger,
            alerter:     alerter,
            metrics:     metrics,
            rateLimiter: NewRateLimiter(10, time.Minute), // Max 10 alerts per minute
        }
    })
}

func GetGlobalErrorHandler() *GlobalErrorHandler {
    if globalHandler == nil {
        panic("global error handler not initialized")
    }
    return globalHandler
}

// Handle error with severity levels
func (h *GlobalErrorHandler) Handle(ctx context.Context, err error, severity ErrorSeverity) {
    // Extract error details
    details := h.extractErrorDetails(err)
    
    // Log error
    h.logError(ctx, err, severity, details)
    
    // Collect metrics
    h.metrics.IncrementError(details.Type, severity.String())
    
    // Alert if critical
    if severity >= SeverityCritical {
        h.sendAlert(ctx, err, details)
    }
}

func (h *GlobalErrorHandler) extractErrorDetails(err error) ErrorDetails {
    details := ErrorDetails{
        Message: err.Error(),
        Type:    "unknown",
    }
    
    // Extract HTTP errors
    var httpErr *HTTPError
    if errors.As(err, &httpErr) {
        details.Type = "http_error"
        details.StatusCode = httpErr.StatusCode
        details.Code = httpErr.Code
    }
    
    // Extract database errors
    var dbErr *DatabaseError
    if errors.As(err, &dbErr) {
        details.Type = "database_error"
        details.Operation = dbErr.Operation
    }
    
    // Extract validation errors
    var valErr *ValidationError
    if errors.As(err, &valErr) {
        details.Type = "validation_error"
        details.Fields = valErr.Fields()
    }
    
    return details
}

func (h *GlobalErrorHandler) logError(ctx context.Context, err error, severity ErrorSeverity, details ErrorDetails) {
    logFunc := h.logger.Error
    
    switch severity {
    case SeverityWarning:
        logFunc = h.logger.Warn
    case SeverityInfo:
        logFunc = h.logger.Info
    }
    
    logFunc("error occurred",
        "message", details.Message,
        "type", details.Type,
        "severity", severity.String(),
        "request_id", getRequestID(ctx),
        "user_id", getUserID(ctx),
        "error", err,
    )
}

func (h *GlobalErrorHandler) sendAlert(ctx context.Context, err error, details ErrorDetails) {
    // Rate limit alerts
    if !h.rateLimiter.Allow() {
        h.logger.Warn("alert rate limited", "error", err.Error())
        return
    }
    
    alert := Alert{
        Title:     "Critical Error",
        Message:   details.Message,
        Severity:  "critical",
        Timestamp: time.Now(),
        Context: map[string]interface{}{
            "error_type": details.Type,
            "request_id": getRequestID(ctx),
            "user_id":    getUserID(ctx),
        },
    }
    
    // Send to alerting system (PagerDuty, Slack, etc.)
    if err := h.alerter.Send(alert); err != nil {
        h.logger.Error("failed to send alert", "error", err)
    }
}

// Error severity levels
type ErrorSeverity int

const (
    SeverityInfo ErrorSeverity = iota
    SeverityWarning
    SeverityError
    SeverityCritical
)

func (s ErrorSeverity) String() string {
    switch s {
    case SeverityInfo:
        return "info"
    case SeverityWarning:
        return "warning"
    case SeverityError:
        return "error"
    case SeverityCritical:
        return "critical"
    default:
        return "unknown"
    }
}

// Usage in application
func ProcessPayment(ctx context.Context, payment *Payment) error {
    handler := GetGlobalErrorHandler()
    
    if err := validatePayment(payment); err != nil {
        handler.Handle(ctx, err, SeverityWarning)
        return err
    }
    
    if err := chargeCard(payment); err != nil {
        handler.Handle(ctx, err, SeverityCritical)
        return err
    }
    
    if err := savePayment(payment); err != nil {
        handler.Handle(ctx, err, SeverityCritical)
        return err
    }
    
    return nil
}
```

### Strategy 3: Context-Based Error Tracking

```go
// Context key for error tracking
type contextKey string

const errorContextKey contextKey = "error_context"

// ErrorContext holds request-scoped error information
type ErrorContext struct {
    RequestID   string
    UserID      string
    Path        string
    Method      string
    Errors      []ErrorEntry
    StartTime   time.Time
    mu          sync.Mutex
}

type ErrorEntry struct {
    Error     error
    Timestamp time.Time
    Component string
    Severity  ErrorSeverity
}

func NewErrorContext(requestID, userID, path, method string) *ErrorContext {
    return &ErrorContext{
        RequestID: requestID,
        UserID:    userID,
        Path:      path,
        Method:    method,
        StartTime: time.Now(),
        Errors:    make([]ErrorEntry, 0),
    }
}

func (ec *ErrorContext) AddError(err error, component string, severity ErrorSeverity) {
    ec.mu.Lock()
    defer ec.mu.Unlock()
    
    ec.Errors = append(ec.Errors, ErrorEntry{
        Error:     err,
        Timestamp: time.Now(),
        Component: component,
        Severity:  severity,
    })
}

func (ec *ErrorContext) HasErrors() bool {
    ec.mu.Lock()
    defer ec.mu.Unlock()
    return len(ec.Errors) > 0
}

func (ec *ErrorContext) GetErrors() []ErrorEntry {
    ec.mu.Lock()
    defer ec.mu.Unlock()
    
    // Return copy
    errors := make([]ErrorEntry, len(ec.Errors))
    copy(errors, ec.Errors)
    return errors
}

// Middleware to add error context
func ErrorContextMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Create error context
        errCtx := NewErrorContext(
            generateRequestID(),
            getUserIDFromRequest(r),
            r.URL.Path,
            r.Method,
        )
        
        // Add to context
        ctx := context.WithValue(r.Context(), errorContextKey, errCtx)
        
        // Call next handler
        next.ServeHTTP(w, r.WithContext(ctx))
        
        // Log all errors that occurred
        if errCtx.HasErrors() {
            logRequestErrors(errCtx)
        }
    })
}

func GetErrorContext(ctx context.Context) *ErrorContext {
    if errCtx, ok := ctx.Value(errorContextKey).(*ErrorContext); ok {
        return errCtx
    }
    return nil
}

// Helper function to add error to context
func TrackError(ctx context.Context, err error, component string, severity ErrorSeverity) {
    if errCtx := GetErrorContext(ctx); errCtx != nil {
        errCtx.AddError(err, component, severity)
    }
}

// Usage in handlers
func ProcessOrderHandler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    order, err := parseOrder(r.Body)
    if err != nil {
        TrackError(ctx, err, "parsing", SeverityWarning)
        http.Error(w, "Invalid order", http.StatusBadRequest)
        return
    }
    
    if err := validateOrder(order); err != nil {
        TrackError(ctx, err, "validation", SeverityWarning)
        http.Error(w, "Validation failed", http.StatusBadRequest)
        return
    }
    
    if err := saveOrder(order); err != nil {
        TrackError(ctx, err, "database", SeverityCritical)
        http.Error(w, "Internal error", http.StatusInternalServerError)
        return
    }
    
    json.NewEncoder(w).Encode(order)
}

func logRequestErrors(errCtx *ErrorContext) {
    duration := time.Since(errCtx.StartTime)
    
    log.Printf("Request completed with errors | RequestID: %s | Duration: %v | Errors: %d",
        errCtx.RequestID,
        duration,
        len(errCtx.Errors),
    )
    
    for i, entry := range errCtx.GetErrors() {
        log.Printf("  Error %d | Component: %s | Severity: %s | Message: %v",
            i+1,
            entry.Component,
            entry.Severity,
            entry.Error,
        )
    }
}
```

---

## Error Handling in HTTP Services

### Complete HTTP Error Handling System

```go
// HTTP error types
type HTTPError struct {
    StatusCode int
    Code       string
    Message    string
    Details    interface{}
    Internal   error
    RequestID  string
    Timestamp  time.Time
}

func (e *HTTPError) Error() string {
    return fmt.Sprintf("[%s] %s", e.Code, e.Message)
}

func (e *HTTPError) Unwrap() error {
    return e.Internal
}

// Error constructors with context
func NewHTTPError(ctx context.Context, statusCode int, code, message string, internal error) *HTTPError {
    return &HTTPError{
        StatusCode: statusCode,
        Code:       code,
        Message:    message,
        Internal:   internal,
        RequestID:  getRequestID(ctx),
        Timestamp:  time.Now(),
    }
}

func BadRequest(ctx context.Context, message string, details interface{}) *HTTPError {
    return &HTTPError{
        StatusCode: http.StatusBadRequest,
        Code:       "BAD_REQUEST",
        Message:    message,
        Details:    details,
        RequestID:  getRequestID(ctx),
        Timestamp:  time.Now(),
    }
}

func Unauthorized(ctx context.Context, message string) *HTTPError {
    return &HTTPError{
        StatusCode: http.StatusUnauthorized,
        Code:       "UNAUTHORIZED",
        Message:    message,
        RequestID:  getRequestID(ctx),
        Timestamp:  time.Now(),
    }
}

func Forbidden(ctx context.Context, message string) *HTTPError {
    return &HTTPError{
        StatusCode: http.StatusForbidden,
        Code:       "FORBIDDEN",
        Message:    message,
        RequestID:  getRequestID(ctx),
        Timestamp:  time.Now(),
    }
}

func NotFound(ctx context.Context, resource string) *HTTPError {
    return &HTTPError{
        StatusCode: http.StatusNotFound,
        Code:       "NOT_FOUND",
        Message:    fmt.Sprintf("%s not found", resource),
        RequestID:  getRequestID(ctx),
        Timestamp:  time.Now(),
    }
}

func Conflict(ctx context.Context, message string) *HTTPError {
    return &HTTPError{
        StatusCode: http.StatusConflict,
        Code:       "CONFLICT",
        Message:    message,
        RequestID:  getRequestID(ctx),
        Timestamp:  time.Now(),
    }
}

func InternalServerError(ctx context.Context, message string, internal error) *HTTPError {
    return &HTTPError{
        StatusCode: http.StatusInternalServerError,
        Code:       "INTERNAL_ERROR",
        Message:    message,
        Internal:   internal,
        RequestID:  getRequestID(ctx),
        Timestamp:  time.Now(),
    }
}

func ServiceUnavailable(ctx context.Context, message string) *HTTPError {
    return &HTTPError{
        StatusCode: http.StatusServiceUnavailable,
        Code:       "SERVICE_UNAVAILABLE",
        Message:    message,
        RequestID:  getRequestID(ctx),
        Timestamp:  time.Now(),
    }
}

// HTTP error response structure
type HTTPErrorResponse struct {
    Code      string      `json:"code"`
    Message   string      `json:"message"`
    Details   interface{} `json:"details,omitempty"`
    RequestID string      `json:"request_id"`
    Timestamp string      `json:"timestamp"`
}

// Send HTTP error response
func SendHTTPError(w http.ResponseWriter, r *http.Request, err error) {
    var httpErr *HTTPError
    if !errors.As(err, &httpErr) {
        // Not an HTTPError - create internal server error
        httpErr = InternalServerError(r.Context(), "Internal server error", err)
    }
    
    // Log error
    logHTTPError(r, httpErr)
    
    // Build response
    response := HTTPErrorResponse{
        Code:      httpErr.Code,
        Message:   httpErr.Message,
        Details:   httpErr.Details,
        RequestID: httpErr.RequestID,
        Timestamp: httpErr.Timestamp.Format(time.RFC3339),
    }
    
    // Send response
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(httpErr.StatusCode)
    json.NewEncoder(w).Encode(response)
}

func logHTTPError(r *http.Request, httpErr *HTTPError) {
    fields := []interface{}{
        "request_id", httpErr.RequestID,
        "method", r.Method,
        "path", r.URL.Path,
        "status", httpErr.StatusCode,
        "code", httpErr.Code,
        "message", httpErr.Message,
    }
    
    if httpErr.Internal != nil {
        fields = append(fields, "internal_error", httpErr.Internal.Error())
    }
    
    // Log based on severity
    if httpErr.StatusCode >= 500 {
        log.Error("HTTP error (5xx)", fields...)
    } else if httpErr.StatusCode >= 400 {
        log.Warn("HTTP error (4xx)", fields...)
    }
}

// HTTP handler wrapper that handles errors
type HTTPHandler func(w http.ResponseWriter, r *http.Request) error

func WrapHTTPHandler(handler HTTPHandler) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        if err := handler(w, r); err != nil {
            SendHTTPError(w, r, err)
        }
    }
}

// Usage example
func GetUserHandler(w http.ResponseWriter, r *http.Request) error {
    ctx := r.Context()
    
    // Parse user ID
    id, err := strconv.ParseInt(r.URL.Query().Get("id"), 10, 64)
    if err != nil {
        return BadRequest(ctx, "Invalid user ID", map[string]string{
            "id": "must be a valid integer",
        })
    }
    
    // Get user
    user, err := GetUser(ctx, id)
    if err != nil {
        if errors.Is(err, ErrNotFound) {
            return NotFound(ctx, "User")
        }
        return InternalServerError(ctx, "Failed to get user", err)
    }
    
    // Check permissions
    if !CanAccessUser(ctx, user) {
        return Forbidden(ctx, "Access denied")
    }
    
    // Success
    w.Header().Set("Content-Type", "application/json")
    return json.NewEncoder(w).Encode(user)
}

// Register handler
http.HandleFunc("/users", WrapHTTPHandler(GetUserHandler))
```

### Validation Error Handling

```go
type ValidationErrors struct {
    Fields map[string][]string
}

func (ve *ValidationErrors) Error() string {
    return "validation failed"
}

func (ve *ValidationErrors) Add(field, message string) {
    if ve.Fields == nil {
        ve.Fields = make(map[string][]string)
    }
    ve.Fields[field] = append(ve.Fields[field], message)
}

func (ve *ValidationErrors) HasErrors() bool {
    return len(ve.Fields) > 0
}

// Validator
type Validator struct {
    errors *ValidationErrors
}

func NewValidator() *Validator {
    return &Validator{
        errors: &ValidationErrors{},
    }
}

func (v *Validator) Required(field string, value interface{}) *Validator {
    if value == nil || fmt.Sprintf("%v", value) == "" {
        v.errors.Add(field, "required")
    }
    return v
}

func (v *Validator) MinLength(field string, value string, min int) *Validator {
    if len(value) < min {
        v.errors.Add(field, fmt.Sprintf("must be at least %d characters", min))
    }
    return v
}

func (v *Validator) MaxLength(field string, value string, max int) *Validator {
    if len(value) > max {
        v.errors.Add(field, fmt.Sprintf("must be at most %d characters", max))
    }
    return v
}

func (v *Validator) Email(field string, value string) *Validator {
    if !strings.Contains(value, "@") {
        v.errors.Add(field, "must be a valid email")
    }
    return v
}

func (v *Validator) Range(field string, value, min, max int) *Validator {
    if value < min || value > max {
        v.errors.Add(field, fmt.Sprintf("must be between %d and %d", min, max))
    }
    return v
}

func (v *Validator) Validate() error {
    if v.errors.HasErrors() {
        return v.errors
    }
    return nil
}

// Usage
type CreateUserRequest struct {
    Username string `json:"username"`
    Email    string `json:"email"`
    Password string `json:"password"`
    Age      int    `json:"age"`
}

func CreateUserHandler(w http.ResponseWriter, r *http.Request) error {
    ctx := r.Context()
    
    var req CreateUserRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        return BadRequest(ctx, "Invalid JSON", nil)
    }
    
    // Validate
    validator := NewValidator()
    err := validator.
        Required("username", req.Username).
        MinLength("username", req.Username, 3).
        MaxLength("username", req.Username, 20).
        Required("email", req.Email).
        Email("email", req.Email).
        Required("password", req.Password).
        MinLength("password", req.Password, 8).
        Range("age", req.Age, 18, 120).
        Validate()
    
    if err != nil {
        var valErr *ValidationErrors
        if errors.As(err, &valErr) {
            return BadRequest(ctx, "Validation failed", valErr.Fields)
        }
        return err
    }
    
    // Create user...
    return nil
}
```

---

## Error Handling in gRPC Services

### gRPC Error Handling System

```go
import (
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)

// gRPC error wrapper
type GRPCError struct {
    Code    codes.Code
    Message string
    Details []interface{}
    Err     error
}

func (e *GRPCError) Error() string {
    return e.Message
}

func (e *GRPCError) GRPCStatus() *status.Status {
    st := status.New(e.Code, e.Message)
    
    // Add details
    if len(e.Details) > 0 {
        st, _ = st.WithDetails(e.Details...)
    }
    
    return st
}

// gRPC error constructors
func NewGRPCError(code codes.Code, message string, err error) *GRPCError {
    return &GRPCError{
        Code:    code,
        Message: message,
        Err:     err,
    }
}

func GRPCInvalidArgument(message string, details ...interface{}) error {
    return &GRPCError{
        Code:    codes.InvalidArgument,
        Message: message,
        Details: details,
    }
}

func GRPCNotFound(resource string) error {
    return &GRPCError{
        Code:    codes.NotFound,
        Message: fmt.Sprintf("%s not found", resource),
    }
}

func GRPCAlreadyExists(resource string) error {
    return &GRPCError{
        Code:    codes.AlreadyExists,
        Message: fmt.Sprintf("%s already exists", resource),
    }
}

func GRPCPermissionDenied(message string) error {
    return &GRPCError{
        Code:    codes.PermissionDenied,
        Message: message,
    }
}

func GRPCUnauthenticated(message string) error {
    return &GRPCError{
        Code:    codes.Unauthenticated,
        Message: message,
    }
}

func GRPCInternal(message string, err error) error {
    return &GRPCError{
        Code:    codes.Internal,
        Message: message,
        Err:     err,
    }
}

func GRPCUnavailable(message string) error {
    return &GRPCError{
        Code:    codes.Unavailable,
        Message: message,
    }
}

// gRPC interceptor for error handling
func ErrorHandlerInterceptor(logger Logger) grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        // Call handler
        resp, err := handler(ctx, req)
        
        if err != nil {
            // Log error
            logGRPCError(ctx, info.FullMethod, err, logger)
            
            // Convert to gRPC error if not already
            if _, ok := err.(*GRPCError); !ok {
                err = convertToGRPCError(err)
            }
        }
        
        return resp, err
    }
}

func logGRPCError(ctx context.Context, method string, err error, logger Logger) {
    var grpcErr *GRPCError
    if errors.As(err, &grpcErr) {
        logger.Error("gRPC error",
            "method", method,
            "code", grpcErr.Code.String(),
            "message", grpcErr.Message,
            "internal_error", grpcErr.Err,
        )
    } else {
        logger.Error("gRPC error",
            "method", method,
            "error", err,
        )
    }
}

func convertToGRPCError(err error) error {
    // Convert common errors to gRPC errors
    if errors.Is(err, ErrNotFound) {
        return GRPCNotFound("Resource")
    }
    
    var valErr *ValidationErrors
    if errors.As(err, &valErr) {
        return GRPCInvalidArgument("Validation failed")
    }
    
    // Default to internal error
    return GRPCInternal("Internal error", err)
}

// Usage in gRPC service
type UserServiceServer struct {
    repo UserRepository
}

func (s *UserServiceServer) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.User, error) {
    // Validate request
    if req.Id <= 0 {
        return nil, GRPCInvalidArgument("Invalid user ID")
    }
    
    // Get user
    user, err := s.repo.FindByID(req.Id)
    if err != nil {
        if errors.Is(err, ErrNotFound) {
            return nil, GRPCNotFound("User")
        }
        return nil, GRPCInternal("Failed to get user", err)
    }
    
    // Check permissions
    if !CanAccessUser(ctx, user) {
        return nil, GRPCPermissionDenied("Access denied")
    }
    
    return userToProto(user), nil
}

func (s *UserServiceServer) CreateUser(ctx context.Context, req *pb.CreateUserRequest) (*pb.User, error) {
    // Validate
    if err := validateCreateUserRequest(req); err != nil {
        return nil, err
    }
    
    // Check if exists
    existing, err := s.repo.FindByEmail(req.Email)
    if err != nil && !errors.Is(err, ErrNotFound) {
        return nil, GRPCInternal("Failed to check existing user", err)
    }
    
    if existing != nil {
        return nil, GRPCAlreadyExists("User with this email")
    }
    
    // Create user
    user := &User{
        Username: req.Username,
        Email:    req.Email,
    }
    
    if err := s.repo.Create(user); err != nil {
        return nil, GRPCInternal("Failed to create user", err)
    }
    
    return userToProto(user), nil
}
```

---

## Advanced Error Patterns

### Pattern 1: Circuit Breaker with Error Handling

```go
type CircuitBreaker struct {
    maxFailures  int
    resetTimeout time.Duration
    failures     int
    lastFailTime time.Time
    state        CircuitState
    mu           sync.Mutex
}

type CircuitState int

const (
    StateClosed CircuitState = iota
    StateOpen
    StateHalfOpen
)

func NewCircuitBreaker(maxFailures int, resetTimeout time.Duration) *CircuitBreaker {
    return &CircuitBreaker{
        maxFailures:  maxFailures,
        resetTimeout: resetTimeout,
        state:        StateClosed,
    }
}

func (cb *CircuitBreaker) Call(fn func() error) error {
    cb.mu.Lock()
    
    // Check state
    if cb.state == StateOpen {
        // Check if should try again
        if time.Since(cb.lastFailTime) > cb.resetTimeout {
            cb.state = StateHalfOpen
            cb.mu.Unlock()
        } else {
            cb.mu.Unlock()
            return ErrCircuitOpen
        }
    } else {
        cb.mu.Unlock()
    }
    
    // Execute function
    err := fn()
    
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    if err != nil {
        cb.failures++
        cb.lastFailTime = time.Now()
        
        if cb.failures >= cb.maxFailures {
            cb.state = StateOpen
            return fmt.Errorf("circuit breaker opened: %w", err)
        }
        
        return err
    }
    
    // Success - reset
    if cb.state == StateHalfOpen {
        cb.state = StateClosed
    }
    cb.failures = 0
    
    return nil
}

var ErrCircuitOpen = errors.New("circuit breaker is open")

// Usage
cb := NewCircuitBreaker(5, time.Minute)

func CallExternalAPI() error {
    return cb.Call(func() error {
        resp, err := http.Get("https://api.example.com/data")
        if err != nil {
            return fmt.Errorf("API call failed: %w", err)
        }
        defer resp.Body.Close()
        
        if resp.StatusCode >= 500 {
            return fmt.Errorf("API returned %d", resp.StatusCode)
        }
        
        return nil
    })
}
```

### Pattern 2: Retry with Exponential Backoff

```go
type RetryConfig struct {
    MaxAttempts   int
    InitialDelay  time.Duration
    MaxDelay      time.Duration
    Multiplier    float64
    RetryableFunc func(error) bool
}

func DefaultRetryConfig() RetryConfig {
    return RetryConfig{
        MaxAttempts:  3,
        InitialDelay: time.Second,
        MaxDelay:     time.Minute,
        Multiplier:   2.0,
        RetryableFunc: func(err error) bool {
            // Retry on temporary errors
            return IsTemporary(err)
        },
    }
}

func RetryWithBackoff(ctx context.Context, config RetryConfig, fn func() error) error {
    var lastErr error
    delay := config.InitialDelay
    
    for attempt := 1; attempt <= config.MaxAttempts; attempt++ {
        // Try operation
        err := fn()
        if err == nil {
            return nil
        }
        
        lastErr = err
        
        // Check if retryable
        if config.RetryableFunc != nil && !config.RetryableFunc(err) {
            return fmt.Errorf("non-retryable error: %w", err)
        }
        
        // Last attempt
        if attempt == config.MaxAttempts {
            return fmt.Errorf("max attempts reached: %w", lastErr)
        }
        
        // Wait with exponential backoff
        select {
        case <-ctx.Done():
            return fmt.Errorf("context cancelled: %w", ctx.Err())
        case <-time.After(delay):
        }
        
        // Increase delay
        delay = time.Duration(float64(delay) * config.Multiplier)
        if delay > config.MaxDelay {
            delay = config.MaxDelay
        }
    }
    
    return lastErr
}

// Usage
err := RetryWithBackoff(ctx, DefaultRetryConfig(), func() error {
    return callExternalService()
})

if err != nil {
    log.Printf("Operation failed after retries: %v", err)
}
```

### Pattern 3: Error Aggregation

```go
type ErrorGroup struct {
    errors []error
    mu     sync.Mutex
}

func (eg *ErrorGroup) Add(err error) {
    if err == nil {
        return
    }
    
    eg.mu.Lock()
    defer eg.mu.Unlock()
    eg.errors = append(eg.errors, err)
}

func (eg *ErrorGroup) Error() string {
    eg.mu.Lock()
    defer eg.mu.Unlock()
    
    if len(eg.errors) == 0 {
        return ""
    }
    
    var messages []string
    for _, err := range eg.errors {
        messages = append(messages, err.Error())
    }
    
    return fmt.Sprintf("%d errors occurred: %s",
        len(eg.errors),
        strings.Join(messages, "; "),
    )
}

func (eg *ErrorGroup) HasErrors() bool {
    eg.mu.Lock()
    defer eg.mu.Unlock()
    return len(eg.errors) > 0
}

func (eg *ErrorGroup) Errors() []error {
    eg.mu.Lock()
    defer eg.mu.Unlock()
    
    result := make([]error, len(eg.errors))
    copy(result, eg.errors)
    return result
}

// Usage - Process multiple items, collect all errors
func ProcessBatch(items []Item) error {
    eg := &ErrorGroup{}
    var wg sync.WaitGroup
    
    for _, item := range items {
        wg.Add(1)
        go func(item Item) {
            defer wg.Done()
            
            if err := processItem(item); err != nil {
                eg.Add(fmt.Errorf("failed to process item %d: %w", item.ID, err))
            }
        }(item)
    }
    
    wg.Wait()
    
    if eg.HasErrors() {
        return eg
    }
    
    return nil
}
```

This completes Part 1 of the Error Handling guide. Part 2 will continue with production error management, testing, and monitoring strategies.

# The Complete Guide to Production Error Management and Testing

## Error Monitoring, Observability, Alerting, and Comprehensive Testing

---

## Table of Contents

### Part A: Production Error Management

1. [Error Logging and Structured Logging](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#error-logging-and-structured-logging)
2. [Error Monitoring and Observability](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#error-monitoring-and-observability)
3. [Error Alerting and Notification Systems](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#error-alerting-and-notification-systems)
4. [Error Metrics and Dashboards](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#error-metrics-and-dashboards)
5. [Error Rate Limiting and Circuit Breaking](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#error-rate-limiting-and-circuit-breaking)
6. [Error Recovery and Graceful Degradation](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#error-recovery-and-graceful-degradation)
7. [Production Error Response Strategies](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#production-error-response-strategies)

### Part B: Testing Error Handling

8. [Unit Testing Error Scenarios](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#unit-testing-error-scenarios)
9. [Integration Testing with Errors](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#integration-testing-with-errors)
10. [Error Mocking and Simulation](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#error-mocking-and-simulation)
11. [Testing Error Propagation](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#testing-error-propagation)
12. [Chaos Engineering for Error Handling](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#chaos-engineering-for-error-handling)
13. [Best Practices Summary](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#best-practices-summary)

---

## Part A: Production Error Management

---

## Error Logging and Structured Logging

Structured logging enables machine-readable logs for analysis, monitoring, and debugging.

### Structured Logger Implementation

```go
type Logger interface {
    Debug(msg string, fields ...interface{})
    Info(msg string, fields ...interface{})
    Warn(msg string, fields ...interface{})
    Error(msg string, fields ...interface{})
    Fatal(msg string, fields ...interface{})
}

type StructuredLogger struct {
    level      LogLevel
    output     io.Writer
    context    map[string]interface{}
    mu         sync.Mutex
}

type LogLevel int

const (
    DebugLevel LogLevel = iota
    InfoLevel
    WarnLevel
    ErrorLevel
    FatalLevel
)

func NewStructuredLogger(level LogLevel, output io.Writer) *StructuredLogger {
    return &StructuredLogger{
        level:   level,
        output:  output,
        context: make(map[string]interface{}),
    }
}

func (l *StructuredLogger) WithContext(key string, value interface{}) *StructuredLogger {
    l.mu.Lock()
    defer l.mu.Unlock()
    
    // Create new logger with additional context
    newLogger := &StructuredLogger{
        level:   l.level,
        output:  l.output,
        context: make(map[string]interface{}),
    }
    
    // Copy existing context
    for k, v := range l.context {
        newLogger.context[k] = v
    }
    
    // Add new context
    newLogger.context[key] = value
    
    return newLogger
}

func (l *StructuredLogger) Error(msg string, fields ...interface{}) {
    if l.level > ErrorLevel {
        return
    }
    l.log(ErrorLevel, msg, fields...)
}

func (l *StructuredLogger) Warn(msg string, fields ...interface{}) {
    if l.level > WarnLevel {
        return
    }
    l.log(WarnLevel, msg, fields...)
}

func (l *StructuredLogger) Info(msg string, fields ...interface{}) {
    if l.level > InfoLevel {
        return
    }
    l.log(InfoLevel, msg, fields...)
}

func (l *StructuredLogger) Debug(msg string, fields ...interface{}) {
    if l.level > DebugLevel {
        return
    }
    l.log(DebugLevel, msg, fields...)
}

func (l *StructuredLogger) log(level LogLevel, msg string, fields ...interface{}) {
    entry := l.buildLogEntry(level, msg, fields...)
    
    jsonData, err := json.Marshal(entry)
    if err != nil {
        fmt.Fprintf(os.Stderr, "Failed to marshal log entry: %v\n", err)
        return
    }
    
    l.mu.Lock()
    defer l.mu.Unlock()
    
    l.output.Write(jsonData)
    l.output.Write([]byte("\n"))
}

func (l *StructuredLogger) buildLogEntry(level LogLevel, msg string, fields ...interface{}) map[string]interface{} {
    entry := map[string]interface{}{
        "timestamp": time.Now().UTC().Format(time.RFC3339Nano),
        "level":     level.String(),
        "message":   msg,
    }
    
    // Add context fields
    for k, v := range l.context {
        entry[k] = v
    }
    
    // Add additional fields
    for i := 0; i < len(fields); i += 2 {
        if i+1 < len(fields) {
            key := fmt.Sprintf("%v", fields[i])
            entry[key] = fields[i+1]
        }
    }
    
    return entry
}

func (l LogLevel) String() string {
    switch l {
    case DebugLevel:
        return "DEBUG"
    case InfoLevel:
        return "INFO"
    case WarnLevel:
        return "WARN"
    case ErrorLevel:
        return "ERROR"
    case FatalLevel:
        return "FATAL"
    default:
        return "UNKNOWN"
    }
}
```

### Error Logging with Context

```go
type ErrorLogger struct {
    logger *StructuredLogger
}

func NewErrorLogger(logger *StructuredLogger) *ErrorLogger {
    return &ErrorLogger{logger: logger}
}

func (el *ErrorLogger) LogError(ctx context.Context, err error, msg string) {
    fields := []interface{}{
        "error", err.Error(),
    }
    
    // Extract request context
    if requestID := ctx.Value("request_id"); requestID != nil {
        fields = append(fields, "request_id", requestID)
    }
    
    if userID := ctx.Value("user_id"); userID != nil {
        fields = append(fields, "user_id", userID)
    }
    
    // Extract error type information
    fields = append(fields, "error_type", fmt.Sprintf("%T", err))
    
    // Check for HTTP errors
    var httpErr *HTTPError
    if errors.As(err, &httpErr) {
        fields = append(fields,
            "http_status", httpErr.StatusCode,
            "error_code", httpErr.Code,
        )
    }
    
    // Check for database errors
    var dbErr *DatabaseError
    if errors.As(err, &dbErr) {
        fields = append(fields,
            "database_operation", dbErr.Operation,
            "table", dbErr.Table,
        )
    }
    
    // Extract stack trace if available
    if stackErr, ok := err.(interface{ StackTrace() []byte }); ok {
        fields = append(fields, "stack_trace", string(stackErr.StackTrace()))
    }
    
    el.logger.Error(msg, fields...)
}

// Usage
logger := NewStructuredLogger(InfoLevel, os.Stdout)
errorLogger := NewErrorLogger(logger)

func ProcessRequest(ctx context.Context, req *Request) error {
    if err := validateRequest(req); err != nil {
        errorLogger.LogError(ctx, err, "request validation failed")
        return err
    }
    
    if err := processData(req.Data); err != nil {
        errorLogger.LogError(ctx, err, "data processing failed")
        return err
    }
    
    return nil
}

// Example output:
// {
//   "timestamp": "2024-01-15T10:30:45.123456Z",
//   "level": "ERROR",
//   "message": "request validation failed",
//   "error": "validation failed: email is required",
//   "error_type": "*ValidationError",
//   "request_id": "req-123-456",
//   "user_id": "user-789"
// }
```

### Error Log Aggregation

```go
type LogAggregator struct {
    buffer    []*LogEntry
    batchSize int
    interval  time.Duration
    sender    LogSender
    mu        sync.Mutex
    stopCh    chan struct{}
}

type LogEntry struct {
    Timestamp time.Time              `json:"timestamp"`
    Level     string                 `json:"level"`
    Message   string                 `json:"message"`
    Fields    map[string]interface{} `json:"fields"`
}

type LogSender interface {
    Send(entries []*LogEntry) error
}

func NewLogAggregator(batchSize int, interval time.Duration, sender LogSender) *LogAggregator {
    la := &LogAggregator{
        buffer:    make([]*LogEntry, 0, batchSize),
        batchSize: batchSize,
        interval:  interval,
        sender:    sender,
        stopCh:    make(chan struct{}),
    }
    
    go la.run()
    return la
}

func (la *LogAggregator) Log(entry *LogEntry) {
    la.mu.Lock()
    defer la.mu.Unlock()
    
    la.buffer = append(la.buffer, entry)
    
    if len(la.buffer) >= la.batchSize {
        la.flush()
    }
}

func (la *LogAggregator) run() {
    ticker := time.NewTicker(la.interval)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            la.mu.Lock()
            la.flush()
            la.mu.Unlock()
        case <-la.stopCh:
            return
        }
    }
}

func (la *LogAggregator) flush() {
    if len(la.buffer) == 0 {
        return
    }
    
    // Send batch
    if err := la.sender.Send(la.buffer); err != nil {
        fmt.Fprintf(os.Stderr, "Failed to send logs: %v\n", err)
    }
    
    // Clear buffer
    la.buffer = la.buffer[:0]
}

func (la *LogAggregator) Stop() {
    close(la.stopCh)
    
    la.mu.Lock()
    la.flush()
    la.mu.Unlock()
}
```

---

## Error Monitoring and Observability

### Error Tracking System

```go
type ErrorTracker struct {
    storage     ErrorStorage
    aggregator  *ErrorAggregator
    notifier    ErrorNotifier
    rateLimiter *RateLimiter
}

type ErrorStorage interface {
    Store(entry *ErrorEntry) error
    Query(filter ErrorFilter) ([]*ErrorEntry, error)
    GetStats(timeRange TimeRange) (*ErrorStats, error)
}

type ErrorEntry struct {
    ID          string                 `json:"id"`
    Timestamp   time.Time              `json:"timestamp"`
    Error       string                 `json:"error"`
    ErrorType   string                 `json:"error_type"`
    Severity    ErrorSeverity          `json:"severity"`
    Context     map[string]interface{} `json:"context"`
    StackTrace  string                 `json:"stack_trace,omitempty"`
    RequestID   string                 `json:"request_id,omitempty"`
    UserID      string                 `json:"user_id,omitempty"`
    ServiceName string                 `json:"service_name"`
    Environment string                 `json:"environment"`
    Fingerprint string                 `json:"fingerprint"` // For grouping similar errors
}

type ErrorAggregator struct {
    mu     sync.RWMutex
    errors map[string]*ErrorGroup // fingerprint -> group
}

type ErrorGroup struct {
    Fingerprint  string
    FirstSeen    time.Time
    LastSeen     time.Time
    Count        int64
    Sample       *ErrorEntry
    AffectedUsers map[string]bool
}

func NewErrorTracker(storage ErrorStorage, notifier ErrorNotifier) *ErrorTracker {
    return &ErrorTracker{
        storage:     storage,
        aggregator:  NewErrorAggregator(),
        notifier:    notifier,
        rateLimiter: NewRateLimiter(100, time.Minute),
    }
}

func (et *ErrorTracker) Track(ctx context.Context, err error) {
    entry := et.buildErrorEntry(ctx, err)
    
    // Store error
    if err := et.storage.Store(entry); err != nil {
        log.Printf("Failed to store error: %v", err)
    }
    
    // Aggregate
    et.aggregator.Add(entry)
    
    // Notify if needed
    if entry.Severity >= SeverityCritical {
        if et.rateLimiter.Allow() {
            et.notifier.Notify(entry)
        }
    }
}

func (et *ErrorTracker) buildErrorEntry(ctx context.Context, err error) *ErrorEntry {
    entry := &ErrorEntry{
        ID:          generateID(),
        Timestamp:   time.Now(),
        Error:       err.Error(),
        ErrorType:   fmt.Sprintf("%T", err),
        Context:     make(map[string]interface{}),
        ServiceName: os.Getenv("SERVICE_NAME"),
        Environment: os.Getenv("ENVIRONMENT"),
    }
    
    // Extract context
    if requestID := ctx.Value("request_id"); requestID != nil {
        entry.RequestID = fmt.Sprintf("%v", requestID)
    }
    
    if userID := ctx.Value("user_id"); userID != nil {
        entry.UserID = fmt.Sprintf("%v", userID)
    }
    
    // Determine severity
    entry.Severity = et.determineSeverity(err)
    
    // Generate fingerprint for grouping
    entry.Fingerprint = et.generateFingerprint(err)
    
    // Extract stack trace
    if stackErr, ok := err.(interface{ StackTrace() []byte }); ok {
        entry.StackTrace = string(stackErr.StackTrace())
    }
    
    return entry
}

func (et *ErrorTracker) determineSeverity(err error) ErrorSeverity {
    // Check error type
    var httpErr *HTTPError
    if errors.As(err, &httpErr) {
        if httpErr.StatusCode >= 500 {
            return SeverityCritical
        }
        return SeverityWarning
    }
    
    // Check for specific errors
    if errors.Is(err, context.DeadlineExceeded) {
        return SeverityError
    }
    
    if errors.Is(err, context.Canceled) {
        return SeverityWarning
    }
    
    return SeverityError
}

func (et *ErrorTracker) generateFingerprint(err error) string {
    // Group similar errors by type and message pattern
    errorType := fmt.Sprintf("%T", err)
    message := err.Error()
    
    // Remove variable parts (IDs, timestamps, etc.)
    message = regexp.MustCompile(`\d+`).ReplaceAllString(message, "N")
    message = regexp.MustCompile(`[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}`).
        ReplaceAllString(message, "UUID")
    
    combined := errorType + ":" + message
    hash := sha256.Sum256([]byte(combined))
    return hex.EncodeToString(hash[:])
}

func (ea *ErrorAggregator) Add(entry *ErrorEntry) {
    ea.mu.Lock()
    defer ea.mu.Unlock()
    
    fingerprint := entry.Fingerprint
    
    group, exists := ea.errors[fingerprint]
    if !exists {
        group = &ErrorGroup{
            Fingerprint:   fingerprint,
            FirstSeen:     entry.Timestamp,
            LastSeen:      entry.Timestamp,
            Count:         0,
            Sample:        entry,
            AffectedUsers: make(map[string]bool),
        }
        ea.errors[fingerprint] = group
    }
    
    group.LastSeen = entry.Timestamp
    group.Count++
    
    if entry.UserID != "" {
        group.AffectedUsers[entry.UserID] = true
    }
}

func (ea *ErrorAggregator) GetTopErrors(limit int) []*ErrorGroup {
    ea.mu.RLock()
    defer ea.mu.RUnlock()
    
    groups := make([]*ErrorGroup, 0, len(ea.errors))
    for _, group := range ea.errors {
        groups = append(groups, group)
    }
    
    // Sort by count
    sort.Slice(groups, func(i, j int) bool {
        return groups[i].Count > groups[j].Count
    })
    
    if len(groups) > limit {
        groups = groups[:limit]
    }
    
    return groups
}
```

### Distributed Tracing Integration

```go
type TraceContext struct {
    TraceID  string
    SpanID   string
    ParentID string
}

type ErrorWithTrace struct {
    Error error
    Trace *TraceContext
}

func (e *ErrorWithTrace) Error() string {
    return e.Error.Error()
}

func (e *ErrorWithTrace) Unwrap() error {
    return e.Error
}

// Wrap error with tracing context
func TraceError(ctx context.Context, err error) error {
    if err == nil {
        return nil
    }
    
    trace := ExtractTraceContext(ctx)
    if trace == nil {
        return err
    }
    
    return &ErrorWithTrace{
        Error: err,
        Trace: trace,
    }
}

func ExtractTraceContext(ctx context.Context) *TraceContext {
    // Extract from OpenTelemetry or similar
    if traceID := ctx.Value("trace_id"); traceID != nil {
        return &TraceContext{
            TraceID:  fmt.Sprintf("%v", traceID),
            SpanID:   fmt.Sprintf("%v", ctx.Value("span_id")),
            ParentID: fmt.Sprintf("%v", ctx.Value("parent_id")),
        }
    }
    return nil
}

// Log error with trace
func LogErrorWithTrace(ctx context.Context, err error, msg string) {
    fields := []interface{}{
        "error", err.Error(),
    }
    
    // Add trace context
    trace := ExtractTraceContext(ctx)
    if trace != nil {
        fields = append(fields,
            "trace_id", trace.TraceID,
            "span_id", trace.SpanID,
            "parent_id", trace.ParentID,
        )
    }
    
    logger.Error(msg, fields...)
}
```

---

## Error Alerting and Notification Systems

### Multi-Channel Alert System

```go
type AlertSystem struct {
    channels map[string]AlertChannel
    rules    []*AlertRule
    mu       sync.RWMutex
}

type AlertChannel interface {
    Send(alert *Alert) error
    Name() string
}

type Alert struct {
    Title       string
    Message     string
    Severity    ErrorSeverity
    Timestamp   time.Time
    Context     map[string]interface{}
    Fingerprint string
}

type AlertRule struct {
    Name      string
    Condition func(*ErrorEntry) bool
    Channels  []string
    Severity  ErrorSeverity
    Throttle  time.Duration
    lastSent  map[string]time.Time
    mu        sync.Mutex
}

func NewAlertSystem() *AlertSystem {
    return &AlertSystem{
        channels: make(map[string]AlertChannel),
        rules:    make([]*AlertRule, 0),
    }
}

func (as *AlertSystem) RegisterChannel(channel AlertChannel) {
    as.mu.Lock()
    defer as.mu.Unlock()
    as.channels[channel.Name()] = channel
}

func (as *AlertSystem) AddRule(rule *AlertRule) {
    as.mu.Lock()
    defer as.mu.Unlock()
    as.rules = append(as.rules, rule)
}

func (as *AlertSystem) ProcessError(entry *ErrorEntry) {
    as.mu.RLock()
    defer as.mu.RUnlock()
    
    for _, rule := range as.rules {
        if rule.Condition(entry) {
            go as.sendAlert(rule, entry)
        }
    }
}

func (as *AlertSystem) sendAlert(rule *AlertRule, entry *ErrorEntry) {
    // Check throttle
    if !rule.shouldSend(entry.Fingerprint) {
        return
    }
    
    alert := &Alert{
        Title:       fmt.Sprintf("[%s] %s", entry.Severity.String(), rule.Name),
        Message:     entry.Error,
        Severity:    entry.Severity,
        Timestamp:   entry.Timestamp,
        Fingerprint: entry.Fingerprint,
        Context: map[string]interface{}{
            "service":    entry.ServiceName,
            "environment": entry.Environment,
            "request_id": entry.RequestID,
            "user_id":    entry.UserID,
        },
    }
    
    // Send to configured channels
    for _, channelName := range rule.Channels {
        if channel, exists := as.channels[channelName]; exists {
            if err := channel.Send(alert); err != nil {
                log.Printf("Failed to send alert to %s: %v", channelName, err)
            }
        }
    }
    
    rule.markSent(entry.Fingerprint)
}

func (ar *AlertRule) shouldSend(fingerprint string) bool {
    ar.mu.Lock()
    defer ar.mu.Unlock()
    
    if ar.lastSent == nil {
        ar.lastSent = make(map[string]time.Time)
    }
    
    lastSent, exists := ar.lastSent[fingerprint]
    if !exists {
        return true
    }
    
    return time.Since(lastSent) >= ar.Throttle
}

func (ar *AlertRule) markSent(fingerprint string) {
    ar.mu.Lock()
    defer ar.mu.Unlock()
    
    if ar.lastSent == nil {
        ar.lastSent = make(map[string]time.Time)
    }
    
    ar.lastSent[fingerprint] = time.Now()
}
```

### Slack Alert Channel

```go
type SlackChannel struct {
    webhookURL string
    username   string
    channel    string
}

func NewSlackChannel(webhookURL, username, channel string) *SlackChannel {
    return &SlackChannel{
        webhookURL: webhookURL,
        username:   username,
        channel:    channel,
    }
}

func (sc *SlackChannel) Name() string {
    return "slack"
}

func (sc *SlackChannel) Send(alert *Alert) error {
    payload := sc.buildSlackPayload(alert)
    
    jsonData, err := json.Marshal(payload)
    if err != nil {
        return fmt.Errorf("failed to marshal slack payload: %w", err)
    }
    
    resp, err := http.Post(sc.webhookURL, "application/json", bytes.NewReader(jsonData))
    if err != nil {
        return fmt.Errorf("failed to send slack message: %w", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("slack returned status %d", resp.StatusCode)
    }
    
    return nil
}

func (sc *SlackChannel) buildSlackPayload(alert *Alert) map[string]interface{} {
    color := sc.getSeverityColor(alert.Severity)
    
    return map[string]interface{}{
        "username": sc.username,
        "channel":  sc.channel,
        "attachments": []map[string]interface{}{
            {
                "color":      color,
                "title":      alert.Title,
                "text":       alert.Message,
                "footer":     "Error Monitoring System",
                "footer_icon": "https://platform.slack-edge.com/img/default_application_icon.png",
                "ts":         alert.Timestamp.Unix(),
                "fields": []map[string]interface{}{
                    {
                        "title": "Service",
                        "value": alert.Context["service"],
                        "short": true,
                    },
                    {
                        "title": "Environment",
                        "value": alert.Context["environment"],
                        "short": true,
                    },
                    {
                        "title": "Request ID",
                        "value": alert.Context["request_id"],
                        "short": true,
                    },
                },
            },
        },
    }
}

func (sc *SlackChannel) getSeverityColor(severity ErrorSeverity) string {
    switch severity {
    case SeverityCritical:
        return "danger"
    case SeverityError:
        return "warning"
    case SeverityWarning:
        return "#FFA500"
    default:
        return "good"
    }
}
```

### PagerDuty Alert Channel

```go
type PagerDutyChannel struct {
    integrationKey string
    client         *http.Client
}

func NewPagerDutyChannel(integrationKey string) *PagerDutyChannel {
    return &PagerDutyChannel{
        integrationKey: integrationKey,
        client:         &http.Client{Timeout: 10 * time.Second},
    }
}

func (pd *PagerDutyChannel) Name() string {
    return "pagerduty"
}

func (pd *PagerDutyChannel) Send(alert *Alert) error {
    payload := map[string]interface{}{
        "routing_key":  pd.integrationKey,
        "event_action": "trigger",
        "dedup_key":    alert.Fingerprint,
        "payload": map[string]interface{}{
            "summary":        alert.Title,
            "severity":       pd.mapSeverity(alert.Severity),
            "timestamp":      alert.Timestamp.Format(time.RFC3339),
            "source":         alert.Context["service"],
            "component":      alert.Context["environment"],
            "custom_details": alert.Context,
        },
    }
    
    jsonData, err := json.Marshal(payload)
    if err != nil {
        return fmt.Errorf("failed to marshal pagerduty payload: %w", err)
    }
    
    resp, err := pd.client.Post(
        "https://events.pagerduty.com/v2/enqueue",
        "application/json",
        bytes.NewReader(jsonData),
    )
    if err != nil {
        return fmt.Errorf("failed to send pagerduty alert: %w", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusAccepted {
        body, _ := ioutil.ReadAll(resp.Body)
        return fmt.Errorf("pagerduty returned status %d: %s", resp.StatusCode, body)
    }
    
    return nil
}

func (pd *PagerDutyChannel) mapSeverity(severity ErrorSeverity) string {
    switch severity {
    case SeverityCritical:
        return "critical"
    case SeverityError:
        return "error"
    case SeverityWarning:
        return "warning"
    default:
        return "info"
    }
}
```

### Alert System Usage

```go
func SetupAlertSystem() *AlertSystem {
    alertSystem := NewAlertSystem()
    
    // Register channels
    slackChannel := NewSlackChannel(
        os.Getenv("SLACK_WEBHOOK_URL"),
        "Error Bot",
        "#alerts",
    )
    alertSystem.RegisterChannel(slackChannel)
    
    pagerdutyChannel := NewPagerDutyChannel(os.Getenv("PAGERDUTY_KEY"))
    alertSystem.RegisterChannel(pagerdutyChannel)
    
    // Add alert rules
    
    // Rule 1: Critical errors go to PagerDuty
    alertSystem.AddRule(&AlertRule{
        Name: "Critical Errors",
        Condition: func(entry *ErrorEntry) bool {
            return entry.Severity >= SeverityCritical
        },
        Channels: []string{"pagerduty", "slack"},
        Severity: SeverityCritical,
        Throttle: 5 * time.Minute,
    })
    
    // Rule 2: High error rate in production
    alertSystem.AddRule(&AlertRule{
        Name: "High Error Rate",
        Condition: func(entry *ErrorEntry) bool {
            return entry.Environment == "production" &&
                entry.Severity >= SeverityError
        },
        Channels: []string{"slack"},
        Severity: SeverityError,
        Throttle: 15 * time.Minute,
    })
    
    // Rule 3: Database errors
    alertSystem.AddRule(&AlertRule{
        Name: "Database Error",
        Condition: func(entry *ErrorEntry) bool {
            _, ok := entry.Context["database_operation"]
            return ok
        },
        Channels: []string{"slack"},
        Severity: SeverityError,
        Throttle: 10 * time.Minute,
    })
    
    return alertSystem
}
```

---

## Error Metrics and Dashboards

### Metrics Collector

```go
type MetricsCollector struct {
    errorCount    *prometheus.CounterVec
    errorDuration *prometheus.HistogramVec
    activeErrors  *prometheus.GaugeVec
}

func NewMetricsCollector() *MetricsCollector {
    mc := &MetricsCollector{
        errorCount: prometheus.NewCounterVec(
            prometheus.CounterOpts{
                Name: "errors_total",
                Help: "Total number of errors",
            },
            []string{"type", "severity", "service", "environment"},
        ),
        errorDuration: prometheus.NewHistogramVec(
            prometheus.HistogramOpts{
                Name:    "error_handling_duration_seconds",
                Help:    "Time spent handling errors",
                Buckets: prometheus.DefBuckets,
            },
            []string{"type", "severity"},
        ),
        activeErrors: prometheus.NewGaugeVec(
            prometheus.GaugeOpts{
                Name: "active_errors",
                Help: "Number of currently active errors",
            },
            []string{"type", "service"},
        ),
    }
    
    // Register metrics
    prometheus.MustRegister(mc.errorCount)
    prometheus.MustRegister(mc.errorDuration)
    prometheus.MustRegister(mc.activeErrors)
    
    return mc
}

func (mc *MetricsCollector) RecordError(entry *ErrorEntry, duration time.Duration) {
    mc.errorCount.WithLabelValues(
        entry.ErrorType,
        entry.Severity.String(),
        entry.ServiceName,
        entry.Environment,
    ).Inc()
    
    mc.errorDuration.WithLabelValues(
        entry.ErrorType,
        entry.Severity.String(),
    ).Observe(duration.Seconds())
}

func (mc *MetricsCollector) IncrementActiveErrors(errorType, service string) {
    mc.activeErrors.WithLabelValues(errorType, service).Inc()
}

func (mc *MetricsCollector) DecrementActiveErrors(errorType, service string) {
    mc.activeErrors.WithLabelValues(errorType, service).Dec()
}
```

### Dashboard Query Examples

```go
// Prometheus queries for dashboards

// 1. Error rate per minute
// rate(errors_total[1m])

// 2. Error rate by severity
// sum by (severity) (rate(errors_total[5m]))

// 3. Top error types
// topk(10, sum by (type) (rate(errors_total[1h])))

// 4. Error rate by service
// sum by (service) (rate(errors_total[5m]))

// 5. 95th percentile error handling duration
// histogram_quantile(0.95, rate(error_handling_duration_seconds_bucket[5m]))

// 6. Errors by environment
// sum by (environment) (errors_total)
```

---

## Part B: Testing Error Handling

---

## Unit Testing Error Scenarios

### Testing Error Returns

```go
func TestUserService_CreateUser_ValidationError(t *testing.T) {
    service := NewUserService(nil)
    
    tests := []struct {
        name    string
        input   *CreateUserInput
        wantErr bool
        errType error
    }{
        {
            name: "empty username",
            input: &CreateUserInput{
                Username: "",
                Email:    "test@example.com",
                Password: "password123",
            },
            wantErr: true,
            errType: &ValidationError{},
        },
        {
            name: "invalid email",
            input: &CreateUserInput{
                Username: "testuser",
                Email:    "invalid",
                Password: "password123",
            },
            wantErr: true,
            errType: &ValidationError{},
        },
        {
            name: "short password",
            input: &CreateUserInput{
                Username: "testuser",
                Email:    "test@example.com",
                Password: "short",
            },
            wantErr: true,
            errType: &ValidationError{},
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            _, err := service.CreateUser(tt.input)
            
            if (err != nil) != tt.wantErr {
                t.Errorf("CreateUser() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            
            if err != nil && tt.errType != nil {
                if !errors.As(err, &tt.errType) {
                    t.Errorf("CreateUser() error type = %T, want %T", err, tt.errType)
                }
            }
        })
    }
}
```

### Testing Error Wrapping

```go
func TestErrorWrapping(t *testing.T) {
    originalErr := errors.New("database connection failed")
    
    wrappedErr := fmt.Errorf("failed to fetch user: %w", originalErr)
    
    // Test errors.Is()
    if !errors.Is(wrappedErr, originalErr) {
        t.Error("errors.Is() failed to identify wrapped error")
    }
    
    // Test error message contains context
    expectedMessage := "failed to fetch user: database connection failed"
    if wrappedErr.Error() != expectedMessage {
        t.Errorf("error message = %q, want %q", wrappedErr.Error(), expectedMessage)
    }
}

func TestCustomErrorWrapping(t *testing.T) {
    baseErr := &DatabaseError{
        Operation: "SELECT",
        Table:     "users",
    }
    
    wrappedErr := fmt.Errorf("query failed: %w", baseErr)
    
    // Test errors.As()
    var dbErr *DatabaseError
    if !errors.As(wrappedErr, &dbErr) {
        t.Error("errors.As() failed to extract DatabaseError")
    }
    
    if dbErr.Operation != "SELECT" {
        t.Errorf("Operation = %q, want %q", dbErr.Operation, "SELECT")
    }
    
    if dbErr.Table != "users" {
        t.Errorf("Table = %q, want %q", dbErr.Table, "users")
    }
}
```

### Testing Error Types

```go
func TestErrorTypes(t *testing.T) {
    tests := []struct {
        name     string
        err      error
        checkErr error
        wantMatch bool
    }{
        {
            name:      "match sentinel error",
            err:       ErrNotFound,
            checkErr:  ErrNotFound,
            wantMatch: true,
        },
        {
            name:      "wrapped sentinel error",
            err:       fmt.Errorf("user not found: %w", ErrNotFound),
            checkErr:  ErrNotFound,
            wantMatch: true,
        },
        {
            name:      "different error",
            err:       ErrInvalidInput,
            checkErr:  ErrNotFound,
            wantMatch: false,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            matched := errors.Is(tt.err, tt.checkErr)
            
            if matched != tt.wantMatch {
                t.Errorf("errors.Is() = %v, want %v", matched, tt.wantMatch)
            }
        })
    }
}
```

---

## Integration Testing with Errors

### Testing HTTP Error Responses

```go
func TestHTTPErrorHandling(t *testing.T) {
    tests := []struct {
        name           string
        setupMock      func(*MockUserRepository)
        requestBody    string
        expectedStatus int
        expectedCode   string
    }{
        {
            name: "user not found",
            setupMock: func(repo *MockUserRepository) {
                repo.On("FindByID", int64(123)).Return(nil, ErrNotFound)
            },
            requestBody:    `{"id": 123}`,
            expectedStatus: http.StatusNotFound,
            expectedCode:   "NOT_FOUND",
        },
        {
            name: "validation error",
            setupMock: func(repo *MockUserRepository) {
                // No setup needed - validation happens before repo
            },
            requestBody:    `{"username": ""}`,
            expectedStatus: http.StatusBadRequest,
            expectedCode:   "BAD_REQUEST",
        },
        {
            name: "database error",
            setupMock: func(repo *MockUserRepository) {
                repo.On("Create", mock.Anything).Return(errors.New("connection lost"))
            },
            requestBody:    `{"username": "test", "email": "test@example.com", "password": "password123"}`,
            expectedStatus: http.StatusInternalServerError,
            expectedCode:   "INTERNAL_ERROR",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            mockRepo := &MockUserRepository{}
            if tt.setupMock != nil {
                tt.setupMock(mockRepo)
            }
            
            service := NewUserService(mockRepo)
            handler := NewUserHandler(service)
            
            req := httptest.NewRequest("POST", "/users", strings.NewReader(tt.requestBody))
            rec := httptest.NewRecorder()
            
            handler.ServeHTTP(rec, req)
            
            if rec.Code != tt.expectedStatus {
                t.Errorf("Status code = %d, want %d", rec.Code, tt.expectedStatus)
            }
            
            var response ErrorResponse
            if err := json.NewDecoder(rec.Body).Decode(&response); err != nil {
                t.Fatalf("Failed to decode response: %v", err)
            }
            
            if response.Code != tt.expectedCode {
                t.Errorf("Error code = %q, want %q", response.Code, tt.expectedCode)
            }
            
            mockRepo.AssertExpectations(t)
        })
    }
}
```

### Testing Error Propagation

```go
func TestErrorPropagation(t *testing.T) {
    // Setup layers
    mockDB := &MockDatabase{}
    repo := NewRepository(mockDB)
    service := NewService(repo)
    handler := NewHandler(service)
    
    // Inject error at database layer
    dbError := errors.New("connection timeout")
    mockDB.On("Query", mock.Anything).Return(nil, dbError)
    
    // Make request
    req := httptest.NewRequest("GET", "/users/123", nil)
    rec := httptest.NewRecorder()
    
    handler.ServeHTTP(rec, req)
    
    // Verify error propagated correctly
    if rec.Code != http.StatusInternalServerError {
        t.Errorf("Status code = %d, want %d", rec.Code, http.StatusInternalServerError)
    }
    
    // Verify error was wrapped with context at each layer
    var response ErrorResponse
    json.NewDecoder(rec.Body).Decode(&response)
    
    expectedMessage := "failed to get user"
    if !strings.Contains(response.Message, expectedMessage) {
        t.Errorf("Error message doesn't contain expected context: %q", response.Message)
    }
}
```

---

## Error Mocking and Simulation

### Mock Error Generator

```go
type ErrorSimulator struct {
    errorRate float64 // 0.0 to 1.0
    mu        sync.Mutex
}

func NewErrorSimulator(errorRate float64) *ErrorSimulator {
    return &ErrorSimulator{errorRate: errorRate}
}

func (es *ErrorSimulator) MaybeError() error {
    es.mu.Lock()
    defer es.mu.Unlock()
    
    if rand.Float64() < es.errorRate {
        return errors.New("simulated error")
    }
    return nil
}

func (es *ErrorSimulator) SetErrorRate(rate float64) {
    es.mu.Lock()
    defer es.mu.Unlock()
    es.errorRate = rate
}

// Usage in tests
func TestWithErrorSimulation(t *testing.T) {
    simulator := NewErrorSimulator(0.5) // 50% error rate
    
    successCount := 0
    errorCount := 0
    iterations := 1000
    
    for i := 0; i < iterations; i++ {
        if err := simulator.MaybeError(); err != nil {
            errorCount++
        } else {
            successCount++
        }
    }
    
    // Verify error rate is approximately 50%
    errorRate := float64(errorCount) / float64(iterations)
    if errorRate < 0.45 || errorRate > 0.55 {
        t.Errorf("Error rate = %.2f, want ~0.50", errorRate)
    }
}
```

### Mock Repository with Controllable Errors

```go
type MockRepository struct {
    mock.Mock
    failureMode FailureMode
    failCount   int
    maxFails    int
}

type FailureMode int

const (
    NoFailure FailureMode = iota
    AlwaysFail
    FailNTimes
    FailRandomly
)

func (m *MockRepository) SetFailureMode(mode FailureMode, params ...int) {
    m.failureMode = mode
    if len(params) > 0 {
        m.maxFails = params[0]
    }
    m.failCount = 0
}

func (m *MockRepository) shouldFail() bool {
    switch m.failureMode {
    case AlwaysFail:
        return true
    case FailNTimes:
        if m.failCount < m.maxFails {
            m.failCount++
            return true
        }
        return false
    case FailRandomly:
        return rand.Float64() < 0.3
    default:
        return false
    }
}

func (m *MockRepository) FindByID(id int64) (*User, error) {
    if m.shouldFail() {
        return nil, errors.New("mock error")
    }
    
    args := m.Called(id)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*User), args.Error(1)
}

// Test with controllable errors
func TestWithControllableErrors(t *testing.T) {
    mockRepo := &MockRepository{}
    service := NewUserService(mockRepo)
    
    // Test: Always fail
    mockRepo.SetFailureMode(AlwaysFail)
    _, err := service.GetUser(123)
    if err == nil {
        t.Error("Expected error with AlwaysFail mode")
    }
    
    // Test: Fail first 3 times, then succeed
    mockRepo.SetFailureMode(FailNTimes, 3)
    mockRepo.On("FindByID", int64(123)).Return(&User{ID: 123}, nil)
    
    for i := 0; i < 3; i++ {
        _, err := service.GetUser(123)
        if err == nil {
            t.Errorf("Expected error on attempt %d", i+1)
        }
    }
    
    // 4th attempt should succeed
    user, err := service.GetUser(123)
    if err != nil {
        t.Errorf("Expected success on 4th attempt, got error: %v", err)
    }
    if user.ID != 123 {
        t.Errorf("User ID = %d, want 123", user.ID)
    }
}
```

---

## Testing Error Propagation

### Multi-Layer Error Propagation Test

```go
func TestErrorPropagationThroughLayers(t *testing.T) {
    // Test that errors propagate correctly from DB → Repo → Service → Handler
    
    // Layer 1: Database (bottom)
    mockDB := &MockDatabase{}
    originalError := errors.New("connection timeout")
    mockDB.On("Query", mock.Anything).Return(nil, originalError)
    
    // Layer 2: Repository
    repo := NewUserRepository(mockDB)
    
    // Layer 3: Service
    service := NewUserService(repo)
    
    // Layer 4: Handler (top)
    handler := WrapHTTPHandler(func(w http.ResponseWriter, r *http.Request) error {
        _, err := service.GetUser(r.Context(), 123)
        return err
    })
    
    // Execute request
    req := httptest.NewRequest("GET", "/users/123", nil)
    rec := httptest.NewRecorder()
    handler.ServeHTTP(rec, req)
    
    // Verify error propagated to HTTP layer
    if rec.Code != http.StatusInternalServerError {
        t.Errorf("Status = %d, want %d", rec.Code, http.StatusInternalServerError)
    }
    
    // Verify error contains context from each layer
    var response map[string]interface{}
    json.NewDecoder(rec.Body).Decode(&response)
    
    message := response["message"].(string)
    
    // Should contain context from each layer
    expectedPhrases := []string{
        "failed to get user",  // Service layer
        "repository",          // Repository layer
        "query",              // Database layer
    }
    
    for _, phrase := range expectedPhrases {
        if !strings.Contains(strings.ToLower(message), strings.ToLower(phrase)) {
            t.Errorf("Error message missing context from layer: %q", phrase)
        }
    }
}
```

### Testing Error Recovery

```go
func TestErrorRecovery(t *testing.T) {
    // Test that system recovers from errors
    
    mockRepo := &MockRepository{}
    service := NewUserService(mockRepo)
    
    // First call fails
    mockRepo.On("FindByID", int64(123)).Return(nil, errors.New("temporary error")).Once()
    
    _, err := service.GetUser(context.Background(), 123)
    if err == nil {
        t.Error("Expected first call to fail")
    }
    
    // Second call succeeds
    expectedUser := &User{ID: 123, Username: "test"}
    mockRepo.On("FindByID", int64(123)).Return(expectedUser, nil).Once()
    
    user, err := service.GetUser(context.Background(), 123)
    if err != nil {
        t.Errorf("Expected second call to succeed, got error: %v", err)
    }
    
    if user.ID != expectedUser.ID {
        t.Errorf("User ID = %d, want %d", user.ID, expectedUser.ID)
    }
    
    mockRepo.AssertExpectations(t)
}
```

---

## Chaos Engineering for Error Handling

### Chaos Testing Framework

```go
type ChaosConfig struct {
    ErrorRate      float64       // Probability of injecting error (0.0-1.0)
    LatencyMin     time.Duration // Minimum added latency
    LatencyMax     time.Duration // Maximum added latency
    NetworkFailure bool          // Simulate network failures
    RandomPanics   bool          // Randomly panic to test recovery
}

type ChaosMiddleware struct {
    config ChaosConfig
    random *rand.Rand
    mu     sync.Mutex
}

func NewChaosMiddleware(config ChaosConfig) *ChaosMiddleware {
    return &ChaosMiddleware{
        config: config,
        random: rand.New(rand.NewSource(time.Now().UnixNano())),
    }
}

func (cm *ChaosMiddleware) Inject(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        cm.mu.Lock()
        
        // Random latency
        if cm.config.LatencyMax > 0 {
            latency := cm.randomDuration(cm.config.LatencyMin, cm.config.LatencyMax)
            cm.mu.Unlock()
            time.Sleep(latency)
            cm.mu.Lock()
        }
        
        // Random error
        if cm.random.Float64() < cm.config.ErrorRate {
            cm.mu.Unlock()
            http.Error(w, "Chaos: Injected error", http.StatusInternalServerError)
            return
        }
        
        // Random panic
        if cm.config.RandomPanics && cm.random.Float64() < 0.01 {
            cm.mu.Unlock()
            panic("Chaos: Injected panic")
        }
        
        cm.mu.Unlock()
        
        next.ServeHTTP(w, r)
    })
}

func (cm *ChaosMiddleware) randomDuration(min, max time.Duration) time.Duration {
    diff := max - min
    return min + time.Duration(cm.random.Int63n(int64(diff)))
}

// Usage in tests
func TestWithChaos(t *testing.T) {
    chaos := NewChaosMiddleware(ChaosConfig{
        ErrorRate:   0.1,  // 10% error rate
        LatencyMin:  10 * time.Millisecond,
        LatencyMax:  100 * time.Millisecond,
        RandomPanics: true,
    })
    
    handler := chaos.Inject(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("OK"))
    }))
    
    server := httptest.NewServer(handler)
    defer server.Close()
    
    successCount := 0
    errorCount := 0
    iterations := 100
    
    for i := 0; i < iterations; i++ {
        resp, err := http.Get(server.URL)
        if err != nil || resp.StatusCode != http.StatusOK {
            errorCount++
        } else {
            successCount++
        }
        
        if resp != nil {
            resp.Body.Close()
        }
    }
    
    t.Logf("Success: %d, Errors: %d", successCount, errorCount)
    
    // Verify we had both successes and failures
    if errorCount == 0 {
        t.Error("Expected some errors with chaos injection")
    }
    
    if successCount == 0 {
        t.Error("Expected some successes even with chaos")
    }
}
```

### Database Chaos Testing

```go
type ChaoticDatabase struct {
    db     *sql.DB
    config ChaosConfig
    random *rand.Rand
    mu     sync.Mutex
}

func NewChaoticDatabase(db *sql.DB, config ChaosConfig) *ChaoticDatabase {
    return &ChaoticDatabase{
        db:     db,
        config: config,
        random: rand.New(rand.NewSource(time.Now().UnixNano())),
    }
}

func (cd *ChaoticDatabase) Query(query string, args ...interface{}) (*sql.Rows, error) {
    if err := cd.maybeInjectError(); err != nil {
        return nil, err
    }
    
    cd.maybeInjectLatency()
    
    return cd.db.Query(query, args...)
}

func (cd *ChaoticDatabase) Exec(query string, args ...interface{}) (sql.Result, error) {
    if err := cd.maybeInjectError(); err != nil {
        return nil, err
    }
    
    cd.maybeInjectLatency()
    
    return cd.db.Exec(query, args...)
}

func (cd *ChaoticDatabase) maybeInjectError() error {
    cd.mu.Lock()
    defer cd.mu.Unlock()
    
    if cd.random.Float64() < cd.config.ErrorRate {
        errors := []error{
            errors.New("connection timeout"),
            errors.New("deadlock detected"),
            errors.New("connection refused"),
            sql.ErrConnDone,
        }
        
        return errors[cd.random.Intn(len(errors))]
    }
    
    return nil
}

func (cd *ChaoticDatabase) maybeInjectLatency() {
    if cd.config.LatencyMax == 0 {
        return
    }
    
    cd.mu.Lock()
    defer cd.mu.Unlock()
    
    latency := cd.config.LatencyMin + 
        time.Duration(cd.random.Int63n(int64(cd.config.LatencyMax-cd.config.LatencyMin)))
    
    time.Sleep(latency)
}

// Test with chaotic database
func TestDatabaseErrorHandling(t *testing.T) {
    // Real database for setup
    db, err := sql.Open("sqlite3", ":memory:")
    if err != nil {
        t.Fatal(err)
    }
    defer db.Close()
    
    // Create chaotic wrapper
    chaosDB := NewChaoticDatabase(db, ChaosConfig{
        ErrorRate:  0.3, // 30% failure rate
        LatencyMin: 10 * time.Millisecond,
        LatencyMax: 50 * time.Millisecond,
    })
    
    repo := NewUserRepository(chaosDB)
    
    // Test with retry logic
    var user *User
    maxRetries := 3
    
    for i := 0; i < maxRetries; i++ {
        user, err = repo.FindByID(123)
        if err == nil {
            break
        }
        
        t.Logf("Attempt %d failed: %v", i+1, err)
        time.Sleep(100 * time.Millisecond)
    }
    
    if err != nil && user == nil {
        // Even with retries, some errors are expected
        t.Logf("All retries failed (expected in chaos test): %v", err)
    }
}
```

### Network Failure Simulation

```go
type FailingHTTPClient struct {
    client     *http.Client
    failRate   float64
    timeoutRate float64
    mu         sync.Mutex
}

func NewFailingHTTPClient(failRate, timeoutRate float64) *FailingHTTPClient {
    return &FailingHTTPClient{
        client:      &http.Client{Timeout: 5 * time.Second},
        failRate:    failRate,
        timeoutRate: timeoutRate,
    }
}

func (fc *FailingHTTPClient) Do(req *http.Request) (*http.Response, error) {
    fc.mu.Lock()
    r := rand.Float64()
    fc.mu.Unlock()
    
    // Simulate timeout
    if r < fc.timeoutRate {
        return nil, &url.Error{
            Op:  "GET",
            URL: req.URL.String(),
            Err: errors.New("context deadline exceeded"),
        }
    }
    
    // Simulate connection error
    if r < fc.failRate {
        return nil, &url.Error{
            Op:  "GET",
            URL: req.URL.String(),
            Err: errors.New("connection refused"),
        }
    }
    
    return fc.client.Do(req)
}

// Test external API with network failures
func TestExternalAPIWithNetworkFailures(t *testing.T) {
    failingClient := NewFailingHTTPClient(0.3, 0.2)
    
    apiClient := &ExternalAPIClient{
        client:  failingClient,
        baseURL: "https://api.example.com",
    }
    
    successCount := 0
    errorCount := 0
    iterations := 50
    
    for i := 0; i < iterations; i++ {
        _, err := apiClient.FetchData(context.Background())
        if err != nil {
            errorCount++
            
            // Verify error is handled correctly
            if !IsNetworkError(err) {
                t.Errorf("Expected network error, got: %T", err)
            }
        } else {
            successCount++
        }
    }
    
    t.Logf("Success: %d, Errors: %d", successCount, errorCount)
    
    // Verify we got expected mix of successes and failures
    if errorCount < 10 {
        t.Errorf("Expected more errors with 50%% failure rate, got %d", errorCount)
    }
    
    if successCount < 10 {
        t.Errorf("Expected some successes, got %d", successCount)
    }
}
```

---

## Best Practices Summary

### Error Handling Best Practices Checklist

```go
// ✓ 1. Always check errors
func goodExample() error {
    file, err := os.Open("file.txt")
    if err != nil {
        return fmt.Errorf("failed to open file: %w", err)
    }
    defer file.Close()
    
    return nil
}

// ✗ Bad: Ignoring errors
func badExample() error {
    file, _ := os.Open("file.txt") // DON'T DO THIS
    defer file.Close()
    return nil
}

// ✓ 2. Add context to errors
func goodContextExample(userID int64) error {
    user, err := getUser(userID)
    if err != nil {
        return fmt.Errorf("failed to get user %d: %w", userID, err)
    }
    return nil
}

// ✓ 3. Use custom error types for different error categories
type NotFoundError struct {
    Resource string
    ID       interface{}
}

func (e *NotFoundError) Error() string {
    return fmt.Sprintf("%s not found: %v", e.Resource, e.ID)
}

// ✓ 4. Use errors.Is() and errors.As() for error checking
func goodErrorChecking(err error) {
    if errors.Is(err, ErrNotFound) {
        // Handle not found
    }
    
    var valErr *ValidationError
    if errors.As(err, &valErr) {
        // Handle validation error
    }
}

// ✓ 5. Wrap errors with %w for error chains
func goodWrapping() error {
    if err := operation(); err != nil {
        return fmt.Errorf("operation failed: %w", err)
    }
    return nil
}

// ✓ 6. Handle errors at appropriate level
func goodLevelHandling(ctx context.Context) error {
    // Low-level: Add context and propagate
    if err := dbOperation(); err != nil {
        return fmt.Errorf("database operation failed: %w", err)
    }
    
    // High-level: Decide what to do
    if err := businessOperation(ctx); err != nil {
        if errors.Is(err, ErrNotFound) {
            return HTTPError{StatusCode: 404, Message: "Not found"}
        }
        return HTTPError{StatusCode: 500, Message: "Internal error"}
    }
    
    return nil
}

// ✓ 7. Use defer for cleanup with error checking
func goodDeferWithError() (err error) {
    f, err := os.Create("file.txt")
    if err != nil {
        return err
    }
    
    defer func() {
        if closeErr := f.Close(); closeErr != nil && err == nil {
            err = closeErr
        }
    }()
    
    _, err = f.Write([]byte("data"))
    return err
}

// ✓ 8. Log errors with structured logging
func goodLogging(ctx context.Context, err error) {
    logger.Error("operation failed",
        "error", err,
        "request_id", getRequestID(ctx),
        "user_id", getUserID(ctx),
        "timestamp", time.Now(),
    )
}

// ✓ 9. Test error cases
func TestErrorHandling(t *testing.T) {
    tests := []struct {
        name    string
        input   string
        wantErr bool
    }{
        {"valid input", "valid", false},
        {"invalid input", "", true},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := process(tt.input)
            if (err != nil) != tt.wantErr {
                t.Errorf("process() error = %v, wantErr %v", err, tt.wantErr)
            }
        })
    }
}

// ✓ 10. Use panic only for unrecoverable errors
func goodPanicUsage() {
    config, err := loadConfig()
    if err != nil {
        // Config is required - cannot continue
        panic(fmt.Sprintf("Failed to load config: %v", err))
    }
}

// ✓ 11. Recover from panics in goroutines
func goodPanicRecovery() {
    go func() {
        defer func() {
            if r := recover(); r != nil {
                log.Printf("Recovered from panic: %v", r)
            }
        }()
        
        // Risky operation
        riskyOperation()
    }()
}

// ✓ 12. Use sentinel errors for well-known errors
var (
    ErrNotFound     = errors.New("not found")
    ErrUnauthorized = errors.New("unauthorized")
    ErrInvalidInput = errors.New("invalid input")
)

// ✓ 13. Implement Unwrap() for custom errors
type CustomError struct {
    Message string
    Cause   error
}

func (e *CustomError) Error() string {
    return e.Message
}

func (e *CustomError) Unwrap() error {
    return e.Cause
}

// ✓ 14. Use context for cancellation
func goodContextUsage(ctx context.Context) error {
    select {
    case <-ctx.Done():
        return fmt.Errorf("operation cancelled: %w", ctx.Err())
    case result := <-doWork():
        return processResult(result)
    }
}

// ✓ 15. Aggregate errors when processing multiple items
func goodErrorAggregation(items []Item) error {
    var errs []error
    
    for _, item := range items {
        if err := processItem(item); err != nil {
            errs = append(errs, fmt.Errorf("item %d: %w", item.ID, err))
        }
    }
    
    if len(errs) > 0 {
        return fmt.Errorf("failed to process %d items: %v", len(errs), errs)
    }
    
    return nil
}
```

### Production Readiness Checklist

```
Error Handling Production Readiness:

Infrastructure:
☑ Structured logging configured
☑ Log aggregation system in place (ELK, Splunk, CloudWatch)
☑ Error tracking system configured (Sentry, Rollbar)
☑ Metrics collection enabled (Prometheus, DataDog)
☑ Distributed tracing configured (Jaeger, Zipkin)

Monitoring:
☑ Error rate dashboards created
☑ Error alerts configured
☑ Alert channels set up (PagerDuty, Slack)
☑ Alert thresholds defined
☑ Alert throttling implemented

Code:
☑ All errors checked and handled
☑ Errors wrapped with context
☑ Custom error types for different categories
☑ HTTP errors return appropriate status codes
☑ Database errors handled with retries
☑ Network errors handled with circuit breakers
☑ Panics recovered in all goroutines
☑ Cleanup handled with defer

Testing:
☑ Unit tests for error scenarios
☑ Integration tests with error injection
☑ Error propagation tested
☑ Error recovery tested
☑ Chaos testing performed
☑ Load testing with error injection

Documentation:
☑ Error codes documented
☑ Error messages user-friendly
☑ Runbooks for common errors
☑ Incident response procedures defined
☑ Monitoring dashboards documented
```

### Error Handling Anti-Patterns to Avoid

```go
// ✗ 1. Silent failures
func bad1() {
    _, _ = doSomething() // DON'T IGNORE ERRORS
}

// ✗ 2. Generic error messages
func bad2() error {
    if err := operation(); err != nil {
        return errors.New("error") // NO CONTEXT
    }
    return nil
}

// ✗ 3. Not using %w for wrapping
func bad3() error {
    if err := operation(); err != nil {
        return fmt.Errorf("failed: %v", err) // Use %w not %v
    }
    return nil
}

// ✗ 4. Panic for expected errors
func bad4(input string) {
    if input == "" {
        panic("empty input") // Use error return
    }
}

// ✗ 5. Not recovering from panics in goroutines
func bad5() {
    go func() {
        riskyOperation() // Panic will crash program
    }()
}

// ✗ 6. Logging and returning error (double handling)
func bad6() error {
    if err := operation(); err != nil {
        log.Printf("Error: %v", err) // Log here
        return err                    // And also return - choose one
    }
    return nil
}

// ✗ 7. Not checking all error returns
func bad7() {
    file, err := os.Open("file.txt")
    if err != nil {
        return
    }
    file.Write([]byte("data")) // Not checking error
    file.Close()                // Not checking error
}

// ✗ 8. Using panic for control flow
func bad8() {
    defer func() {
        if r := recover(); r != nil {
            // Using panic/recover instead of error return
        }
    }()
    
    if condition {
        panic("condition failed")
    }
}

// ✗ 9. Swallowing errors in defer
func bad9() error {
    f, _ := os.Open("file.txt")
    defer f.Close() // Error ignored
    return nil
}

// ✗ 10. Not using custom error types
func bad10() error {
    return errors.New("user not found") // Should be custom type
}
```

---

## Complete Example: Production-Ready Error Handling System

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "os"
    "time"
)

// 1. Define error types
type AppError struct {
    Code       string                 `json:"code"`
    Message    string                 `json:"message"`
    StatusCode int                    `json:"-"`
    Internal   error                  `json:"-"`
    Context    map[string]interface{} `json:"context,omitempty"`
    Timestamp  time.Time              `json:"timestamp"`
    RequestID  string                 `json:"request_id"`
}

func (e *AppError) Error() string {
    return fmt.Sprintf("[%s] %s", e.Code, e.Message)
}

func (e *AppError) Unwrap() error {
    return e.Internal
}

// 2. Global error handler
var globalErrorHandler *GlobalErrorHandler

func InitErrorHandling() {
    logger := NewStructuredLogger(InfoLevel, os.Stdout)
    metrics := NewMetricsCollector()
    alerter := NewAlertSystem()
    
    globalErrorHandler = &GlobalErrorHandler{
        logger:  logger,
        metrics: metrics,
        alerter: alerter,
        tracker: NewErrorTracker(),
    }
}

// 3. HTTP middleware
func ErrorHandlingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Add request ID
        requestID := generateRequestID()
        ctx := context.WithValue(r.Context(), "request_id", requestID)
        
        // Panic recovery
        defer func() {
            if err := recover(); err != nil {
                globalErrorHandler.HandlePanic(ctx, err)
                sendErrorResponse(w, &AppError{
                    Code:       "INTERNAL_ERROR",
                    Message:    "Internal server error",
                    StatusCode: http.StatusInternalServerError,
                    Timestamp:  time.Now(),
                    RequestID:  requestID,
                })
            }
        }()
        
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// 4. Application handler with error handling
func GetUserHandler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    userID := r.URL.Query().Get("id")
    if userID == "" {
        sendErrorResponse(w, &AppError{
            Code:       "INVALID_INPUT",
            Message:    "User ID is required",
            StatusCode: http.StatusBadRequest,
            Timestamp:  time.Now(),
            RequestID:  getRequestID(ctx),
        })
        return
    }
    
    user, err := getUserFromDB(ctx, userID)
    if err != nil {
        handleError(ctx, w, err)
        return
    }
    
    json.NewEncoder(w).Encode(user)
}

func handleError(ctx context.Context, w http.ResponseWriter, err error) {
    // Track error
    globalErrorHandler.Track(ctx, err)
    
    // Convert to AppError
    var appErr *AppError
    if !errors.As(err, &appErr) {
        appErr = &AppError{
            Code:       "INTERNAL_ERROR",
            Message:    "An unexpected error occurred",
            StatusCode: http.StatusInternalServerError,
            Internal:   err,
            Timestamp:  time.Now(),
            RequestID:  getRequestID(ctx),
        }
    }
    
    // Send response
    sendErrorResponse(w, appErr)
}

func sendErrorResponse(w http.ResponseWriter, err *AppError) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(err.StatusCode)
    json.NewEncoder(w).Encode(err)
}

// 5. Main application
func main() {
    InitErrorHandling()
    
    mux := http.NewServeMux()
    mux.HandleFunc("/users", GetUserHandler)
    
    handler := ErrorHandlingMiddleware(mux)
    
    log.Println("Server starting on :8080")
    if err := http.ListenAndServe(":8080", handler); err != nil {
        log.Fatal(err)
    }
}
```

---

## Conclusion

This guide covered comprehensive error handling in Go including:

✅ **Production Error Management:**

- Structured logging with context
- Error monitoring and observability
- Multi-channel alerting (Slack, PagerDuty)
- Error metrics and dashboards
- Distributed tracing integration

✅ **Testing Error Handling:**

- Unit testing error scenarios
- Integration testing with error injection
- Error mocking and simulation
- Error propagation testing
- Chaos engineering

✅ **Best Practices:**

- Always check errors
- Add context to errors
- Use custom error types
- Wrap errors properly
- Test error scenarios
- Monitor errors in production

✅ **Production Readiness:**

- Complete monitoring setup
- Alert configuration
- Incident response procedures
- Comprehensive testing
- Documentation

Your error handling system is now production-ready with monitoring, alerting, testing, and best practices in place!
