# The Complete Go HTTP Request-Response Cycle: From Server Boot to Response

## Table of Contents

1. [Introduction - The Complete Journey](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#introduction)
2. [Server Startup - Phase by Phase](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#server-startup)
3. [Network Layer - TCP Connection Establishment](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#network-layer)
4. [Request Arrival - From Bytes to Structure](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#request-arrival)
5. [Request Processing - Through the Layers](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#request-processing)
6. [Handler Execution - Your Code Runs](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#handler-execution)
7. [Response Generation - Building the Reply](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#response-generation)
8. [Response Transmission - Bytes on the Wire](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#response-transmission)
9. [Connection Lifecycle - Keep-Alive and Closure](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#connection-lifecycle)
10. [Complete End-to-End Visualization](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#complete-visualization)
11. [Real-World Scenarios](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#real-world-scenarios)

---

## Introduction - The Complete Journey {#introduction}

Imagine you're watching a package delivery from the moment it's created to when it reaches the customer's door. You see:

- The warehouse opening (server startup)
- A truck arriving (TCP connection)
- Loading the package (request parsing)
- Routing through sorting centers (middleware, routing)
- Final delivery (handler execution)
- Return receipt (response)
- Truck returning for next delivery (connection reuse)

This guide provides that complete view for HTTP requests in Go. We'll trace EVERY step from `go run main.go` to the response bytes leaving the server, with detailed visualizations at each stage.

---

## Server Startup - Phase by Phase {#server-startup}

### Your Starting Code

```go
package main

import (
    "fmt"
    "log"
    "net/http"
)

func main() {
    http.HandleFunc("/hello", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Hello, World!")
    })
    
    log.Println("Server starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

### Complete Startup Sequence Visualization

```
┌───────────────────────────────────────────────────────────────────────────┐
│                    COMPLETE SERVER STARTUP SEQUENCE                       │
└───────────────────────────────────────────────────────────────────────────┘

Time    Phase                           Action                      State
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

0ms     ┌─────────────────────┐
        │ PROGRAM LOAD        │         OS loads executable        [LOADING]
        └──────────┬──────────┘         into memory
                   │
1ms                ↓
        ┌─────────────────────┐
        │ GO RUNTIME INIT     │         - Memory allocator         [INIT]
        │                     │         - GC structures
        │   ┌─────────────┐   │         - Scheduler (GMP)
        │   │ Memory Mgmt │   │         - Set GOMAXPROCS=8
        │   ├─────────────┤   │         - Create sysmon
        │   │ GC Setup    │   │         - Network poller
        │   ├─────────────┤   │
        │   │ Scheduler   │   │
        │   └─────────────┘   │
        └──────────┬──────────┘
                   │
2ms                ↓
        ┌─────────────────────┐
        │ IMPORT INIT         │         - net/http package         [INIT]
        │                     │         - DefaultServeMux
        │  ┌──────────────┐   │         - Transport layer
        │  │ net/http     │   │         - Default timeouts
        │  ├──────────────┤   │
        │  │ Init funcs   │   │
        │  └──────────────┘   │
        └──────────┬──────────┘
                   │
3ms                ↓
        ┌─────────────────────┐
        │ MAIN GOROUTINE      │         Main goroutine created     [RUNNING]
        │                     │         and starts executing
        │   ┌─────────────┐   │
        │   │  main()     │   │
        │   └─────────────┘   │
        └──────────┬──────────┘
                   │
3ms                ↓
        ┌─────────────────────┐
        │ HANDLER REGISTER    │         http.HandleFunc()          [READY]
        │                     │         creates muxEntry
        │  DefaultServeMux    │
        │  ┌──────────────┐   │         Pattern: "/hello"
        │  │ "/hello" →   │   │         Handler: HandlerFunc
        │  │   handler    │   │
        │  └──────────────┘   │
        └──────────┬──────────┘
                   │
4ms                ↓
        ┌─────────────────────┐
        │ CREATE SOCKET       │         socket() system call       [SOCKET]
        │                     │         Returns fd: 3
        │  ┌──────────────┐   │
        │  │  TCP Socket  │   │         Type: SOCK_STREAM
        │  │  FD: 3       │   │         Protocol: TCP
        │  └──────────────┘   │
        └──────────┬──────────┘
                   │
4ms                ↓
        ┌─────────────────────┐
        │ BIND TO PORT        │         bind() system call         [BOUND]
        │                     │
        │  ┌──────────────┐   │         Address: 0.0.0.0:8080
        │  │ 0.0.0.0:8080 │   │         (All interfaces)
        │  │  BOUND       │   │
        │  └──────────────┘   │         Port 8080 now reserved
        └──────────┬──────────┘
                   │
5ms                ↓
        ┌─────────────────────┐
        │ START LISTENING     │         listen() system call       [LISTEN]
        │                     │
        │  ┌──────────────┐   │         Backlog: 128 connections
        │  │  Listening   │   │         Socket marked passive
        │  │  Queue: 0/128│   │
        │  └──────────────┘   │
        └──────────┬──────────┘
                   │
5ms                ↓
        ┌─────────────────────┐
        │ ACCEPT LOOP         │         Enter accept loop          [SERVING]
        │                     │
        │  ┌──────────────┐   │         Blocked in Accept()
        │  │ for {        │   │         Waiting for connections
        │  │   Accept()   │◄──┼─────    System call blocks here
        │  │   spawn()    │   │
        │  │ }            │   │
        │  └──────────────┘   │
        └─────────────────────┘

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Final State at 5ms:
┌────────────────────────────────────────────────────────────┐
│  SERVER READY                                              │
│  ─────────────────────────────────────────────────────     │
│  Listening:    0.0.0.0:8080                                │
│  Handlers:     1 ("/hello")                                │
│  Goroutines:   2 (main + sysmon)                           │
│  Memory:       ~2MB                                        │
│  State:        WAITING FOR CONNECTIONS                     │
│  CPU Usage:    0% (blocked in Accept)                      │
└────────────────────────────────────────────────────────────┘
```

---

## Network Layer - TCP Connection Establishment {#network-layer}

A client wants to connect. Let's watch the TCP handshake in detail.

### Three-Way Handshake Visualization

```
┌───────────────────────────────────────────────────────────────────────────┐
│              TCP THREE-WAY HANDSHAKE (Detailed Timeline)                  │
└───────────────────────────────────────────────────────────────────────────┘

Client (192.168.1.50:54321)                      Server (192.168.1.100:8080)
      │                                                      │
      │                                              ┌───────┴────────┐
T=0ms │                                              │ Accept() blocks│
      │                                              │ (sleeping)     │
      │                                              └───────┬────────┘
      │                                                      │
      │ ──────── SYN Packet ─────────────────────────────--─→│
      │                                                      │
      │  ┌────────────────────────────────────┐              │
      │  │ Source: 192.168.1.50:54321         │              │
      │  │ Dest:   192.168.1.100:8080         │              │
      │  │ Flags:  SYN                        │              │
      │  │ Seq:    1000                       │              │
      │  │ Window: 65535 bytes                │              │
      │  └────────────────────────────────────┘              │
      │                                                      │
      │                                              ┌───────▼────────┐
      │                                              │ Kernel receives│
      │                                              │ SYN packet     │
      │                                              │                │
      │                                              │ Creates TCB    │
      │                                              │ (Control Block)│
      │                                              └───────┬────────┘
T=1ms │                                                      │
      │                                                      │
      │ ←──────── SYN-ACK Packet ─────────────────────────── │
      │                                                      │
      │  ┌────────────────────────────────────┐              │
      │  │ Source: 192.168.1.100:8080         │              │
      │  │ Dest:   192.168.1.50:54321         │              │
      │  │ Flags:  SYN + ACK                  │              │
      │  │ Seq:    2000                       │              │
      │  │ Ack:    1001 (1000 + 1)            │              │
      │  │ Window: 65535 bytes                │              │
      │  └────────────────────────────────────┘              │
      │                                                      │
  ┌───▼────┐                                                 │
  │ Kernel │                                                 │
  │receives│                                                 │
  │SYN-ACK │                                                 │
  │        │                                                 │
  │Creates │                                                 │
  │TCB     │                                                 │
  └───┬────┘                                                 │
T=2ms │                                                      │
      │                                                      │
      │ ──────── ACK Packet ────────────────────────────-──→ │
      │                                                      │
      │  ┌────────────────────────────────────┐              │
      │  │ Source: 192.168.1.50:54321         │              │
      │  │ Dest:   192.168.1.100:8080         │              │
      │  │ Flags:  ACK                        │              │
      │  │ Seq:    1001                       │              │
      │  │ Ack:    2001 (2000 + 1)            │              │
      │  └────────────────────────────────────┘              │
      │                                                      │
      │                                              ┌───────▼────────┐
      │                                              │ Connection     │
      │                                              │ ESTABLISHED    │
      │                                              │                │
      │                                              │ Add to accept  │
      │                                              │ queue          │
      │                                              └───────┬────────┘
      │                                                      │
      │                                              ┌───────▼────────┐
      │                                              │ Accept() wakes │
      │                                              │ Returns conn   │
      │                                              └────────────────┘
      │                                                      │
      │════════════════════════════════════════════════════│
      │         CONNECTION ESTABLISHED                     │
      │    Both sides can now send/receive data            │
      │════════════════════════════════════════════════════│
```

### Connection Object Creation

```
┌───────────────────────────────────────────────────────────────────────────┐
│                 CONNECTION OBJECT AFTER ACCEPT()                          │
└───────────────────────────────────────────────────────────────────────────┘

When ln.Accept() returns, Go creates:

┌─────────────────────────────────────────────────────────────────────────┐
│  net.TCPConn (implements net.Conn interface)                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Connection Identity:                                                   │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │  File Descriptor: 5                (OS handle)                 │    │
│  │  Local Address:   192.168.1.100:8080                           │    │
│  │  Remote Address:  192.168.1.50:54321                           │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  State Information:                                                     │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │  TCP State:     ESTABLISHED                                    │    │
│  │  Bytes Sent:    0                                              │    │
│  │  Bytes Received:0                                              │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  Buffers:                                                               │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │  Read Buffer:   [Empty] (4KB capacity)                         │    │
│  │  Write Buffer:  [Empty] (4KB capacity)                         │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  Timeouts (from Server config):                                         │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │  Read Timeout:  15 seconds                                     │    │
│  │  Write Timeout: 15 seconds                                     │    │
│  │  Idle Timeout:  60 seconds                                     │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  OS-Level Socket Options:                                               │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │  TCP_NODELAY:   enabled   (Nagle's algorithm off)             │    │
│  │  SO_KEEPALIVE:  enabled   (TCP keep-alive)                    │    │
│  │  SO_REUSEADDR:  enabled   (Port reuse)                        │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### Goroutine Spawning

```
┌───────────────────────────────────────────────────────────────────────────┐
│              SERVER SPAWNS CONNECTION GOROUTINE                           │
└───────────────────────────────────────────────────────────────────────────┘

Main Goroutine (Accept Loop):          New Connection Goroutine:
       │                                        
T=2ms  │ conn, err := ln.Accept() ✓             
       │ (returns with connection)              
       │                                        
T=2ms  ├─→ go c.serve(ctx) ─────────────────-───┐
       │                                        │
       │                                        │ Goroutine Created
       │                                        │ Stack: 2KB allocated
       │                                        │ State: Runnable
       │                                        ↓
       │                                 ┌─────────────────┐
       │                                 │ Waiting for CPU │
       │                                 │ In run queue    │
       │                                 └────────┬────────┘
T=2ms  │                                          │
       └─→ back to Accept()                       │ Scheduler assigns CPU
       │   (blocks immediately)                   │
       │                                          ↓
       │                                 ┌─────────────────┐
       │                                 │ c.serve() runs  │
       │                                 │ State: Running  │
       │                                 └─────────────────┘

Memory Usage Per Connection:
┌────────────────────────────────────────────────────┐
│  Goroutine stack:        2,048 bytes               │
│  Connection buffers:     8,192 bytes (2 × 4KB)     │
│  http.conn struct:         512 bytes               │
│  Misc overhead:            256 bytes               │
│  ─────────────────────────────────────────────     │
│  Total per connection: ~11,000 bytes (~11KB)       │
└────────────────────────────────────────────────────┘

Capacity: With 1GB memory dedicated to connections:
          1GB / 11KB ≈ 93,000 concurrent connections
```

---

## Request Arrival - From Bytes to Structure {#request-arrival}

Now the client sends an HTTP request. Let's watch it get parsed byte by byte.

### HTTP Request on the Wire

```
┌───────────────────────────────────────────────────────────────────────────┐
│              CLIENT SENDS HTTP REQUEST (RAW BYTES)                        │
└───────────────────────────────────────────────────────────────────────────┘

Client executes: curl http://localhost:8080/hello

Bytes sent over TCP connection:

Hex View:                                     ASCII View:
───────────────────────────────────────────   ──────────────────────────────
47 45 54 20 2f 68 65 6c 6c 6f 20 48 54 54     GET /hello HTT
50 2f 31 2e 31 0d 0a                          P/1.1\r\n
48 6f 73 74 3a 20 6c 6f 63 61 6c 68 6f 73     Host: localhos
74 3a 38 30 38 30 0d 0a                       t:8080\r\n
55 73 65 72 2d 41 67 65 6e 74 3a 20 63 75     User-Agent: cu
72 6c 2f 37 2e 38 30 2e 30 0d 0a              rl/7.80.0\r\n
41 63 63 65 70 74 3a 20 2a 2f 2a 0d 0a        Accept: */*\r\n
0d 0a                                         \r\n

Total: 80 bytes

Breakdown:
┌────────────────────────────────────────────────────────┐
│  Request Line:    21 bytes  "GET /hello HTTP/1.1"     │
│  Host Header:     25 bytes  "Host: localhost:8080"    │
│  User-Agent:      27 bytes  "User-Agent: curl/7.80.0" │
│  Accept Header:   15 bytes  "Accept: */*"             │
│  Blank Line:       2 bytes  "\r\n"                    │
│  ─────────────────────────────────────────────────     │
│  Total:           80 bytes                             │
└────────────────────────────────────────────────────────┘
```

### Reading and Buffering

```
┌───────────────────────────────────────────────────────────────────────────┐
│              READING REQUEST FROM TCP CONNECTION                          │
└───────────────────────────────────────────────────────────────────────────┘

Connection Goroutine Execution:

func (c *conn) serve(ctx context.Context) {
    // Step 1: Create buffered reader
    br := bufio.NewReader(c.rwc)
    
    Step 1: Create Reader
    ┌─────────────────────────────────────────┐
    │  bufio.Reader                           │
    │  ┌───────────────────────────────────┐  │
    │  │  Buffer: 4KB (4096 bytes)        │  │
    │  │  Filled: 0 bytes                 │  │
    │  │  Position: 0                     │  │
    │  └───────────────────────────────────┘  │
    └─────────────────────────────────────────┘
    
    // Step 2: Read from TCP connection
    n, err := c.rwc.Read(br.buf)
    
    Step 2: Read System Call
    ┌────────────────────────────────┐
    │  read(fd=5, buf, 4096)         │  ← System call
    │  ─────────────────────────     │
    │  Blocks if no data available   │
    │  Returns when data arrives     │
    └────────────────────────────────┘
                    ↓
    ┌─────────────────────────────────────────┐
    │  bufio.Reader                           │
    │  ┌───────────────────────────────────┐  │
    │  │  Buffer: 4KB                      │  │
    │  │  Filled: 80 bytes ✓               │  │
    │  │  ┌────────────────────────────┐   │  │
    │  │  │ GET /hello HTTP/1.1\r\n    │   │  │
    │  │  │ Host: localhost:8080\r\n   │   │  │
    │  │  │ User-Agent: curl/7.80.0\r\n│   │  │
    │  │  │ Accept: */*\r\n            │   │  │
    │  │  │ \r\n                       │   │  │
    │  │  │ [Rest empty]               │   │  │
    │  │  └────────────────────────────┘   │  │
    │  └───────────────────────────────────┘  │
    └─────────────────────────────────────────┘
}
```

### Parsing Request Line

```
┌───────────────────────────────────────────────────────────────────────────┐
│                  PARSING HTTP REQUEST LINE                                │
└───────────────────────────────────────────────────────────────────────────┘

Input: "GET /hello HTTP/1.1\r\n"

Step 1: Read until \r\n
┌──────────────────────────────────┐
│ "GET /hello HTTP/1.1"            │
└──────────────────────────────────┘

Step 2: Split by spaces
┌────────┐  ┌────────┐  ┌──────────┐
│  GET   │  │ /hello │  │ HTTP/1.1 │
└───┬────┘  └───┬────┘  └────┬─────┘
    │           │             │
Method      Path/URI      Protocol

Step 3: Validate and Store
┌─────────────────────────────────────────────────────────┐
│  http.Request                                           │
│  ┌───────────────────────────────────────────────────┐  │
│  │  Method:      "GET"           ✓ Valid method     │  │
│  │  RequestURI:  "/hello"        ✓ Valid URI        │  │
│  │  Proto:       "HTTP/1.1"      ✓ Valid protocol   │  │
│  │  ProtoMajor:  1                                  │  │
│  │  ProtoMinor:  1                                  │  │
│  └───────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘

Step 4: Parse URL
Input: "/hello"
┌─────────────────────────────────────────────────────────┐
│  url.URL                                                │
│  ┌───────────────────────────────────────────────────┐  │
│  │  Scheme:   ""          (filled by server)         │  │
│  │  Host:     ""          (from Host header)         │  │
│  │  Path:     "/hello"    ✓ Extracted               │  │
│  │  RawQuery: ""          (no ? in path)             │  │
│  └───────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

### Parsing Headers

```
┌───────────────────────────────────────────────────────────────────────────┐
│                    PARSING HTTP HEADERS                                   │
└───────────────────────────────────────────────────────────────────────────┘

Reading Loop:
┌────────────────────────────────────────────────────────┐
│ for {                                                  │
│     line, err := br.ReadString('\n')                   │
│     if line == "\r\n" {                                │
│         break  // Blank line signals end of headers    │
│     }                                                  │
│     key, value := parseHeader(line)                    │
│     headers.Add(key, value)                            │
│ }                                                      │
└────────────────────────────────────────────────────────┘

Iteration 1:
Input:  "Host: localhost:8080\r\n"
        ↓ Split at first ":"
Key:    "Host"
Value:  " localhost:8080"
        ↓ Trim spaces
Value:  "localhost:8080"
        ↓ Store
headers["Host"] = ["localhost:8080"]

Iteration 2:
Input:  "User-Agent: curl/7.80.0\r\n"
Key:    "User-Agent"
Value:  "curl/7.80.0"
headers["User-Agent"] = ["curl/7.80.0"]

Iteration 3:
Input:  "Accept: */*\r\n"
Key:    "Accept"
Value:  "*/*"
headers["Accept"] = ["*/*"]

Iteration 4:
Input:  "\r\n"
        ↓ Blank line detected
Break loop

Final Headers Map:
┌───────────────────────────────────────────────────────┐
│  http.Header (map[string][]string)                   │
│  ┌─────────────────────────────────────────────────┐  │
│  │  "Host":       ["localhost:8080"]              │  │
│  │  "User-Agent": ["curl/7.80.0"]                 │  │
│  │  "Accept":     ["*/*"]                          │  │
│  └─────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────┘
```

Now we have a complete `http.Request` object ready for processing!

## Request Processing - Through the Layers {#request-processing}

The complete `http.Request` object is now ready. Let's watch it flow through the server layers.

### Complete Request Object

```
┌───────────────────────────────────────────────────────────────────────────┐
│                  COMPLETE http.Request OBJECT                             │
└───────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│  http.Request                                                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  HTTP Method and URL:                                                   │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │  Method:     "GET"                                             │    │
│  │  URL:        &url.URL{Path: "/hello"}                          │    │
│  │  RequestURI: "/hello"                                          │    │
│  │  Proto:      "HTTP/1.1"                                        │    │
│  │  ProtoMajor: 1                                                 │    │
│  │  ProtoMinor: 1                                                 │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│  Headers:                                                               │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │  Header: map[string][]string{                                  │    │
│  │      "Host":       ["localhost:8080"],                         │    │
│  │      "User-Agent": ["curl/7.80.0"],                            │    │
│  │      "Accept":     ["*/*"],                                    │    │
│  │  }                                                             │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│  Connection Info:                                                       │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │  Host:       "localhost:8080"  (from Host header)              │    │
│  │  RemoteAddr: "192.168.1.50:54321"                              │    │
│  │  TLS:        nil (not HTTPS)                                   │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│  Body:                                                                  │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │  Body:          nil (GET request, no body)                     │    │
│  │  ContentLength: 0                                              │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│  Context:                                                               │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │  Context:   context.Background()                               │    │
│  │             (can be used for cancellation, timeouts)           │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘

Memory location: Stack of connection goroutine
Size: ~1.5KB for the struct + headers
```

### Routing - Finding the Handler

```
┌───────────────────────────────────────────────────────────────────────────┐
│                  ROUTING REQUEST TO HANDLER                               │
└───────────────────────────────────────────────────────────────────────────┘

Server calls: serverHandler{srv}.ServeHTTP(w, req)
                    ↓
            Uses DefaultServeMux
                    ↓

Step 1: Extract Path
┌────────────────────────────────┐
│  path := req.URL.Path          │
│  path = "/hello"               │
└────────────────────────────────┘

Step 2: Match Against Registered Patterns
┌──────────────────────────────────────────────────────────────────┐
│  ServeMux Pattern Matching                                       │
│                                                                  │
│  Registered Patterns:                                            │
│  ┌────────────┬──────────────────────────────────────┐           │
│  │  Pattern   │  Handler                             │           │
│  ├────────────┼──────────────────────────────────────┤           │
│  │  "/hello"  │  HandlerFunc(yourFunc) ◄─── Match!   │           │
│  │  "/"       │  NotFoundHandler                     │           │
│  └────────────┴──────────────────────────────────────┘           │
│                                                                  │
│  Matching Algorithm:                                             │
│  1. Exact match: "/hello" == "/hello" ✓                          │
│  2. This pattern wins                                            │
└──────────────────────────────────────────────────────────────────┘

Step 3: Extract Handler
┌────────────────────────────────┐
│  handler := mux.m["/hello"].h  │
│  handler = HandlerFunc(...)    │
└────────────────────────────────┘

Routing Timeline:
T=0µs    Path extraction           "/hello"
T=1µs    Pattern lookup            map lookup O(1)
T=2µs    Handler found             HandlerFunc
T=3µs    Ready to call             handler.ServeHTTP()

Total routing time: ~3 microseconds
```

### Creating Response Writer

```
┌───────────────────────────────────────────────────────────────────────────┐
│              RESPONSE WRITER CREATION                                     │
└───────────────────────────────────────────────────────────────────────────┘

Before calling handler, server creates http.ResponseWriter:

┌─────────────────────────────────────────────────────────────────────────┐
│  http.response (implements http.ResponseWriter)                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Connection Reference:                                                  │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │  conn: *conn (pointer to connection)                           │    │
│  │  req:  *Request (pointer to request)                           │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  Response State:                                                        │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │  status:      0 (not yet written)                              │    │
│  │  wroteHeader: false                                            │    │
│  │  written:     0 bytes                                          │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  Headers:                                                               │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │  header: make(http.Header)  // Empty map initially             │    │
│  │  {                                                             │    │
│  │     // Handler will add headers here                           │    │
│  │  }                                                             │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  Write Buffer:                                                          │
│  ┌────────────────────────────────────────────────────────────────┐     │
│  │  w: *bufio.Writer                                              │     │
│  │  Buffer: 4KB (writes buffered before flushing)                 │     │
│  └────────────────────────────────────────────────────────────────┘     │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Handler Execution - Your Code Runs {#handler-execution}

Finally, your handler function executes. Let's watch it step by step.

### Handler Call

```
┌───────────────────────────────────────────────────────────────────────────┐
│                  HANDLER FUNCTION EXECUTION                               │
└───────────────────────────────────────────────────────────────────────────┘

Server calls: handler.ServeHTTP(w, req)
                    ↓
           Your function runs:

func(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, World!")
}

Execution Flow:
┌────────────────────────────────────────────────────────────┐
│  Step 1: Function enters                                   │
│  ─────────────────────────────────────────────────────     │
│  - Parameters received:                                    │
│    w: http.ResponseWriter (response object)                │
│    r: *http.Request (request object)                       │
│  - Function stack frame created (~100 bytes)               │
└────────────────────────────────────────────────────────────┘
            ↓
┌────────────────────────────────────────────────────────────┐
│  Step 2: fmt.Fprintf(w, "Hello, World!")                   │
│  ─────────────────────────────────────────────────────     │
│  Internally calls:                                         │
│    w.Write([]byte("Hello, World!"))                        │
└────────────────────────────────────────────────────────────┘
            ↓
┌────────────────────────────────────────────────────────────┐
│  Step 3: w.Write() execution                               │
│  (See next section for details)                            │
└────────────────────────────────────────────────────────────┘
            ↓
┌────────────────────────────────────────────────────────────┐
│  Step 4: Function returns                                  │
│  ─────────────────────────────────────────────────────     │
│  - No explicit return statement needed                     │
│  - Control returns to server                               │
│  - Server will finish response and close/reuse connection  │
└────────────────────────────────────────────────────────────┘

Handler Timeline:
T=0µs     Handler function called
T=1µs     fmt.Fprintf processes format string
T=2µs     w.Write() called
T=2µs     WriteHeader(200) implicitly called
T=3µs     "Hello, World!" written to buffer
T=4µs     Function returns
Total: 4 microseconds (actual work)
```

### Write() Method Execution

```
┌───────────────────────────────────────────────────────────────────────────┐
│              ResponseWriter.Write() INTERNAL EXECUTION                    │
└───────────────────────────────────────────────────────────────────────────┘

func (w *response) Write(data []byte) (n int, err error) {

Step 1: Check if header written
┌────────────────────────────────────────┐
│  if !w.wroteHeader {                   │
│      w.WriteHeader(200)  // Default    │
│  }                                     │
└────────────────────────────────────────┘
            ↓

Step 2: WriteHeader() execution
┌──────────────────────────────────────────────────────────────┐
│  func (w *response) WriteHeader(code int) {                  │
│                                                              │
│    Step 2a: Check if already written                         │
│    ┌──────────────────────────────────────────────┐          │
│    │  if w.wroteHeader {                          │          │
│    │      return  // Already wrote header         │          │
│    │  }                                           │          │
│    │  w.wroteHeader = true                        │          │
│    └──────────────────────────────────────────────┘          │
│            ↓                                                 │
│    Step 2b: Set status code                                  │
│    ┌──────────────────────────────────────────────┐          │
│    │  w.status = 200                              │          │
│    └──────────────────────────────────────────────┘          │
│            ↓                                                 │
│    Step 2c: Write status line                                │
│    ┌──────────────────────────────────────────────┐          │
│    │  fmt.Fprintf(w.w, "HTTP/1.1 %d %s\r\n",      │          │
│    │             200, "OK")                       │          │
│    │  // Writes: "HTTP/1.1 200 OK\r\n"            │          │
│    └──────────────────────────────────────────────┘          │
│            ↓                                                 │
│    Step 2d: Write headers                                    │
│    ┌──────────────────────────────────────────────┐          │
│    │  for key, values := range w.header {         │          │
│    │      for _, value := range values {          │          │
│    │          fmt.Fprintf(w.w, "%s: %s\r\n",      │         │
│    │                     key, value)              │         │
│    │      }                                       │         │
│    │  }                                           │         │
│    └──────────────────────────────────────────────┘         │
│            ↓                                                 │
│    Step 2e: Automatically add headers                       │
│    ┌──────────────────────────────────────────────┐         │
│    │  // Date header                              │         │
│    │  fmt.Fprintf(w.w, "Date: %s\r\n",            │         │
│    │             time.Now().UTC().Format(...))    │         │
│    │                                              │         │
│    │  // Content-Length (if known)                │         │
│    │  if w.contentLength > 0 {                    │         │
│    │      fmt.Fprintf(w.w, "Content-Length: %d\r\n",│       │
│    │                 w.contentLength)             │         │
│    │  }                                           │         │
│    └──────────────────────────────────────────────┘         │
│            ↓                                                │
│    Step 2f: Blank line (end of headers)                     │
│    ┌──────────────────────────────────────────────┐         │
│    │  fmt.Fprintf(w.w, "\r\n")                    │         │
│    └──────────────────────────────────────────────┘         │
│  }                                                          │
└─────────────────────────────────────────────────────────────┘
            ↓

Step 3: Write body data
┌────────────────────────────────────────┐
│  return w.w.Write(data)                │
│  // Writes: "Hello, World!"            │
└────────────────────────────────────────┘
}

Buffer State After Write:
┌─────────────────────────────────────────────────────────┐
│  bufio.Writer Buffer (4KB)                              │
│  ┌───────────────────────────────────────────────────┐  │
│  │  HTTP/1.1 200 OK\r\n                              │  │
│  │  Date: Sun, 28 Dec 2025 10:30:00 GMT\r\n          │  │
│  │  Content-Length: 13\r\n                           │  │
│  │  \r\n                                             │  │
│  │  Hello, World!                                    │  │
│  │  [Rest empty]                                     │  │
│  └───────────────────────────────────────────────────┘  │
│  Bytes used: ~95 bytes                                  │
└─────────────────────────────────────────────────────────┘
```

---

## Response Generation - Building the Reply {#response-generation}

The response is now buffered. Let's see how it gets completed and prepared for transmission.

### Complete Response in Buffer

```
┌───────────────────────────────────────────────────────────────────────────┐
│              COMPLETE HTTP RESPONSE IN BUFFER                             │
└───────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│  Response Structure:                                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Status Line:                                                           │
│  ┌────────────────────────────────────────────────────────────────┐     │
│  │  HTTP/1.1 200 OK\r\n                                (17 bytes) │     │
│  └────────────────────────────────────────────────────────────────┘     │
│                                                                         │
│  Headers:                                                               │
│  ┌────────────────────────────────────────────────────────────────┐     │
│  │  Date: Sun, 28 Dec 2025 10:30:00 GMT\r\n        (39 bytes)     │     │
│  │  Content-Length: 13\r\n                          (19 bytes)    │     │
│  │  Content-Type: text/plain; charset=utf-8\r\n    (41 bytes)     │     │
│  └────────────────────────────────────────────────────────────────┘     │
│                                                                         │
│  Blank Line (separates headers from body):                              │
│  ┌────────────────────────────────────────────────────────────────┐     │
│  │  \r\n                                             (2 bytes)    │     │
│  └────────────────────────────────────────────────────────────────┘     │
│                                                                         │
│  Body:                                                                  │
│  ┌────────────────────────────────────────────────────────────────┐     │
│  │  Hello, World!                                    (13 bytes)   │     │
│  └────────────────────────────────────────────────────────────────┘     │
│                                                                         │
│  ────────────────────────────────────────────────────────────────────   │
│  Total Response Size: 131 bytes                                         │
└─────────────────────────────────────────────────────────────────────────┘

Byte-by-byte view:
┌──────────────────────────────────────────────────────────────┐
│  Offset   Hex                              ASCII             │
│  ──────   ───────────────────────────      ───────────────── │
│  0000:    48 54 54 50 2f 31 2e 31 20      HTTP/1.1           │
│  0009:    32 30 30 20 4f 4b 0d 0a         200 OK\r\n         │
│  0017:    44 61 74 65 3a 20 53 75 6e      Date: Sun          │
│  0026:    2c 20 32 38 20 44 65 63 20      , 28 Dec           │
│  0035:    32 30 32 35 20 31 30 3a 33      2025 10:3          │
│  0044:    30 3a 30 30 20 47 4d 54 0d      0:00 GMT\r         │
│  0053:    0a 43 6f 6e 74 65 6e 74 2d      \nContent-         │
│  0062:    4c 65 6e 67 74 68 3a 20 31      Length: 1          │
│  0071:    33 0d 0a 43 6f 6e 74 65 6e      3\r\nConten        │
│  0080:    74 2d 54 79 70 65 3a 20 74      t-Type: t          │
│  0089:    65 78 74 2f 70 6c 61 69 6e      ext/plain          │
│  0098:    3b 20 63 68 61 72 73 65 74      ; charset          │
│  0107:    3d 75 74 66 2d 38 0d 0a 0d      =utf-8\r\n\r       │
│  0116:    0a 48 65 6c 6c 6f 2c 20 57      \nHello, W         │
│  0125:    6f 72 6c 64 21                  orld!              │
└──────────────────────────────────────────────────────────────┘
```

### Handler Completion

```
┌───────────────────────────────────────────────────────────────────────────┐
│              HANDLER RETURNS - POST PROCESSING                            │
└───────────────────────────────────────────────────────────────────────────┘

Your handler function returns:
            ↓
Server resumes control:
            ↓

Step 1: Check response state
┌────────────────────────────────────────┐
│  if !w.wroteHeader {                   │
│      w.WriteHeader(200)                │
│  }                                     │
│  // Already written in this case       │
└────────────────────────────────────────┘
            ↓

Step 2: Flush buffered writes
┌────────────────────────────────────────┐
│  w.w.Flush()                           │
│  // Flush bufio.Writer to TCP conn     │
└────────────────────────────────────────┘
            ↓

Step 3: Log request (if logging enabled)
┌────────────────────────────────────────┐
│  log.Printf("%s %s %d %d bytes",       │
│             req.Method,                │
│             req.URL.Path,              │
│             w.status,                  │
│             w.written)                 │
│  // "GET /hello 200 13 bytes"          │
└────────────────────────────────────────┘
            ↓

Step 4: Cleanup
┌────────────────────────────────────────┐
│  // Close request body if exists       │
│  if req.Body != nil {                  │
│      req.Body.Close()                  │
│  }                                     │
└────────────────────────────────────────┘
```

---

## Response Transmission - Bytes on the Wire {#response-transmission}

Now the response leaves the server and travels back to the client.

### Flush to TCP Connection

```
┌───────────────────────────────────────────────────────────────────────────┐
│              FLUSHING RESPONSE TO TCP CONNECTION                          │
└───────────────────────────────────────────────────────────────────────────┘

w.w.Flush() execution:

Step 1: Copy from bufio.Writer to TCP connection
┌────────────────────────────────────────────────────────────┐
│  bufio.Writer Buffer                                       │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  [HTTP Response - 131 bytes]                         │  │
│  └──────────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────────┘
            │
            │ Copy to TCP send buffer
            ↓
┌────────────────────────────────────────────────────────────┐
│  TCP Send Buffer (Kernel Space)                            │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  [HTTP Response - 131 bytes]                         │  │
│  └──────────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────────┘
            │
            │ System call: write(fd, buf, 131)
            ↓
┌────────────────────────────────────────────────────────────┐
│  Network Card Transmit Queue                               │
│  Ready to transmit to network                              │
└────────────────────────────────────────────────────────────┘

Transmission:
┌───────────────────────────────────────────────────────────┐
│  Network Layer                                            │
│  ┌─────────────────────────────────────────────────────┐  │
│  │  TCP Packet 1:                                      │  │
│  │  ┌───────────────────────────────────────────────┐  │  │
│  │  │ TCP Header: 20 bytes                          │  │  │
│  │  │ Data: 131 bytes (entire HTTP response)        │  │  │
│  │  │ Seq: 2001                                     │  │  │
│  │  │ Flags: PSH, ACK                               │  │  │
│  │  └───────────────────────────────────────────────┘  │  │
│  └─────────────────────────────────────────────────────┘  │
│  ┌─────────────────────────────────────────────────────┐  │
│  │  IP Header: 20 bytes                                │  │
│  │  Source: 192.168.1.100                              │  │
│  │  Dest:   192.168.1.50                               │  │
│  │  Total packet size: 171 bytes                       │  │
│  └─────────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────────┘
```

### Network Transmission

```
┌───────────────────────────────────────────────────────────────────────────┐
│              RESPONSE TRANSMISSION TIMELINE                               │
└───────────────────────────────────────────────────────────────────────────┘

Server (192.168.1.100:8080)                  Client (192.168.1.50:54321)
      │                                                      │
T=0ms │                                                      │
      │                                                      │
      │ ─── TCP Packet (171 bytes) ─────────────────────────→│
      │                                                      │
      │  ┌────────────────────────────────────┐              │
      │  │ TCP Header                         │              │
      │  │ IP Header                          │              │
      │  │ HTTP Response (131 bytes)          │              │
      │  └────────────────────────────────────┘              │
      │                                                      │
      │                                              Kernel receives
      │                                              Places in recv buffer
      │                                                      │
T=1ms │                                                      │
      │                                                      │
      │←────────────────────────── TCP ACK (ack=2132) -──────┤
      │                                                      │
      │  ┌────────────────────────────────────┐              │
      │  │ ACK packet (40 bytes)              │              │
      │  │ Acknowledges receipt               │              │
      │  └────────────────────────────────────┘              │
      │                                                      │
      │                                              Application reads
      │                                              read() system call
      │                                              Returns 131 bytes
      │                                                      │
      │═══════════════════════════════════════════════════════
      │       RESPONSE SUCCESSFULLY DELIVERED                │
      │═══════════════════════════════════════════════════════
```

## Connection Lifecycle - Keep-Alive and Closure {#connection-lifecycle}

After the response is sent, what happens to the connection? Let's explore both scenarios.

### HTTP/1.1 Keep-Alive (Connection Reuse)

```
┌───────────────────────────────────────────────────────────────────────────┐
│              HTTP/1.1 KEEP-ALIVE CONNECTION LIFECYCLE                     │
└───────────────────────────────────────────────────────────────────────────┘

Connection Goroutine After Response Sent:

func (c *conn) serve(ctx context.Context) {
    for {
        // Read request
        req, err := c.readRequest(ctx)
        
        // Process request (done for first request)
        
        // After response sent, check if connection should stay open
        if !req.Close && req.ProtoAtLeast(1, 1) {
            // HTTP/1.1 with Connection: keep-alive (default)
            // Loop continues, read next request on same connection
            continue
        } else {
            // Close connection
            break
        }
    }
}

Timeline with Keep-Alive:
┌────────────────────────────────────────────────────────────────┐
│                                                                │
│  T=0ms    First Request arrives                                │
│  T=5ms    First Response sent                                  │
│           ↓                                                    │
│  T=5ms    Connection stays open                                │
│           Goroutine loops back to read next request            │
│           Blocks in read() waiting for more data               │
│           ↓                                                    │
│  [Connection idle - no CPU usage]                              │
│           ↓                                                    │
│  T=100ms  Second Request arrives (same connection)             │
│  T=105ms  Second Response sent                                 │
│           ↓                                                    │
│  T=105ms  Connection stays open again                          │
│           ↓                                                    │
│  [Idle again]                                                  │
│           ↓                                                    │
│  T=60s    IdleTimeout reached (no new requests)                │
│           Server closes connection                             │
│           Goroutine exits                                      │
│                                                                │
└────────────────────────────────────────────────────────────────┘

Benefits of Keep-Alive:
┌───────────────────────────────────────────────────────────────┐
│  ✓ No TCP handshake overhead for subsequent requests          │
│  ✓ No SSL/TLS handshake (for HTTPS)                           │
│  ✓ Reduced latency (~3ms saved per request)                   │
│  ✓ Less CPU usage (no connection setup/teardown)              │
│  ✓ Can serve 100s of requests on one connection               │
└───────────────────────────────────────────────────────────────┘

Connection State Machine:
┌───────────────────────────────────────────────────────────────┐
│                                                               │
│    ESTABLISHED ──→ SERVING REQUEST ──→ IDLE                   │
│         ↑              │                 │                    │
│         │              │                 │                    │
│         └──────────────┴─────────────────┘                    │
│                  (keep-alive loop)                            │
│                                                               │
│                        │                                      │
│                        │ Timeout or Close header              │
│                        ↓                                      │
│                    CLOSING                                    │
│                        │                                      │
│                        ↓                                      │
│                    CLOSED                                     │
│                                                               │
└───────────────────────────────────────────────────────────────┘
```

### Connection Close

```
┌───────────────────────────────────────────────────────────────────────────┐
│              CONNECTION CLOSURE (HTTP/1.0 or Connection: close)           │
└───────────────────────────────────────────────────────────────────────────┘

When connection should close:
1. HTTP/1.0 request (no keep-alive by default)
2. Connection: close header in request
3. Connection: close header in response (set by server)
4. IdleTimeout reached
5. ReadTimeout or WriteTimeout exceeded
6. Error during processing

Closure Process:
┌────────────────────────────────────────────────────────────┐
│  Step 1: Close TCP write side                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  c.rwc.Close()                                       │  │
│  │  - Sends TCP FIN packet to client                    │  │
│  │  - "I'm done sending"                                │  │
│  └──────────────────────────────────────────────────────┘  │
│            ↓                                               │
│  Step 2: Wait for client to close their end                │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  Client receives FIN                                 │  │
│  │  Client sends FIN back                               │  │
│  │  - "I'm done too"                                    │  │
│  └──────────────────────────────────────────────────────┘  │
│            ↓                                               │
│  Step 3: Connection fully closed                           │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  OS cleans up TCP state                              │  │
│  │  File descriptor released                            │  │
│  │  Port freed for reuse                                │  │
│  └──────────────────────────────────────────────────────┘  │
│            ↓                                               │
│  Step 4: Goroutine cleanup                                 │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  serve() function returns                            │  │
│  │  Goroutine stack freed                               │  │
│  │  Goroutine marked as dead                            │  │
│  └──────────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────────┘

TCP Four-Way Termination:
Server                                          Client
   │                                               │
   │ ───────── FIN (seq=2132) ─────────────────→   │
   │                                               │
   │  ←──────── ACK (ack=2133) ──────────────────  │
   │                                               │
   │  ←──────── FIN (seq=1001) ──────────────────  │
   │                                               │
   │ ───────── ACK (ack=1002) ─────────────────→   │
   │                                               │
   │════════════════════════════════════════════════
   │         CONNECTION CLOSED                     │
   │════════════════════════════════════════════════
```

---

## Complete End-to-End Visualization {#complete-visualization}

Let's see the ENTIRE journey from server start to response delivery in one view.

### Complete Request-Response Cycle

```
┌───────────────────────────────────────────────────────────────────────────┐
│         COMPLETE GO HTTP REQUEST-RESPONSE CYCLE (TIMELINE)                │
│                  Single Request: GET /hello                               │
└───────────────────────────────────────────────────────────────────────────┘

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PHASE 1: SERVER STARTUP (One-time initialization)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Time    Component              Action                           State
────────────────────────────────────────────────────────────────────────────
0ms     OS                     Load executable                  [LOADING]
        │
1ms     Go Runtime             Initialize                       [INIT]
        ├─ Memory allocator    Setup heap/spans
        ├─ GC                  Initialize structures
        ├─ Scheduler           Create P0...P7 (8 cores)
        └─ sysmon              Start monitor goroutine
        │
2ms     Imports                net/http init                    [INIT]
        └─ http package        Create DefaultServeMux
        │
3ms     main() goroutine       Start executing                  [RUNNING]
        │
3ms     Application            HandleFunc("/hello", ...)        [REGISTER]
        └─ ServeMux            Store in route table
        │
4ms     Network                socket() system call             [SOCKET]
        └─ TCP socket          FD: 3 created
        │
4ms     Network                bind() to :8080                  [BOUND]
        └─ Port 8080           Reserved by server
        │
5ms     Network                listen()                         [LISTENING]
        └─ Backlog: 128        Ready for connections
        │
5ms     Accept Loop            ln.Accept() blocks               [READY]
        └─ Main goroutine      Waiting...                       [BLOCKED]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PHASE 2: CLIENT CONNECTION (Per connection)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

0ms     Client                 connect() to server              [CONNECTING]
        └─ TCP handshake       SYN sent
        │
1ms     Server kernel          Receive SYN                      [SYN_RECV]
        └─ Send SYN-ACK        Response sent
        │
2ms     Client kernel          Receive SYN-ACK                  [ESTABLISHED]
        └─ Send ACK            Connection complete
        │
2ms     Server kernel          Receive ACK                      [ESTABLISHED]
        ├─ Add to accept queue Connection ready
        └─ Wake Accept()       System call returns
        │
2ms     Accept Loop            Accept() returns                 [CONNECTED]
        ├─ Get conn object     FD: 5, Remote: 192.168.1.50
        └─ Spawn goroutine     go c.serve()
        │
2ms     Connection Goroutine   Created                          [NEW]
        ├─ Stack: 2KB          Allocated
        └─ State: Runnable     In queue
        │
2ms     Accept Loop            Back to Accept()                 [BLOCKED]
        └─ Main goroutine      Waiting for next connection
        │
3ms     Connection Goroutine   Scheduled on CPU                 [RUNNING]
        └─ c.serve() starts    Begin processing

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PHASE 3: REQUEST READING AND PARSING
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

3ms     Client                 Send HTTP request                [SENDING]
        └─ Write data          80 bytes
        │
4ms     Server TCP buffer      Receive data                     [RECEIVED]
        └─ Kernel buffer       80 bytes in recv buffer
        │
4ms     Connection Goroutine   read() system call               [READING]
        ├─ bufio.Reader        Read into 4KB buffer
        └─ Parse request line  "GET /hello HTTP/1.1"
        │
5ms     Parser                 Parse headers                    [PARSING]
        ├─ Host header         "localhost:8080"
        ├─ User-Agent          "curl/7.80.0"
        └─ Accept header       "*/*"
        │
5ms     Parser                 Complete http.Request            [READY]
        └─ Request object      Fully populated

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PHASE 4: ROUTING AND HANDLER EXECUTION
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

6ms     Server                 Route request                    [ROUTING]
        ├─ Extract path        "/hello"
        ├─ Lookup in ServeMux  Pattern match
        └─ Find handler        HandlerFunc found
        │
6ms     Server                 Create ResponseWriter            [PREPARING]
        └─ response object     Empty headers, no body yet
        │
7ms     Server                 Call handler                     [EXECUTING]
        └─ handler.ServeHTTP() Your code runs
        │
7ms     Your Handler           Execute                          [RUNNING]
        ├─ fmt.Fprintf()       Format "Hello, World!"
        └─ w.Write()           Write to ResponseWriter
        │
7ms     ResponseWriter         Write operations                 [WRITING]
        ├─ WriteHeader(200)    Status line + headers
        ├─ Write body          "Hello, World!"
        └─ Buffer response     In 4KB buffer
        │
8ms     Your Handler           Return                           [COMPLETE]
        └─ Control to server   Handler done

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PHASE 5: RESPONSE TRANSMISSION
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

8ms     Server                 Flush response                   [FLUSHING]
        └─ bufio.Writer.Flush() Copy to TCP buffer
        │
8ms     TCP Send               write() system call              [SENDING]
        ├─ Copy to kernel      131 bytes
        └─ Kernel sends TCP    Packet with response
        │
9ms     Network                Transmit                         [ON WIRE]
        └─ Ethernet frame      171 bytes total (IP+TCP+HTTP)
        │
10ms    Client TCP buffer      Receive packet                   [RECEIVED]
        └─ Kernel buffer       131 bytes HTTP response
        │
10ms    Client                 read() returns                   [DELIVERED]
        └─ Application         Receives response
        │
11ms    Client                 Send ACK                         [ACK]
        └─ Acknowledge         Confirm receipt

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PHASE 6: CONNECTION LIFECYCLE (Keep-Alive)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

11ms    Connection Goroutine   Check keep-alive                 [CHECKING]
        ├─ HTTP/1.1: Yes       Connection can be reused
        └─ Loop back           Go to Phase 3 for next request
        │
11ms    Connection Goroutine   read() blocks                    [IDLE]
        └─ Waiting             For next request on same conn
        │
        [Connection goroutine uses 0% CPU while idle]
        │
60s     Idle Timeout           No new requests                  [TIMEOUT]
        └─ Close connection    Send FIN packet
        │
60s     Connection Goroutine   Exit serve()                     [EXITING]
        ├─ Stack freed         2KB returned
        └─ Goroutine dead      Removed from scheduler

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

SUMMARY STATISTICS:
───────────────────────────────────────────────────────────────────────────
  Total time (first request): 11ms
  - Startup: 5ms (one-time)
  - Connection: 2ms
  - Processing: 4ms (read, parse, route, execute, send)
  
  Breakdown of 4ms processing:
  - Read request: 1ms
  - Parse: 1ms
  - Route + Execute handler: 1ms
  - Send response: 1ms
  
  Memory per connection: ~11KB
  CPU usage: <0.1% per request (mostly I/O wait)
  
  With keep-alive: Subsequent requests only 4ms (no connection setup)
```

---

## Real-World Scenarios {#real-world-scenarios}

Let's see how this works with different request types.

### Scenario 1: POST Request with JSON Body

```
┌───────────────────────────────────────────────────────────────────────────┐
│              POST REQUEST WITH BODY PROCESSING                            │
└───────────────────────────────────────────────────────────────────────────┘

Client sends:
POST /api/users HTTP/1.1
Host: localhost:8080
Content-Type: application/json
Content-Length: 45

{"name":"John","email":"john@example.com"}

Processing Timeline:
─────────────────────────────────────────────────────────────────────────────

Phase 1: Read Request Line (Same as GET)
  0ms: "POST /api/users HTTP/1.1"

Phase 2: Read Headers (includes Content-Length)
  1ms: Content-Type: application/json
  1ms: Content-Length: 45
  1ms: Blank line detected

Phase 3: Read Body (NEW - doesn't happen for GET)
  2ms: Read 45 bytes from connection
  ┌────────────────────────────────────────────────────────┐
  │  {"name":"John","email":"john@example.com"}           │
  └────────────────────────────────────────────────────────┘
  2ms: Store in req.Body (io.ReadCloser)

Phase 4: Route to Handler
  3ms: Match pattern "/api/users"
  3ms: Find handler: createUserHandler

Phase 5: Handler Executes
  func createUserHandler(w http.ResponseWriter, r *http.Request) {
      4ms: var user User
      4ms: json.NewDecoder(r.Body).Decode(&user)
           ↓ Reads from req.Body
           ↓ Parses JSON
      5ms: user = {Name: "John", Email: "john@example.com"}
      
      6ms: Insert into database (blocking I/O)
           [Goroutine blocks on DB, doesn't use CPU]
           
      50ms: Database returns (44ms elapsed)
      
      51ms: w.WriteHeader(201)
      51ms: json.NewEncoder(w).Encode(user)
      52ms: Response ready
  }

Phase 6: Send Response
  52ms: HTTP/1.1 201 Created
        Content-Type: application/json
        {"id":123,"name":"John","email":"john@example.com"}

Total: 52ms (but CPU used: ~8ms, rest was DB I/O)
```

### Scenario 2: File Upload (Multipart Form)

```
┌───────────────────────────────────────────────────────────────────────────┐
│              FILE UPLOAD REQUEST PROCESSING                               │
└───────────────────────────────────────────────────────────────────────────┘

Client sends:
POST /upload HTTP/1.1
Content-Type: multipart/form-data; boundary=----WebKitBoundary
Content-Length: 5242880  (5MB file)

------WebKitBoundary
Content-Disposition: form-data; name="file"; filename="image.jpg"
Content-Type: image/jpeg

[5MB of binary data]
------WebKitBoundary--

Processing:
─────────────────────────────────────────────────────────────────────────────

Phase 1: Read Request Line + Headers
  0-2ms: Standard parsing (quick)

Phase 2: Detect Large Body
  2ms: Content-Length: 5242880
       Server sees large body coming

Phase 3: Read Body (Streaming)
  2ms:   Start reading multipart form
  2-50ms: Read chunks of data as they arrive
          ├─ Network delivers in packets (~1.5KB each)
          ├─ Parse multipart boundaries
          └─ Write to temporary file or memory
  
  Timeline:
  ┌────────────────────────────────────────────────────────┐
  │  2ms:  Read first 8KB chunk                           │
  │  4ms:  Read next 8KB chunk                            │
  │  6ms:  Read next 8KB chunk                            │
  │  ...                                                  │
  │  50ms: All 5MB received                               │
  │  (Network speed: ~100MB/s)                            │
  └────────────────────────────────────────────────────────┘

Phase 4: Handler Processes File
  func uploadHandler(w http.ResponseWriter, r *http.Request) {
      50ms: r.ParseMultipartForm(10 << 20)  // 10MB max
            ↓ Already parsed during read
      
      51ms: file, header, _ := r.FormFile("file")
            filename := header.Filename  // "image.jpg"
      
      52ms: dst, _ := os.Create("/uploads/" + filename)
      52ms: io.Copy(dst, file)  // Write to disk
            ↓ Blocking I/O
            
      100ms: File written (48ms for 5MB write)
      
      101ms: w.WriteHeader(201)
             w.Write([]byte("Upload successful"))
  }

Total: 101ms
- Network receive: 48ms
- Parsing: 3ms
- Disk write: 48ms
- Other: 2ms
```

### Scenario 3: Long-Running Request with Timeout

```
┌───────────────────────────────────────────────────────────────────────────┐
│              REQUEST WITH TIMEOUT SCENARIO                                │
└───────────────────────────────────────────────────────────────────────────┘

Server configured with:
  ReadTimeout:  5s
  WriteTimeout: 5s
  Handler timeout: 10s (via middleware)

Slow Handler:
func slowHandler(w http.ResponseWriter, r *http.Request) {
    // Simulate slow external API call
    time.Sleep(15 * time.Second)  // TOO LONG!
    
    w.Write([]byte("Done"))
}

Execution Timeline:
─────────────────────────────────────────────────────────────────────────────

0s      Request arrives
0s      Parse request (fast)
0s      Route to slowHandler
0s      Handler starts executing
        ├─ Context timer starts (10s timeout)
        └─ time.Sleep(15s) begins
        
1-9s    [Handler sleeping]
        [Goroutine blocked, uses no CPU]
        [Context deadline approaching]
        
10s     TIMEOUT!
        ├─ Context deadline exceeded
        ├─ Timeout middleware catches it
        └─ Sends timeout response

Response sent at 10s:
HTTP/1.1 408 Request Timeout
Content-Type: text/plain

Request timed out

10s     Handler's sleep continues (but response already sent)
15s     Handler finally wakes up
        ├─ Tries to write response
        └─ Error: response already written
        └─ Handler exits

Key Points:
- Request timeout prevented handler from blocking forever
- User got response after 10s (not 15s)
- Resources (goroutine) freed after handler completes
- Timeout is crucial for server health
```

### Scenario 4: Concurrent Requests (Load Test)

```
┌───────────────────────────────────────────────────────────────────────────┐
│              1000 CONCURRENT REQUESTS                                     │
└───────────────────────────────────────────────────────────────────────────┘

Scenario: 1000 clients send requests simultaneously

System: 8 CPU cores, Go server

What Happens:
─────────────────────────────────────────────────────────────────────────────

T=0ms:  1000 TCP connections arrive
        ├─ Accept() loop processes as fast as possible
        ├─ Spawns 1000 goroutines
        └─ All goroutines created in ~50ms

Goroutines: 1000 (one per connection)
  ├─ Stack memory: 1000 × 2KB = 2MB
  ├─ Connection buffers: 1000 × 8KB = 8MB
  └─ Total: ~10MB (very manageable)

CPU Cores: 8
  ├─ At any moment, 8 goroutines actually running
  ├─ Scheduler cycles through all 1000
  └─ Each gets fair share of CPU time

Timeline:
┌────────────────────────────────────────────────────────────┐
│                                                            │
│  T=0-50ms:   All 1000 connections accepted                 │
│              1000 goroutines created                       │
│              All start reading requests                    │
│                                                            │
│  T=50ms:     All requests parsed                           │
│              All routing to handlers                       │
│                                                            │
│  T=50-100ms: Handlers executing                            │
│              ├─ 8 running at any moment (on 8 cores)       │
│              ├─ Others waiting in run queues               │
│              └─ Fair scheduling across all                 │
│                                                            │
│  T=100ms:    All responses generated                       │
│              All responses sent                            │
│                                                            │
│  T=100ms:    All goroutines back to idle                   │
│              Waiting for next requests on connections      │
│                                                            │
└────────────────────────────────────────────────────────────┘

Results:
  Total requests: 1000
  Total time: 100ms
  Throughput: 10,000 requests/second
  CPU usage: 90% (efficiently utilized)
  Memory: ~10MB
  
  Per-request latency:
  - Min: 50ms (first requests)
  - Max: 100ms (last requests queued)
  - Avg: 75ms
  
  Without goroutines (traditional threads):
  - Would need 1000 OS threads = ~8GB memory
  - Context switching overhead would be massive
  - Performance would be much worse
```

This completes the comprehensive journey through the Go HTTP request-response cycle!