# The Complete Guide to Testing in Golang

## Table of Contents

1. [Introduction to Testing in Go](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#introduction)
2. [The Go Testing Package](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#testing-package)
3. [Unit Testing](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#unit-testing)
4. [Table-Driven Tests](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#table-driven-tests)
5. [Benchmark Testing](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#benchmark-testing)
6. [Example Tests](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#example-tests)
7. [Test Coverage](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#test-coverage)
8. [Mocking and Stubbing](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#mocking)
9. [Integration Testing](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#integration-testing)
10. [End-to-End Testing](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#e2e-testing)
11. [Testing Best Practices](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#best-practices)

---

## Introduction to Testing in Go {#introduction}

Testing is the process of verifying that your code works as expected under various conditions. In Go, testing is not just an afterthought—it's a first-class citizen of the language. Go provides a built-in testing framework that makes writing and running tests straightforward and consistent.

### Why Testing Matters

Imagine you're building a payment processing system for an e-commerce platform. Without proper testing, a small bug could result in customers being charged twice, or worse, not being charged at all. Testing helps you catch these issues before they reach production.

Testing in Go serves several critical purposes:

**Verification of Correctness**: Testing ensures that your functions and methods produce the expected outputs for given inputs. For example, if you write a function to calculate the total price of items in a shopping cart, testing verifies that discounts are applied correctly and tax calculations are accurate.

**Prevention of Regressions**: When you add new features or refactor existing code, tests act as a safety net. They ensure that your changes haven't broken existing functionality. This is particularly important in large codebases where changes in one area might unexpectedly affect another.

**Documentation Through Examples**: Well-written tests serve as living documentation. They show other developers (and your future self) how your code is intended to be used. This is especially valuable when working with APIs or library code.

**Confidence in Refactoring**: With a comprehensive test suite, you can refactor code with confidence. If your tests pass after refactoring, you know the behavior hasn't changed, even if the implementation has.

### The Go Testing Philosophy

Go's testing philosophy is built on simplicity and convention. Unlike many other languages that require external testing frameworks, Go includes everything you need in the standard library. The testing approach in Go follows these principles:

**Convention Over Configuration**: Go uses naming conventions to identify test files and functions. Any file ending with `_test.go` is recognized as a test file. This simplicity means there's no complex configuration to manage.

**Standard Library Support**: The `testing` package provides all the essential tools you need. You don't need to install third-party frameworks to get started, though they're available if you need more advanced features.

**Fast Execution**: Go tests are compiled and run as native binaries, making them extremely fast. This encourages developers to run tests frequently during development.

---

## The Go Testing Package {#testing-package}

The `testing` package is the foundation of all testing in Go. It provides the types, functions, and conventions needed to write and run tests. Let's explore its core components in detail.

### The testing.T Type

The `testing.T` type is your primary interface for writing unit tests. When Go runs your tests, it creates a `testing.T` instance and passes it to each test function. This type provides methods that let you interact with the testing framework.

Think of `testing.T` as your communication channel with the test runner. Through it, you can report failures, log messages, skip tests, and control parallel execution.

**Key Methods of testing.T**:

The `Error` and `Errorf` methods mark a test as failed but allow it to continue running. This is useful when you want to report multiple failures in a single test. For example, if you're testing a user validation function, you might want to check multiple fields and report all validation errors, not just the first one.

```go
func TestUserValidation(t *testing.T) {
    user := User{Name: "", Email: "invalid-email"}
    
    if user.Name == "" {
        t.Error("Name should not be empty")
    }
    if !strings.Contains(user.Email, "@") {
        t.Error("Email should contain @")
    }
    // Test continues and reports both errors
}
```

The `Fatal` and `Fatalf` methods also mark a test as failed, but they immediately stop the test execution. Use these when continuing the test would be meaningless or dangerous. For instance, if you can't connect to a database, there's no point in running database queries.

```go
func TestDatabaseConnection(t *testing.T) {
    db, err := ConnectDB()
    if err != nil {
        t.Fatalf("Failed to connect to database: %v", err)
        // Test stops here
    }
    // This code only runs if connection succeeds
    defer db.Close()
}
```

The `Log` and `Logf` methods print messages, but only when a test fails or when running with the verbose flag (`-v`). This helps keep test output clean while still providing debugging information when needed.

The `Skip` and `Skipf` methods allow you to skip tests under certain conditions. This is useful for tests that require specific environments or resources.

### The testing.B Type

The `testing.B` type is designed specifically for benchmarking. It's similar to `testing.T` but includes additional fields and methods for performance testing.

The most important field in `testing.B` is `N`, which represents the number of iterations the benchmark should run. The testing framework automatically adjusts `N` to get statistically significant results. Your benchmark code should loop `N` times to allow accurate measurements.

### Test File Structure

Go enforces a specific structure for test files, and understanding this structure is crucial for writing tests that the Go tooling can recognize and execute.

**File Naming Convention**: Test files must end with `_test.go`. If you have a file called `user.go` containing your production code, the corresponding test file should be named `user_test.go`. This convention allows the Go compiler to exclude test code from production builds automatically.

**Package Declaration**: Test files can belong to the same package as the code they're testing, or they can use a separate package with the `_test` suffix. Each approach has its uses:

When you use the same package (e.g., `package user`), your tests have access to unexported (private) functions and types. This is useful for unit testing internal implementation details.

```go
// user.go
package user

func validateEmail(email string) bool {
    return strings.Contains(email, "@")
}

// user_test.go
package user

func TestValidateEmail(t *testing.T) {
    // Can access unexported validateEmail function
    if !validateEmail("test@example.com") {
        t.Error("Valid email was rejected")
    }
}
```

When you use a separate package (e.g., `package user_test`), your tests can only access exported (public) functions and types. This encourages you to test the public API the way external users would interact with your code.

```go
// user_test.go
package user_test

import "myapp/user"

func TestPublicAPI(t *testing.T) {
    // Can only access exported functions
    u := user.NewUser("John", "john@example.com")
    // Tests public interface only
}
```

---

## Unit Testing {#unit-testing}

Unit testing is the foundation of a solid testing strategy. A unit test verifies that a single "unit" of code—typically a function or method—works correctly in isolation from the rest of the system.

### What is a Unit Test?

A unit test focuses on testing the smallest testable parts of your application independently. The key word here is "independently." A true unit test should not depend on external systems like databases, file systems, network services, or even other parts of your codebase beyond what's necessary.

Think of unit tests as testing individual components in a factory. Before assembling a car, you test each part separately: does the engine start? do the brakes work? do the lights turn on? You don't test everything together first because if something fails, you won't know which part is broken.

### Anatomy of a Unit Test

Every unit test follows a similar pattern, often called the AAA pattern: Arrange, Act, Assert.

**Arrange**: Set up the test data and conditions. This is where you create the inputs your function needs and any necessary test state.

**Act**: Execute the function or method you're testing. This is typically a single function call.

**Assert**: Verify that the result matches your expectations. This is where you check if the output is correct.

Let's see this pattern in action with a real-world example:

```go
// calculator.go
package calculator

import "errors"

// Add returns the sum of two integers
func Add(a, b int) int {
    return a + b
}

// Divide divides two numbers and returns an error if dividing by zero
func Divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("cannot divide by zero")
    }
    return a / b, nil
}
```

Now let's write unit tests for these functions:

```go
// calculator_test.go
package calculator

import (
    "testing"
)

func TestAdd(t *testing.T) {
    // Arrange: Set up our test inputs
    a := 5
    b := 3
    expected := 8
    
    // Act: Call the function we're testing
    result := Add(a, b)
    
    // Assert: Verify the result matches our expectation
    if result != expected {
        t.Errorf("Add(%d, %d) = %d; expected %d", a, b, result, expected)
    }
}

func TestAddNegativeNumbers(t *testing.T) {
    // Arrange
    a := -5
    b := -3
    expected := -8
    
    // Act
    result := Add(a, b)
    
    // Assert
    if result != expected {
        t.Errorf("Add(%d, %d) = %d; expected %d", a, b, result, expected)
    }
}

func TestDivide(t *testing.T) {
    // Arrange
    a := 10.0
    b := 2.0
    expected := 5.0
    
    // Act
    result, err := Divide(a, b)
    
    // Assert
    if err != nil {
        t.Fatalf("Unexpected error: %v", err)
    }
    if result != expected {
        t.Errorf("Divide(%f, %f) = %f; expected %f", a, b, result, expected)
    }
}

func TestDivideByZero(t *testing.T) {
    // Arrange
    a := 10.0
    b := 0.0
    
    // Act
    result, err := Divide(a, b)
    
    // Assert
    if err == nil {
        t.Error("Expected error when dividing by zero, got nil")
    }
    if result != 0 {
        t.Errorf("Expected result to be 0 when error occurs, got %f", result)
    }
}
```

### Real-World Example: User Service

Let's look at a more realistic example that you might encounter in backend development. We'll test a user service that handles user registration:

```go
// user_service.go
package user

import (
    "errors"
    "regexp"
    "strings"
)

type User struct {
    ID       int
    Username string
    Email    string
    Age      int
}

type UserService struct {
    users  map[int]*User
    nextID int
}

func NewUserService() *UserService {
    return &UserService{
        users:  make(map[int]*User),
        nextID: 1,
    }
}

// Register creates a new user after validating the input
func (s *UserService) Register(username, email string, age int) (*User, error) {
    // Validate username
    if len(username) < 3 {
        return nil, errors.New("username must be at least 3 characters")
    }
    
    // Validate email
    emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
    if !emailRegex.MatchString(email) {
        return nil, errors.New("invalid email format")
    }
    
    // Validate age
    if age < 18 {
        return nil, errors.New("user must be at least 18 years old")
    }
    
    // Check if user already exists
    for _, user := range s.users {
        if strings.EqualFold(user.Username, username) {
            return nil, errors.New("username already exists")
        }
        if strings.EqualFold(user.Email, email) {
            return nil, errors.New("email already exists")
        }
    }
    
    // Create user
    user := &User{
        ID:       s.nextID,
        Username: username,
        Email:    email,
        Age:      age,
    }
    
    s.users[s.nextID] = user
    s.nextID++
    
    return user, nil
}

// GetUser retrieves a user by ID
func (s *UserService) GetUser(id int) (*User, error) {
    user, exists := s.users[id]
    if !exists {
        return nil, errors.New("user not found")
    }
    return user, nil
}
```

Now let's write comprehensive unit tests:

```go
// user_service_test.go
package user

import (
    "testing"
)

func TestRegisterValidUser(t *testing.T) {
    // Arrange
    service := NewUserService()
    username := "johndoe"
    email := "john@example.com"
    age := 25
    
    // Act
    user, err := service.Register(username, email, age)
    
    // Assert
    if err != nil {
        t.Fatalf("Expected no error, got: %v", err)
    }
    if user == nil {
        t.Fatal("Expected user to be created, got nil")
    }
    if user.Username != username {
        t.Errorf("Expected username %s, got %s", username, user.Username)
    }
    if user.Email != email {
        t.Errorf("Expected email %s, got %s", email, user.Email)
    }
    if user.Age != age {
        t.Errorf("Expected age %d, got %d", age, user.Age)
    }
    if user.ID != 1 {
        t.Errorf("Expected ID 1 for first user, got %d", user.ID)
    }
}

func TestRegisterShortUsername(t *testing.T) {
    // Arrange
    service := NewUserService()
    username := "ab"  // Too short
    email := "test@example.com"
    age := 25
    
    // Act
    user, err := service.Register(username, email, age)
    
    // Assert
    if err == nil {
        t.Error("Expected error for short username, got nil")
    }
    if user != nil {
        t.Error("Expected nil user when registration fails")
    }
}

func TestRegisterInvalidEmail(t *testing.T) {
    // Arrange
    service := NewUserService()
    username := "johndoe"
    email := "invalid-email"  // Missing @ and domain
    age := 25
    
    // Act
    user, err := service.Register(username, email, age)
    
    // Assert
    if err == nil {
        t.Error("Expected error for invalid email, got nil")
    }
    if user != nil {
        t.Error("Expected nil user when registration fails")
    }
}

func TestRegisterUnderageUser(t *testing.T) {
    // Arrange
    service := NewUserService()
    username := "younguser"
    email := "young@example.com"
    age := 16  // Under 18
    
    // Act
    user, err := service.Register(username, email, age)
    
    // Assert
    if err == nil {
        t.Error("Expected error for underage user, got nil")
    }
    if user != nil {
        t.Error("Expected nil user when registration fails")
    }
}

func TestRegisterDuplicateUsername(t *testing.T) {
    // Arrange
    service := NewUserService()
    username := "johndoe"
    
    // Register first user
    _, err := service.Register(username, "john1@example.com", 25)
    if err != nil {
        t.Fatalf("Failed to register first user: %v", err)
    }
    
    // Act - Try to register with same username
    user, err := service.Register(username, "john2@example.com", 30)
    
    // Assert
    if err == nil {
        t.Error("Expected error for duplicate username, got nil")
    }
    if user != nil {
        t.Error("Expected nil user when registration fails")
    }
}

func TestGetUserExists(t *testing.T) {
    // Arrange
    service := NewUserService()
    registeredUser, _ := service.Register("johndoe", "john@example.com", 25)
    
    // Act
    retrievedUser, err := service.GetUser(registeredUser.ID)
    
    // Assert
    if err != nil {
        t.Fatalf("Expected no error, got: %v", err)
    }
    if retrievedUser.ID != registeredUser.ID {
        t.Errorf("Expected user ID %d, got %d", registeredUser.ID, retrievedUser.ID)
    }
}

func TestGetUserNotFound(t *testing.T) {
    // Arrange
    service := NewUserService()
    nonExistentID := 999
    
    // Act
    user, err := service.GetUser(nonExistentID)
    
    // Assert
    if err == nil {
        t.Error("Expected error for non-existent user, got nil")
    }
    if user != nil {
        t.Error("Expected nil user when not found")
    }
}
```

### Running Unit Tests

To run your tests, use the `go test` command:

```bash
# Run all tests in the current package
go test

# Run tests with verbose output
go test -v

# Run a specific test function
go test -v -run TestRegisterValidUser

# Run tests matching a pattern
go test -v -run TestRegister
```

## Table-Driven Tests {#table-driven-tests}

Table-driven tests are one of the most elegant patterns in Go testing. Instead of writing multiple similar test functions, you create a table (slice) of test cases and iterate through them. This approach makes your tests more maintainable and easier to extend.

### Why Use Table-Driven Tests?

Imagine you need to test a password validation function with dozens of different scenarios: passwords that are too short, passwords without numbers, passwords without special characters, valid passwords, etc. Writing a separate test function for each scenario would result in hundreds of lines of repetitive code.

Table-driven tests solve this problem by separating test data from test logic. You define all your test cases in a structured format, then run them through the same test logic. This has several benefits:

**Reduced Code Duplication**: You write the test logic once and apply it to multiple test cases. This makes your test suite more maintainable because changes to the test logic only need to be made in one place.

**Easier to Add New Cases**: Adding a new test case is as simple as adding a new entry to the table. You don't need to copy and modify entire test functions.

**Better Readability**: All test cases are visible in one place, making it easy to see what scenarios you're testing and spot any gaps in your test coverage.

**Clearer Failure Messages**: You can include descriptive names for each test case, making it immediately clear which scenario failed.

### Structure of Table-Driven Tests

A table-driven test follows this structure:

```go
func TestFunctionName(t *testing.T) {
    // Define test cases as a slice of structs
    tests := []struct {
        name     string  // Description of this test case
        input    Type    // Input data
        expected Type    // Expected output
        // Add other fields as needed
    }{
        // List of test cases
    }
    
    // Iterate through test cases
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Test logic using tt.input and tt.expected
        })
    }
}
```

### Real-World Example: Password Validation

Let's implement and test a password validation function using table-driven tests:

```go
// password.go
package auth

import (
    "errors"
    "regexp"
    "unicode"
)

type PasswordStrength string

const (
    Weak   PasswordStrength = "weak"
    Medium PasswordStrength = "medium"
    Strong PasswordStrength = "strong"
)

// ValidatePassword checks if a password meets security requirements
func ValidatePassword(password string) error {
    if len(password) < 8 {
        return errors.New("password must be at least 8 characters long")
    }
    
    if len(password) > 72 {
        return errors.New("password must not exceed 72 characters")
    }
    
    hasUpper := false
    hasLower := false
    hasNumber := false
    hasSpecial := false
    
    for _, char := range password {
        switch {
        case unicode.IsUpper(char):
            hasUpper = true
        case unicode.IsLower(char):
            hasLower = true
        case unicode.IsNumber(char):
            hasNumber = true
        case unicode.IsPunct(char) || unicode.IsSymbol(char):
            hasSpecial = true
        }
    }
    
    if !hasUpper {
        return errors.New("password must contain at least one uppercase letter")
    }
    if !hasLower {
        return errors.New("password must contain at least one lowercase letter")
    }
    if !hasNumber {
        return errors.New("password must contain at least one number")
    }
    if !hasSpecial {
        return errors.New("password must contain at least one special character")
    }
    
    return nil
}

// CheckPasswordStrength evaluates the strength of a password
func CheckPasswordStrength(password string) PasswordStrength {
    if len(password) < 8 {
        return Weak
    }
    
    score := 0
    
    if len(password) >= 12 {
        score++
    }
    if regexp.MustCompile(`[A-Z]`).MatchString(password) {
        score++
    }
    if regexp.MustCompile(`[a-z]`).MatchString(password) {
        score++
    }
    if regexp.MustCompile(`[0-9]`).MatchString(password) {
        score++
    }
    if regexp.MustCompile(`[^a-zA-Z0-9]`).MatchString(password) {
        score++
    }
    
    if score >= 4 {
        return Strong
    } else if score >= 2 {
        return Medium
    }
    return Weak
}
```

Now let's write table-driven tests:

```go
// password_test.go
package auth

import (
    "testing"
)

func TestValidatePassword(t *testing.T) {
    tests := []struct {
        name        string
        password    string
        expectError bool
        errorMsg    string
    }{
        {
            name:        "valid strong password",
            password:    "MyP@ssw0rd123",
            expectError: false,
        },
        {
            name:        "too short",
            password:    "Abc1@",
            expectError: true,
            errorMsg:    "password must be at least 8 characters long",
        },
        {
            name:        "no uppercase letter",
            password:    "myp@ssw0rd123",
            expectError: true,
            errorMsg:    "password must contain at least one uppercase letter",
        },
        {
            name:        "no lowercase letter",
            password:    "MYP@SSW0RD123",
            expectError: true,
            errorMsg:    "password must contain at least one lowercase letter",
        },
        {
            name:        "no number",
            password:    "MyP@ssword",
            expectError: true,
            errorMsg:    "password must contain at least one number",
        },
        {
            name:        "no special character",
            password:    "MyPassword123",
            expectError: true,
            errorMsg:    "password must contain at least one special character",
        },
        {
            name:        "exactly 8 characters valid",
            password:    "MyP@ss0r",
            expectError: false,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := ValidatePassword(tt.password)
            
            if tt.expectError {
                if err == nil {
                    t.Errorf("Expected error but got none")
                    return
                }
                if err.Error() != tt.errorMsg {
                    t.Errorf("Expected error message '%s', got '%s'", tt.errorMsg, err.Error())
                }
            } else {
                if err != nil {
                    t.Errorf("Expected no error but got: %v", err)
                }
            }
        })
    }
}

func TestCheckPasswordStrength(t *testing.T) {
    tests := []struct {
        name     string
        password string
        expected PasswordStrength
    }{
        {
            name:     "weak - too short",
            password: "Pass1!",
            expected: Weak,
        },
        {
            name:     "weak - only letters",
            password: "Password",
            expected: Weak,
        },
        {
            name:     "medium - missing some requirements",
            password: "password123",
            expected: Medium,
        },
        {
            name:     "strong - all requirements met",
            password: "MyP@ssw0rd123",
            expected: Strong,
        },
        {
            name:     "strong - long and complex",
            password: "MyVery$ecureP@ssw0rd2024",
            expected: Strong,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := CheckPasswordStrength(tt.password)
            
            if result != tt.expected {
                t.Errorf("For password '%s': expected strength %s, got %s",
                    tt.password, tt.expected, result)
            }
        })
    }
}
```

### Advanced Table-Driven Testing: E-commerce Cart

Let's look at a more complex example:

```go
// cart.go
package shop

import (
    "errors"
)

type Item struct {
    Name     string
    Price    float64
    Quantity int
}

type Cart struct {
    Items           []Item
    TaxRate         float64
    DiscountPercent float64
}

func (c *Cart) AddItem(item Item) error {
    if item.Quantity <= 0 {
        return errors.New("quantity must be positive")
    }
    if item.Price < 0 {
        return errors.New("price cannot be negative")
    }
    c.Items = append(c.Items, item)
    return nil
}

func (c *Cart) Subtotal() float64 {
    total := 0.0
    for _, item := range c.Items {
        total += item.Price * float64(item.Quantity)
    }
    return total
}

func (c *Cart) Discount() float64 {
    return c.Subtotal() * (c.DiscountPercent / 100)
}

func (c *Cart) Tax() float64 {
    afterDiscount := c.Subtotal() - c.Discount()
    return afterDiscount * (c.TaxRate / 100)
}

func (c *Cart) Total() float64 {
    return c.Subtotal() - c.Discount() + c.Tax()
}
```

```go
// cart_test.go
package shop

import (
    "math"
    "testing"
)

func TestCartCalculations(t *testing.T) {
    tests := []struct {
        name             string
        items            []Item
        taxRate          float64
        discountPercent  float64
        expectedSubtotal float64
        expectedDiscount float64
        expectedTax      float64
        expectedTotal    float64
    }{
        {
            name: "single item no tax no discount",
            items: []Item{
                {Name: "Book", Price: 20.00, Quantity: 1},
            },
            taxRate:          0,
            discountPercent:  0,
            expectedSubtotal: 20.00,
            expectedDiscount: 0.00,
            expectedTax:      0.00,
            expectedTotal:    20.00,
        },
        {
            name: "multiple items with 10% tax",
            items: []Item{
                {Name: "Book", Price: 20.00, Quantity: 2},
                {Name: "Pen", Price: 5.00, Quantity: 3},
            },
            taxRate:          10,
            discountPercent:  0,
            expectedSubtotal: 55.00,
            expectedDiscount: 0.00,
            expectedTax:      5.50,
            expectedTotal:    60.50,
        },
        {
            name: "with 20% discount and 8% tax",
            items: []Item{
                {Name: "Laptop", Price: 1000.00, Quantity: 1},
            },
            taxRate:          8,
            discountPercent:  20,
            expectedSubtotal: 1000.00,
            expectedDiscount: 200.00,
            expectedTax:      64.00,
            expectedTotal:    864.00,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            cart := &Cart{
                TaxRate:         tt.taxRate,
                DiscountPercent: tt.discountPercent,
            }
            
            for _, item := range tt.items {
                err := cart.AddItem(item)
                if err != nil {
                    t.Fatalf("Failed to add item: %v", err)
                }
            }
            
            // Helper function to compare floats
            assertEqual := func(name string, got, want float64) {
                if math.Abs(got-want) > 0.001 {
                    t.Errorf("%s: got %.2f, want %.2f", name, got, want)
                }
            }
            
            assertEqual("Subtotal", cart.Subtotal(), tt.expectedSubtotal)
            assertEqual("Discount", cart.Discount(), tt.expectedDiscount)
            assertEqual("Tax", cart.Tax(), tt.expectedTax)
            assertEqual("Total", cart.Total(), tt.expectedTotal)
        })
    }
}
```

---

## Benchmark Testing {#benchmark-testing}

Benchmark testing measures the performance of your code by timing how long operations take and how much memory they use. In Go, benchmarking is built into the testing package, making it easy to identify performance bottlenecks.

### Understanding Benchmarks

A benchmark in Go is a special type of test that measures performance rather than correctness. While unit tests verify that your code produces the correct results, benchmarks verify that your code performs efficiently.

### Writing Benchmark Functions

Benchmark functions follow a specific naming convention:

```go
func BenchmarkFunctionName(b *testing.B) {
    // Setup code (runs once)
    
    for i := 0; i < b.N; i++ {
        // Code to benchmark (runs b.N times)
    }
}
```

The `b.N` field tells you how many times to run the operation. The testing framework automatically adjusts this number to get statistically significant results.

### Real-World Example: String Concatenation

```go
// string_concat.go
package stringops

import (
    "bytes"
    "strings"
)

func ConcatWithPlus(strs []string) string {
    result := ""
    for _, s := range strs {
        result += s
    }
    return result
}

func ConcatWithBuilder(strs []string) string {
    var builder strings.Builder
    for _, s := range strs {
        builder.WriteString(s)
    }
    return builder.String()
}

func ConcatWithBuffer(strs []string) string {
    var buffer bytes.Buffer
    for _, s := range strs {
        buffer.WriteString(s)
    }
    return buffer.String()
}

func ConcatWithJoin(strs []string) string {
    return strings.Join(strs, "")
}
```

```go
// string_concat_test.go
package stringops

import (
    "testing"
)

var testStrings = []string{
    "Hello", " ", "World", "!", " ",
    "This", " ", "is", " ", "a", " ",
    "benchmark", " ", "test", ".",
}

func BenchmarkConcatWithPlus(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = ConcatWithPlus(testStrings)
    }
}

func BenchmarkConcatWithBuilder(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = ConcatWithBuilder(testStrings)
    }
}

func BenchmarkConcatWithBuffer(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = ConcatWithBuffer(testStrings)
    }
}

func BenchmarkConcatWithJoin(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = ConcatWithJoin(testStrings)
    }
}
```

Run benchmarks with:

```bash
go test -bench=. -benchmem
```

### Memory Benchmarks

```go
func BenchmarkMemoryIntensive(b *testing.B) {
    b.ReportAllocs()
    
    for i := 0; i < b.N; i++ {
        data := make([]int, 1000)
        _ = data
    }
}
```

### Resetting Timers

```go
func BenchmarkWithSetup(b *testing.B) {
    // Setup that shouldn't be measured
    largeData := generateLargeDataset()
    
    b.ResetTimer() // Reset timer after setup
    
    for i := 0; i < b.N; i++ {
        processData(largeData)
    }
}
```

---

## Example Tests {#example-tests}

Example tests serve dual purposes: they verify that your code works and provide executable documentation.

### Writing Example Tests

```go
func ExampleFunctionName() {
    // Your example code
    // Output:
    // Expected output
}
```

### Real-World Example

```go
// user_registration_example_test.go
package registration_test

import (
    "fmt"
    "myapp/registration"
)

func ExampleRegistrationService_Register() {
    service := registration.NewRegistrationService()
    
    user, err := service.Register("johndoe", "john@example.com")
    if err != nil {
        fmt.Printf("Error: %v\n", err)
        return
    }
    
    fmt.Printf("Registered user: %s\n", user.Username)
    fmt.Printf("Email: %s\n", user.Email)
    // Output:
    // Registered user: johndoe
    // Email: john@example.com
}

func ExampleRegistrationService_Register_error() {
    service := registration.NewRegistrationService()
    
    _, err := service.Register("ab", "test@example.com")
    if err != nil {
        fmt.Printf("Error: %v\n", err)
    }
    // Output:
    // Error: username must be at least 3 characters
}
```

### Unordered Output

```go
func ExampleMapIteration() {
    users := map[string]int{
        "alice": 25,
        "bob":   30,
    }
    
    for name, age := range users {
        fmt.Printf("%s is %d years old\n", name, age)
    }
    // Unordered output:
    // alice is 25 years old
    // bob is 30 years old
}
```

## Test Coverage {#test-coverage}

Test coverage measures what percentage of your code is executed during testing. It helps identify untested code paths and improve your test suite's comprehensiveness.

### Understanding Coverage

Code coverage answers: "How much of my code is actually being tested?" It tracks which lines, branches, and functions are executed when your tests run.

However, 100% code coverage doesn't mean your code is bug-free. You could have every line covered but if tests don't check for the right things, bugs can still slip through.

### Measuring Coverage

```bash
# Run tests with coverage
go test -cover

# Generate detailed coverage report
go test -coverprofile=coverage.out

# View coverage in browser
go tool cover -html=coverage.out

# Get coverage by function
go tool cover -func=coverage.out
```

### Real-World Example: Order Processing

```go
// order.go
package order

import (
    "errors"
    "time"
)

type OrderStatus string

const (
    StatusPending   OrderStatus = "pending"
    StatusPaid      OrderStatus = "paid"
    StatusShipped   OrderStatus = "shipped"
    StatusDelivered OrderStatus = "delivered"
    StatusCancelled OrderStatus = "cancelled"
)

type Order struct {
    ID          string
    CustomerID  string
    Items       []OrderItem
    Total       float64
    Status      OrderStatus
    CreatedAt   time.Time
    ShippedAt   *time.Time
    DeliveredAt *time.Time
}

type OrderItem struct {
    ProductID string
    Quantity  int
    Price     float64
}

type OrderProcessor struct {
    minOrderAmount float64
    maxOrderAmount float64
}

func NewOrderProcessor(minAmount, maxAmount float64) *OrderProcessor {
    return &OrderProcessor{
        minOrderAmount: minAmount,
        maxOrderAmount: maxAmount,
    }
}

func (op *OrderProcessor) ValidateOrder(order *Order) error {
    if order == nil {
        return errors.New("order cannot be nil")
    }
    
    if order.CustomerID == "" {
        return errors.New("customer ID is required")
    }
    
    if len(order.Items) == 0 {
        return errors.New("order must contain at least one item")
    }
    
    total := 0.0
    for _, item := range order.Items {
        if item.Quantity <= 0 {
            return errors.New("item quantity must be positive")
        }
        if item.Price < 0 {
            return errors.New("item price cannot be negative")
        }
        total += item.Price * float64(item.Quantity)
    }
    
    if total < op.minOrderAmount {
        return errors.New("order total below minimum amount")
    }
    
    if total > op.maxOrderAmount {
        return errors.New("order total exceeds maximum amount")
    }
    
    order.Total = total
    return nil
}

func (op *OrderProcessor) ProcessPayment(order *Order) error {
    if order.Status != StatusPending {
        return errors.New("can only process payment for pending orders")
    }
    
    if err := op.ValidateOrder(order); err != nil {
        return err
    }
    
    order.Status = StatusPaid
    return nil
}

func (op *OrderProcessor) ShipOrder(order *Order) error {
    if order.Status != StatusPaid {
        return errors.New("can only ship paid orders")
    }
    
    now := time.Now()
    order.ShippedAt = &now
    order.Status = StatusShipped
    return nil
}

func (op *OrderProcessor) CancelOrder(order *Order) error {
    if order.Status == StatusShipped || order.Status == StatusDelivered {
        return errors.New("cannot cancel shipped or delivered orders")
    }
    
    order.Status = StatusCancelled
    return nil
}
```

```go
// order_test.go
package order

import (
    "testing"
)

func TestValidateOrder(t *testing.T) {
    processor := NewOrderProcessor(10.0, 10000.0)
    
    tests := []struct {
        name        string
        order       *Order
        expectError bool
    }{
        {
            name: "valid order",
            order: &Order{
                CustomerID: "cust123",
                Items: []OrderItem{
                    {ProductID: "prod1", Quantity: 2, Price: 25.00},
                },
                Status: StatusPending,
            },
            expectError: false,
        },
        {
            name:        "nil order",
            order:       nil,
            expectError: true,
        },
        {
            name: "empty customer ID",
            order: &Order{
                CustomerID: "",
                Items: []OrderItem{
                    {ProductID: "prod1", Quantity: 1, Price: 25.00},
                },
            },
            expectError: true,
        },
        {
            name: "negative quantity",
            order: &Order{
                CustomerID: "cust123",
                Items: []OrderItem{
                    {ProductID: "prod1", Quantity: -1, Price: 25.00},
                },
            },
            expectError: true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := processor.ValidateOrder(tt.order)
            if tt.expectError && err == nil {
                t.Error("Expected error but got none")
            }
            if !tt.expectError && err != nil {
                t.Errorf("Expected no error but got: %v", err)
            }
        })
    }
}
```

### Coverage Goals

- **80% or higher**: Generally considered good
- **90% or higher**: Excellent
- **100%**: Rarely necessary or practical

Focus on covering critical and complex parts of your code.

---

## Mocking and Stubbing {#mocking}

Mocking and stubbing isolate the code you're testing from its dependencies. This allows you to test your logic without connecting to external systems.

### Understanding Mocks and Stubs

A **stub** returns predetermined values. A **mock** also tracks how it was called, allowing verification of interactions.

### Defining Interfaces

```go
// Good: depends on interface
type UserService struct {
    db UserDatabase
}

type UserDatabase interface {
    GetUser(id string) (*User, error)
    SaveUser(user *User) error
}
```

### Real-World Example: Payment Processing

```go
// payment.go
package payment

import (
    "errors"
    "fmt"
    "time"
)

type PaymentStatus string

const (
    StatusSuccess PaymentStatus = "success"
    StatusFailed  PaymentStatus = "failed"
    StatusPending PaymentStatus = "pending"
)

type Payment struct {
    ID            string
    Amount        float64
    Currency      string
    CustomerID    string
    Status        PaymentStatus
    TransactionID string
    CreatedAt     time.Time
    FailureReason string
}

type PaymentGateway interface {
    ProcessPayment(amount float64, currency, customerID string) (transactionID string, err error)
    RefundPayment(transactionID string) error
}

type NotificationService interface {
    SendEmail(customerID, subject, body string) error
}

type PaymentService struct {
    gateway      PaymentGateway
    notification NotificationService
    minAmount    float64
    maxAmount    float64
}

func NewPaymentService(gateway PaymentGateway, notification NotificationService) *PaymentService {
    return &PaymentService{
        gateway:      gateway,
        notification: notification,
        minAmount:    1.0,
        maxAmount:    10000.0,
    }
}

func (s *PaymentService) ProcessPayment(customerID string, amount float64, currency string) (*Payment, error) {
    if amount < s.minAmount {
        return nil, fmt.Errorf("amount %.2f is below minimum %.2f", amount, s.minAmount)
    }
    
    payment := &Payment{
        ID:         fmt.Sprintf("pay_%d", time.Now().UnixNano()),
        Amount:     amount,
        Currency:   currency,
        CustomerID: customerID,
        Status:     StatusPending,
        CreatedAt:  time.Now(),
    }
    
    transactionID, err := s.gateway.ProcessPayment(amount, currency, customerID)
    if err != nil {
        payment.Status = StatusFailed
        payment.FailureReason = err.Error()
        
        s.notification.SendEmail(
            customerID,
            "Payment Failed",
            fmt.Sprintf("Your payment of %.2f %s failed", amount, currency),
        )
        
        return payment, fmt.Errorf("payment processing failed: %w", err)
    }
    
    payment.Status = StatusSuccess
    payment.TransactionID = transactionID
    
    s.notification.SendEmail(
        customerID,
        "Payment Successful",
        fmt.Sprintf("Your payment of %.2f %s was successful", amount, currency),
    )
    
    return payment, nil
}
```

```go
// payment_test.go
package payment

import (
    "errors"
    "testing"
)

type MockPaymentGateway struct {
    ProcessPaymentFunc func(amount float64, currency, customerID string) (string, error)
    ProcessPaymentCalls []ProcessPaymentCall
}

type ProcessPaymentCall struct {
    Amount     float64
    Currency   string
    CustomerID string
}

func (m *MockPaymentGateway) ProcessPayment(amount float64, currency, customerID string) (string, error) {
    m.ProcessPaymentCalls = append(m.ProcessPaymentCalls, ProcessPaymentCall{
        Amount:     amount,
        Currency:   currency,
        CustomerID: customerID,
    })
    
    if m.ProcessPaymentFunc != nil {
        return m.ProcessPaymentFunc(amount, currency, customerID)
    }
    return "", nil
}

func (m *MockPaymentGateway) RefundPayment(transactionID string) error {
    return nil
}

type MockNotificationService struct {
    EmailsSent []EmailCall
}

type EmailCall struct {
    CustomerID string
    Subject    string
    Body       string
}

func (m *MockNotificationService) SendEmail(customerID, subject, body string) error {
    m.EmailsSent = append(m.EmailsSent, EmailCall{
        CustomerID: customerID,
        Subject:    subject,
        Body:       body,
    })
    return nil
}

func TestProcessPayment_Success(t *testing.T) {
    mockGateway := &MockPaymentGateway{
        ProcessPaymentFunc: func(amount float64, currency, customerID string) (string, error) {
            return "txn_12345", nil
        },
    }
    mockNotification := &MockNotificationService{}
    
    service := NewPaymentService(mockGateway, mockNotification)
    
    payment, err := service.ProcessPayment("cust_123", 100.00, "USD")
    
    if err != nil {
        t.Fatalf("Expected no error, got: %v", err)
    }
    
    if payment.Status != StatusSuccess {
        t.Errorf("Expected status %s, got %s", StatusSuccess, payment.Status)
    }
    
    if len(mockGateway.ProcessPaymentCalls) != 1 {
        t.Fatalf("Expected 1 gateway call, got %d", len(mockGateway.ProcessPaymentCalls))
    }
    
    if len(mockNotification.EmailsSent) != 1 {
        t.Fatalf("Expected 1 email sent, got %d", len(mockNotification.EmailsSent))
    }
    
    email := mockNotification.EmailsSent[0]
    if email.Subject != "Payment Successful" {
        t.Errorf("Expected subject 'Payment Successful', got '%s'", email.Subject)
    }
}

func TestProcessPayment_GatewayFailure(t *testing.T) {
    mockGateway := &MockPaymentGateway{
        ProcessPaymentFunc: func(amount float64, currency, customerID string) (string, error) {
            return "", errors.New("insufficient funds")
        },
    }
    mockNotification := &MockNotificationService{}
    
    service := NewPaymentService(mockGateway, mockNotification)
    
    payment, err := service.ProcessPayment("cust_123", 100.00, "USD")
    
    if err == nil {
        t.Fatal("Expected error, got nil")
    }
    
    if payment.Status != StatusFailed {
        t.Errorf("Expected status %s, got %s", StatusFailed, payment.Status)
    }
    
    if len(mockNotification.EmailsSent) != 1 {
        t.Fatalf("Expected 1 email sent, got %d", len(mockNotification.EmailsSent))
    }
    
    email := mockNotification.EmailsSent[0]
    if email.Subject != "Payment Failed" {
        t.Errorf("Expected subject 'Payment Failed', got '%s'", email.Subject)
    }
}
```

---

## Integration Testing {#integration-testing}

Integration tests verify that different parts of your system work together correctly. They test multiple components interacting, using real dependencies.

### Setting Up Test Databases

```go
// db_integration_test.go
package integration

import (
    "database/sql"
    "fmt"
    "os"
    "testing"
    
    _ "github.com/lib/pq"
)

var testDB *sql.DB

func TestMain(m *testing.M) {
    var err error
    testDB, err = sql.Open("postgres", "postgres://user:pass@localhost/testdb?sslmode=disable")
    if err != nil {
        fmt.Printf("Failed to connect: %v\n", err)
        os.Exit(1)
    }
    
    setupTestSchema(testDB)
    code := m.Run()
    testDB.Close()
    
    os.Exit(code)
}

func setupTestSchema(db *sql.DB) {
    schema := `
        CREATE TABLE IF NOT EXISTS users (
            id SERIAL PRIMARY KEY,
            username VARCHAR(50) UNIQUE NOT NULL,
            email VARCHAR(100) UNIQUE NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
    `
    _, err := db.Exec(schema)
    if err != nil {
        panic(fmt.Sprintf("Failed to setup schema: %v", err))
    }
}

func cleanupTestData(t *testing.T) {
    _, err := testDB.Exec("TRUNCATE users RESTART IDENTITY")
    if err != nil {
        t.Fatalf("Failed to cleanup: %v", err)
    }
}
```

### Real-World Example: User Repository

```go
// user_repository.go
package repository

import (
    "database/sql"
    "errors"
    "time"
)

type User struct {
    ID        int
    Username  string
    Email     string
    CreatedAt time.Time
}

type UserRepository struct {
    db *sql.DB
}

func NewUserRepository(db *sql.DB) *UserRepository {
    return &UserRepository{db: db}
}

func (r *UserRepository) Create(username, email string) (*User, error) {
    var user User
    err := r.db.QueryRow(
        "INSERT INTO users (username, email) VALUES ($1, $2) RETURNING id, username, email, created_at",
        username, email,
    ).Scan(&user.ID, &user.Username, &user.Email, &user.CreatedAt)
    
    if err != nil {
        return nil, err
    }
    return &user, nil
}

func (r *UserRepository) GetByID(id int) (*User, error) {
    var user User
    err := r.db.QueryRow(
        "SELECT id, username, email, created_at FROM users WHERE id = $1",
        id,
    ).Scan(&user.ID, &user.Username, &user.Email, &user.CreatedAt)
    
    if err == sql.ErrNoRows {
        return nil, errors.New("user not found")
    }
    return &user, err
}
```

```go
// user_repository_integration_test.go
package repository

import (
    "testing"
)

func TestUserRepository_Create(t *testing.T) {
    defer cleanupTestData(t)
    
    repo := NewUserRepository(testDB)
    
    user, err := repo.Create("johndoe", "john@example.com")
    if err != nil {
        t.Fatalf("Failed to create user: %v", err)
    }
    
    if user.ID == 0 {
        t.Error("Expected user ID to be set")
    }
    if user.Username != "johndoe" {
        t.Errorf("Expected username 'johndoe', got '%s'", user.Username)
    }
}

func TestUserRepository_GetByID(t *testing.T) {
    defer cleanupTestData(t)
    
    repo := NewUserRepository(testDB)
    
    created, err := repo.Create("janedoe", "jane@example.com")
    if err != nil {
        t.Fatalf("Failed to create user: %v", err)
    }
    
    retrieved, err := repo.GetByID(created.ID)
    if err != nil {
        t.Fatalf("Failed to get user: %v", err)
    }
    
    if retrieved.Username != created.Username {
        t.Errorf("Expected username %s, got %s", created.Username, retrieved.Username)
    }
}
```

---

## End-to-End Testing {#e2e-testing}

End-to-end (E2E) tests verify the entire system from the user's perspective, testing the complete workflow through all layers.

### HTTP API Testing

```go
// api_test.go
package api_test

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
    "myapp/api"
)

func TestUserRegistrationE2E(t *testing.T) {
    // Setup
    router := api.SetupRouter()
    
    // Test data
    requestBody := map[string]interface{}{
        "username": "johndoe",
        "email":    "john@example.com",
        "age":      25,
    }
    
    jsonData, _ := json.Marshal(requestBody)
    
    // Create request
    req := httptest.NewRequest("POST", "/api/users/register", bytes.NewBuffer(jsonData))
    req.Header.Set("Content-Type", "application/json")
    
    // Record response
    w := httptest.NewRecorder()
    router.ServeHTTP(w, req)
    
    // Assertions
    if w.Code != http.StatusCreated {
        t.Errorf("Expected status 201, got %d", w.Code)
    }
    
    var response map[string]interface{}
    json.Unmarshal(w.Body.Bytes(), &response)
    
    if response["username"] != "johndoe" {
        t.Errorf("Expected username johndoe, got %v", response["username"])
    }
}

func TestUserLoginE2E(t *testing.T) {
    router := api.SetupRouter()
    
    // First register a user
    registerBody := map[string]interface{}{
        "username": "testuser",
        "email":    "test@example.com",
        "password": "Test@1234",
    }
    
    registerData, _ := json.Marshal(registerBody)
    registerReq := httptest.NewRequest("POST", "/api/users/register", bytes.NewBuffer(registerData))
    registerReq.Header.Set("Content-Type", "application/json")
    
    w := httptest.NewRecorder()
    router.ServeHTTP(w, registerReq)
    
    if w.Code != http.StatusCreated {
        t.Fatalf("Failed to register user: %d", w.Code)
    }
    
    // Now test login
    loginBody := map[string]interface{}{
        "username": "testuser",
        "password": "Test@1234",
    }
    
    loginData, _ := json.Marshal(loginBody)
    loginReq := httptest.NewRequest("POST", "/api/users/login", bytes.NewBuffer(loginData))
    loginReq.Header.Set("Content-Type", "application/json")
    
    w = httptest.NewRecorder()
    router.ServeHTTP(w, loginReq)
    
    if w.Code != http.StatusOK {
        t.Errorf("Expected status 200, got %d", w.Code)
    }
    
    var loginResponse map[string]interface{}
    json.Unmarshal(w.Body.Bytes(), &loginResponse)
    
    if loginResponse["token"] == nil {
        t.Error("Expected token in response")
    }
}
```

---

## Testing Best Practices {#best-practices}

### 1. Test Organization

**Group Related Tests**: Use subtests with `t.Run()` to organize related test cases.

```go
func TestUserService(t *testing.T) {
    t.Run("Registration", func(t *testing.T) {
        t.Run("ValidUser", func(t *testing.T) {
            // Test valid registration
        })
        t.Run("InvalidEmail", func(t *testing.T) {
            // Test invalid email
        })
    })
    
    t.Run("Authentication", func(t *testing.T) {
        // Authentication tests
    })
}
```

### 2. Test Independence

**Each Test Should Be Independent**: Tests should not depend on other tests or share state.

```go
// Bad: Tests share state
var globalUser *User

func TestCreateUser(t *testing.T) {
    globalUser = &User{Name: "John"}
    // ...
}

func TestUpdateUser(t *testing.T) {
    // Depends on TestCreateUser running first
    globalUser.Name = "Jane"
}

// Good: Each test is independent
func TestCreateUser(t *testing.T) {
    user := &User{Name: "John"}
    // ...
}

func TestUpdateUser(t *testing.T) {
    user := &User{Name: "John"}
    user.Name = "Jane"
    // ...
}
```

### 3. Clear Test Names

**Use Descriptive Names**: Test names should clearly indicate what they're testing.

```go
// Bad
func TestUser1(t *testing.T) { }
func TestUser2(t *testing.T) { }

// Good
func TestUserRegistration_ValidCredentials(t *testing.T) { }
func TestUserRegistration_DuplicateEmail(t *testing.T) { }
```

### 4. Test Failure Messages

**Provide Helpful Error Messages**: When a test fails, the message should help identify the problem quickly.

```go
// Bad
if result != expected {
    t.Error("wrong")
}

// Good
if result != expected {
    t.Errorf("Calculate(5, 3) = %d; expected %d", result, expected)
}
```

### 5. Use Helper Functions

**Extract Common Setup**: Use helper functions to reduce duplication.

```go
func createTestUser(t *testing.T, username, email string) *User {
    t.Helper() // Marks this as a helper function
    
    user, err := NewUser(username, email)
    if err != nil {
        t.Fatalf("Failed to create test user: %v", err)
    }
    return user
}

func TestUserMethods(t *testing.T) {
    user := createTestUser(t, "john", "john@example.com")
    // Use user in tests
}
```

### 6. Test Edge Cases

**Cover Boundary Conditions**: Test minimum values, maximum values, empty inputs, and invalid inputs.

```go
func TestAgeValidation(t *testing.T) {
    tests := []struct {
        name string
        age  int
        want bool
    }{
        {"Zero age", 0, false},
        {"Negative age", -1, false},
        {"Minimum valid", 18, true},
        {"Normal adult", 30, true},
        {"Senior", 100, true},
        {"Beyond reasonable", 200, false},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := IsValidAge(tt.age)
            if got != tt.want {
                t.Errorf("IsValidAge(%d) = %v; want %v", tt.age, got, tt.want)
            }
        })
    }
}
```

### 7. Parallel Testing

**Run Independent Tests in Parallel**: Use `t.Parallel()` for tests that don't share state.

```go
func TestFeatureA(t *testing.T) {
    t.Parallel() // Run in parallel
    // Test code
}

func TestFeatureB(t *testing.T) {
    t.Parallel() // Run in parallel
    // Test code
}
```

### 8. Clean Up Resources

**Always Clean Up**: Use `defer` or `t.Cleanup()` to ensure resources are released.

```go
func TestDatabaseOperation(t *testing.T) {
    db := setupTestDB(t)
    t.Cleanup(func() {
        db.Close()
    })
    
    // Test code using db
}
```

### 9. Testing Pyramid

**Follow the Testing Pyramid**:

- **Many unit tests**: Fast, focused, test individual functions
- **Some integration tests**: Test component interactions
- **Few E2E tests**: Test complete workflows

### 10. Continuous Testing

**Run Tests Frequently**: Integrate tests into your development workflow.

```bash
# Run tests on save
go test ./...

# Run with coverage
go test -cover ./...

# Run specific tests
go test -run TestUserService ./...
```

---

## Summary

Testing in Go is straightforward and powerful. The key points to remember:

1. **Unit Tests**: Test individual functions in isolation
2. **Table-Driven Tests**: Efficient way to test multiple scenarios
3. **Benchmarks**: Measure performance
4. **Coverage**: Track what code is tested
5. **Mocking**: Isolate code from dependencies
6. **Integration Tests**: Test components working together
7. **E2E Tests**: Test complete workflows
8. **Best Practices**: Write clear, independent, maintainable tests

With Go's built-in testing tools and these patterns, you can build a robust test suite that gives you confidence in your code. Happy testing!