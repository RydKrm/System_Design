# The Complete Guide to Go Methods - Part 1 of 2

## From Necessity to Advanced Patterns with Structs

---

## Table of Contents - Complete Guide

### Part 1 (This Document)

1. [Introduction: Why Methods Exist](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#introduction-why-methods-exist)
2. [The Necessity of Methods](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#the-necessity-of-methods)
3. [Methods vs Functions](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#methods-vs-functions)
4. [Real-World Use Cases](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#real-world-use-cases)
5. [Method Fundamentals](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#method-fundamentals)

### Part 2

6. Memory Architecture of Methods
7. Value vs Pointer Receivers - Deep Dive
8. Method Sets and Interfaces
9. Advanced Patterns and Techniques
10. Practical Backend Examples
11. Performance and Best Practices

---

## Introduction: Why Methods Exist

Imagine you're building a user management system. You have a `User` struct and need various operations on it—validation, authentication, profile updates, permission checks. Without methods, you'd write separate functions:

```go
type User struct {
    ID       int64
    Username string
    Email    string
    Password string
    Role     string
    Active   bool
}

// Without methods - separate functions
func ValidateUser(u User) error {
    if len(u.Username) < 3 {
        return errors.New("username too short")
    }
    if !strings.Contains(u.Email, "@") {
        return errors.New("invalid email")
    }
    return nil
}

func AuthenticateUser(u User, password string) bool {
    return u.Password == hashPassword(password)
}

func UpdateUserEmail(u *User, email string) error {
    if !strings.Contains(email, "@") {
        return errors.New("invalid email")
    }
    u.Email = email
    return nil
}

func UserHasPermission(u User, permission string) bool {
    // Complex permission logic
    return u.Role == "admin" || checkPermission(u.Role, permission)
}

// Usage becomes verbose
user := User{Username: "alice", Email: "alice@example.com"}
if err := ValidateUser(user); err != nil {
    log.Fatal(err)
}
if AuthenticateUser(user, "password123") {
    if UserHasPermission(user, "write") {
        // Do something
    }
}
```

This approach has several problems:

**1. Namespace Pollution** Every function needs a unique name prefixed with the type name. This clutters the global namespace and makes related operations scattered.

**2. No Logical Grouping** Functions related to `User` are disconnected from the type itself. When reading code, the relationship isn't immediately clear.

**3. Difficult Discoverability** IDE autocomplete can't help—you must remember function names. There's no natural way to discover what operations a type supports.

**4. Package Organization Issues** Where do these functions live? In the same package as `User`? Spread across multiple packages? No clear answer.

Methods solve these problems by attaching operations directly to types:

```go
// With methods - operations attached to the type
type User struct {
    ID       int64
    Username string
    Email    string
    Password string
    Role     string
    Active   bool
}

func (u User) Validate() error {
    if len(u.Username) < 3 {
        return errors.New("username too short")
    }
    if !strings.Contains(u.Email, "@") {
        return errors.New("invalid email")
    }
    return nil
}

func (u User) Authenticate(password string) bool {
    return u.Password == hashPassword(password)
}

func (u *User) UpdateEmail(email string) error {
    if !strings.Contains(email, "@") {
        return errors.New("invalid email")
    }
    u.Email = email
    return nil
}

func (u User) HasPermission(permission string) bool {
    return u.Role == "admin" || checkPermission(u.Role, permission)
}

// Usage becomes intuitive
user := User{Username: "alice", Email: "alice@example.com"}
if err := user.Validate(); err != nil {
    log.Fatal(err)
}
if user.Authenticate("password123") {
    if user.HasPermission("write") {
        // Do something
    }
}
```

**The Benefits:**

```
Conceptual Grouping:

Without Methods:
Global Namespace
├─ ValidateUser()
├─ AuthenticateUser()
├─ UpdateUserEmail()
├─ UserHasPermission()
├─ ValidateProduct()
├─ UpdateProduct()
└─ ... (cluttered)

With Methods:
User Type
├─ Validate()
├─ Authenticate()
├─ UpdateEmail()
└─ HasPermission()

Product Type
├─ Validate()
└─ Update()

Clean, organized, discoverable!
```

Methods create a natural namespace per type. Operations belong to the data they operate on. This is the essence of object-oriented programming in Go—not inheritance or classes, but methods that give behavior to types.

---

## The Necessity of Methods

Methods aren't just syntactic sugar—they're necessary for solving fundamental problems in software design. Let's explore why through concrete scenarios.

### The Encapsulation Problem

Data and the operations on that data should be closely coupled. Without methods, this coupling is weak and error-prone.

**Problem: Scattered Logic**

```go
// Without methods - validation logic scattered
type BankAccount struct {
    AccountNumber string
    Balance       float64
    Currency      string
    Frozen        bool
}

// Global functions - no encapsulation
func ValidateAccountNumber(number string) error {
    if len(number) != 10 {
        return errors.New("account number must be 10 digits")
    }
    return nil
}

func CanWithdraw(account BankAccount, amount float64) bool {
    return !account.Frozen && account.Balance >= amount
}

func Withdraw(account *BankAccount, amount float64) error {
    // Easy to forget validation!
    if account.Frozen {
        return errors.New("account is frozen")
    }
    if account.Balance < amount {
        return errors.New("insufficient funds")
    }
    account.Balance -= amount
    return nil
}

// Problem: Anyone can modify balance directly
account.Balance = 1000000  // No validation, no checks!
```

This design has critical flaws:

1. **No Encapsulation**: Direct field access bypasses all validation
2. **Easy to Forget Checks**: Developers must remember to call validation functions
3. **Inconsistent State**: Account can be in invalid states
4. **Security Risk**: Balance manipulation without audit trail

**Solution: Methods with Encapsulation**

```go
// With methods - proper encapsulation
type BankAccount struct {
    accountNumber string  // Unexported - encapsulated
    balance       float64 // Unexported - encapsulated
    currency      string  // Unexported - encapsulated
    frozen        bool    // Unexported - encapsulated
}

// Constructor ensures valid creation
func NewBankAccount(accountNumber, currency string) (*BankAccount, error) {
    if len(accountNumber) != 10 {
        return nil, errors.New("account number must be 10 digits")
    }
    
    return &BankAccount{
        accountNumber: accountNumber,
        balance:       0,
        currency:      currency,
        frozen:        false,
    }, nil
}

// Methods enforce invariants
func (ba *BankAccount) Withdraw(amount float64) error {
    if ba.frozen {
        return errors.New("account is frozen")
    }
    
    if amount <= 0 {
        return errors.New("withdrawal amount must be positive")
    }
    
    if ba.balance < amount {
        return errors.New("insufficient funds")
    }
    
    ba.balance -= amount
    logTransaction("withdraw", ba.accountNumber, amount)
    return nil
}

func (ba *BankAccount) Deposit(amount float64) error {
    if ba.frozen {
        return errors.New("account is frozen")
    }
    
    if amount <= 0 {
        return errors.New("deposit amount must be positive")
    }
    
    ba.balance += amount
    logTransaction("deposit", ba.accountNumber, amount)
    return nil
}

func (ba BankAccount) GetBalance() float64 {
    return ba.balance  // Read-only access
}

func (ba *BankAccount) Freeze() {
    ba.frozen = true
    logTransaction("freeze", ba.accountNumber, 0)
}

// Usage - safe and validated
account, err := NewBankAccount("1234567890", "USD")
if err != nil {
    log.Fatal(err)
}

account.Deposit(1000)
account.Withdraw(100)
balance := account.GetBalance()  // Can only read, not write

// account.balance = 1000000  // Compile error - unexported field!
```

Methods enable true encapsulation by:

- Hiding internal state (unexported fields)
- Enforcing invariants in all operations
- Preventing invalid state transitions
- Providing controlled access to data

### The Type Association Problem

Operations should be clearly associated with the types they operate on. Without methods, this association is implicit and fragile.

**Problem: Unclear Ownership**

```go
// Without methods - unclear ownership
type Order struct {
    ID         int64
    CustomerID int64
    Items      []OrderItem
    Total      float64
    Status     string
}

type OrderItem struct {
    ProductID int64
    Quantity  int
    Price     float64
}

// Where do these functions belong?
// In "order" package? "business" package? "calculation" package?
func CalculateOrderTotal(o Order) float64 {
    total := 0.0
    for _, item := range o.Items {
        total += float64(item.Quantity) * item.Price
    }
    return total
}

func ValidateOrder(o Order) error {
    if len(o.Items) == 0 {
        return errors.New("order must have items")
    }
    return nil
}

func CanCancelOrder(o Order) bool {
    return o.Status == "pending" || o.Status == "processing"
}

// When someone reads the Order struct, they have NO IDEA
// what operations are available. They must search the codebase.
```

**Solution: Methods Make Association Explicit**

```go
// With methods - clear ownership
type Order struct {
    ID         int64
    CustomerID int64
    Items      []OrderItem
    Total      float64
    Status     string
}

// Methods clearly belong to Order
func (o *Order) CalculateTotal() float64 {
    total := 0.0
    for _, item := range o.Items {
        total += float64(item.Quantity) * item.Price
    }
    o.Total = total  // Can update internal state
    return total
}

func (o Order) Validate() error {
    if len(o.Items) == 0 {
        return errors.New("order must have items")
    }
    if o.Total <= 0 {
        return errors.New("order total must be positive")
    }
    return nil
}

func (o Order) CanCancel() bool {
    return o.Status == "pending" || o.Status == "processing"
}

func (o *Order) Cancel() error {
    if !o.CanCancel() {
        return errors.New("order cannot be cancelled")
    }
    o.Status = "cancelled"
    return nil
}

func (o *Order) AddItem(item OrderItem) {
    o.Items = append(o.Items, item)
    o.CalculateTotal()  // Automatically recalculate
}

// Now when someone sees Order, they type "order." and IDE shows:
// - order.CalculateTotal()
// - order.Validate()
// - order.CanCancel()
// - order.Cancel()
// - order.AddItem()
// All operations are discoverable!
```

Methods create a clear namespace per type. Every operation on `Order` is an `Order` method. This makes code self-documenting and discoverable.

### The State Mutation Problem

Some operations need to modify the receiver, others don't. This distinction is critical and must be clear.

**Problem: Unclear Mutation Semantics**

```go
// Without methods - mutation is unclear
type Counter struct {
    value int
}

// Does this modify the counter? You must read the implementation!
func IncrementCounter(c Counter) Counter {
    c.value++
    return c  // Returns new counter, original unchanged
}

// Or maybe it modifies in place?
func IncrementCounterPtr(c *Counter) {
    c.value++  // Modifies original
}

// User must guess which function to use
counter := Counter{value: 0}
counter = IncrementCounter(counter)  // Reassign needed?
IncrementCounterPtr(&counter)        // Or pass pointer?
```

**Solution: Receiver Type Makes Mutation Clear**

```go
// With methods - mutation is explicit
type Counter struct {
    value int
}

// Value receiver - DOES NOT modify original
func (c Counter) NextValue() int {
    return c.value + 1  // Returns next value, c unchanged
}

// Pointer receiver - MODIFIES original
func (c *Counter) Increment() {
    c.value++  // Modifies c in place
}

// Value receiver - immutable operation
func (c Counter) IsZero() bool {
    return c.value == 0
}

// Usage - clear semantics
counter := Counter{value: 5}

next := counter.NextValue()    // counter still 5, next is 6
fmt.Println(counter.value)     // 5 (unchanged)

counter.Increment()            // counter modified
fmt.Println(counter.value)     // 6 (changed)

if counter.IsZero() {          // Read-only check
    // ...
}
```

The receiver type (value vs pointer) communicates intent:

- **Value receiver**: "This method reads but doesn't modify"
- **Pointer receiver**: "This method may modify the receiver"

This convention makes code self-documenting and prevents accidental mutations.

### The Interface Satisfaction Problem

Go interfaces are satisfied implicitly—a type automatically implements an interface if it has the required methods. This requires methods (functions don't count).

**Problem: Functions Don't Satisfy Interfaces**

```go
// Interface definition
type Writer interface {
    Write(p []byte) (n int, err error)
}

// Type with function
type FileLogger struct {
    filename string
}

// Function - DOES NOT satisfy Writer interface!
func WriteToFile(fl FileLogger, p []byte) (int, error) {
    // Write implementation
    return len(p), nil
}

// Cannot use FileLogger as Writer
var w Writer = FileLogger{}  // Compile error!
// FileLogger doesn't have Write method
```

**Solution: Methods Satisfy Interfaces**

```go
// Type with method
type FileLogger struct {
    filename string
}

// Method - SATISFIES Writer interface!
func (fl FileLogger) Write(p []byte) (n int, err error) {
    file, err := os.OpenFile(fl.filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
    if err != nil {
        return 0, err
    }
    defer file.Close()
    
    return file.Write(p)
}

// Now FileLogger automatically implements Writer
var w Writer = FileLogger{filename: "app.log"}
w.Write([]byte("Hello, World!"))

// Can use FileLogger anywhere Writer is expected
func LogMessage(w Writer, message string) {
    w.Write([]byte(message))
}

LogMessage(FileLogger{filename: "app.log"}, "System started")
```

Methods are the ONLY way to satisfy interfaces in Go. This is fundamental to Go's type system and enables polymorphism without inheritance.

### The Code Organization Problem

Methods naturally organize code by type, making large codebases maintainable.

**Problem: Scattered Functions**

```go
// user_validation.go
func ValidateUser(u User) error { ... }
func ValidateUsername(username string) error { ... }

// user_authentication.go  
func AuthenticateUser(u User, password string) bool { ... }
func HashUserPassword(password string) string { ... }

// user_permissions.go
func UserHasPermission(u User, perm string) bool { ... }
func UserCanAccess(u User, resource string) bool { ... }

// user_update.go
func UpdateUserEmail(u *User, email string) error { ... }
func UpdateUserPassword(u *User, password string) error { ... }

// Spread across multiple files, hard to find related operations
```

**Solution: Methods Keep Related Code Together**

```go
// user.go - all User methods in one place
type User struct {
    ID       int64
    Username string
    Email    string
    Password string
    Role     string
}

// Validation methods
func (u User) Validate() error { ... }
func (u User) ValidatePassword(password string) error { ... }

// Authentication methods
func (u User) Authenticate(password string) bool { ... }
func (u User) HashPassword() string { ... }

// Permission methods
func (u User) HasPermission(perm string) bool { ... }
func (u User) CanAccess(resource string) bool { ... }

// Update methods
func (u *User) UpdateEmail(email string) error { ... }
func (u *User) UpdatePassword(password string) error { ... }

// Everything related to User is in one place, easy to find
```

Methods organize code naturally. All operations on a type are methods on that type. This makes codebases navigable and maintainable.

---

## Methods vs Functions

Understanding when to use methods versus functions is crucial for good Go design.

### Syntactic Differences

```go
// Function syntax
func FunctionName(receiver Type, param1 Type1) ReturnType {
    // Implementation
}

// Method syntax
func (receiver Type) MethodName(param1 Type1) ReturnType {
    // Implementation
}
```

The key difference: methods have a **receiver** (the type they're attached to) specified between `func` and the method name.

### Semantic Differences

**Functions:**

- Operate on parameters passed to them
- Global scope (package-level)
- No type association
- Cannot satisfy interfaces
- Used for general-purpose operations

**Methods:**

- Operate on a receiver (the instance)
- Associated with a specific type
- Can satisfy interfaces
- Enable encapsulation
- Used for type-specific operations

### When to Use Functions

**1. General-Purpose Utilities**

Operations that don't logically belong to any particular type:

```go
// General utilities - functions
func Min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func Max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func Contains(slice []string, item string) bool {
    for _, s := range slice {
        if s == item {
            return true
        }
    }
    return false
}
```

**2. Operations on Multiple Types**

When an operation treats multiple types equally:

```go
// Compares any two comparable values - function
func Equal[T comparable](a, b T) bool {
    return a == b
}

// Merges two maps - function
func MergeMaps[K comparable, V any](m1, m2 map[K]V) map[K]V {
    result := make(map[K]V)
    for k, v := range m1 {
        result[k] = v
    }
    for k, v := range m2 {
        result[k] = v
    }
    return result
}
```

**3. Package-Level Operations**

Operations that coordinate multiple types:

```go
// Package-level initialization - function
func InitializeDatabase(config Config) (*DB, error) {
    db, err := sql.Open(config.Driver, config.DSN)
    if err != nil {
        return nil, err
    }
    
    if err := db.Ping(); err != nil {
        return nil, err
    }
    
    return &DB{conn: db}, nil
}

// Coordinates multiple types - function
func TransferBetweenAccounts(from, to *BankAccount, amount float64) error {
    if err := from.Withdraw(amount); err != nil {
        return err
    }
    
    if err := to.Deposit(amount); err != nil {
        from.Deposit(amount)  // Rollback
        return err
    }
    
    return nil
}
```

### When to Use Methods

**1. Type-Specific Operations**

Operations that operate primarily on one type:

```go
type User struct {
    ID       int64
    Username string
    Email    string
}

// Type-specific - method
func (u User) IsValid() bool {
    return len(u.Username) >= 3 && strings.Contains(u.Email, "@")
}

// Type-specific - method
func (u User) GetDisplayName() string {
    return fmt.Sprintf("%s (%s)", u.Username, u.Email)
}
```

**2. State Modifications**

Operations that modify the receiver:

```go
type Counter struct {
    value int
}

// Modifies state - method with pointer receiver
func (c *Counter) Increment() {
    c.value++
}

func (c *Counter) Reset() {
    c.value = 0
}
```

**3. Interface Implementation**

When you need to satisfy an interface:

```go
// Interface
type Stringer interface {
    String() string
}

type Point struct {
    X, Y int
}

// Must be a method to satisfy interface
func (p Point) String() string {
    return fmt.Sprintf("(%d, %d)", p.X, p.Y)
}
```

**4. Encapsulation**

When you need controlled access to internal state:

```go
type Account struct {
    balance float64  // unexported
}

// Methods provide controlled access
func (a Account) GetBalance() float64 {
    return a.balance
}

func (a *Account) Deposit(amount float64) error {
    if amount <= 0 {
        return errors.New("amount must be positive")
    }
    a.balance += amount
    return nil
}
```

### Conversion Examples

Let's see how to convert between functions and methods:

**Function to Method:**

```go
// Function version
func CalculateDiscount(product Product, percentage float64) float64 {
    return product.Price * (percentage / 100)
}

// Method version
func (p Product) CalculateDiscount(percentage float64) float64 {
    return p.Price * (percentage / 100)
}

// Usage comparison
discount := CalculateDiscount(product, 10)  // Function
discount := product.CalculateDiscount(10)   // Method (more intuitive)
```

**Method to Function:**

```go
// Method version
func (u User) Validate() error {
    if len(u.Username) < 3 {
        return errors.New("username too short")
    }
    return nil
}

// Function version
func ValidateUser(u User) error {
    if len(u.Username) < 3 {
        return errors.New("username too short")
    }
    return nil
}

// Both work, but method is more idiomatic for type-specific operations
```

### Decision Tree

```
Should this be a function or method?

Does it operate primarily on ONE type?
├─ Yes → Does it need to satisfy an interface?
│  ├─ Yes → MUST be a method
│  └─ No → Does it modify the receiver?
│     ├─ Yes → Should be a method (with pointer receiver)
│     └─ No → Could be method or function
│        └─ Is it type-specific behavior?
│           ├─ Yes → Method (for better organization)
│           └─ No → Function
│
└─ No → Does it coordinate multiple types?
   ├─ Yes → Function
   └─ No → Is it a general utility?
      ├─ Yes → Function
      └─ No → Reconsider design
```

---

## Real-World Use Cases

Let's explore concrete backend scenarios where methods are essential, demonstrating their power in production systems.

### Use Case 1: Domain Model with Business Logic

E-commerce order management with complex business rules:

```go
type Order struct {
    ID          int64
    CustomerID  int64
    Items       []OrderItem
    Subtotal    float64
    Tax         float64
    Shipping    float64
    Total       float64
    Status      string
    CreatedAt   time.Time
    UpdatedAt   time.Time
}

type OrderItem struct {
    ProductID int64
    Quantity  int
    Price     float64
    Discount  float64
}

// Calculation methods
func (o *Order) CalculateSubtotal() {
    subtotal := 0.0
    for _, item := range o.Items {
        itemTotal := float64(item.Quantity) * item.Price
        itemTotal -= itemTotal * (item.Discount / 100)
        subtotal += itemTotal
    }
    o.Subtotal = subtotal
    o.UpdatedAt = time.Now()
}

func (o *Order) CalculateTax(taxRate float64) {
    o.Tax = o.Subtotal * (taxRate / 100)
    o.UpdatedAt = time.Now()
}

func (o *Order) CalculateShipping() {
    // Free shipping over $100
    if o.Subtotal >= 100 {
        o.Shipping = 0
    } else if o.Subtotal >= 50 {
        o.Shipping = 5.99
    } else {
        o.Shipping = 9.99
    }
    o.UpdatedAt = time.Now()
}

func (o *Order) CalculateTotal() {
    o.CalculateSubtotal()
    o.CalculateTax(8.5)  // 8.5% tax
    o.CalculateShipping()
    o.Total = o.Subtotal + o.Tax + o.Shipping
    o.UpdatedAt = time.Now()
}

// Validation methods
func (o Order) Validate() error {
    if o.CustomerID <= 0 {
        return errors.New("invalid customer ID")
    }
    
    if len(o.Items) == 0 {
        return errors.New("order must have at least one item")
    }
    
    for i, item := range o.Items {
        if item.Quantity <= 0 {
            return fmt.Errorf("item %d: invalid quantity", i)
        }
        if item.Price < 0 {
            return fmt.Errorf("item %d: invalid price", i)
        }
    }
    
    return nil
}

// State management methods
func (o Order) CanCancel() bool {
    return o.Status == "pending" || o.Status == "processing"
}

func (o Order) CanShip() bool {
    return o.Status == "processing"
}

func (o Order) CanComplete() bool {
    return o.Status == "shipped"
}

func (o *Order) Cancel() error {
    if !o.CanCancel() {
        return fmt.Errorf("order in status '%s' cannot be cancelled", o.Status)
    }
    o.Status = "cancelled"
    o.UpdatedAt = time.Now()
    return nil
}

func (o *Order) MarkAsProcessing() error {
    if o.Status != "pending" {
        return fmt.Errorf("only pending orders can be marked as processing")
    }
    o.Status = "processing"
    o.UpdatedAt = time.Now()
    return nil
}

func (o *Order) Ship() error {
    if !o.CanShip() {
        return fmt.Errorf("order in status '%s' cannot be shipped", o.Status)
    }
    o.Status = "shipped"
    o.UpdatedAt = time.Now()
    return nil
}

func (o *Order) Complete() error {
    if !o.CanComplete() {
        return fmt.Errorf("order in status '%s' cannot be completed", o.Status)
    }
    o.Status = "completed"
    o.UpdatedAt = time.Now()
    return nil
}

// Item management methods
func (o *Order) AddItem(item OrderItem) {
    o.Items = append(o.Items, item)
    o.CalculateTotal()
}

func (o *Order) RemoveItem(productID int64) bool {
    for i, item := range o.Items {
        if item.ProductID == productID {
            o.Items = append(o.Items[:i], o.Items[i+1:]...)
            o.CalculateTotal()
            return true
        }
    }
    return false
}

func (o *Order) UpdateItemQuantity(productID int64, quantity int) error {
    for i, item := range o.Items {
        if item.ProductID == productID {
            if quantity <= 0 {
                return errors.New("quantity must be positive")
            }
            o.Items[i].Quantity = quantity
            o.CalculateTotal()
            return nil
        }
    }
    return errors.New("item not found")
}

// Query methods
func (o Order) GetItemCount() int {
    count := 0
    for _, item := range o.Items {
        count += item.Quantity
    }
    return count
}

func (o Order) HasItem(productID int64) bool {
    for _, item := range o.Items {
        if item.ProductID == productID {
            return true
        }
    }
    return false
}

func (o Order) GetDiscountTotal() float64 {
    discount := 0.0
    for _, item := range o.Items {
        itemDiscount := float64(item.Quantity) * item.Price * (item.Discount / 100)
        discount += itemDiscount
    }
    return discount
}

// Usage in application
func processNewOrder(customerID int64, items []OrderItem) error {
    order := &Order{
        CustomerID: customerID,
        Items:      items,
        Status:     "pending",
        CreatedAt:  time.Now(),
        UpdatedAt:  time.Now(),
    }
    
    // Validate order
    if err := order.Validate(); err != nil {
        return fmt.Errorf("invalid order: %w", err)
    }
    
    // Calculate totals
    order.CalculateTotal()
    
    // Save to database
    if err := saveOrder(order); err != nil {
        return err
    }
    
    // Process payment
    if err := processPayment(order); err != nil {
        order.Cancel()
        saveOrder(order)
        return err
    }
    
    // Mark as processing
    order.MarkAsProcessing()
    saveOrder(order)
    
    return nil
}
```

This example demonstrates:

- **Business logic encapsulation** in methods
- **State management** with validation
- **Automatic recalculation** when state changes
- **Clear separation** between read and write operations
- **Fluent API** for working with domain objects

### Use Case 2: Repository Pattern with Methods

Database access layer with CRUD operations:

```go
type User struct {
    ID        int64
    Username  string
    Email     string
    Password  string
    CreatedAt time.Time
    UpdatedAt time.Time
}

// Validation methods
func (u User) Validate() error {
    if len(u.Username) < 3 {
        return errors.New("username must be at least 3 characters")
    }
    
    if !strings.Contains(u.Email, "@") {
        return errors.New("invalid email address")
    }
    
    if len(u.Password) < 8 {
        return errors.New("password must be at least 8 characters")
    }
    
    return nil
}

// Transformation methods
func (u *User) HashPassword() error {
    if u.Password == "" {
        return errors.New("password is required")
    }
    
    hashed, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
    if err != nil {
        return err
    }
    
    u.Password = string(hashed)
    return nil
}

func (u User) VerifyPassword(password string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password))
    return err == nil
}

// Serialization methods
func (u User) ToJSON() ([]byte, error) {
    // Exclude password from JSON
    type UserJSON struct {
        ID        int64     `json:"id"`
        Username  string    `json:"username"`
        Email     string    `json:"email"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
    }
    
    return json.Marshal(UserJSON{
        ID:        u.ID,
        Username:  u.Username,
        Email:     u.Email,
        CreatedAt: u.CreatedAt,
        UpdatedAt: u.UpdatedAt,
    })
}

// Repository pattern with methods
type UserRepository struct {
    db *sql.DB
}

func NewUserRepository(db *sql.DB) *UserRepository {
    return &UserRepository{db: db}
}

func (r *UserRepository) Create(user *User) error {
    // Validate before creating
    if err := user.Validate(); err != nil {
        return err
    }
    
    // Hash password
    if err := user.HashPassword(); err != nil {
        return err
    }
    
    // Set timestamps
    now := time.Now()
    user.CreatedAt = now
    user.UpdatedAt = now
    
    // Insert into database
    query := `
        INSERT INTO users (username, email, password, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id
    `
    
    err := r.db.QueryRow(
        query,
        user.Username,
        user.Email,
        user.Password,
        user.CreatedAt,
        user.UpdatedAt,
    ).Scan(&user.ID)
    
    return err
}

func (r *UserRepository) FindByID(id int64) (*User, error) {
    user := &User{}
    
    query := `
        SELECT id, username, email, password, created_at, updated_at
        FROM users
        WHERE id = $1
    `
    
    err := r.db.QueryRow(query, id).Scan(
        &user.ID,
        &user.Username,
        &user.Email,
        &user.Password,
        &user.CreatedAt,
        &user.UpdatedAt,
    )
    
    if err == sql.ErrNoRows {
        return nil, errors.New("user not found")
    }
    
    return user, err
}

func (r *UserRepository) FindByEmail(email string) (*User, error) {
    user := &User{}
    
    query := `
        SELECT id, username, email, password, created_at, updated_at
        FROM users
        WHERE email = $1
    `
    
    err := r.db.QueryRow(query, email).Scan(
        &user.ID,
        &user.Username,
        &user.Email,
        &user.Password,
        &user.CreatedAt,
        &user.UpdatedAt,
    )
    
    if err == sql.ErrNoRows {
        return nil, errors.New("user not found")
    }
    
    return user, err
}

func (r *UserRepository) Update(user *User) error {
    if err := user.Validate(); err != nil {
        return err
    }
    
    user.UpdatedAt = time.Now()
    
    query := `
        UPDATE users
        SET username = $1, email = $2, updated_at = $3
        WHERE id = $4
    `
    
    result, err := r.db.Exec(
        query,
        user.Username,
        user.Email,
        user.UpdatedAt,
        user.ID,
    )
    
    if err != nil {
        return err
    }
    
    rows, err := result.RowsAffected()
    if err != nil {
        return err
    }
    
    if rows == 0 {
        return errors.New("user not found")
    }
    
    return nil
}

func (r *UserRepository) Delete(id int64) error {
    query := `DELETE FROM users WHERE id = $1`
    
    result, err := r.db.Exec(query, id)
    if err != nil {
        return err
    }
    
    rows, err := result.RowsAffected()
    if err != nil {
        return err
    }
    
    if rows == 0 {
        return errors.New("user not found")
    }
    
    return nil
}

func (r *UserRepository) List(limit, offset int) ([]*User, error) {
    query := `
        SELECT id, username, email, password, created_at, updated_at
        FROM users
        ORDER BY created_at DESC
        LIMIT $1 OFFSET $2
    `
    
    rows, err := r.db.Query(query, limit, offset)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    users := []*User{}
    
    for rows.Next() {
        user := &User{}
        err := rows.Scan(
            &user.ID,
            &user.Username,
            &user.Email,
            &user.Password,
            &user.CreatedAt,
            &user.UpdatedAt,
        )
        if err != nil {
            return nil, err
        }
        users = append(users, user)
    }
    
    return users, rows.Err()
}

// Usage in application
func registerUser(repo *UserRepository, username, email, password string) error {
    user := &User{
        Username: username,
        Email:    email,
        Password: password,
    }
    
    if err := repo.Create(user); err != nil {
        return err
    }
    
    log.Printf("User created: ID=%d, Username=%s", user.ID, user.Username)
    return nil
}

func authenticateUser(repo *UserRepository, email, password string) (*User, error) {
    user, err := repo.FindByEmail(email)
    if err != nil {
        return nil, err
    }
    
    if !user.VerifyPassword(password) {
        return nil, errors.New("invalid credentials")
    }
    
    return user, nil
}
```

This repository pattern demonstrates:

- **Separation of concerns**: Domain logic in `User`, persistence in `UserRepository`
- **Method-based CRUD operations** on repository
- **Validation and transformation** methods on domain model
- **Encapsulation** of database operations
- **Clean API** for application code

This completes Part 1. Continue to Part 2 for:

- Memory Architecture of Methods
- Value vs Pointer Receivers - Deep Dive
- Method Sets and Interfaces
- Advanced Patterns
- Performance Optimization


## Memory Architecture, Advanced Patterns, and Performance

---

## Memory Architecture of Methods

Understanding how methods work at the memory level helps you write efficient, correct code.

### Method Storage and Dispatch

Methods are stored differently from their data. The method code exists once; all instances share it.

```
Memory Layout:

Text Segment (Code):
┌─────────────────────────────┐
│ Rectangle.Area() code       │  0x1000
│ Rectangle.Perimeter() code  │  0x1050
│ Circle.Area() code          │  0x1100
│ Circle.Perimeter() code     │  0x1150
└─────────────────────────────┘

Heap/Stack (Data):
┌─────────────────────────────┐
│ rect1: Rectangle            │
│   Width: 10.0               │
│   Height: 5.0               │
├─────────────────────────────┤
│ rect2: Rectangle            │
│   Width: 20.0               │
│   Height: 15.0              │
├─────────────────────────────┤
│ circle1: Circle             │
│   Radius: 7.5               │
└─────────────────────────────┘

Both rect1 and rect2 share the same method code!
```

**Method Call Process:**

```go
type Rectangle struct {
    Width  float64
    Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

rect := Rectangle{Width: 10, Height: 5}
area := rect.Area()
```

**What Happens:**

```
1. Caller prepares call:
   - Copies rect to method's receiver parameter
   - Pushes return address

Stack Before Call:
┌─────────────────────────┐
│ rect: Rectangle         │
│   Width: 10.0           │
│   Height: 5.0           │
│ area: uninitialized     │
└─────────────────────────┘

2. Method executes:
   - Receiver 'r' is a copy of rect
   - Calculates r.Width * r.Height
   - Returns result

Stack During Call:
┌─────────────────────────┐
│ Area() frame            │
│   r: Rectangle (copy)   │
│     Width: 10.0         │
│     Height: 5.0         │
│   [return: 50.0]        │
├─────────────────────────┤
│ main() frame            │
│   rect: Rectangle       │
│   area: uninitialized   │
└─────────────────────────┘

3. Return:
   - Result (50.0) copied to 'area'
   - Method frame popped

Stack After Call:
┌─────────────────────────┐
│ rect: Rectangle         │
│   Width: 10.0           │
│   Height: 5.0           │
│ area: 50.0              │
└─────────────────────────┘
```

### Value Receiver Memory Model

Value receivers receive a **copy** of the struct. Changes to the receiver don't affect the original.

```go
type Counter struct {
    value int
}

func (c Counter) Increment() {
    c.value++  // Modifies only the copy!
}

func main() {
    counter := Counter{value: 5}
    counter.Increment()
    fmt.Println(counter.value)  // Still 5!
}
```

**Memory View:**

```
Before Increment():
Stack:
┌─────────────────────┐
│ counter:            │
│   value: 5          │  Address: 0x1000
└─────────────────────┘

During Increment():
┌─────────────────────┐
│ Increment() frame   │
│   c (copy):         │
│     value: 5 → 6    │  Address: 0x2000 (different!)
├─────────────────────┤
│ main() frame        │
│   counter:          │
│     value: 5        │  Address: 0x1000 (unchanged)
└─────────────────────┘

After Increment():
┌─────────────────────┐
│ counter:            │
│   value: 5          │  Original unchanged!
└─────────────────────┘
```

### Pointer Receiver Memory Model

Pointer receivers receive the **address** of the struct. Changes affect the original.

```go
type Counter struct {
    value int
}

func (c *Counter) Increment() {
    c.value++  // Modifies through pointer!
}

func main() {
    counter := Counter{value: 5}
    counter.Increment()
    fmt.Println(counter.value)  // Now 6!
}
```

**Memory View:**

```
Before Increment():
Stack:
┌─────────────────────┐
│ counter:            │
│   value: 5          │  Address: 0x1000
└─────────────────────┘

During Increment():
┌─────────────────────┐
│ Increment() frame   │
│   c: *Counter       │
│     = 0x1000        │  Points to original!
├─────────────────────┤
│ main() frame        │
│   counter:          │
│     value: 5 → 6    │  Modified through pointer
└─────────────────────┘

After Increment():
┌─────────────────────┐
│ counter:            │
│   value: 6          │  Original modified!
└─────────────────────┘
```

**Key Difference:**

```
Value Receiver:
- Copies entire struct
- Method works with independent copy
- Original unchanged
- Safe but potentially slow for large structs

Pointer Receiver:
- Copies only pointer (8 bytes on 64-bit)
- Method works with original through pointer
- Original can be modified
- Efficient for large structs
```

---

## Value vs Pointer Receivers - Deep Dive

Choosing between value and pointer receivers is one of the most important decisions in Go method design.

### The Complete Decision Matrix

```
Choose VALUE receiver when:
✓ Type is small (≤ a few words, e.g., 16-32 bytes)
✓ Type should be immutable
✓ Method doesn't modify the receiver
✓ Type has no mutable fields (or you want copies of them)
✓ Receiver is a basic type (int, string, etc.)

Choose POINTER receiver when:
✓ Type is large (copying would be expensive)
✓ Method needs to modify the receiver
✓ Receiver contains pointer fields that shouldn't be copied
✓ Receiver contains sync primitives (sync.Mutex, etc.)
✓ Consistency (if any method needs pointer, use for all)
```

### Detailed Examples

**Example 1: Small Immutable Type - Value Receiver**

```go
type Point struct {
    X, Y int  // 16 bytes total - small!
}

// Value receiver - reads data, doesn't modify
func (p Point) Distance() float64 {
    return math.Sqrt(float64(p.X*p.X + p.Y*p.Y))
}

// Value receiver - returns new Point, doesn't modify original
func (p Point) Add(other Point) Point {
    return Point{X: p.X + other.X, Y: p.Y + other.Y}
}

// Value receiver - immutable operations
func (p Point) String() string {
    return fmt.Sprintf("(%d, %d)", p.X, p.Y)
}

// Usage - immutable, functional style
p1 := Point{X: 3, Y: 4}
p2 := Point{X: 1, Y: 2}
p3 := p1.Add(p2)  // p1 unchanged, p3 is new point

distance := p1.Distance()  // p1 unchanged
```

**Example 2: Large Type - Pointer Receiver**

```go
type Image struct {
    Pixels [1920][1080]uint32  // ~8MB! Very large!
    Width  int
    Height int
}

// Pointer receiver - avoid copying 8MB
func (img *Image) SetPixel(x, y int, color uint32) {
    if x >= 0 && x < img.Width && y >= 0 && y < img.Height {
        img.Pixels[y][x] = color
    }
}

// Pointer receiver - even read-only, avoid copy
func (img *Image) GetPixel(x, y int) uint32 {
    if x >= 0 && x < img.Width && y >= 0 && y < img.Height {
        return img.Pixels[y][x]
    }
    return 0
}

// Pointer receiver - modifies internal state
func (img *Image) Clear(color uint32) {
    for y := 0; y < img.Height; y++ {
        for x := 0; x < img.Width; x++ {
            img.Pixels[y][x] = color
        }
    }
}

// Usage - mutations affect original
img := &Image{Width: 1920, Height: 1080}
img.SetPixel(100, 100, 0xFF0000)  // Modifies img
img.Clear(0x000000)                // Modifies img
```

**Example 3: Type with Sync Primitives - MUST Use Pointer**

```go
type SafeCounter struct {
    mu    sync.Mutex  // NEVER copy sync.Mutex!
    value int
}

// MUST use pointer receiver - sync.Mutex cannot be copied
func (sc *SafeCounter) Increment() {
    sc.mu.Lock()
    defer sc.mu.Unlock()
    sc.value++
}

// MUST use pointer receiver
func (sc *SafeCounter) Value() int {
    sc.mu.Lock()
    defer sc.mu.Unlock()
    return sc.value
}

// If you used value receiver, you'd copy the mutex - WRONG!
// func (sc SafeCounter) Increment() {  // BUG!
//     sc.mu.Lock()  // Locks a COPY of the mutex!
//     sc.value++
//     sc.mu.Unlock()
// }
```

**Example 4: Consistency - All Pointer or All Value**

```go
// BAD: Mixing value and pointer receivers
type User struct {
    ID       int64
    Username string
}

func (u User) GetID() int64 {        // Value receiver
    return u.ID
}

func (u *User) SetUsername(name string) {  // Pointer receiver
    u.Username = name
}

// Problem: Inconsistent interface, confusing behavior

// GOOD: All pointer receivers for consistency
type User struct {
    ID       int64
    Username string
}

func (u *User) GetID() int64 {       // Pointer receiver
    return u.ID
}

func (u *User) SetUsername(name string) {  // Pointer receiver
    u.Username = name
}

// Or all value receivers if type is small and immutable
```

### Method Call Automatic Conversions

Go automatically takes addresses or dereferences when calling methods:

```go
type Rectangle struct {
    Width, Height float64
}

func (r Rectangle) AreaValue() float64 {
    return r.Width * r.Height
}

func (r *Rectangle) AreaPointer() float64 {
    return r.Width * r.Height
}

// Value receiver method
rect1 := Rectangle{Width: 10, Height: 5}
rect1.AreaValue()   // Direct call

rectPtr := &Rectangle{Width: 10, Height: 5}
rectPtr.AreaValue()  // Go automatically dereferences: (*rectPtr).AreaValue()

// Pointer receiver method
rect2 := Rectangle{Width: 10, Height: 5}
rect2.AreaPointer()  // Go automatically takes address: (&rect2).AreaPointer()

rectPtr2 := &Rectangle{Width: 10, Height: 5}
rectPtr2.AreaPointer()  // Direct call
```

**Automatic Conversion Rules:**

```
Method Receiver    |  Value Variable  |  Pointer Variable
─────────────────────────────────────────────────────────
Value (r T)        |  Direct call     |  *ptr (automatic)
Pointer (r *T)     |  &val (automatic)|  Direct call
```

**Important Limitation:**

```go
// Automatic conversion works for variables
rect := Rectangle{Width: 10, Height: 5}
rect.AreaPointer()  // ✓ Go takes address automatically

// Does NOT work for non-addressable values
Rectangle{Width: 10, Height: 5}.AreaPointer()  // ✗ Compile error!
// Cannot take address of temporary value

// Workaround: Assign to variable first
rect := Rectangle{Width: 10, Height: 5}
rect.AreaPointer()  // ✓ Works
```

---

## Method Sets and Interfaces

Method sets determine which methods are available on a type and how types satisfy interfaces.

### Method Set Rules

The **method set** of a type is the set of methods you can call on values of that type.

```
Type T (value):
  Method set = all methods with receiver T

Type *T (pointer):
  Method set = all methods with receiver T + all methods with receiver *T
```

**Example:**

```go
type Counter struct {
    value int
}

// Value receiver
func (c Counter) Get() int {
    return c.value
}

// Pointer receiver
func (c *Counter) Set(val int) {
    c.value = val
}

func (c *Counter) Increment() {
    c.value++
}

// Method sets:
// Counter (value):  Get()
// *Counter (pointer): Get(), Set(), Increment()

// Usage with value
counter := Counter{value: 5}
counter.Get()        // ✓ In method set
counter.Set(10)      // ✓ Go takes address automatically
counter.Increment()  // ✓ Go takes address automatically

// Usage with pointer
counterPtr := &Counter{value: 5}
counterPtr.Get()        // ✓ In method set
counterPtr.Set(10)      // ✓ In method set
counterPtr.Increment()  // ✓ In method set
```

### Interface Satisfaction with Method Sets

Interface satisfaction depends on method sets:

```go
type Getter interface {
    Get() int
}

type Setter interface {
    Set(int)
}

type GetterSetter interface {
    Get() int
    Set(int)
}

// Counter satisfies Getter (has Get with value receiver)
var g Getter = Counter{value: 5}  // ✓ Works
g.Get()

// Counter does NOT satisfy Setter (Set has pointer receiver)
var s Setter = Counter{value: 5}  // ✗ Compile error!
// Counter does not implement Setter (Set method has pointer receiver)

// *Counter satisfies both
var gs GetterSetter = &Counter{value: 5}  // ✓ Works
gs.Get()
gs.Set(10)
```

**The Rule:**

```
To satisfy interface I:

If interface method has ANY pointer receiver methods:
  → Only *T satisfies the interface

If interface methods all have value receivers:
  → Both T and *T satisfy the interface
```

**Practical Example:**

```go
type Writer interface {
    Write([]byte) (int, error)
}

type Buffer struct {
    data []byte
}

// Pointer receiver - modifies buffer
func (b *Buffer) Write(p []byte) (int, error) {
    b.data = append(b.data, p...)
    return len(p), nil
}

// WRONG: Value doesn't satisfy Writer
var w Writer = Buffer{}  // ✗ Compile error!
// Buffer does not implement Writer (Write method has pointer receiver)

// CORRECT: Pointer satisfies Writer
var w Writer = &Buffer{}  // ✓ Works
w.Write([]byte("hello"))
```

### Nil Receivers

Pointer receiver methods can be called on nil pointers (carefully!):

```go
type Tree struct {
    value int
    left  *Tree
    right *Tree
}

func (t *Tree) Sum() int {
    // Handle nil receiver
    if t == nil {
        return 0
    }
    return t.value + t.left.Sum() + t.right.Sum()
}

// Can call on nil
var tree *Tree = nil
sum := tree.Sum()  // Returns 0, doesn't panic!
```

**Useful for Optional Types:**

```go
type OptionalConfig struct {
    timeout time.Duration
}

func (c *OptionalConfig) GetTimeout() time.Duration {
    if c == nil {
        return 30 * time.Second  // Default
    }
    return c.timeout
}

// Works with nil - provides default
var config *OptionalConfig = nil
timeout := config.GetTimeout()  // 30 seconds
```

---

## Advanced Patterns and Techniques

### Pattern 1: Method Chaining (Fluent Interface)

Methods return the receiver to enable chaining:

```go
type QueryBuilder struct {
    table   string
    columns []string
    where   []string
    orderBy string
    limit   int
}

func NewQuery(table string) *QueryBuilder {
    return &QueryBuilder{table: table}
}

func (qb *QueryBuilder) Select(columns ...string) *QueryBuilder {
    qb.columns = columns
    return qb
}

func (qb *QueryBuilder) Where(condition string) *QueryBuilder {
    qb.where = append(qb.where, condition)
    return qb
}

func (qb *QueryBuilder) OrderBy(column string) *QueryBuilder {
    qb.orderBy = column
    return qb
}

func (qb *QueryBuilder) Limit(n int) *QueryBuilder {
    qb.limit = n
    return qb
}

func (qb *QueryBuilder) Build() string {
    query := "SELECT "
    if len(qb.columns) == 0 {
        query += "*"
    } else {
        query += strings.Join(qb.columns, ", ")
    }
    
    query += " FROM " + qb.table
    
    if len(qb.where) > 0 {
        query += " WHERE " + strings.Join(qb.where, " AND ")
    }
    
    if qb.orderBy != "" {
        query += " ORDER BY " + qb.orderBy
    }
    
    if qb.limit > 0 {
        query += fmt.Sprintf(" LIMIT %d", qb.limit)
    }
    
    return query
}

// Usage - fluent, readable
query := NewQuery("users").
    Select("id", "name", "email").
    Where("active = true").
    Where("age > 18").
    OrderBy("created_at DESC").
    Limit(10).
    Build()

fmt.Println(query)
// SELECT id, name, email FROM users WHERE active = true AND age > 18 ORDER BY created_at DESC LIMIT 10
```

### Pattern 2: Builder Pattern with Methods

Separate construction from representation:

```go
type Server struct {
    host         string
    port         int
    timeout      time.Duration
    maxConns     int
    readTimeout  time.Duration
    writeTimeout time.Duration
}

type ServerBuilder struct {
    server *Server
}

func NewServerBuilder() *ServerBuilder {
    return &ServerBuilder{
        server: &Server{
            host:         "localhost",
            port:         8080,
            timeout:      30 * time.Second,
            maxConns:     100,
            readTimeout:  5 * time.Second,
            writeTimeout: 5 * time.Second,
        },
    }
}

func (sb *ServerBuilder) Host(host string) *ServerBuilder {
    sb.server.host = host
    return sb
}

func (sb *ServerBuilder) Port(port int) *ServerBuilder {
    sb.server.port = port
    return sb
}

func (sb *ServerBuilder) Timeout(timeout time.Duration) *ServerBuilder {
    sb.server.timeout = timeout
    return sb
}

func (sb *ServerBuilder) MaxConnections(max int) *ServerBuilder {
    sb.server.maxConns = max
    return sb
}

func (sb *ServerBuilder) ReadTimeout(timeout time.Duration) *ServerBuilder {
    sb.server.readTimeout = timeout
    return sb
}

func (sb *ServerBuilder) WriteTimeout(timeout time.Duration) *ServerBuilder {
    sb.server.writeTimeout = timeout
    return sb
}

func (sb *ServerBuilder) Build() (*Server, error) {
    // Validation
    if sb.server.port < 1 || sb.server.port > 65535 {
        return nil, errors.New("invalid port")
    }
    
    if sb.server.maxConns < 1 {
        return nil, errors.New("maxConns must be positive")
    }
    
    return sb.server, nil
}

// Usage
server, err := NewServerBuilder().
    Host("0.0.0.0").
    Port(9000).
    Timeout(60 * time.Second).
    MaxConnections(500).
    ReadTimeout(10 * time.Second).
    WriteTimeout(10 * time.Second).
    Build()

if err != nil {
    log.Fatal(err)
}
```

### Pattern 3: State Pattern with Methods

Encode state in types, transitions through methods:

```go
type ConnectionState interface {
    Connect() ConnectionState
    Disconnect() ConnectionState
    Send(data []byte) error
    State() string
}

type DisconnectedState struct {
    conn *Connection
}

func (s *DisconnectedState) Connect() ConnectionState {
    fmt.Println("Connecting...")
    s.conn.socket = openSocket()
    return &ConnectedState{conn: s.conn}
}

func (s *DisconnectedState) Disconnect() ConnectionState {
    return s  // Already disconnected
}

func (s *DisconnectedState) Send(data []byte) error {
    return errors.New("cannot send: not connected")
}

func (s *DisconnectedState) State() string {
    return "disconnected"
}

type ConnectedState struct {
    conn *Connection
}

func (s *ConnectedState) Connect() ConnectionState {
    return s  // Already connected
}

func (s *ConnectedState) Disconnect() ConnectionState {
    fmt.Println("Disconnecting...")
    s.conn.socket.Close()
    s.conn.socket = nil
    return &DisconnectedState{conn: s.conn}
}

func (s *ConnectedState) Send(data []byte) error {
    _, err := s.conn.socket.Write(data)
    return err
}

func (s *ConnectedState) State() string {
    return "connected"
}

type Connection struct {
    state  ConnectionState
    socket net.Conn
}

func NewConnection() *Connection {
    conn := &Connection{}
    conn.state = &DisconnectedState{conn: conn}
    return conn
}

func (c *Connection) Connect() {
    c.state = c.state.Connect()
}

func (c *Connection) Disconnect() {
    c.state = c.state.Disconnect()
}

func (c *Connection) Send(data []byte) error {
    return c.state.Send(data)
}

func (c *Connection) State() string {
    return c.state.State()
}

// Usage
conn := NewConnection()
fmt.Println(conn.State())  // "disconnected"

conn.Send([]byte("hello"))  // Error: cannot send: not connected

conn.Connect()
fmt.Println(conn.State())  // "connected"

conn.Send([]byte("hello"))  // Works!

conn.Disconnect()
fmt.Println(conn.State())  // "disconnected"
```

### Pattern 4: Mixin Pattern with Embedded Structs

Compose behavior through embedding:

```go
// Timestamp mixin
type Timestamped struct {
    CreatedAt time.Time
    UpdatedAt time.Time
}

func (t *Timestamped) Touch() {
    t.UpdatedAt = time.Now()
}

func (t *Timestamped) SetCreated() {
    t.CreatedAt = time.Now()
    t.UpdatedAt = time.Now()
}

// Validation mixin
type Validated struct {
    errors []error
}

func (v *Validated) AddError(err error) {
    v.errors = append(v.errors, err)
}

func (v *Validated) IsValid() bool {
    return len(v.errors) == 0
}

func (v *Validated) Errors() []error {
    return v.errors
}

func (v *Validated) ClearErrors() {
    v.errors = nil
}

// Composite type with mixins
type User struct {
    ID       int64
    Username string
    Email    string
    
    Timestamped  // Embedded - gets all Timestamped methods
    Validated    // Embedded - gets all Validated methods
}

func (u *User) Validate() {
    u.ClearErrors()
    
    if len(u.Username) < 3 {
        u.AddError(errors.New("username too short"))
    }
    
    if !strings.Contains(u.Email, "@") {
        u.AddError(errors.New("invalid email"))
    }
}

// Usage
user := &User{
    Username: "ab",
    Email:    "invalid",
}

user.SetCreated()  // From Timestamped
user.Validate()    // Own method

if !user.IsValid() {  // From Validated
    for _, err := range user.Errors() {
        fmt.Println(err)
    }
}

user.Touch()  // From Timestamped
```

---

## Practical Backend Examples

### Example: HTTP Handler with Method-Based Routing

```go
type UserHandler struct {
    repo UserRepository
}

func NewUserHandler(repo UserRepository) *UserHandler {
    return &UserHandler{repo: repo}
}

// Each HTTP method is a method
func (h *UserHandler) Get(w http.ResponseWriter, r *http.Request) {
    id, err := strconv.ParseInt(r.URL.Query().Get("id"), 10, 64)
    if err != nil {
        http.Error(w, "Invalid ID", http.StatusBadRequest)
        return
    }
    
    user, err := h.repo.FindByID(id)
    if err != nil {
        http.Error(w, "User not found", http.StatusNotFound)
        return
    }
    
    json.NewEncoder(w).Encode(user)
}

func (h *UserHandler) Post(w http.ResponseWriter, r *http.Request) {
    var user User
    if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
        http.Error(w, "Invalid JSON", http.StatusBadRequest)
        return
    }
    
    if err := h.repo.Create(&user); err != nil {
        http.Error(w, "Failed to create user", http.StatusInternalServerError)
        return
    }
    
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(user)
}

func (h *UserHandler) Put(w http.ResponseWriter, r *http.Request) {
    var user User
    if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
        http.Error(w, "Invalid JSON", http.StatusBadRequest)
        return
    }
    
    if err := h.repo.Update(&user); err != nil {
        http.Error(w, "Failed to update user", http.StatusInternalServerError)
        return
    }
    
    json.NewEncoder(w).Encode(user)
}

func (h *UserHandler) Delete(w http.ResponseWriter, r *http.Request) {
    id, err := strconv.ParseInt(r.URL.Query().Get("id"), 10, 64)
    if err != nil {
        http.Error(w, "Invalid ID", http.StatusBadRequest)
        return
    }
    
    if err := h.repo.Delete(id); err != nil {
        http.Error(w, "Failed to delete user", http.StatusInternalServerError)
        return
    }
    
    w.WriteHeader(http.StatusNoContent)
}

// ServeHTTP dispatches to appropriate method
func (h *UserHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
    case http.MethodGet:
        h.Get(w, r)
    case http.MethodPost:
        h.Post(w, r)
    case http.MethodPut:
        h.Put(w, r)
    case http.MethodDelete:
        h.Delete(w, r)
    default:
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}

// Usage
func main() {
    repo := NewSQLUserRepository(db)
    handler := NewUserHandler(repo)
    
    http.Handle("/users", handler)
    http.ListenAndServe(":8080", nil)
}
```

### Example: Service Layer with Transaction Support

```go
type OrderService struct {
    db       *sql.DB
    orders   OrderRepository
    products ProductRepository
    inventory InventoryService
}

func NewOrderService(
    db *sql.DB,
    orders OrderRepository,
    products ProductRepository,
    inventory InventoryService,
) *OrderService {
    return &OrderService{
        db:        db,
        orders:    orders,
        products:  products,
        inventory: inventory,
    }
}

func (s *OrderService) withTransaction(fn func(*sql.Tx) error) error {
    tx, err := s.db.Begin()
    if err != nil {
        return err
    }
    
    defer func() {
        if p := recover(); p != nil {
            tx.Rollback()
            panic(p)
        }
    }()
    
    if err := fn(tx); err != nil {
        tx.Rollback()
        return err
    }
    
    return tx.Commit()
}

func (s *OrderService) CreateOrder(order *Order) error {
    return s.withTransaction(func(tx *sql.Tx) error {
        // Validate order
        if err := order.Validate(); err != nil {
            return err
        }
        
        // Check inventory for each item
        for _, item := range order.Items {
            available, err := s.inventory.CheckAvailability(tx, item.ProductID, item.Quantity)
            if err != nil {
                return err
            }
            
            if !available {
                return fmt.Errorf("insufficient inventory for product %d", item.ProductID)
            }
        }
        
        // Reserve inventory
        for _, item := range order.Items {
            if err := s.inventory.Reserve(tx, item.ProductID, item.Quantity); err != nil {
                return err
            }
        }
        
        // Calculate totals
        order.CalculateTotal()
        
        // Save order
        if err := s.orders.CreateWithTx(tx, order); err != nil {
            return err
        }
        
        return nil
    })
}

func (s *OrderService) CancelOrder(orderID int64) error {
    return s.withTransaction(func(tx *sql.Tx) error {
        // Get order
        order, err := s.orders.FindByIDWithTx(tx, orderID)
        if err != nil {
            return err
        }
        
        // Check if can cancel
        if !order.CanCancel() {
            return errors.New("order cannot be cancelled")
        }
        
        // Release inventory
        for _, item := range order.Items {
            if err := s.inventory.Release(tx, item.ProductID, item.Quantity); err != nil {
                return err
            }
        }
        
        // Update order status
        order.Status = "cancelled"
        if err := s.orders.UpdateWithTx(tx, order); err != nil {
            return err
        }
        
        return nil
    })
}
```

---

## Performance and Best Practices

### Performance Considerations

**1. Receiver Size Matters**

```go
// Small struct - value receiver is fine
type Point struct {
    X, Y int  // 16 bytes
}

func (p Point) Distance() float64 {  // Copy is cheap
    return math.Sqrt(float64(p.X*p.X + p.Y*p.Y))
}

// Large struct - pointer receiver is better
type Matrix struct {
    Data [1000][1000]float64  // 8MB!
}

func (m *Matrix) Determinant() float64 {  // Don't copy 8MB!
    // Calculate determinant
}
```

**2. Method Call Overhead**

```go
// Method calls have minimal overhead
func BenchmarkMethodCall(b *testing.B) {
    p := Point{X: 3, Y: 4}
    for i := 0; i < b.N; i++ {
        _ = p.Distance()
    }
}

// Inlining can eliminate overhead for small methods
// Compiler often inlines methods automatically
```

**3. Interface Method Calls**

```go
// Interface calls are slightly slower (virtual dispatch)
func BenchmarkInterfaceCall(b *testing.B) {
    var s Shape = Point{X: 3, Y: 4}
    for i := 0; i < b.N; i++ {
        _ = s.Area()
    }
}

// Direct method calls are faster
func BenchmarkDirectCall(b *testing.B) {
    p := Point{X: 3, Y: 4}
    for i := 0; i < b.N; i++ {
        _ = p.Area()
    }
}
```

### Best Practices Summary

**Method Design:**

1. Use value receivers for small, immutable types
2. Use pointer receivers for large types or when mutation is needed
3. Be consistent - don't mix value and pointer receivers
4. Consider nil receiver handling for pointer receivers
5. Methods that modify state MUST use pointer receivers

**Naming:**

1. Keep method names concise and descriptive
2. Use verb names for actions: `Calculate`, `Validate`, `Process`
3. Use noun/adjective names for queries: `IsValid`, `GetName`, `HasPermission`
4. Avoid redundant type names: `user.GetUser()` → `user.Get()`

**Organization:**

1. Group related methods together in files
2. Document exported methods with godoc comments
3. Put method definitions near struct definition
4. Consider separating interface implementations into files

**Testing:**

1. Test methods independently when possible
2. Use table-driven tests for multiple scenarios
3. Mock dependencies through interfaces
4. Test both success and failure cases

This completes the Methods guide! You now understand methods from fundamentals through advanced patterns and performance optimization.