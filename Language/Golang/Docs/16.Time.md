# A Comprehensive Guide to Go Time Operations

## Table of Contents

1. [Introduction to Time in Go](#introduction-to-time-in-go)
2. [Working with Time](#working-with-time)
3. [Timers](#timers)
4. [Tickers](#tickers)
5. [Epoch Time](#epoch-time)
6. [Time Formatting and Parsing](#time-formatting-and-parsing)
7. [Time Conversion and Manipulation](#time-conversion-and-manipulation)
8. [Time in Backend Systems](#time-in-backend-systems)
9. [Real-World Examples](#real-world-examples)

---

## Introduction to Time in Go

Time is one of the most critical aspects of any software system. Whether you're logging events, scheduling tasks, measuring performance, or coordinating distributed systems, understanding how to work with time correctly is essential. Go's `time` package provides a comprehensive and well-designed API for handling all time-related operations.

### The Importance of Time in Software

Imagine you're building an e-commerce platform. You need to track when orders are placed, schedule promotional campaigns, handle different time zones for international customers, measure API response times, and expire user sessions. Every one of these scenarios requires precise time handling.

### Go's Time Philosophy

Go treats time as a combination of two components:

1. **Wall Clock Time**: The time you'd see on a wall clock (e.g., 2:30 PM)
2. **Monotonic Time**: A steadily increasing clock that's not affected by system clock changes

This dual nature protects you from issues like clock adjustments, daylight saving time changes, or NTP synchronization affecting your duration measurements.

```
Time Representation in Go:

┌─────────────────────────────────────────────────┐
│           time.Time                             │
├─────────────────────────────────────────────────┤
│  Wall Clock: 2024-01-15 14:30:00 UTC            │
│  Monotonic:  +123456789 (nanoseconds)           │
│  Location:   *time.Location (UTC/Local/etc)     │
└─────────────────────────────────────────────────┘

When you subtract two times:
  duration = t2 - t1
  ↓
  Uses monotonic clock (immune to system time changes)

When you format a time:
  formatted = t.Format("2006-01-02")
  ↓
  Uses wall clock (what users see)
```

### The Zero Value

The zero value of `time.Time` is January 1, year 1, 00:00:00 UTC. You can check if a time is zero:

```go
var t time.Time
if t.IsZero() {
    fmt.Println("Time is zero")
}
```

This is useful for optional time fields in structs or database columns that might be NULL.

---

## Working with Time

### Getting Current Time

The most basic operation is getting the current time:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // Get current time
    now := time.Now()
    fmt.Println("Current time:", now)
    // Output: Current time: 2024-01-15 14:30:45.123456789 +0000 UTC
    
    // Get UTC time
    utc := time.Now().UTC()
    fmt.Println("UTC time:", utc)
    
    // Get local time (system's local timezone)
    local := time.Now().Local()
    fmt.Println("Local time:", local)
}
```

**Understanding the Output**: When you print a `time.Time`, you see several components:

- Date and time: `2024-01-15 14:30:45.123456789`
- Timezone offset: `+0000` (UTC is zero offset)
- Timezone name: `UTC`

### Creating Specific Times

You can create times for specific moments:

```go
// Create a specific date and time
// Date(year, month, day, hour, min, sec, nsec, location)
t := time.Date(2024, time.January, 15, 14, 30, 0, 0, time.UTC)
fmt.Println(t) // 2024-01-15 14:30:00 +0000 UTC

// Create time in different timezone
loc, _ := time.LoadLocation("America/New_York")
nyTime := time.Date(2024, time.January, 15, 9, 30, 0, 0, loc)
fmt.Println(nyTime) // 2024-01-15 09:30:00 -0500 EST

// Parse from string (we'll cover this in detail later)
parsed, _ := time.Parse("2006-01-02", "2024-01-15")
fmt.Println(parsed)
```

### Extracting Components

You can extract individual components from a time:

```go
now := time.Now()

// Date components
year := now.Year()          // 2024
month := now.Month()        // January (type time.Month)
day := now.Day()            // 15
weekday := now.Weekday()    // Monday (type time.Weekday)
yearDay := now.YearDay()    // 15 (day of year)

// Time components
hour := now.Hour()          // 14 (24-hour format)
minute := now.Minute()      // 30
second := now.Second()      // 45
nanosecond := now.Nanosecond() // 123456789

// Get year, month, day in one call
y, m, d := now.Date()

// Get hour, minute, second in one call
h, min, s := now.Clock()

fmt.Printf("Date: %d-%02d-%02d\n", y, m, d)
fmt.Printf("Time: %02d:%02d:%02d\n", h, min, s)
```

### Time Comparison

Comparing times is straightforward:

```go
t1 := time.Now()
time.Sleep(1 * time.Second)
t2 := time.Now()

// Basic comparisons
if t2.After(t1) {
    fmt.Println("t2 is after t1")
}

if t1.Before(t2) {
    fmt.Println("t1 is before t2")
}

if t1.Equal(t2) {
    fmt.Println("times are equal")
}

// Calculate duration between times
duration := t2.Sub(t1)
fmt.Printf("Time difference: %v\n", duration)
// Output: Time difference: 1.000123s

// Compare with specific threshold
if duration > 500*time.Millisecond {
    fmt.Println("More than 500ms elapsed")
}
```

**Important Note**: Use `Equal()` instead of `==` for time comparison. The `==` operator compares the internal structure, which might include monotonic clock readings and could give unexpected results.

### Time Arithmetic

You can add or subtract durations from times:

```go
now := time.Now()

// Add duration
future := now.Add(2 * time.Hour)
fmt.Println("2 hours later:", future)

// Add multiple durations
later := now.Add(1*time.Hour + 30*time.Minute + 45*time.Second)
fmt.Println("Later:", later)

// Subtract duration (add negative duration)
past := now.Add(-24 * time.Hour)
fmt.Println("24 hours ago:", past)

// Add date components
nextWeek := now.AddDate(0, 0, 7)   // Add 7 days
nextMonth := now.AddDate(0, 1, 0)  // Add 1 month
nextYear := now.AddDate(1, 0, 0)   // Add 1 year

// AddDate handles month overflow
jan31 := time.Date(2024, time.January, 31, 0, 0, 0, 0, time.UTC)
feb := jan31.AddDate(0, 1, 0)
fmt.Println(feb) // 2024-03-02 (February only has 29 days in 2024)
```

### Truncating and Rounding

You can truncate or round times to specific precision:

```go
now := time.Now()
fmt.Println("Now:", now)
// Now: 2024-01-15 14:30:45.123456789 +0000 UTC

// Truncate to hour
hourTrunc := now.Truncate(time.Hour)
fmt.Println("Truncated to hour:", hourTrunc)
// Truncated to hour: 2024-01-15 14:00:00 +0000 UTC

// Truncate to minute
minTrunc := now.Truncate(time.Minute)
fmt.Println("Truncated to minute:", minTrunc)
// Truncated to minute: 2024-01-15 14:30:00 +0000 UTC

// Round to nearest hour
hourRound := now.Round(time.Hour)
fmt.Println("Rounded to hour:", hourRound)
// Rounded to hour: 2024-01-15 15:00:00 +0000 UTC

// Round to nearest 15 minutes
round15 := now.Round(15 * time.Minute)
fmt.Println("Rounded to 15 min:", round15)
```

**Use Cases**:

- Truncate for grouping logs by hour
- Round for scheduling tasks to nearest interval
- Remove subsecond precision before storing in database

### Time Zones and Locations

Working with time zones is crucial for global applications:

```go
// Load specific timezone
utc, _ := time.LoadLocation("UTC")
est, _ := time.LoadLocation("America/New_York")
tokyo, _ := time.LoadLocation("Asia/Tokyo")
london, _ := time.LoadLocation("Europe/London")

// Create time in specific timezone
nyTime := time.Date(2024, 1, 15, 9, 0, 0, 0, est)
fmt.Println("New York:", nyTime)
// New York: 2024-01-15 09:00:00 -0500 EST

// Convert between timezones
tokyoTime := nyTime.In(tokyo)
fmt.Println("Tokyo:", tokyoTime)
// Tokyo: 2024-01-15 23:00:00 +0900 JST

londonTime := nyTime.In(london)
fmt.Println("London:", londonTime)
// London: 2024-01-15 14:00:00 +0000 GMT

// Convert to UTC
utcTime := nyTime.UTC()
fmt.Println("UTC:", utcTime)
// UTC: 2024-01-15 14:00:00 +0000 UTC

// Get timezone information
name, offset := nyTime.Zone()
fmt.Printf("Zone: %s, Offset: %d seconds\n", name, offset)
// Zone: EST, Offset: -18000 seconds (-5 hours)
```

**Important**: Time zone names are from the IANA Time Zone Database. Always use these standard names, not abbreviations like "PST" which can be ambiguous.

### Duration Type

`time.Duration` represents elapsed time as an int64 nanosecond count:

```go
// Creating durations
d1 := 5 * time.Second
d2 := 500 * time.Millisecond
d3 := 100 * time.Microsecond
d4 := 1000 * time.Nanosecond

// Duration arithmetic
total := d1 + d2
fmt.Println("Total:", total) // 5.5s

// Convert duration to different units
fmt.Println("Seconds:", d1.Seconds())       // 5.0
fmt.Println("Milliseconds:", d1.Milliseconds()) // 5000
fmt.Println("Microseconds:", d1.Microseconds()) // 5000000
fmt.Println("Nanoseconds:", d1.Nanoseconds())   // 5000000000

// Duration comparison
if d1 > d2 {
    fmt.Println("d1 is longer than d2")
}

// Parse duration from string
parsed, err := time.ParseDuration("1h30m45s")
if err == nil {
    fmt.Println("Parsed:", parsed) // 1h30m45s
}

// Complex duration
complex := time.ParseDuration("2h30m15s500ms")
// valid units: ns, us/µs, ms, s, m, h
```

---

## Timers

Timers allow you to execute code after a specific duration. Think of a timer as an alarm clock—you set it, and it goes off once after the specified time.

### Basic Timer Usage

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // Create a timer that fires after 2 seconds
    timer := time.NewTimer(2 * time.Second)
    
    fmt.Println("Timer started at:", time.Now().Format("15:04:05"))
    
    // Block until timer fires
    <-timer.C
    
    fmt.Println("Timer fired at:", time.Now().Format("15:04:05"))
}
```

**How It Works**:

```
Timeline:
─────────────────────────────────────────────────
T+0s: Create timer
T+0s: Print "Timer started"
T+0s: Block on timer.C channel
      ... waiting ...
T+2s: Timer fires, sends to timer.C channel
T+2s: Receive from timer.C, unblock
T+2s: Print "Timer fired"
```

### Timer with Select

Timers are often used with `select` for timeout patterns:

```go
func fetchDataWithTimeout(url string) error {
    // Create channels
    resultCh := make(chan string)
    errorCh := make(chan error)
    
    // Start fetching in goroutine
    go func() {
        time.Sleep(3 * time.Second) // Simulate slow network
        resultCh <- "data from " + url
    }()
    
    // Create timer
    timer := time.NewTimer(2 * time.Second)
    
    select {
    case result := <-resultCh:
        timer.Stop() // Important: stop timer if we got result
        fmt.Println("Success:", result)
        return nil
        
    case err := <-errorCh:
        timer.Stop()
        return err
        
    case <-timer.C:
        return fmt.Errorf("timeout after 2 seconds")
    }
}
```

**Pattern Explanation**:

- Start long-running operation in goroutine
- Use timer to enforce timeout
- Select waits for either result or timeout
- **Always stop unused timers** to free resources

### Timer.Stop() and Timer.Reset()

You can stop or reset timers:

```go
// Create timer
timer := time.NewTimer(5 * time.Second)

// Stop timer before it fires
stopped := timer.Stop()
if stopped {
    fmt.Println("Timer was stopped")
} else {
    fmt.Println("Timer already fired")
}

// Reset timer with new duration
timer.Reset(3 * time.Second)
fmt.Println("Timer reset to 3 seconds")

// Now it will fire after 3 seconds
<-timer.C
fmt.Println("Timer fired")
```

**Important**: After stopping a timer, you should drain the channel if the timer might have already fired:

```go
if !timer.Stop() {
    <-timer.C // Drain channel
}
```

### AfterFunc - Execute Function After Duration

`time.AfterFunc` schedules a function to run after a duration:

```go
func main() {
    fmt.Println("Start:", time.Now().Format("15:04:05"))
    
    // Schedule function to run after 2 seconds
    timer := time.AfterFunc(2*time.Second, func() {
        fmt.Println("Function executed at:", time.Now().Format("15:04:05"))
    })
    
    // You can stop it before it fires
    // timer.Stop()
    
    // Wait for function to execute
    time.Sleep(3 * time.Second)
    fmt.Println("End")
}
```

### Simple Timeout Pattern with time.After

For simple timeouts, use `time.After`:

```go
func quickTimeout() {
    select {
    case result := <-doWork():
        fmt.Println("Got result:", result)
    case <-time.After(2 * time.Second):
        fmt.Println("Timeout!")
    }
}

func doWork() <-chan string {
    ch := make(chan string)
    go func() {
        time.Sleep(1 * time.Second)
        ch <- "work done"
    }()
    return ch
}
```

**Warning**: `time.After` creates a timer that can't be stopped. For loops or frequently called functions, use `time.NewTimer` instead to avoid timer leaks:

```go
// Bad: Creates new timer every iteration
for {
    select {
    case <-time.After(1 * time.Second): // Timer leak!
        // process
    }
}

// Good: Reuse timer
timer := time.NewTimer(1 * time.Second)
for {
    select {
    case <-timer.C:
        // process
        timer.Reset(1 * time.Second)
    }
}
```

### Real-World Timer Patterns

**Rate Limiting with Token Bucket**:

```go
type RateLimiter struct {
    rate     time.Duration
    lastCall time.Time
}

func (r *RateLimiter) Allow() bool {
    now := time.Now()
    if now.Sub(r.lastCall) < r.rate {
        return false
    }
    r.lastCall = now
    return true
}

func (r *RateLimiter) Wait() {
    elapsed := time.Since(r.lastCall)
    if elapsed < r.rate {
        time.Sleep(r.rate - elapsed)
    }
    r.lastCall = time.Now()
}
```

**Timeout with Context**:

```go
import "context"

func doWorkWithContext(ctx context.Context) error {
    // Create timeout context
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()
    
    select {
    case result := <-heavyWork():
        fmt.Println("Result:", result)
        return nil
    case <-ctx.Done():
        return ctx.Err() // Returns context.DeadlineExceeded
    }
}
```

---

## Tickers

While timers fire once, tickers fire repeatedly at regular intervals. Think of a ticker as a metronome—it ticks at a steady pace.

### Basic Ticker Usage

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // Create ticker that ticks every second
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop() // Always stop tickers when done
    
    count := 0
    for {
        <-ticker.C // Block until tick
        count++
        fmt.Printf("Tick %d at %s\n", count, time.Now().Format("15:04:05"))
        
        if count >= 5 {
            break
        }
    }
}
```

**Output**:

```
Tick 1 at 14:30:01
Tick 2 at 14:30:02
Tick 3 at 14:30:03
Tick 4 at 14:30:04
Tick 5 at 14:30:05
```

### Ticker with Select

Tickers work great with `select` for concurrent patterns:

```go
func periodicTask() {
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()
    
    done := make(chan bool)
    
    go func() {
        time.Sleep(20 * time.Second)
        done <- true
    }()
    
    for {
        select {
        case <-ticker.C:
            fmt.Println("Performing periodic task...")
            // Do work here
            
        case <-done:
            fmt.Println("Done!")
            return
        }
    }
}
```

### Multiple Tickers

You can use multiple tickers for different periodic tasks:

```go
func multipleTimers() {
    fastTicker := time.NewTicker(1 * time.Second)
    slowTicker := time.NewTicker(5 * time.Second)
    defer fastTicker.Stop()
    defer slowTicker.Stop()
    
    for {
        select {
        case <-fastTicker.C:
            fmt.Println("Fast tick")
            
        case <-slowTicker.C:
            fmt.Println("Slow tick")
        }
    }
}
```

### Ticker.Reset

You can change a ticker's interval:

```go
ticker := time.NewTicker(1 * time.Second)
defer ticker.Stop()

// After 5 ticks, speed up
count := 0
for range ticker.C {
    count++
    fmt.Println("Tick", count)
    
    if count == 5 {
        ticker.Reset(500 * time.Millisecond)
        fmt.Println("Ticker speed doubled")
    }
    
    if count == 10 {
        break
    }
}
```

### Simple Ticker with time.Tick

For simple cases, use `time.Tick`:

```go
func simpleTicker() {
    for range time.Tick(2 * time.Second) {
        fmt.Println("Tick at", time.Now().Format("15:04:05"))
        // Be careful: this ticker can't be stopped!
    }
}
```

**Warning**: `time.Tick` creates a ticker that can never be stopped, leading to goroutine leaks. Use it only for programs that run forever.

### Real-World Ticker Patterns

**Periodic Health Check**:

```go
type HealthChecker struct {
    url      string
    interval time.Duration
    ticker   *time.Ticker
    stopCh   chan struct{}
}

func NewHealthChecker(url string, interval time.Duration) *HealthChecker {
    return &HealthChecker{
        url:      url,
        interval: interval,
        stopCh:   make(chan struct{}),
    }
}

func (h *HealthChecker) Start() {
    h.ticker = time.NewTicker(h.interval)
    
    go func() {
        for {
            select {
            case <-h.ticker.C:
                h.check()
            case <-h.stopCh:
                return
            }
        }
    }()
}

func (h *HealthChecker) check() {
    // Perform health check
    fmt.Printf("[%s] Checking %s\n", 
        time.Now().Format("15:04:05"), h.url)
}

func (h *HealthChecker) Stop() {
    h.ticker.Stop()
    close(h.stopCh)
}
```

**Metrics Collection**:

```go
type MetricsCollector struct {
    interval time.Duration
    metrics  map[string]int64
    mu       sync.Mutex
}

func (m *MetricsCollector) Start() {
    ticker := time.NewTicker(m.interval)
    go func() {
        for range ticker.C {
            m.collect()
        }
    }()
}

func (m *MetricsCollector) collect() {
    m.mu.Lock()
    defer m.mu.Unlock()
    
    fmt.Printf("[%s] Metrics: %+v\n", 
        time.Now().Format("15:04:05"), m.metrics)
}
```

**Rate-Limited Worker**:

```go
func rateLimitedWorker(jobs <-chan Job, rate time.Duration) {
    ticker := time.NewTicker(rate)
    defer ticker.Stop()
    
    for job := range jobs {
        <-ticker.C // Wait for tick before processing
        processJob(job)
    }
}
```

### Ticker vs Timer Comparison

```
Timer (time.NewTimer):
─────────────────────────────────────
Create → Wait → Fire (ONCE) → Stop
         2s     ↓
                Event

Ticker (time.NewTicker):
─────────────────────────────────────
Create → Tick → Tick → Tick → Stop
         1s     1s     1s
         ↓      ↓      ↓
        Event  Event  Event

Use Timer when: One-time delay, timeout
Use Ticker when: Repeated intervals, polling
```

---

## Epoch Time

Epoch time (also called Unix time) represents time as the number of seconds (or other units) since January 1, 1970 00:00:00 UTC. This is crucial for storing times in databases, APIs, and cross-platform communication.

### Understanding Epoch

```
Epoch (Unix Timestamp):
═══════════════════════════════════════════════
                January 1, 1970 00:00:00 UTC
                         ↓
                      Epoch 0
                         ↓
Time moves forward ──────┼──────→
                    +1s, +2s, +3s...
                         ↓
           Current: 1705329000 seconds
                         ↓
            December 25, 2024 12:00:00 UTC
```

### Getting Epoch Time

```go
now := time.Now()

// Unix timestamp (seconds since epoch)
seconds := now.Unix()
fmt.Println("Seconds:", seconds)
// Output: 1705329000

// Milliseconds since epoch
millis := now.UnixMilli()
fmt.Println("Milliseconds:", millis)
// Output: 1705329000123

// Microseconds since epoch
micros := now.UnixMicro()
fmt.Println("Microseconds:", micros)
// Output: 1705329000123456

// Nanoseconds since epoch
nanos := now.UnixNano()
fmt.Println("Nanoseconds:", nanos)
// Output: 1705329000123456789
```

### Converting Epoch to Time

```go
// From seconds
timestamp := int64(1705329000)
t := time.Unix(timestamp, 0)
fmt.Println(t)
// Output: 2024-12-25 12:00:00 +0000 UTC

// From seconds and nanoseconds
t2 := time.Unix(1705329000, 123456789)
fmt.Println(t2)
// Output: 2024-12-25 12:00:00.123456789 +0000 UTC

// From milliseconds
millisTimestamp := int64(1705329000123)
t3 := time.UnixMilli(millisTimestamp)
fmt.Println(t3)

// From microseconds
microsTimestamp := int64(1705329000123456)
t4 := time.UnixMicro(microsTimestamp)
fmt.Println(t4)
```

### Why Use Epoch Time?

**Storage Efficiency**: Storing an integer is more efficient than storing a formatted string:

```
Formatted: "2024-12-25T12:00:00Z" (20+ bytes)
Epoch:     1705329000              (8 bytes as int64)
```

**Time Zone Independence**: Epoch is always UTC, avoiding timezone confusion:

```go
// These are the same moment
nyTime := time.Date(2024, 12, 25, 7, 0, 0, 0, 
    time.FixedZone("EST", -5*3600))
utcTime := time.Date(2024, 12, 25, 12, 0, 0, 0, time.UTC)

fmt.Println(nyTime.Unix())  // 1705329000
fmt.Println(utcTime.Unix()) // 1705329000  (same!)
```

**Easy Arithmetic**: Calculate durations by simple subtraction:

```go
start := time.Now().Unix()
// ... do work ...
end := time.Now().Unix()
duration := end - start  // Duration in seconds
```

### Common Epoch Pitfalls

**Pitfall 1: Milliseconds vs Seconds Confusion**

```go
// JavaScript timestamp (milliseconds)
jsTimestamp := 1705329000123

// Wrong: treats as seconds
wrong := time.Unix(jsTimestamp, 0)
fmt.Println(wrong) // Year 56000+  (way in future!)

// Correct: convert to seconds
correct := time.UnixMilli(jsTimestamp)
fmt.Println(correct) // 2024-12-25...
```

**Pitfall 2: Losing Precision**

```go
now := time.Now()

// Loses subsecond precision
seconds := now.Unix()
reconstructed := time.Unix(seconds, 0)

fmt.Println("Original:", now)
// 2024-12-25 12:00:00.123456789 +0000 UTC

fmt.Println("After round-trip:", reconstructed)
// 2024-12-25 12:00:00 +0000 UTC

// Use nanoseconds for full precision
nanos := now.UnixNano()
fullPrecision := time.Unix(0, nanos)
fmt.Println("Full precision:", fullPrecision)
```

**Pitfall 3: Year 2038 Problem (32-bit systems)**

```go
// On 32-bit systems, int32 overflows on Jan 19, 2038
// January 19, 2038, 03:14:07 UTC = 2^31 - 1 seconds

maxInt32 := int64(2147483647)
y2038 := time.Unix(maxInt32, 0)
fmt.Println("Max 32-bit timestamp:", y2038)
// 2038-01-19 03:14:07 +0000 UTC

// Always use int64 for timestamps!
```

### Working with Epoch in Different Languages

```go
// Go to JavaScript timestamp
goTime := time.Now()
jsTimestamp := goTime.UnixMilli()
fmt.Printf("JavaScript: %d\n", jsTimestamp)

// Python timestamp (seconds with decimal)
pyTimestamp := float64(goTime.UnixNano()) / 1e9
fmt.Printf("Python: %.6f\n", pyTimestamp)

// Java timestamp (milliseconds)
javaTimestamp := goTime.UnixMilli()
fmt.Printf("Java: %d\n", javaTimestamp)
```

---

## Time Formatting and Parsing

Time formatting and parsing in Go is unique compared to other languages. Instead of using format codes like `%Y-%m-%d`, Go uses a reference time: **January 2, 2006, 15:04:05 MST** (which can be remembered as 01/02 03:04:05PM '06 -0700).

### The Magic Reference Time

```
The Go Reference Time:
══════════════════════════════════════
Mon Jan 2 15:04:05 MST 2006

Think of it as: 1 2 3 4 5 6 7
                │ │ │ │ │ │ └─ Timezone
                │ │ │ │ │ └─ Year
                │ │ │ │ └─ Seconds
                │ │ │ └─ Minutes
                │ │ └─ Hours (24-hour)
                │ └─ Day
                └─ Month

To format: Replace each component with what you want
```

### Basic Formatting

```go
now := time.Now()

// Common formats
fmt.Println(now.Format("2006-01-02"))
// Output: 2024-12-25

fmt.Println(now.Format("2006-01-02 15:04:05"))
// Output: 2024-12-25 14:30:45

fmt.Println(now.Format("01/02/2006"))
// Output: 12/25/2024

fmt.Println(now.Format("Jan 2, 2006"))
// Output: Dec 25, 2024

fmt.Println(now.Format("Monday, January 2,fmt.Println(now.Format("Monday, January 2, 2006")) // Output: Tuesday, December 25, 2024

fmt.Println(now.Format("3:04 PM")) // Output: 2:30 PM

fmt.Println(now.Format("15:04:05")) // Output: 14:30:45

````

### Predefined Format Constants

Go provides several predefined format constants:

```go
now := time.Now()

// RFC3339: ISO 8601 standard
fmt.Println(now.Format(time.RFC3339))
// 2024-12-25T14:30:45Z

// RFC3339Nano: with nanoseconds
fmt.Println(now.Format(time.RFC3339Nano))
// 2024-12-25T14:30:45.123456789Z

// RFC822: email headers
fmt.Println(now.Format(time.RFC822))
// 25 Dec 24 14:30 UTC

// RFC1123: HTTP headers
fmt.Println(now.Format(time.RFC1123))
// Tue, 25 Dec 2024 14:30:45 UTC

// Kitchen: simple time
fmt.Println(now.Format(time.Kitchen))
// 2:30PM

// ANSIC: ANSI C format
fmt.Println(now.Format(time.ANSIC))
// Tue Dec 25 14:30:45 2024

// Unix date
fmt.Println(now.Format(time.UnixDate))
// Tue Dec 25 14:30:45 UTC 2024

// Stamp formats
fmt.Println(now.Format(time.Stamp))
// Dec 25 14:30:45

fmt.Println(now.Format(time.StampMilli))
// Dec 25 14:30:45.123

fmt.Println(now.Format(time.StampMicro))
// Dec 25 14:30:45.123456

fmt.Println(now.Format(time.StampNano))
// Dec 25 14:30:45.123456789
````

### Custom Format Patterns

Build custom formats using the reference time components:

```go
now := time.Now()

// Date formats
fmt.Println(now.Format("2006-01-02"))           // 2024-12-25 (ISO date)
fmt.Println(now.Format("02/01/2006"))           // 25/12/2024 (European)
fmt.Println(now.Format("01/02/2006"))           // 12/25/2024 (American)
fmt.Println(now.Format("2006/01/02"))           // 2024/12/25 (Japanese)
fmt.Println(now.Format("Jan 02, 2006"))         // Dec 25, 2024
fmt.Println(now.Format("January 2, 2006"))      // December 25, 2024
fmt.Println(now.Format("Monday, Jan 2, 2006"))  // Tuesday, Dec 25, 2024

// Time formats
fmt.Println(now.Format("15:04"))                // 14:30 (24-hour)
fmt.Println(now.Format("3:04 PM"))              // 2:30 PM (12-hour)
fmt.Println(now.Format("03:04:05 PM"))          // 02:30:45 PM
fmt.Println(now.Format("15:04:05"))             // 14:30:45
fmt.Println(now.Format("15:04:05.000"))         // 14:30:45.123 (milliseconds)
fmt.Println(now.Format("15:04:05.000000"))      // 14:30:45.123456 (microseconds)
fmt.Println(now.Format("15:04:05.000000000"))   // 14:30:45.123456789 (nanoseconds)

// Combined formats
fmt.Println(now.Format("2006-01-02 15:04:05"))
// 2024-12-25 14:30:45

fmt.Println(now.Format("Mon, 02 Jan 2006 15:04:05 MST"))
// Tue, 25 Dec 2024 14:30:45 UTC

// With timezone
fmt.Println(now.Format("2006-01-02 15:04:05 MST"))
// 2024-12-25 14:30:45 UTC

fmt.Println(now.Format("2006-01-02 15:04:05 -0700"))
// 2024-12-25 14:30:45 +0000

// Custom separators
fmt.Println(now.Format("2006.01.02"))           // 2024.12.25
fmt.Println(now.Format("2006_01_02_15_04_05"))  // 2024_12_25_14_30_45
fmt.Println(now.Format("20060102"))             // 20241225 (compact)
```

### Format Reference Guide

Here's a comprehensive reference for all format components:

```
Year:
  2006  → 2024 (4-digit year)
  06    → 24   (2-digit year)

Month:
  01    → 12   (2-digit numeric)
  1     → 12   (1 or 2-digit numeric)
  Jan   → Dec  (3-letter abbreviation)
  January → December (full name)

Day:
  02    → 25   (2-digit day)
  2     → 25   (1 or 2-digit day)
  _2    → 25   (space-padded)

Weekday:
  Mon   → Tue  (3-letter abbreviation)
  Monday → Tuesday (full name)

Hour:
  15    → 14   (24-hour format, 2-digit)
  3     → 2    (12-hour format, 1 or 2-digit)
  03    → 02   (12-hour format, 2-digit)

Minute:
  04    → 30   (2-digit minute)
  4     → 30   (1 or 2-digit minute)

Second:
  05    → 45   (2-digit second)
  5     → 45   (1 or 2-digit second)

Subseconds:
  .000  → .123 (milliseconds)
  .000000 → .123456 (microseconds)
  .000000000 → .123456789 (nanoseconds)
  .999999999 → trailing zeros removed

AM/PM:
  PM    → PM   (uppercase)
  pm    → pm   (lowercase)

Timezone:
  MST   → UTC  (3-letter abbreviation)
  -0700 → +0000 (numeric offset)
  -07:00 → +00:00 (numeric offset with colon)
  Z0700 → Z or +0000 (RFC3339 style)
  Z07:00 → Z or +00:00 (RFC3339 style)
```

### Parsing Time Strings

Parse strings into `time.Time` using the same format patterns:

```go
// Basic parsing
timeStr := "2024-12-25 14:30:45"
t, err := time.Parse("2006-01-02 15:04:05", timeStr)
if err != nil {
    fmt.Println("Parse error:", err)
}
fmt.Println("Parsed:", t)

// Parse different formats
examples := map[string]string{
    "2024-12-25":                 "2006-01-02",
    "12/25/2024":                 "01/02/2006",
    "Dec 25, 2024":               "Jan 2, 2006",
    "25 December 2024":           "2 January 2006",
    "2024-12-25T14:30:45Z":       time.RFC3339,
    "Tue, 25 Dec 2024 14:30:45 UTC": time.RFC1123,
}

for timeStr, layout := range examples {
    t, err := time.Parse(layout, timeStr)
    if err != nil {
        fmt.Printf("Error parsing %s: %v\n", timeStr, err)
    } else {
        fmt.Printf("Parsed %s → %v\n", timeStr, t)
    }
}
```

### ParseInLocation - Parse with Timezone

By default, `Parse` interprets times as UTC. Use `ParseInLocation` to parse in a specific timezone:

```go
// Parse time as UTC (default)
utcTime, _ := time.Parse("2006-01-02 15:04:05", "2024-12-25 14:30:45")
fmt.Println("UTC:", utcTime)
// UTC: 2024-12-25 14:30:45 +0000 UTC

// Parse time as New York time
loc, _ := time.LoadLocation("America/New_York")
nyTime, _ := time.ParseInLocation("2006-01-02 15:04:05", 
    "2024-12-25 14:30:45", loc)
fmt.Println("NY:", nyTime)
// NY: 2024-12-25 14:30:45 -0500 EST

// Parse time as local timezone
localTime, _ := time.ParseInLocation("2006-01-02 15:04:05",
    "2024-12-25 14:30:45", time.Local)
fmt.Println("Local:", localTime)
```

### Common Parsing Errors

```go
// Error: wrong format
_, err := time.Parse("2006-01-02", "2024/12/25")
fmt.Println(err)
// parsing time "2024/12/25" as "2006-01-02": cannot parse "/12/25" as "-"

// Error: invalid date
_, err = time.Parse("2006-01-02", "2024-13-45")
fmt.Println(err)
// parsing time "2024-13-45": month out of range

// Error: missing timezone in format
_, err = time.Parse("2006-01-02 15:04:05", "2024-12-25 14:30:45 UTC")
fmt.Println(err)
// parsing time "2024-12-25 14:30:45 UTC" as "2006-01-02 15:04:05": 
// cannot parse " UTC" as ""

// Correct: include timezone in format
t, err := time.Parse("2006-01-02 15:04:05 MST", "2024-12-25 14:30:45 UTC")
fmt.Println("Success:", t)
```

### Flexible Parsing with Multiple Formats

Try multiple formats when the input format is uncertain:

```go
func parseFlexible(timeStr string) (time.Time, error) {
    formats := []string{
        time.RFC3339,
        time.RFC3339Nano,
        "2006-01-02 15:04:05",
        "2006-01-02T15:04:05",
        "2006-01-02",
        "01/02/2006",
        "02-Jan-2006",
        "January 2, 2006",
    }
    
    for _, format := range formats {
        t, err := time.Parse(format, timeStr)
        if err == nil {
            return t, nil
        }
    }
    
    return time.Time{}, fmt.Errorf("unable to parse: %s", timeStr)
}

// Test
examples := []string{
    "2024-12-25T14:30:45Z",
    "2024-12-25 14:30:45",
    "12/25/2024",
    "December 25, 2024",
}

for _, example := range examples {
    t, err := parseFlexible(example)
    if err != nil {
        fmt.Printf("Failed: %s\n", example)
    } else {
        fmt.Printf("Parsed: %s → %v\n", example, t)
    }
}
```

---

## Time Conversion and Manipulation

In real-world applications, you constantly need to convert between time zones, formats, and representations. Let's explore comprehensive time conversion techniques.

### Timezone Conversions

Converting between different time zones is essential for global applications:

```go
// Create time in one timezone
nyLoc, _ := time.LoadLocation("America/New_York")
nyTime := time.Date(2024, 12, 25, 9, 0, 0, 0, nyLoc)
fmt.Println("New York:", nyTime)
// New York: 2024-12-25 09:00:00 -0500 EST

// Convert to different timezones
tokyoLoc, _ := time.LoadLocation("Asia/Tokyo")
tokyoTime := nyTime.In(tokyoLoc)
fmt.Println("Tokyo:", tokyoTime)
// Tokyo: 2024-12-25 23:00:00 +0900 JST

londonLoc, _ := time.LoadLocation("Europe/London")
londonTime := nyTime.In(londonLoc)
fmt.Println("London:", londonTime)
// London: 2024-12-25 14:00:00 +0000 GMT

// Convert to UTC
utcTime := nyTime.UTC()
fmt.Println("UTC:", utcTime)
// UTC: 2024-12-25 14:00:00 +0000 UTC

// All represent the same moment
fmt.Println("\nAll Unix timestamps equal:")
fmt.Println("NY:", nyTime.Unix())
fmt.Println("Tokyo:", tokyoTime.Unix())
fmt.Println("London:", londonTime.Unix())
fmt.Println("UTC:", utcTime.Unix())
// All print: 1735132800
```

### Understanding Timezone Offsets

```go
t := time.Now()

// Get timezone name and offset
name, offset := t.Zone()
fmt.Printf("Timezone: %s\n", name)
fmt.Printf("Offset: %d seconds (%d hours)\n", offset, offset/3600)

// Offset examples:
// UTC:    name="UTC",  offset=0
// EST:    name="EST",  offset=-18000  (-5 hours)
// JST:    name="JST",  offset=32400   (+9 hours)
// PST:    name="PST",  offset=-28800  (-8 hours)
```

### Creating Fixed Offset Timezones

For APIs that use fixed offsets without daylight saving:

```go
// Create fixed offset timezone (+5:30 for India)
ist := time.FixedZone("IST", 5*3600+30*60)
indiaTime := time.Date(2024, 12, 25, 19, 30, 0, 0, ist)
fmt.Println("India:", indiaTime)
// India: 2024-12-25 19:30:00 +0530 IST

// Convert to UTC
utcTime := indiaTime.UTC()
fmt.Println("UTC:", utcTime)
// UTC: 2024-12-25 14:00:00 +0000 UTC

// Negative offset (Western hemisphere)
est := time.FixedZone("EST", -5*3600)
estTime := time.Date(2024, 12, 25, 9, 0, 0, 0, est)
fmt.Println("EST:", estTime)
// EST: 2024-12-25 09:00:00 -0500 EST
```

### Date Calculations

Calculate dates relative to a given time:

```go
now := time.Now()

// Add days
tomorrow := now.AddDate(0, 0, 1)
nextWeek := now.AddDate(0, 0, 7)
yesterday := now.AddDate(0, 0, -1)

fmt.Println("Today:", now.Format("2006-01-02"))
fmt.Println("Tomorrow:", tomorrow.Format("2006-01-02"))
fmt.Println("Next week:", nextWeek.Format("2006-01-02"))
fmt.Println("Yesterday:", yesterday.Format("2006-01-02"))

// Add months
nextMonth := now.AddDate(0, 1, 0)
lastMonth := now.AddDate(0, -1, 0)
threeMonthsLater := now.AddDate(0, 3, 0)

// Add years
nextYear := now.AddDate(1, 0, 0)
lastYear := now.AddDate(-1, 0, 0)

// Complex date arithmetic
futureDate := now.AddDate(1, 2, 15)  // 1 year, 2 months, 15 days
fmt.Println("Future:", futureDate.Format("2006-01-02"))
```

### Time of Day Operations

Work with specific times of day:

```go
now := time.Now()

// Get start of day (midnight)
startOfDay := time.Date(now.Year(), now.Month(), now.Day(), 
    0, 0, 0, 0, now.Location())
fmt.Println("Start of day:", startOfDay)
// 2024-12-25 00:00:00

// Get end of day (23:59:59.999999999)
endOfDay := time.Date(now.Year(), now.Month(), now.Day(), 
    23, 59, 59, 999999999, now.Location())
fmt.Println("End of day:", endOfDay)
// 2024-12-25 23:59:59.999999999

// Noon
noon := time.Date(now.Year(), now.Month(), now.Day(), 
    12, 0, 0, 0, now.Location())
fmt.Println("Noon:", noon)

// Check if time is within today
isToday := func(t time.Time) bool {
    return t.After(startOfDay) && t.Before(endOfDay)
}
```

### Week Calculations

Work with weeks and weekdays:

```go
now := time.Now()

// Get current weekday
weekday := now.Weekday()
fmt.Println("Today is:", weekday)  // Tuesday

// Days until next Monday
daysUntilMonday := (7 - int(weekday) + int(time.Monday)) % 7
if daysUntilMonday == 0 {
    daysUntilMonday = 7  // Next week's Monday
}
nextMonday := now.AddDate(0, 0, daysUntilMonday)
fmt.Println("Next Monday:", nextMonday.Format("2006-01-02"))

// Get start of week (Sunday)
daysFromSunday := int(weekday)
startOfWeek := now.AddDate(0, 0, -daysFromSunday)
startOfWeek = time.Date(startOfWeek.Year(), startOfWeek.Month(), 
    startOfWeek.Day(), 0, 0, 0, 0, now.Location())
fmt.Println("Start of week:", startOfWeek.Format("2006-01-02"))

// Get end of week (Saturday)
daysToSaturday := 6 - int(weekday)
endOfWeek := now.AddDate(0, 0, daysToSaturday)
endOfWeek = time.Date(endOfWeek.Year(), endOfWeek.Month(), 
    endOfWeek.Day(), 23, 59, 59, 999999999, now.Location())
fmt.Println("End of week:", endOfWeek.Format("2006-01-02"))

// Is weekend?
isWeekend := weekday == time.Saturday || weekday == time.Sunday
fmt.Println("Is weekend:", isWeekend)
```

### Month Calculations

```go
now := time.Now()

// First day of current month
firstDay := time.Date(now.Year(), now.Month(), 1, 
    0, 0, 0, 0, now.Location())
fmt.Println("First day of month:", firstDay.Format("2006-01-02"))

// Last day of current month
nextMonth := now.AddDate(0, 1, 0)
lastDay := time.Date(nextMonth.Year(), nextMonth.Month(), 1, 
    0, 0, 0, 0, now.Location()).AddDate(0, 0, -1)
fmt.Println("Last day of month:", lastDay.Format("2006-01-02"))

// Number of days in month
daysInMonth := lastDay.Day()
fmt.Println("Days in month:", daysInMonth)

// Is last day of month?
isLastDay := now.Day() == daysInMonth
fmt.Println("Is last day:", isLastDay)
```

### Quarter Calculations

```go
// Get quarter from month
getQuarter := func(m time.Month) int {
    return int((m-1)/3) + 1
}

// Get first day of quarter
getQuarterStart := func(t time.Time) time.Time {
    quarter := getQuarter(t.Month())
    month := time.Month((quarter-1)*3 + 1)
    return time.Date(t.Year(), month, 1, 0, 0, 0, 0, t.Location())
}

// Get last day of quarter
getQuarterEnd := func(t time.Time) time.Time {
    quarter := getQuarter(t.Month())
    month := time.Month(quarter * 3)
    // Get first day of next quarter, then subtract one day
    nextQuarter := time.Date(t.Year(), month+1, 1, 
        0, 0, 0, 0, t.Location())
    return nextQuarter.AddDate(0, 0, -1)
}

now := time.Now()
quarter := getQuarter(now.Month())
quarterStart := getQuarterStart(now)
quarterEnd := getQuarterEnd(now)

fmt.Printf("Current quarter: Q%d\n", quarter)
fmt.Println("Quarter start:", quarterStart.Format("2006-01-02"))
fmt.Println("Quarter end:", quarterEnd.Format("2006-01-02"))
```

### Business Days Calculation

Skip weekends when calculating business days:

```go
func addBusinessDays(start time.Time, days int) time.Time {
    current := start
    remaining := days
    
    for remaining > 0 {
        current = current.AddDate(0, 0, 1)
        // Skip weekends
        if current.Weekday() != time.Saturday && 
           current.Weekday() != time.Sunday {
            remaining--
        }
    }
    
    return current
}

func countBusinessDays(start, end time.Time) int {
    count := 0
    current := start
    
    for current.Before(end) || current.Equal(end) {
        if current.Weekday() != time.Saturday && 
           current.Weekday() != time.Sunday {
            count++
        }
        current = current.AddDate(0, 0, 1)
    }
    
    return count
}

// Usage
now := time.Now()
future := addBusinessDays(now, 10)
fmt.Printf("10 business days from now: %s\n", 
    future.Format("2006-01-02"))

bizDays := countBusinessDays(now, future)
fmt.Printf("Business days between: %d\n", bizDays)
```

### Age Calculation

Calculate age accurately:

```go
func calculateAge(birthDate time.Time) int {
    now := time.Now()
    
    age := now.Year() - birthDate.Year()
    
    // Adjust if birthday hasn't occurred this year
    if now.Month() < birthDate.Month() ||
       (now.Month() == birthDate.Month() && now.Day() < birthDate.Day()) {
        age--
    }
    
    return age
}

// Usage
birthDate := time.Date(1990, 5, 15, 0, 0, 0, 0, time.UTC)
age := calculateAge(birthDate)
fmt.Printf("Age: %d years\n", age)

// Days until next birthday
func daysUntilBirthday(birthDate time.Time) int {
    now := time.Now()
    thisYearBirthday := time.Date(now.Year(), birthDate.Month(), 
        birthDate.Day(), 0, 0, 0, 0, now.Location())
    
    if thisYearBirthday.Before(now) {
        // Birthday already passed this year
        thisYearBirthday = thisYearBirthday.AddDate(1, 0, 0)
    }
    
    duration := thisYearBirthday.Sub(now)
    return int(duration.Hours() / 24)
}

days := daysUntilBirthday(birthDate)
fmt.Printf("Days until birthday: %d\n", days)
```

---

## Time in Backend Systems

Time handling is critical in backend systems. Poor time management leads to bugs, data inconsistencies, and security vulnerabilities. Let's explore best practices for production systems.

### Always Store Times in UTC

**Why UTC**: Universal Time Coordinated (UTC) is the global time standard. Storing times in UTC prevents timezone-related bugs and makes data portable.

```go
// GOOD: Store in UTC
func saveUser(db *sql.DB, user User) error {
    user.CreatedAt = time.Now().UTC()
    user.UpdatedAt = time.Now().UTC()
    
    _, err := db.Exec(
        "INSERT INTO users (name, created_at, updated_at) VALUES (?, ?, ?)",
        user.Name, user.CreatedAt, user.UpdatedAt,
    )
    return err
}

// BAD: Store in local timezone
func saveUserBad(db *sql.DB, user User) error {
    user.CreatedAt = time.Now()  // Uses system timezone!
    // If server moves or timezone changes, data is inconsistent
    return nil
}
```

**Database Schema**:

```sql
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(255),
    created_at TIMESTAMP,  -- Always store as UTC
    updated_at TIMESTAMP
);
```

### Converting for Display

Convert to user's timezone only for display:

```go
type UserResponse struct {
    Name      string `json:"name"`
    CreatedAt string `json:"created_at"`
}

func getUserResponse(user User, userTimezone string) UserResponse {
    // Load user's timezone
    loc, err := time.LoadLocation(userTimezone)
    if err != nil {
        loc = time.UTC  // Fallback to UTC
    }
    
    // Convert UTC time to user's timezone for display
    localTime := user.CreatedAt.In(loc)
    
    return UserResponse{
        Name:      user.Name,
        CreatedAt: localTime.Format(time.RFC3339),
    }
}
```

### API Time Handling

**Best Practice**: Use ISO 8601 (RFC3339) format in APIs:

```go
type APIRequest struct {
    StartDate time.Time `json:"start_date"`
    EndDate   time.Time `json:"end_date"`
}

// Unmarshal handles RFC3339 automatically
func handleRequest(w http.ResponseWriter, r *http.Request) {
    var req APIRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    // req.StartDate and req.EndDate are parsed automatically
    fmt.Printf("Start: %v\n", req.StartDate)
    fmt.Printf("End: %v\n", req.EndDate)
}

// Response
type APIResponse struct {
    Data      interface{} `json:"data"`
    Timestamp time.Time   `json:"timestamp"`
}

func sendResponse(w http.ResponseWriter, data interface{}) {
    response := APIResponse{
        Data:      data,
        Timestamp: time.Now().UTC(),
    }
    
    // Marshals to RFC3339 automatically
    json.NewEncoder(w).Encode(response)
    // {"data": ..., "timestamp": "2024-12-25T14:30:45Z"}
}
```

### Custom JSON Time Format

If you need a different format:

```go
type CustomTime struct {
    time.Time
}

func (ct CustomTime) MarshalJSON() ([]byte, error) {
    formatted := ct.Time.Format("2006-01-02 15:04:05")
    return json.Marshal(formatted)
}

func (ct *CustomTime) UnmarshalJSON(data []byte) error {
    var timeStr string
    if err := json.Unmarshal(data, &timeStr); err != nil {
        return err
    }
    
    parsed, err := time.Parse("2006-01-02 15:04:05", timeStr)
    if err != nil {
        return err
    }
    
    ct.Time = parsed
    return nil
}

type Event struct {
    Name      string     `json:"name"`
    OccurredAt CustomTime `json:"occurred_at"`
}
```

### Database Time Handling

Different databases handle time differently:

```go
// PostgreSQL with timezone
func saveToPostgres(db *sql.DB) error {
    now := time.Now().UTC()
    
    // PostgreSQL stores TIMESTAMP WITH TIME ZONE in UTC
    _, err := db.Exec(
        "INSERT INTO events (name, occurred_at) VALUES ($1, $2)",
        "user_login", now,
    )
    return err
}

// MySQL
func saveToMySQL(db *sql.DB) error {
    now := time.Now().UTC()
    
    // MySQL DATETIME doesn't store timezone info
    // ALWAYS convert to UTC before storing
    _, err := db.Exec(
        "INSERT INTO events (name, occurred_at) VALUES (?, ?)",
        "user_login", now.Format("2006-01-02 15:04:05"),
    )
    return err
}

// Reading from database
func readFromDB(db *sql.DB) (time.Time, error) {
    var occurredAt time.Time
    
    err := db.QueryRow("SELECT occurred_at FROM events WHERE id = ?", 1).
        Scan(&occurredAt)
    
    // IMPORTANT: If database doesn't store timezone,
    // assume UTC and set explicitly
    if occurredAt.Location() == time.Local {
        occurredAt = time.Date(
            occurredAt.Year(), occurredAt.Month(), occurredAt.Day(),
            occurredAt.Hour(), occurredAt.Minute(), occurredAt.Second(),
            occurredAt.Nanosecond(), time.UTC,
        )
    }
    
    return occurredAt, err
}
```

### Time-Based Data Partitioning

For large datasets, partition by time:

```go
// Generate table name based on date
func getTableName(t time.Time) string {
    return fmt.Sprintf("events_%s", t.Format("200601"))  // events_202412
}

func insertEvent(db *sql.DB, event Event) error {
    tableName := getTableName(event.OccurredAt)
    
    query := fmt.Sprintf(
        "INSERT INTO %s (name, occurred_at) VALUES (?, ?)",
        tableName,
    )
    
    _, err := db.Exec(query, event.Name, event.OccurredAt)
    return err
}

// Query across multiple partitions
func queryDateRange(db *sql.DB, start, end time.Time) ([]Event, error) {
    var events []Event
    
    // Generate list of tables to query
    current := time.Date(start.Year(), start.Month(), 1, 
        0, 0, 0, 0, time.UTC)
    endMonth := time.Date(end.Year(), end.Month(), 1, 
        0, 0, 0, 0, time.UTC)
    
    for !current.After(endMonth) {
        tableName := getTableName(current)
        
        query := fmt.Sprintf(
            "SELECT name, occurred_at FROM# A Comprehensive Guide to Go Time Operations

## Table of Contents
1. [Introduction to Time in Go](#introduction-to-time-in-go)
2. [Working with Time](#working-with-time)
3. [Timers](#timers)
4. [Tickers](#tickers)
5. [Epoch Time](#epoch-time)
6. [Time Formatting and Parsing](#time-formatting-and-parsing)
7. [Time Conversion and Manipulation](#time-conversion-and-manipulation)
8. [Time in Backend Systems](#time-in-backend-systems)
9. [Real-World Examples](#real-world-examples)

---

## Introduction to Time in Go

Time is one of the most critical aspects of any software system. Whether you're logging events, scheduling tasks, measuring performance, or coordinating distributed systems, understanding how to work with time correctly is essential. Go's `time` package provides a comprehensive and well-designed API for handling all time-related operations.

### The Importance of Time in Software

Imagine you're building an e-commerce platform. You need to track when orders are placed, schedule promotional campaigns, handle different time zones for international customers, measure API response times, and expire user sessions. Every one of these scenarios requires precise time handling.

### Go's Time Philosophy

Go treats time as a combination of two components:
1. **Wall Clock Time**: The time you'd see on a wall clock (e.g., 2:30 PM)
2. **Monotonic Time**: A steadily increasing clock that's not affected by system clock changes

This dual nature protects you from issues like clock adjustments, daylight saving time changes, or NTP synchronization affecting your duration measurements.

```

Time Representation in Go:

┌─────────────────────────────────────────────────┐ │ time.Time │ ├─────────────────────────────────────────────────┤ │ Wall Clock: 2024-01-15 14:30:00 UTC │ │ Monotonic: +123456789 (nanoseconds) │ │ Location: *time.Location (UTC/Local/etc) │ └─────────────────────────────────────────────────┘

When you subtract two times: duration = t2 - t1 ↓ Uses monotonic clock (immune to system time changes)

When you format a time: formatted = t.Format("2006-01-02") ↓ Uses wall clock (what users see)

````

### The Zero Value

The zero value of `time.Time` is January 1, year 1, 00:00:00 UTC. You can check if a time is zero:

```go
var t time.Time
if t.IsZero() {
    fmt.Println("Time is zero")
}
````

This is useful for optional time fields in structs or database columns that might be NULL.

---
