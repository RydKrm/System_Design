# The Complete Guide to Go Interfaces - Part 1 of 2

## From Necessity to Polymorphism with Structs and Methods

---

## Table of Contents - Complete Guide

### Part 1 (This Document)

1. [Introduction: Why Interfaces Exist](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#introduction-why-interfaces-exist)
2. [The Necessity of Interfaces](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#the-necessity-of-interfaces)
3. [Interfaces with Structs and Methods](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#interfaces-with-structs-and-methods)
4. [Real-World Use Cases](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#real-world-use-cases)
5. [Interface Fundamentals](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#interface-fundamentals)

### Part 2

6. Interface Satisfaction and Type System
7. Empty Interface and Type Assertions
8. Interface Composition
9. Advanced Patterns and Techniques
10. Practical Backend Examples
11. Interface vs Struct Embedding
12. Performance and Best Practices

---

## Introduction: Why Interfaces Exist

Imagine you're building a notification system that needs to send messages through different channels—email, SMS, Slack, push notifications. Without interfaces, you'd write specific code for each channel:

```go
type EmailNotifier struct {
    SMTPHost string
    From     string
}

type SMSNotifier struct {
    APIKey string
    From   string
}

type SlackNotifier struct {
    WebhookURL string
    Channel    string
}

// Separate functions for each type - no unified handling
func SendEmailNotification(notifier EmailNotifier, to, message string) error {
    // Email-specific implementation
    return sendEmail(notifier.SMTPHost, notifier.From, to, message)
}

func SendSMSNotification(notifier SMSNotifier, to, message string) error {
    // SMS-specific implementation
    return sendSMS(notifier.APIKey, notifier.From, to, message)
}

func SendSlackNotification(notifier SlackNotifier, to, message string) error {
    // Slack-specific implementation
    return sendSlack(notifier.WebhookURL, notifier.Channel, to, message)
}

// Problem: How do we handle them uniformly?
func NotifyUser(userID int64, message string) error {
    user := getUser(userID)
    
    // Messy if/else or switch for each type
    if user.PreferredChannel == "email" {
        emailNotifier := EmailNotifier{...}
        return SendEmailNotification(emailNotifier, user.Email, message)
    } else if user.PreferredChannel == "sms" {
        smsNotifier := SMSNotifier{...}
        return SendSMSNotification(smsNotifier, user.Phone, message)
    } else if user.PreferredChannel == "slack" {
        slackNotifier := SlackNotifier{...}
        return SendSlackNotification(slackNotifier, user.SlackID, message)
    }
    
    return errors.New("unknown channel")
}
```

This approach has severe problems:

**1. No Unified Type** You can't write a function that accepts "any notifier"—each type is different.

**2. Impossible to Extend** Adding a new notification channel requires modifying every place that handles notifications.

**3. Violation of Open/Closed Principle** Code isn't open for extension but closed for modification. Every new channel breaks existing code.

**4. Type-Specific Logic Everywhere** Every function that sends notifications needs type-switching logic.

Interfaces solve this by defining behavior contracts:

```go
// Interface defines the contract
type Notifier interface {
    Send(to, message string) error
}

// Each type implements the interface
type EmailNotifier struct {
    SMTPHost string
    From     string
}

func (e EmailNotifier) Send(to, message string) error {
    return sendEmail(e.SMTPHost, e.From, to, message)
}

type SMSNotifier struct {
    APIKey string
    From   string
}

func (s SMSNotifier) Send(to, message string) error {
    return sendSMS(s.APIKey, s.From, to, message)
}

type SlackNotifier struct {
    WebhookURL string
    Channel    string
}

func (sl SlackNotifier) Send(to, message string) error {
    return sendSlack(sl.WebhookURL, sl.Channel, to, message)
}

// Now we can write generic code!
func NotifyUser(notifier Notifier, to, message string) error {
    return notifier.Send(to, message)
}

// Usage - all types work the same way
func ProcessNotifications(users []User, message string) {
    notifiers := map[string]Notifier{
        "email": EmailNotifier{SMTPHost: "smtp.example.com", From: "app@example.com"},
        "sms":   SMSNotifier{APIKey: "key123", From: "123-456-7890"},
        "slack": SlackNotifier{WebhookURL: "https://hooks.slack.com/...", Channel: "#general"},
    }
    
    for _, user := range users {
        notifier := notifiers[user.PreferredChannel]
        if notifier != nil {
            NotifyUser(notifier, user.ContactInfo, message)
        }
    }
}

// Adding new channel? Just implement the interface!
type PushNotifier struct {
    ServerKey string
}

func (p PushNotifier) Send(to, message string) error {
    return sendPushNotification(p.ServerKey, to, message)
}

// Works automatically with all existing code!
```

**The Power of Interfaces:**

```
Conceptual View:

Without Interfaces (Concrete Types):
NotifyUser() → Must know about
               ├─ EmailNotifier
               ├─ SMSNotifier  
               ├─ SlackNotifier
               └─ (Every new type breaks this)

With Interfaces (Abstraction):
NotifyUser(Notifier) → Works with ANY type
                       that implements Send()
                       ├─ EmailNotifier ✓
                       ├─ SMSNotifier ✓
                       ├─ SlackNotifier ✓
                       ├─ PushNotifier ✓ (Just add it!)
                       └─ (Future types work automatically)
```

Interfaces enable **polymorphism**—write code once that works with many types. They're Go's answer to the "write once, use with anything" problem, without inheritance or classes.

---

## The Necessity of Interfaces

Interfaces aren't just convenient—they're essential for building flexible, maintainable systems. Let's explore why through fundamental problems only interfaces can solve.

### The Polymorphism Problem

Real systems need to work with multiple types that share common behavior. Without polymorphism, code becomes rigid and unmaintainable.

**Problem: No Unified Handling**

```go
// Different storage backends
type FileStorage struct {
    basePath string
}

type S3Storage struct {
    bucket string
    region string
}

type DatabaseStorage struct {
    db *sql.DB
}

// Separate functions for each type - code duplication!
func SaveToFile(storage FileStorage, key string, data []byte) error {
    path := filepath.Join(storage.basePath, key)
    return ioutil.WriteFile(path, data, 0644)
}

func SaveToS3(storage S3Storage, key string, data []byte) error {
    // S3 upload logic
    return uploadToS3(storage.bucket, storage.region, key, data)
}

func SaveToDatabase(storage DatabaseStorage, key string, data []byte) error {
    _, err := storage.db.Exec("INSERT INTO files (key, data) VALUES ($1, $2)", key, data)
    return err
}

// Application code becomes a nightmare
func SaveUserAvatar(userID int64, imageData []byte) error {
    config := getStorageConfig()
    
    // Must handle each type separately
    switch config.Type {
    case "file":
        fs := FileStorage{basePath: config.Path}
        return SaveToFile(fs, fmt.Sprintf("avatar_%d.jpg", userID), imageData)
    case "s3":
        s3 := S3Storage{bucket: config.Bucket, region: config.Region}
        return SaveToS3(s3, fmt.Sprintf("avatar_%d.jpg", userID), imageData)
    case "database":
        db := DatabaseStorage{db: getDB()}
        return SaveToDatabase(db, fmt.Sprintf("avatar_%d.jpg", userID), imageData)
    default:
        return errors.New("unknown storage type")
    }
}

// Every function that saves data needs this switch!
// Adding a new storage type requires modifying EVERY function!
```

**Solution: Interface-Based Polymorphism**

```go
// Define the behavior contract
type Storage interface {
    Save(key string, data []byte) error
    Load(key string) ([]byte, error)
    Delete(key string) error
}

// Implement for each type
type FileStorage struct {
    basePath string
}

func (fs FileStorage) Save(key string, data []byte) error {
    path := filepath.Join(fs.basePath, key)
    return ioutil.WriteFile(path, data, 0644)
}

func (fs FileStorage) Load(key string) ([]byte, error) {
    path := filepath.Join(fs.basePath, key)
    return ioutil.ReadFile(path)
}

func (fs FileStorage) Delete(key string) error {
    path := filepath.Join(fs.basePath, key)
    return os.Remove(path)
}

type S3Storage struct {
    bucket string
    region string
}

func (s3 S3Storage) Save(key string, data []byte) error {
    return uploadToS3(s3.bucket, s3.region, key, data)
}

func (s3 S3Storage) Load(key string) ([]byte, error) {
    return downloadFromS3(s3.bucket, s3.region, key)
}

func (s3 S3Storage) Delete(key string) error {
    return deleteFromS3(s3.bucket, s3.region, key)
}

type DatabaseStorage struct {
    db *sql.DB
}

func (ds DatabaseStorage) Save(key string, data []byte) error {
    _, err := ds.db.Exec("INSERT INTO files (key, data) VALUES ($1, $2)", key, data)
    return err
}

func (ds DatabaseStorage) Load(key string) ([]byte, error) {
    var data []byte
    err := ds.db.QueryRow("SELECT data FROM files WHERE key = $1", key).Scan(&data)
    return data, err
}

func (ds DatabaseStorage) Delete(key string) error {
    _, err := ds.db.Exec("DELETE FROM files WHERE key = $1", key)
    return err
}

// Now application code is clean and extensible
func SaveUserAvatar(storage Storage, userID int64, imageData []byte) error {
    key := fmt.Sprintf("avatar_%d.jpg", userID)
    return storage.Save(key, imageData)
}

// Works with ANY storage type!
func ProcessUserUploads(storage Storage, uploads []Upload) error {
    for _, upload := range uploads {
        if err := storage.Save(upload.Key, upload.Data); err != nil {
            return err
        }
    }
    return nil
}

// Adding new storage type? Just implement the interface!
type RedisStorage struct {
    client *redis.Client
}

func (rs RedisStorage) Save(key string, data []byte) error {
    return rs.client.Set(context.Background(), key, data, 0).Err()
}

func (rs RedisStorage) Load(key string) ([]byte, error) {
    return rs.client.Get(context.Background(), key).Bytes()
}

func (rs RedisStorage) Delete(key string) error {
    return rs.client.Del(context.Background(), key).Err()
}

// Works with ALL existing code automatically!
```

Interfaces enable true polymorphism—write code once that works with infinite types, present and future.

### The Dependency Inversion Problem

High-level modules shouldn't depend on low-level modules. Both should depend on abstractions (interfaces). This is the Dependency Inversion Principle.

**Problem: Tight Coupling**

```go
// High-level business logic depends on low-level database
type UserService struct {
    db *sql.DB  // Direct dependency on SQL database
}

func NewUserService(db *sql.DB) *UserService {
    return &UserService{db: db}
}

func (s *UserService) CreateUser(username, email string) error {
    // Directly coupled to SQL implementation
    _, err := s.db.Exec(
        "INSERT INTO users (username, email) VALUES ($1, $2)",
        username, email,
    )
    return err
}

func (s *UserService) GetUser(id int64) (*User, error) {
    user := &User{}
    err := s.db.QueryRow(
        "SELECT id, username, email FROM users WHERE id = $1",
        id,
    ).Scan(&user.ID, &user.Username, &user.Email)
    return user, err
}

// Problems:
// 1. Cannot test without a real database
// 2. Cannot switch to different database (MongoDB, DynamoDB)
// 3. Cannot add caching layer
// 4. UserService knows too much about persistence details
```

**Solution: Interface-Based Dependency Inversion**

```go
// Define abstraction (interface)
type UserRepository interface {
    Create(user *User) error
    FindByID(id int64) (*User, error)
    FindByEmail(email string) (*User, error)
    Update(user *User) error
    Delete(id int64) error
}

// High-level business logic depends on abstraction
type UserService struct {
    repo UserRepository  // Depends on interface, not concrete type
}

func NewUserService(repo UserRepository) *UserService {
    return &UserService{repo: repo}
}

func (s *UserService) RegisterUser(username, email, password string) error {
    // Business logic - doesn't care about persistence details
    user := &User{
        Username: username,
        Email:    email,
        Password: hashPassword(password),
    }
    
    // Validate
    if err := user.Validate(); err != nil {
        return err
    }
    
    // Check if email already exists
    existing, _ := s.repo.FindByEmail(email)
    if existing != nil {
        return errors.New("email already registered")
    }
    
    // Save
    return s.repo.Create(user)
}

// SQL implementation
type SQLUserRepository struct {
    db *sql.DB
}

func (r *SQLUserRepository) Create(user *User) error {
    query := "INSERT INTO users (username, email, password) VALUES ($1, $2, $3) RETURNING id"
    return r.db.QueryRow(query, user.Username, user.Email, user.Password).Scan(&user.ID)
}

func (r *SQLUserRepository) FindByID(id int64) (*User, error) {
    user := &User{}
    query := "SELECT id, username, email, password FROM users WHERE id = $1"
    err := r.db.QueryRow(query, id).Scan(&user.ID, &user.Username, &user.Email, &user.Password)
    return user, err
}

// MongoDB implementation (easily swappable!)
type MongoUserRepository struct {
    collection *mongo.Collection
}

func (r *MongoUserRepository) Create(user *User) error {
    result, err := r.collection.InsertOne(context.Background(), user)
    if err != nil {
        return err
    }
    user.ID = result.InsertedID.(int64)
    return nil
}

func (r *MongoUserRepository) FindByID(id int64) (*User, error) {
    user := &User{}
    err := r.collection.FindOne(
        context.Background(),
        bson.M{"_id": id},
    ).Decode(user)
    return user, err
}

// Cached implementation (decorator pattern!)
type CachedUserRepository struct {
    repo  UserRepository  // Wraps any repository
    cache map[int64]*User
}

func (r *CachedUserRepository) FindByID(id int64) (*User, error) {
    // Check cache first
    if user, ok := r.cache[id]; ok {
        return user, nil
    }
    
    // Not in cache - fetch from wrapped repository
    user, err := r.repo.FindByID(id)
    if err != nil {
        return nil, err
    }
    
    // Store in cache
    r.cache[id] = user
    return user, nil
}

// Mock for testing!
type MockUserRepository struct {
    users map[int64]*User
}

func (r *MockUserRepository) Create(user *User) error {
    user.ID = int64(len(r.users) + 1)
    r.users[user.ID] = user
    return nil
}

func (r *MockUserRepository) FindByID(id int64) (*User, error) {
    user, exists := r.users[id]
    if !exists {
        return nil, errors.New("user not found")
    }
    return user, nil
}

// Usage - UserService works with ANY implementation!
func main() {
    // Production: SQL database
    sqlRepo := &SQLUserRepository{db: openDatabase()}
    service := NewUserService(sqlRepo)
    
    // Or production: MongoDB
    mongoRepo := &MongoUserRepository{collection: getCollection()}
    service = NewUserService(mongoRepo)
    
    // Or production: Cached SQL
    cachedRepo := &CachedUserRepository{
        repo:  sqlRepo,
        cache: make(map[int64]*User),
    }
    service = NewUserService(cachedRepo)
    
    // Or testing: Mock
    mockRepo := &MockUserRepository{users: make(map[int64]*User)}
    service = NewUserService(mockRepo)
}
```

Interfaces invert dependencies—high-level code depends on abstractions, not concrete implementations. This makes code flexible, testable, and maintainable.

### The Testing Problem

Testing code that depends on external systems (databases, APIs, filesystems) is difficult without interfaces.

**Problem: Untestable Code**

```go
type OrderProcessor struct {
    db       *sql.DB            // Real database
    payment  *stripe.Client     // Real payment API
    shipping *fedex.Client      // Real shipping API
    email    *smtp.Client       // Real email server
}

func (op *OrderProcessor) ProcessOrder(order *Order) error {
    // To test this, you need:
    // 1. Running PostgreSQL database with test data
    // 2. Stripe test API keys and test mode
    // 3. FedEx test API access
    // 4. SMTP server for emails
    
    // Save order to database
    _, err := op.db.Exec(
        "INSERT INTO orders (customer_id, total) VALUES ($1, $2)",
        order.CustomerID, order.Total,
    )
    if err != nil {
        return err
    }
    
    // Charge payment
    _, err = op.payment.Charges.New(&stripe.ChargeParams{
        Amount:   stripe.Int64(int64(order.Total * 100)),
        Currency: stripe.String("usd"),
    })
    if err != nil {
        return err
    }
    
    // Create shipping label
    _, err = op.shipping.CreateShipment(order.ShippingAddress)
    if err != nil {
        return err
    }
    
    // Send confirmation email
    err = op.email.SendMail(order.CustomerEmail, "Order Confirmed", "...")
    if err != nil {
        return err
    }
    
    return nil
}

// Testing this is EXTREMELY difficult and slow!
```

**Solution: Interface-Based Testing**

```go
// Define interfaces for external dependencies
type Database interface {
    SaveOrder(order *Order) error
    GetOrder(id int64) (*Order, error)
}

type PaymentGateway interface {
    Charge(amount float64, currency string) (string, error)
}

type ShippingService interface {
    CreateShipment(address Address) (string, error)
}

type EmailService interface {
    SendEmail(to, subject, body string) error
}

// OrderProcessor depends on interfaces, not concrete types
type OrderProcessor struct {
    db       Database
    payment  PaymentGateway
    shipping ShippingService
    email    EmailService
}

func (op *OrderProcessor) ProcessOrder(order *Order) error {
    // Same business logic, but now testable!
    
    if err := op.db.SaveOrder(order); err != nil {
        return err
    }
    
    transactionID, err := op.payment.Charge(order.Total, "usd")
    if err != nil {
        return err
    }
    order.TransactionID = transactionID
    
    trackingNumber, err := op.shipping.CreateShipment(order.ShippingAddress)
    if err != nil {
        return err
    }
    order.TrackingNumber = trackingNumber
    
    if err := op.email.SendEmail(order.CustomerEmail, "Order Confirmed", "..."); err != nil {
        return err
    }
    
    return nil
}

// Production implementations
type PostgresDatabase struct {
    db *sql.DB
}

func (pd PostgresDatabase) SaveOrder(order *Order) error {
    _, err := pd.db.Exec(
        "INSERT INTO orders (customer_id, total) VALUES ($1, $2)",
        order.CustomerID, order.Total,
    )
    return err
}

type StripePayment struct {
    client *stripe.Client
}

func (sp StripePayment) Charge(amount float64, currency string) (string, error) {
    charge, err := sp.client.Charges.New(&stripe.ChargeParams{
        Amount:   stripe.Int64(int64(amount * 100)),
        Currency: stripe.String(currency),
    })
    if err != nil {
        return "", err
    }
    return charge.ID, nil
}

// Mock implementations for testing
type MockDatabase struct {
    orders map[int64]*Order
}

func (md *MockDatabase) SaveOrder(order *Order) error {
    order.ID = int64(len(md.orders) + 1)
    md.orders[order.ID] = order
    return nil
}

type MockPayment struct {
    shouldFail bool
}

func (mp MockPayment) Charge(amount float64, currency string) (string, error) {
    if mp.shouldFail {
        return "", errors.New("payment failed")
    }
    return "mock-transaction-123", nil
}

type MockShipping struct {
    shipments []Address
}

func (ms *MockShipping) CreateShipment(address Address) (string, error) {
    ms.shipments = append(ms.shipments, address)
    return "TRACK-123", nil
}

type MockEmail struct {
    sentEmails []string
}

func (me *MockEmail) SendEmail(to, subject, body string) error {
    me.sentEmails = append(me.sentEmails, to)
    return nil
}

// Now testing is easy and fast!
func TestProcessOrder(t *testing.T) {
    // Arrange - create mocks
    mockDB := &MockDatabase{orders: make(map[int64]*Order)}
    mockPayment := MockPayment{shouldFail: false}
    mockShipping := &MockShipping{}
    mockEmail := &MockEmail{}
    
    processor := &OrderProcessor{
        db:       mockDB,
        payment:  mockPayment,
        shipping: mockShipping,
        email:    mockEmail,
    }
    
    order := &Order{
        CustomerID:      123,
        CustomerEmail:   "customer@example.com",
        Total:           99.99,
        ShippingAddress: Address{Street: "123 Main St"},
    }
    
    // Act
    err := processor.ProcessOrder(order)
    
    // Assert
    if err != nil {
        t.Fatalf("ProcessOrder failed: %v", err)
    }
    
    // Verify database was called
    if len(mockDB.orders) != 1 {
        t.Error("Order was not saved to database")
    }
    
    // Verify shipping was created
    if len(mockShipping.shipments) != 1 {
        t.Error("Shipment was not created")
    }
    
    // Verify email was sent
    if len(mockEmail.sentEmails) != 1 {
        t.Error("Confirmation email was not sent")
    }
    
    // Test runs in milliseconds, no external dependencies needed!
}

func TestProcessOrderPaymentFailure(t *testing.T) {
    // Test payment failure scenario
    mockDB := &MockDatabase{orders: make(map[int64]*Order)}
    mockPayment := MockPayment{shouldFail: true}  // Simulate failure
    mockShipping := &MockShipping{}
    mockEmail := &MockEmail{}
    
    processor := &OrderProcessor{
        db:       mockDB,
        payment:  mockPayment,
        shipping: mockShipping,
        email:    mockEmail,
    }
    
    order := &Order{CustomerID: 123, Total: 99.99}
    
    err := processor.ProcessOrder(order)
    
    // Should fail
    if err == nil {
        t.Error("Expected error when payment fails")
    }
    
    // Verify shipping and email were NOT called
    if len(mockShipping.shipments) != 0 {
        t.Error("Shipment should not be created on payment failure")
    }
    if len(mockEmail.sentEmails) != 0 {
        t.Error("Email should not be sent on payment failure")
    }
}
```

Interfaces make testing practical by allowing mock implementations. Tests run fast, don't depend on external systems, and can simulate any scenario (including failures).

### The Flexibility Problem

Systems evolve. Requirements change. New features are added. Without interfaces, every change breaks existing code.

**Problem: Rigid Code**

```go
// Original: Only logs to files
type Logger struct {
    file *os.File
}

func (l *Logger) Log(message string) {
    l.file.WriteString(time.Now().Format(time.RFC3339) + ": " + message + "\n")
}

// All application code uses this directly
func ProcessRequest(logger *Logger, req Request) {
    logger.Log("Processing request")
    // Process...
    logger.Log("Request completed")
}

// New requirement: Also log to Syslog
// Problem: Can't change Logger without breaking EVERYTHING
// Must create new type and update ALL code that uses Logger
```

**Solution: Interface-Based Flexibility**

```go
// Define interface for logging behavior
type Logger interface {
    Log(message string)
    LogWithLevel(level string, message string)
}

// Application code uses interface
func ProcessRequest(logger Logger, req Request) {
    logger.Log("Processing request")
    // Process...
    logger.LogWithLevel("INFO", "Request completed")
}

// Original implementation
type FileLogger struct {
    file *os.File
}

func (fl *FileLogger) Log(message string) {
    fl.LogWithLevel("INFO", message)
}

func (fl *FileLogger) LogWithLevel(level string, message string) {
    line := fmt.Sprintf("%s [%s]: %s\n", time.Now().Format(time.RFC3339), level, message)
    fl.file.WriteString(line)
}

// Add new implementation - existing code doesn't change!
type SyslogLogger struct {
    writer *syslog.Writer
}

func (sl *SyslogLogger) Log(message string) {
    sl.writer.Info(message)
}

func (sl *SyslogLogger) LogWithLevel(level string, message string) {
    switch level {
    case "ERROR":
        sl.writer.Err(message)
    case "WARN":
        sl.writer.Warning(message)
    default:
        sl.writer.Info(message)
    }
}

// Add multi-logger - sends to multiple destinations
type MultiLogger struct {
    loggers []Logger
}

func (ml *MultiLogger) Log(message string) {
    for _, logger := range ml.loggers {
        logger.Log(message)
    }
}

func (ml *MultiLogger) LogWithLevel(level string, message string) {
    for _, logger := range ml.loggers {
        logger.LogWithLevel(level, message)
    }
}

// Add structured logger - JSON format
type StructuredLogger struct {
    output io.Writer
}

func (sl *StructuredLogger) Log(message string) {
    sl.LogWithLevel("INFO", message)
}

func (sl *StructuredLogger) LogWithLevel(level string, message string) {
    entry := map[string]interface{}{
        "timestamp": time.Now().Unix(),
        "level":     level,
        "message":   message,
    }
    json.NewEncoder(sl.output).Encode(entry)
}

// All work with existing code - no changes needed!
func main() {
    // Use file logger
    fileLogger := &FileLogger{file: openLogFile()}
    ProcessRequest(fileLogger, request)
    
    // Switch to syslog
    syslogLogger := &SyslogLogger{writer: openSyslog()}
    ProcessRequest(syslogLogger, request)
    
    // Use both!
    multiLogger := &MultiLogger{
        loggers: []Logger{fileLogger, syslogLogger},
    }
    ProcessRequest(multiLogger, request)
    
    // Use structured logging
    structuredLogger := &StructuredLogger{output: os.Stdout}
    ProcessRequest(structuredLogger, request)
}
```

Interfaces provide flexibility—add new implementations without touching existing code. This is the Open/Closed Principle: open for extension, closed for modification.

---

## Interfaces with Structs and Methods

Interfaces and structs work together to create Go's type system. Understanding their relationship is crucial.

### How Structs Satisfy Interfaces

A struct satisfies an interface **implicitly** when it has all the methods required by the interface. There's no explicit declaration.

```go
// Interface definition
type Shape interface {
    Area() float64
    Perimeter() float64
}

// Struct definition
type Rectangle struct {
    Width  float64
    Height float64
}

// Methods implementation
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

// Rectangle automatically satisfies Shape interface!
// No explicit declaration needed

func PrintShapeInfo(s Shape) {
    fmt.Printf("Area: %.2f\n", s.Area())
    fmt.Printf("Perimeter: %.2f\n", s.Perimeter())
}

func main() {
    rect := Rectangle{Width: 10, Height: 5}
    
    // Can pass Rectangle where Shape is expected
    PrintShapeInfo(rect)  // Works automatically!
}
```

**The Implicit Satisfaction Rule:**

```
For struct S to satisfy interface I:
✓ S must have ALL methods declared in I
✓ Method signatures must match EXACTLY
✓ Method receiver can be value OR pointer (with some rules)

Example:
Interface: type Writer interface { Write([]byte) (int, error) }

Satisfies:
✓ func (s MyStruct) Write(p []byte) (int, error) { ... }
✓ func (s *MyStruct) Write(p []byte) (int, error) { ... }

Does NOT satisfy:
✗ func (s MyStruct) Write(p []byte) error { ... }        // Wrong signature
✗ func (s MyStruct) Write(data []byte) (int, error) { ... } // Param name doesn't matter, but...
✗ Missing Write method entirely
```

This completes Part 1. Part 2 will be created next with the remaining sections.