# The Complete Guide to Go Interfaces 

## From Necessity to Polymorphism with Structs and Methods

---
## Table of Contents - Complete Guide
1. [Introduction: Why Interfaces Exist](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#introduction-why-interfaces-exist)
2. [The Necessity of Interfaces](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#the-necessity-of-interfaces)
3. [Interfaces with Structs and Methods](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#interfaces-with-structs-and-methods)
4. [Real-World Use Cases](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#real-world-use-cases)
5. [Interface Fundamentals](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#interface-fundamentals)
6. Interface Satisfaction and Type System
7. Empty Interface and Type Assertions
8. Interface Composition
9. Advanced Patterns and Techniques
10. Practical Backend Examples
11. Interface vs Struct Embedding
12. Performance and Best Practices

---

## Introduction: Why Interfaces Exist

Imagine you're building a notification system that needs to send messages through different channels—email, SMS, Slack, push notifications. Without interfaces, you'd write specific code for each channel:

```go
type EmailNotifier struct {
    SMTPHost string
    From     string
}

type SMSNotifier struct {
    APIKey string
    From   string
}

type SlackNotifier struct {
    WebhookURL string
    Channel    string
}

// Separate functions for each type - no unified handling
func SendEmailNotification(notifier EmailNotifier, to, message string) error {
    // Email-specific implementation
    return sendEmail(notifier.SMTPHost, notifier.From, to, message)
}

func SendSMSNotification(notifier SMSNotifier, to, message string) error {
    // SMS-specific implementation
    return sendSMS(notifier.APIKey, notifier.From, to, message)
}

func SendSlackNotification(notifier SlackNotifier, to, message string) error {
    // Slack-specific implementation
    return sendSlack(notifier.WebhookURL, notifier.Channel, to, message)
}

// Problem: How do we handle them uniformly?
func NotifyUser(userID int64, message string) error {
    user := getUser(userID)
    
    // Messy if/else or switch for each type
    if user.PreferredChannel == "email" {
        emailNotifier := EmailNotifier{...}
        return SendEmailNotification(emailNotifier, user.Email, message)
    } else if user.PreferredChannel == "sms" {
        smsNotifier := SMSNotifier{...}
        return SendSMSNotification(smsNotifier, user.Phone, message)
    } else if user.PreferredChannel == "slack" {
        slackNotifier := SlackNotifier{...}
        return SendSlackNotification(slackNotifier, user.SlackID, message)
    }
    
    return errors.New("unknown channel")
}
```

This approach has severe problems:

**1. No Unified Type** You can't write a function that accepts "any notifier"—each type is different.

**2. Impossible to Extend** Adding a new notification channel requires modifying every place that handles notifications.

**3. Violation of Open/Closed Principle** Code isn't open for extension but closed for modification. Every new channel breaks existing code.

**4. Type-Specific Logic Everywhere** Every function that sends notifications needs type-switching logic.

Interfaces solve this by defining behavior contracts:

```go
// Interface defines the contract
type Notifier interface {
    Send(to, message string) error
}

// Each type implements the interface
type EmailNotifier struct {
    SMTPHost string
    From     string
}

func (e EmailNotifier) Send(to, message string) error {
    return sendEmail(e.SMTPHost, e.From, to, message)
}

type SMSNotifier struct {
    APIKey string
    From   string
}

func (s SMSNotifier) Send(to, message string) error {
    return sendSMS(s.APIKey, s.From, to, message)
}

type SlackNotifier struct {
    WebhookURL string
    Channel    string
}

func (sl SlackNotifier) Send(to, message string) error {
    return sendSlack(sl.WebhookURL, sl.Channel, to, message)
}

// Now we can write generic code!
func NotifyUser(notifier Notifier, to, message string) error {
    return notifier.Send(to, message)
}

// Usage - all types work the same way
func ProcessNotifications(users []User, message string) {
    notifiers := map[string]Notifier{
        "email": EmailNotifier{SMTPHost: "smtp.example.com", From: "app@example.com"},
        "sms":   SMSNotifier{APIKey: "key123", From: "123-456-7890"},
        "slack": SlackNotifier{WebhookURL: "https://hooks.slack.com/...", Channel: "#general"},
    }
    
    for _, user := range users {
        notifier := notifiers[user.PreferredChannel]
        if notifier != nil {
            NotifyUser(notifier, user.ContactInfo, message)
        }
    }
}

// Adding new channel? Just implement the interface!
type PushNotifier struct {
    ServerKey string
}

func (p PushNotifier) Send(to, message string) error {
    return sendPushNotification(p.ServerKey, to, message)
}

// Works automatically with all existing code!
```

**The Power of Interfaces:**

```
Conceptual View:

Without Interfaces (Concrete Types):
NotifyUser() → Must know about
               ├─ EmailNotifier
               ├─ SMSNotifier  
               ├─ SlackNotifier
               └─ (Every new type breaks this)

With Interfaces (Abstraction):
NotifyUser(Notifier) → Works with ANY type
                       that implements Send()
                       ├─ EmailNotifier ✓
                       ├─ SMSNotifier ✓
                       ├─ SlackNotifier ✓
                       ├─ PushNotifier ✓ (Just add it!)
                       └─ (Future types work automatically)
```

Interfaces enable **polymorphism**—write code once that works with many types. They're Go's answer to the "write once, use with anything" problem, without inheritance or classes.

---

## The Necessity of Interfaces

Interfaces aren't just convenient—they're essential for building flexible, maintainable systems. Let's explore why through fundamental problems only interfaces can solve.

### The Polymorphism Problem

Real systems need to work with multiple types that share common behavior. Without polymorphism, code becomes rigid and unmaintainable.

**Problem: No Unified Handling**

```go
// Different storage backends
type FileStorage struct {
    basePath string
}

type S3Storage struct {
    bucket string
    region string
}

type DatabaseStorage struct {
    db *sql.DB
}

// Separate functions for each type - code duplication!
func SaveToFile(storage FileStorage, key string, data []byte) error {
    path := filepath.Join(storage.basePath, key)
    return ioutil.WriteFile(path, data, 0644)
}

func SaveToS3(storage S3Storage, key string, data []byte) error {
    // S3 upload logic
    return uploadToS3(storage.bucket, storage.region, key, data)
}

func SaveToDatabase(storage DatabaseStorage, key string, data []byte) error {
    _, err := storage.db.Exec("INSERT INTO files (key, data) VALUES ($1, $2)", key, data)
    return err
}

// Application code becomes a nightmare
func SaveUserAvatar(userID int64, imageData []byte) error {
    config := getStorageConfig()
    
    // Must handle each type separately
    switch config.Type {
    case "file":
        fs := FileStorage{basePath: config.Path}
        return SaveToFile(fs, fmt.Sprintf("avatar_%d.jpg", userID), imageData)
    case "s3":
        s3 := S3Storage{bucket: config.Bucket, region: config.Region}
        return SaveToS3(s3, fmt.Sprintf("avatar_%d.jpg", userID), imageData)
    case "database":
        db := DatabaseStorage{db: getDB()}
        return SaveToDatabase(db, fmt.Sprintf("avatar_%d.jpg", userID), imageData)
    default:
        return errors.New("unknown storage type")
    }
}

// Every function that saves data needs this switch!
// Adding a new storage type requires modifying EVERY function!
```

**Solution: Interface-Based Polymorphism**

```go
// Define the behavior contract
type Storage interface {
    Save(key string, data []byte) error
    Load(key string) ([]byte, error)
    Delete(key string) error
}

// Implement for each type
type FileStorage struct {
    basePath string
}

func (fs FileStorage) Save(key string, data []byte) error {
    path := filepath.Join(fs.basePath, key)
    return ioutil.WriteFile(path, data, 0644)
}

func (fs FileStorage) Load(key string) ([]byte, error) {
    path := filepath.Join(fs.basePath, key)
    return ioutil.ReadFile(path)
}

func (fs FileStorage) Delete(key string) error {
    path := filepath.Join(fs.basePath, key)
    return os.Remove(path)
}

type S3Storage struct {
    bucket string
    region string
}

func (s3 S3Storage) Save(key string, data []byte) error {
    return uploadToS3(s3.bucket, s3.region, key, data)
}

func (s3 S3Storage) Load(key string) ([]byte, error) {
    return downloadFromS3(s3.bucket, s3.region, key)
}

func (s3 S3Storage) Delete(key string) error {
    return deleteFromS3(s3.bucket, s3.region, key)
}

type DatabaseStorage struct {
    db *sql.DB
}

func (ds DatabaseStorage) Save(key string, data []byte) error {
    _, err := ds.db.Exec("INSERT INTO files (key, data) VALUES ($1, $2)", key, data)
    return err
}

func (ds DatabaseStorage) Load(key string) ([]byte, error) {
    var data []byte
    err := ds.db.QueryRow("SELECT data FROM files WHERE key = $1", key).Scan(&data)
    return data, err
}

func (ds DatabaseStorage) Delete(key string) error {
    _, err := ds.db.Exec("DELETE FROM files WHERE key = $1", key)
    return err
}

// Now application code is clean and extensible
func SaveUserAvatar(storage Storage, userID int64, imageData []byte) error {
    key := fmt.Sprintf("avatar_%d.jpg", userID)
    return storage.Save(key, imageData)
}

// Works with ANY storage type!
func ProcessUserUploads(storage Storage, uploads []Upload) error {
    for _, upload := range uploads {
        if err := storage.Save(upload.Key, upload.Data); err != nil {
            return err
        }
    }
    return nil
}

// Adding new storage type? Just implement the interface!
type RedisStorage struct {
    client *redis.Client
}

func (rs RedisStorage) Save(key string, data []byte) error {
    return rs.client.Set(context.Background(), key, data, 0).Err()
}

func (rs RedisStorage) Load(key string) ([]byte, error) {
    return rs.client.Get(context.Background(), key).Bytes()
}

func (rs RedisStorage) Delete(key string) error {
    return rs.client.Del(context.Background(), key).Err()
}

// Works with ALL existing code automatically!
```

Interfaces enable true polymorphism—write code once that works with infinite types, present and future.

### The Dependency Inversion Problem

High-level modules shouldn't depend on low-level modules. Both should depend on abstractions (interfaces). This is the Dependency Inversion Principle.

**Problem: Tight Coupling**

```go
// High-level business logic depends on low-level database
type UserService struct {
    db *sql.DB  // Direct dependency on SQL database
}

func NewUserService(db *sql.DB) *UserService {
    return &UserService{db: db}
}

func (s *UserService) CreateUser(username, email string) error {
    // Directly coupled to SQL implementation
    _, err := s.db.Exec(
        "INSERT INTO users (username, email) VALUES ($1, $2)",
        username, email,
    )
    return err
}

func (s *UserService) GetUser(id int64) (*User, error) {
    user := &User{}
    err := s.db.QueryRow(
        "SELECT id, username, email FROM users WHERE id = $1",
        id,
    ).Scan(&user.ID, &user.Username, &user.Email)
    return user, err
}

// Problems:
// 1. Cannot test without a real database
// 2. Cannot switch to different database (MongoDB, DynamoDB)
// 3. Cannot add caching layer
// 4. UserService knows too much about persistence details
```

**Solution: Interface-Based Dependency Inversion**

```go
// Define abstraction (interface)
type UserRepository interface {
    Create(user *User) error
    FindByID(id int64) (*User, error)
    FindByEmail(email string) (*User, error)
    Update(user *User) error
    Delete(id int64) error
}

// High-level business logic depends on abstraction
type UserService struct {
    repo UserRepository  // Depends on interface, not concrete type
}

func NewUserService(repo UserRepository) *UserService {
    return &UserService{repo: repo}
}

func (s *UserService) RegisterUser(username, email, password string) error {
    // Business logic - doesn't care about persistence details
    user := &User{
        Username: username,
        Email:    email,
        Password: hashPassword(password),
    }
    
    // Validate
    if err := user.Validate(); err != nil {
        return err
    }
    
    // Check if email already exists
    existing, _ := s.repo.FindByEmail(email)
    if existing != nil {
        return errors.New("email already registered")
    }
    
    // Save
    return s.repo.Create(user)
}

// SQL implementation
type SQLUserRepository struct {
    db *sql.DB
}

func (r *SQLUserRepository) Create(user *User) error {
    query := "INSERT INTO users (username, email, password) VALUES ($1, $2, $3) RETURNING id"
    return r.db.QueryRow(query, user.Username, user.Email, user.Password).Scan(&user.ID)
}

func (r *SQLUserRepository) FindByID(id int64) (*User, error) {
    user := &User{}
    query := "SELECT id, username, email, password FROM users WHERE id = $1"
    err := r.db.QueryRow(query, id).Scan(&user.ID, &user.Username, &user.Email, &user.Password)
    return user, err
}

// MongoDB implementation (easily swappable!)
type MongoUserRepository struct {
    collection *mongo.Collection
}

func (r *MongoUserRepository) Create(user *User) error {
    result, err := r.collection.InsertOne(context.Background(), user)
    if err != nil {
        return err
    }
    user.ID = result.InsertedID.(int64)
    return nil
}

func (r *MongoUserRepository) FindByID(id int64) (*User, error) {
    user := &User{}
    err := r.collection.FindOne(
        context.Background(),
        bson.M{"_id": id},
    ).Decode(user)
    return user, err
}

// Cached implementation (decorator pattern!)
type CachedUserRepository struct {
    repo  UserRepository  // Wraps any repository
    cache map[int64]*User
}

func (r *CachedUserRepository) FindByID(id int64) (*User, error) {
    // Check cache first
    if user, ok := r.cache[id]; ok {
        return user, nil
    }
    
    // Not in cache - fetch from wrapped repository
    user, err := r.repo.FindByID(id)
    if err != nil {
        return nil, err
    }
    
    // Store in cache
    r.cache[id] = user
    return user, nil
}

// Mock for testing!
type MockUserRepository struct {
    users map[int64]*User
}

func (r *MockUserRepository) Create(user *User) error {
    user.ID = int64(len(r.users) + 1)
    r.users[user.ID] = user
    return nil
}

func (r *MockUserRepository) FindByID(id int64) (*User, error) {
    user, exists := r.users[id]
    if !exists {
        return nil, errors.New("user not found")
    }
    return user, nil
}

// Usage - UserService works with ANY implementation!
func main() {
    // Production: SQL database
    sqlRepo := &SQLUserRepository{db: openDatabase()}
    service := NewUserService(sqlRepo)
    
    // Or production: MongoDB
    mongoRepo := &MongoUserRepository{collection: getCollection()}
    service = NewUserService(mongoRepo)
    
    // Or production: Cached SQL
    cachedRepo := &CachedUserRepository{
        repo:  sqlRepo,
        cache: make(map[int64]*User),
    }
    service = NewUserService(cachedRepo)
    
    // Or testing: Mock
    mockRepo := &MockUserRepository{users: make(map[int64]*User)}
    service = NewUserService(mockRepo)
}
```

Interfaces invert dependencies—high-level code depends on abstractions, not concrete implementations. This makes code flexible, testable, and maintainable.

### The Testing Problem

Testing code that depends on external systems (databases, APIs, filesystems) is difficult without interfaces.

**Problem: Untestable Code**

```go
type OrderProcessor struct {
    db       *sql.DB            // Real database
    payment  *stripe.Client     // Real payment API
    shipping *fedex.Client      // Real shipping API
    email    *smtp.Client       // Real email server
}

func (op *OrderProcessor) ProcessOrder(order *Order) error {
    // To test this, you need:
    // 1. Running PostgreSQL database with test data
    // 2. Stripe test API keys and test mode
    // 3. FedEx test API access
    // 4. SMTP server for emails
    
    // Save order to database
    _, err := op.db.Exec(
        "INSERT INTO orders (customer_id, total) VALUES ($1, $2)",
        order.CustomerID, order.Total,
    )
    if err != nil {
        return err
    }
    
    // Charge payment
    _, err = op.payment.Charges.New(&stripe.ChargeParams{
        Amount:   stripe.Int64(int64(order.Total * 100)),
        Currency: stripe.String("usd"),
    })
    if err != nil {
        return err
    }
    
    // Create shipping label
    _, err = op.shipping.CreateShipment(order.ShippingAddress)
    if err != nil {
        return err
    }
    
    // Send confirmation email
    err = op.email.SendMail(order.CustomerEmail, "Order Confirmed", "...")
    if err != nil {
        return err
    }
    
    return nil
}

// Testing this is EXTREMELY difficult and slow!
```

**Solution: Interface-Based Testing**

```go
// Define interfaces for external dependencies
type Database interface {
    SaveOrder(order *Order) error
    GetOrder(id int64) (*Order, error)
}

type PaymentGateway interface {
    Charge(amount float64, currency string) (string, error)
}

type ShippingService interface {
    CreateShipment(address Address) (string, error)
}

type EmailService interface {
    SendEmail(to, subject, body string) error
}

// OrderProcessor depends on interfaces, not concrete types
type OrderProcessor struct {
    db       Database
    payment  PaymentGateway
    shipping ShippingService
    email    EmailService
}

func (op *OrderProcessor) ProcessOrder(order *Order) error {
    // Same business logic, but now testable!
    
    if err := op.db.SaveOrder(order); err != nil {
        return err
    }
    
    transactionID, err := op.payment.Charge(order.Total, "usd")
    if err != nil {
        return err
    }
    order.TransactionID = transactionID
    
    trackingNumber, err := op.shipping.CreateShipment(order.ShippingAddress)
    if err != nil {
        return err
    }
    order.TrackingNumber = trackingNumber
    
    if err := op.email.SendEmail(order.CustomerEmail, "Order Confirmed", "..."); err != nil {
        return err
    }
    
    return nil
}

// Production implementations
type PostgresDatabase struct {
    db *sql.DB
}

func (pd PostgresDatabase) SaveOrder(order *Order) error {
    _, err := pd.db.Exec(
        "INSERT INTO orders (customer_id, total) VALUES ($1, $2)",
        order.CustomerID, order.Total,
    )
    return err
}

type StripePayment struct {
    client *stripe.Client
}

func (sp StripePayment) Charge(amount float64, currency string) (string, error) {
    charge, err := sp.client.Charges.New(&stripe.ChargeParams{
        Amount:   stripe.Int64(int64(amount * 100)),
        Currency: stripe.String(currency),
    })
    if err != nil {
        return "", err
    }
    return charge.ID, nil
}

// Mock implementations for testing
type MockDatabase struct {
    orders map[int64]*Order
}

func (md *MockDatabase) SaveOrder(order *Order) error {
    order.ID = int64(len(md.orders) + 1)
    md.orders[order.ID] = order
    return nil
}

type MockPayment struct {
    shouldFail bool
}

func (mp MockPayment) Charge(amount float64, currency string) (string, error) {
    if mp.shouldFail {
        return "", errors.New("payment failed")
    }
    return "mock-transaction-123", nil
}

type MockShipping struct {
    shipments []Address
}

func (ms *MockShipping) CreateShipment(address Address) (string, error) {
    ms.shipments = append(ms.shipments, address)
    return "TRACK-123", nil
}

type MockEmail struct {
    sentEmails []string
}

func (me *MockEmail) SendEmail(to, subject, body string) error {
    me.sentEmails = append(me.sentEmails, to)
    return nil
}

// Now testing is easy and fast!
func TestProcessOrder(t *testing.T) {
    // Arrange - create mocks
    mockDB := &MockDatabase{orders: make(map[int64]*Order)}
    mockPayment := MockPayment{shouldFail: false}
    mockShipping := &MockShipping{}
    mockEmail := &MockEmail{}
    
    processor := &OrderProcessor{
        db:       mockDB,
        payment:  mockPayment,
        shipping: mockShipping,
        email:    mockEmail,
    }
    
    order := &Order{
        CustomerID:      123,
        CustomerEmail:   "customer@example.com",
        Total:           99.99,
        ShippingAddress: Address{Street: "123 Main St"},
    }
    
    // Act
    err := processor.ProcessOrder(order)
    
    // Assert
    if err != nil {
        t.Fatalf("ProcessOrder failed: %v", err)
    }
    
    // Verify database was called
    if len(mockDB.orders) != 1 {
        t.Error("Order was not saved to database")
    }
    
    // Verify shipping was created
    if len(mockShipping.shipments) != 1 {
        t.Error("Shipment was not created")
    }
    
    // Verify email was sent
    if len(mockEmail.sentEmails) != 1 {
        t.Error("Confirmation email was not sent")
    }
    
    // Test runs in milliseconds, no external dependencies needed!
}

func TestProcessOrderPaymentFailure(t *testing.T) {
    // Test payment failure scenario
    mockDB := &MockDatabase{orders: make(map[int64]*Order)}
    mockPayment := MockPayment{shouldFail: true}  // Simulate failure
    mockShipping := &MockShipping{}
    mockEmail := &MockEmail{}
    
    processor := &OrderProcessor{
        db:       mockDB,
        payment:  mockPayment,
        shipping: mockShipping,
        email:    mockEmail,
    }
    
    order := &Order{CustomerID: 123, Total: 99.99}
    
    err := processor.ProcessOrder(order)
    
    // Should fail
    if err == nil {
        t.Error("Expected error when payment fails")
    }
    
    // Verify shipping and email were NOT called
    if len(mockShipping.shipments) != 0 {
        t.Error("Shipment should not be created on payment failure")
    }
    if len(mockEmail.sentEmails) != 0 {
        t.Error("Email should not be sent on payment failure")
    }
}
```

Interfaces make testing practical by allowing mock implementations. Tests run fast, don't depend on external systems, and can simulate any scenario (including failures).

### The Flexibility Problem

Systems evolve. Requirements change. New features are added. Without interfaces, every change breaks existing code.

**Problem: Rigid Code**

```go
// Original: Only logs to files
type Logger struct {
    file *os.File
}

func (l *Logger) Log(message string) {
    l.file.WriteString(time.Now().Format(time.RFC3339) + ": " + message + "\n")
}

// All application code uses this directly
func ProcessRequest(logger *Logger, req Request) {
    logger.Log("Processing request")
    // Process...
    logger.Log("Request completed")
}

// New requirement: Also log to Syslog
// Problem: Can't change Logger without breaking EVERYTHING
// Must create new type and update ALL code that uses Logger
```

**Solution: Interface-Based Flexibility**

```go
// Define interface for logging behavior
type Logger interface {
    Log(message string)
    LogWithLevel(level string, message string)
}

// Application code uses interface
func ProcessRequest(logger Logger, req Request) {
    logger.Log("Processing request")
    // Process...
    logger.LogWithLevel("INFO", "Request completed")
}

// Original implementation
type FileLogger struct {
    file *os.File
}

func (fl *FileLogger) Log(message string) {
    fl.LogWithLevel("INFO", message)
}

func (fl *FileLogger) LogWithLevel(level string, message string) {
    line := fmt.Sprintf("%s [%s]: %s\n", time.Now().Format(time.RFC3339), level, message)
    fl.file.WriteString(line)
}

// Add new implementation - existing code doesn't change!
type SyslogLogger struct {
    writer *syslog.Writer
}

func (sl *SyslogLogger) Log(message string) {
    sl.writer.Info(message)
}

func (sl *SyslogLogger) LogWithLevel(level string, message string) {
    switch level {
    case "ERROR":
        sl.writer.Err(message)
    case "WARN":
        sl.writer.Warning(message)
    default:
        sl.writer.Info(message)
    }
}

// Add multi-logger - sends to multiple destinations
type MultiLogger struct {
    loggers []Logger
}

func (ml *MultiLogger) Log(message string) {
    for _, logger := range ml.loggers {
        logger.Log(message)
    }
}

func (ml *MultiLogger) LogWithLevel(level string, message string) {
    for _, logger := range ml.loggers {
        logger.LogWithLevel(level, message)
    }
}

// Add structured logger - JSON format
type StructuredLogger struct {
    output io.Writer
}

func (sl *StructuredLogger) Log(message string) {
    sl.LogWithLevel("INFO", message)
}

func (sl *StructuredLogger) LogWithLevel(level string, message string) {
    entry := map[string]interface{}{
        "timestamp": time.Now().Unix(),
        "level":     level,
        "message":   message,
    }
    json.NewEncoder(sl.output).Encode(entry)
}

// All work with existing code - no changes needed!
func main() {
    // Use file logger
    fileLogger := &FileLogger{file: openLogFile()}
    ProcessRequest(fileLogger, request)
    
    // Switch to syslog
    syslogLogger := &SyslogLogger{writer: openSyslog()}
    ProcessRequest(syslogLogger, request)
    
    // Use both!
    multiLogger := &MultiLogger{
        loggers: []Logger{fileLogger, syslogLogger},
    }
    ProcessRequest(multiLogger, request)
    
    // Use structured logging
    structuredLogger := &StructuredLogger{output: os.Stdout}
    ProcessRequest(structuredLogger, request)
}
```

Interfaces provide flexibility—add new implementations without touching existing code. This is the Open/Closed Principle: open for extension, closed for modification.

---

## Interfaces with Structs and Methods

Interfaces and structs work together to create Go's type system. Understanding their relationship is crucial.

### How Structs Satisfy Interfaces

A struct satisfies an interface **implicitly** when it has all the methods required by the interface. There's no explicit declaration.

```go
// Interface definition
type Shape interface {
    Area() float64
    Perimeter() float64
}

// Struct definition
type Rectangle struct {
    Width  float64
    Height float64
}

// Methods implementation
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

// Rectangle automatically satisfies Shape interface!
// No explicit declaration needed

func PrintShapeInfo(s Shape) {
    fmt.Printf("Area: %.2f\n", s.Area())
    fmt.Printf("Perimeter: %.2f\n", s.Perimeter())
}

func main() {
    rect := Rectangle{Width: 10, Height: 5}
    
    // Can pass Rectangle where Shape is expected
    PrintShapeInfo(rect)  // Works automatically!
}
```

**The Implicit Satisfaction Rule:**

```
For struct S to satisfy interface I:
✓ S must have ALL methods declared in I
✓ Method signatures must match EXACTLY
✓ Method receiver can be value OR pointer (with some rules)

Example:
Interface: type Writer interface { Write([]byte) (int, error) }

Satisfies:
✓ func (s MyStruct) Write(p []byte) (int, error) { ... }
✓ func (s *MyStruct) Write(p []byte) (int, error) { ... }

Does NOT satisfy:
✗ func (s MyStruct) Write(p []byte) error { ... }        // Wrong signature
✗ func (s MyStruct) Write(data []byte) (int, error) { ... } // Param name doesn't matter, but...
✗ Missing Write method entirely
```

## Advanced Patterns, Type System, and Production Techniques

---

## Interface Satisfaction and Type System

Understanding how Go's type system works with interfaces is crucial for writing correct, flexible code.

### Implicit Interface Satisfaction

Go uses **structural typing** for interfaces—a type implements an interface by having the required methods, without explicit declaration.

```go
// Interface definition
type Reader interface {
    Read(p []byte) (n int, err error)
}

// FileReader implements Reader (implicitly)
type FileReader struct {
    file *os.File
}

func (fr FileReader) Read(p []byte) (int, error) {
    return fr.file.Read(p)
}

// StringReader also implements Reader (implicitly)
type StringReader struct {
    data string
    pos  int
}

func (sr *StringReader) Read(p []byte) (int, error) {
    if sr.pos >= len(sr.data) {
        return 0, io.EOF
    }
    
    n := copy(p, sr.data[sr.pos:])
    sr.pos += n
    return n, nil
}

// Both can be used as Reader - no explicit "implements" needed!
func ProcessData(r Reader) {
    data := make([]byte, 1024)
    n, err := r.Read(data)
    // Process...
}

// Usage
fileReader := FileReader{file: f}
stringReader := &StringReader{data: "hello"}

ProcessData(fileReader)    // Works
ProcessData(stringReader)  // Works
```

**Why Implicit Satisfaction?**

```
Benefits:
✓ No tight coupling between types and interfaces
✓ Interfaces can be defined after types
✓ Types can satisfy interfaces without knowing they exist
✓ Enables retroactive interface satisfaction
✓ Packages don't need to import interface definitions

Example:
Package A defines: type MyType struct { ... }
                   func (m MyType) Read(p []byte) (int, error) { ... }

Package B defines: type Reader interface { Read([]byte) (int, error) }

MyType satisfies Reader automatically, even though:
- MyType was defined first
- Package A doesn't know about Reader interface
- No import relationship needed
```

### Interface Satisfaction Rules

```
For type T to satisfy interface I:

1. T must have ALL methods declared in I
2. Method signatures must match EXACTLY:
   - Same method name
   - Same parameter types (including order)
   - Same return types (including order)
   - Parameter names don't matter

3. Receiver type matters:
   - If method has value receiver (r T), both T and *T satisfy
   - If method has pointer receiver (r *T), only *T satisfies

4. Interface is empty? Every type satisfies it!
```

**Example - Satisfaction Rules:**

```go
type Writer interface {
    Write(p []byte) (n int, err error)
}

// ✓ Satisfies - exact match
type GoodWriter struct{}

func (gw GoodWriter) Write(p []byte) (int, error) {
    return len(p), nil
}

// ✗ Does NOT satisfy - different parameter type
type BadWriter1 struct{}

func (bw BadWriter1) Write(p string) (int, error) {  // string instead of []byte
    return len(p), nil
}

// ✗ Does NOT satisfy - different return types
type BadWriter2 struct{}

func (bw BadWriter2) Write(p []byte) error {  // Missing int return
    return nil
}

// ✗ Does NOT satisfy - different parameter count
type BadWriter3 struct{}

func (bw BadWriter3) Write(p []byte, offset int) (int, error) {
    return len(p), nil
}

// ✗ Does NOT satisfy - method name mismatch
type BadWriter4 struct{}

func (bw BadWriter4) WriteData(p []byte) (int, error) {  // Wrong name
    return len(p), nil
}
```

### Checking Interface Satisfaction at Compile Time

You can force compile-time checking of interface satisfaction:

```go
type Reader interface {
    Read([]byte) (int, error)
}

type MyReader struct{}

func (mr MyReader) Read(p []byte) (int, error) {
    return 0, nil
}

// Compile-time check - will fail if MyReader doesn't implement Reader
var _ Reader = MyReader{}        // Value satisfies
var _ Reader = (*MyReader)(nil)  // Pointer satisfies

// If MyReader doesn't implement Reader, compile error:
// "cannot use MyReader{} (type MyReader) as type Reader"
```

**Common Pattern in Production:**

```go
// In your implementation file
type PostgresRepository struct {
    db *sql.DB
}

// Compile-time verification
var _ UserRepository = (*PostgresRepository)(nil)

// If PostgresRepository is missing any UserRepository methods,
// this line will cause a compile error
```

---

## Empty Interface and Type Assertions

The empty interface `interface{}` (or `any` in Go 1.18+) is special—it accepts any type.

### Empty Interface Basics

```go
// Empty interface - satisfied by ALL types
var anything interface{}

anything = 42           // int
anything = "hello"      // string
anything = []int{1,2,3} // slice
anything = true         // bool
anything = struct{}{}   // struct

// Common use: containers for heterogeneous types
func PrintAny(value interface{}) {
    fmt.Println(value)
}

PrintAny(42)
PrintAny("hello")
PrintAny([]int{1, 2, 3})
```

**Why Empty Interface Works:**

```
interface{} has zero methods
→ Every type has at least zero methods
→ Every type satisfies interface{}
```

### Type Assertions

Type assertions extract concrete values from interfaces:

```go
var i interface{} = "hello"

// Type assertion - unsafe
s := i.(string)  // s = "hello"
fmt.Println(s)

// If wrong type - PANICS!
n := i.(int)  // PANIC: interface conversion: interface {} is string, not int

// Safe type assertion - returns bool
s, ok := i.(string)
if ok {
    fmt.Println("It's a string:", s)
} else {
    fmt.Println("Not a string")
}

n, ok := i.(int)
if ok {
    fmt.Println("It's an int:", n)
} else {
    fmt.Println("Not an int")  // This executes
}
```

**Type Assertion Syntax:**

```go
// Unsafe (panics on wrong type)
value := interfaceValue.(ConcreteType)

// Safe (returns zero value and false on wrong type)
value, ok := interfaceValue.(ConcreteType)
if ok {
    // Use value
}
```

### Type Switches

Type switches handle multiple possible types:

```go
func Describe(value interface{}) {
    switch v := value.(type) {
    case int:
        fmt.Printf("Integer: %d\n", v)
    case string:
        fmt.Printf("String: %s\n", v)
    case bool:
        fmt.Printf("Boolean: %t\n", v)
    case []int:
        fmt.Printf("Slice of ints: %v\n", v)
    case map[string]int:
        fmt.Printf("Map: %v\n", v)
    case nil:
        fmt.Println("nil value")
    default:
        fmt.Printf("Unknown type: %T\n", v)
    }
}

Describe(42)                    // "Integer: 42"
Describe("hello")               // "String: hello"
Describe([]int{1, 2, 3})       // "Slice of ints: [1 2 3]"
Describe(3.14)                  // "Unknown type: float64"
```

**Type Switch Patterns:**

```go
// Extract and use specific types
func ProcessValue(value interface{}) {
    switch v := value.(type) {
    case string:
        // v is string here
        fmt.Println("String length:", len(v))
    case int:
        // v is int here
        fmt.Println("Int doubled:", v*2)
    case []byte:
        // v is []byte here
        fmt.Println("Byte count:", len(v))
    }
}

// Check for interface satisfaction
func ProcessReader(value interface{}) {
    switch v := value.(type) {
    case io.Reader:
        // v implements io.Reader
        data := make([]byte, 100)
        n, _ := v.Read(data)
        fmt.Printf("Read %d bytes\n", n)
    default:
        fmt.Println("Not a reader")
    }
}
```

### Practical Empty Interface Examples

**Example 1: Generic Container**

```go
type Container struct {
    items []interface{}
}

func (c *Container) Add(item interface{}) {
    c.items = append(c.items, item)
}

func (c *Container) Get(index int) (interface{}, bool) {
    if index < 0 || index >= len(c.items) {
        return nil, false
    }
    return c.items[index], true
}

func (c *Container) GetString(index int) (string, bool) {
    item, ok := c.Get(index)
    if !ok {
        return "", false
    }
    
    str, ok := item.(string)
    return str, ok
}

// Usage
container := &Container{}
container.Add("hello")
container.Add(42)
container.Add(true)

if str, ok := container.GetString(0); ok {
    fmt.Println("String:", str)
}
```

**Example 2: JSON-like Structure**

```go
type JSON map[string]interface{}

func (j JSON) GetString(key string) (string, bool) {
    value, exists := j[key]
    if !exists {
        return "", false
    }
    
    str, ok := value.(string)
    return str, ok
}

func (j JSON) GetInt(key string) (int, bool) {
    value, exists := j[key]
    if !exists {
        return 0, false
    }
    
    // Handle both int and float64 (JSON numbers)
    switch v := value.(type) {
    case int:
        return v, true
    case float64:
        return int(v), true
    default:
        return 0, false
    }
}

func (j JSON) GetObject(key string) (JSON, bool) {
    value, exists := j[key]
    if !exists {
        return nil, false
    }
    
    obj, ok := value.(map[string]interface{})
    return JSON(obj), ok
}

// Usage
data := JSON{
    "name":  "Alice",
    "age":   30,
    "admin": true,
    "address": map[string]interface{}{
        "city":  "NYC",
        "zip":   10001,
    },
}

name, _ := data.GetString("name")
age, _ := data.GetInt("age")
address, _ := data.GetObject("address")
city, _ := address.GetString("city")
```

**Example 3: Flexible Function Arguments**

```go
func Printf(format string, args ...interface{}) {
    // Process each argument based on its type
    for i, arg := range args {
        switch v := arg.(type) {
        case int:
            fmt.Printf("arg %d: int = %d\n", i, v)
        case string:
            fmt.Printf("arg %d: string = %s\n", i, v)
        case bool:
            fmt.Printf("arg %d: bool = %t\n", i, v)
        default:
            fmt.Printf("arg %d: %T = %v\n", i, v, v)
        }
    }
}

Printf("values:", 42, "hello", true, 3.14)
```

---

## Interface Composition

Interfaces can be composed from other interfaces, creating more complex contracts.

### Basic Interface Composition

```go
// Simple interfaces
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type Closer interface {
    Close() error
}

// Composite interfaces
type ReadWriter interface {
    Reader  // Embeds Reader interface
    Writer  // Embeds Writer interface
}

type ReadCloser interface {
    Reader
    Closer
}

type WriteCloser interface {
    Writer
    Closer
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}

// Implementation must have all methods
type File struct {
    // ...
}

func (f *File) Read(p []byte) (int, error) {
    // Implementation
}

func (f *File) Write(p []byte) (int, error) {
    // Implementation
}

func (f *File) Close() error {
    // Implementation
}

// File satisfies ReadWriteCloser automatically!
var rwc ReadWriteCloser = &File{}
```

**Composition Rules:**

```
interface C {
    A  // Embeds interface A
    B  // Embeds interface B
}

To satisfy C, type must have:
- All methods from A
- All methods from B
- No duplicate method names (compile error if conflict)
```

### Standard Library Interface Composition

```go
// From io package - real examples
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type Seeker interface {
    Seek(offset int64, whence int) (int64, error)
}

type ReadWriter interface {
    Reader
    Writer
}

type ReadSeeker interface {
    Reader
    Seeker
}

type WriteSeeker interface {
    Writer
    Seeker
}

type ReadWriteSeeker interface {
    Reader
    Writer
    Seeker
}

// Usage - function accepts any combination
func CopyData(w Writer, r Reader) error {
    buffer := make([]byte, 4096)
    for {
        n, err := r.Read(buffer)
        if err != nil {
            if err == io.EOF {
                break
            }
            return err
        }
        
        if _, err := w.Write(buffer[:n]); err != nil {
            return err
        }
    }
    return nil
}
```

### Creating Reusable Interface Compositions

```go
// Base capability interfaces
type Validator interface {
    Validate() error
}

type Persister interface {
    Save() error
    Load() error
}

type Timestamped interface {
    CreatedAt() time.Time
    UpdatedAt() time.Time
}

type Identifiable interface {
    ID() int64
}

// Compose into domain-specific interfaces
type Entity interface {
    Identifiable
    Timestamped
    Validator
}

type PersistentEntity interface {
    Entity
    Persister
}

// Implementation
type User struct {
    id        int64
    username  string
    createdAt time.Time
    updatedAt time.Time
}

func (u *User) ID() int64              { return u.id }
func (u *User) CreatedAt() time.Time   { return u.createdAt }
func (u *User) UpdatedAt() time.Time   { return u.updatedAt }
func (u *User) Validate() error        { /* ... */ }
func (u *User) Save() error            { /* ... */ }
func (u *User) Load() error            { /* ... */ }

// User satisfies PersistentEntity!
var entity PersistentEntity = &User{}
```

---

## Advanced Patterns and Techniques

### Pattern 1: Interface Adapters

Adapt one interface to another:

```go
// External library interface (can't modify)
type ThirdPartyLogger interface {
    LogMessage(level int, msg string)
}

// Our interface
type Logger interface {
    Info(msg string)
    Error(msg string)
    Debug(msg string)
}

// Adapter
type LoggerAdapter struct {
    logger ThirdPartyLogger
}

func (la *LoggerAdapter) Info(msg string) {
    la.logger.LogMessage(1, msg)
}

func (la *LoggerAdapter) Error(msg string) {
    la.logger.LogMessage(3, msg)
}

func (la *LoggerAdapter) Debug(msg string) {
    la.logger.LogMessage(0, msg)
}

// Now ThirdPartyLogger can be used as Logger
func UseLogger(logger Logger) {
    logger.Info("This works!")
}

thirdParty := getThirdPartyLogger()
adapter := &LoggerAdapter{logger: thirdParty}
UseLogger(adapter)
```

### Pattern 2: Interface Decorators

Add behavior to existing implementations:

```go
type DataStore interface {
    Get(key string) ([]byte, error)
    Set(key string, value []byte) error
}

// Original implementation
type MemoryStore struct {
    data map[string][]byte
}

func (ms *MemoryStore) Get(key string) ([]byte, error) {
    value, exists := ms.data[key]
    if !exists {
        return nil, errors.New("key not found")
    }
    return value, nil
}

func (ms *MemoryStore) Set(key string, value []byte) error {
    ms.data[key] = value
    return nil
}

// Logging decorator
type LoggingStore struct {
    store DataStore  // Wraps any DataStore
}

func (ls *LoggingStore) Get(key string) ([]byte, error) {
    log.Printf("GET %s", key)
    value, err := ls.store.Get(key)
    if err != nil {
        log.Printf("GET %s failed: %v", key, err)
    } else {
        log.Printf("GET %s returned %d bytes", key, len(value))
    }
    return value, err
}

func (ls *LoggingStore) Set(key string, value []byte) error {
    log.Printf("SET %s (%d bytes)", key, len(value))
    err := ls.store.Set(key, value)
    if err != nil {
        log.Printf("SET %s failed: %v", key, err)
    }
    return err
}

// Caching decorator
type CachingStore struct {
    store DataStore
    cache map[string][]byte
}

func (cs *CachingStore) Get(key string) ([]byte, error) {
    // Check cache first
    if value, exists := cs.cache[key]; exists {
        return value, nil
    }
    
    // Not in cache - fetch from wrapped store
    value, err := cs.store.Get(key)
    if err == nil {
        cs.cache[key] = value
    }
    return value, err
}

func (cs *CachingStore) Set(key string, value []byte) error {
    // Update cache
    cs.cache[key] = value
    
    // Update wrapped store
    return cs.store.Set(key, value)
}

// Usage - stack decorators
baseStore := &MemoryStore{data: make(map[string][]byte)}

// Add caching
cachedStore := &CachingStore{
    store: baseStore,
    cache: make(map[string][]byte),
}

// Add logging
loggedStore := &LoggingStore{
    store: cachedStore,
}

// All operations now cached AND logged
loggedStore.Set("key1", []byte("value1"))
loggedStore.Get("key1")
```

### Pattern 3: Strategy Pattern

Define family of algorithms, make them interchangeable:

```go
// Strategy interface
type CompressionStrategy interface {
    Compress(data []byte) ([]byte, error)
    Decompress(data []byte) ([]byte, error)
}

// Concrete strategies
type GzipCompression struct{}

func (g *GzipCompression) Compress(data []byte) ([]byte, error) {
    var buf bytes.Buffer
    writer := gzip.NewWriter(&buf)
    defer writer.Close()
    
    if _, err := writer.Write(data); err != nil {
        return nil, err
    }
    
    return buf.Bytes(), nil
}

func (g *GzipCompression) Decompress(data []byte) ([]byte, error) {
    reader, err := gzip.NewReader(bytes.NewReader(data))
    if err != nil {
        return nil, err
    }
    defer reader.Close()
    
    return ioutil.ReadAll(reader)
}

type ZlibCompression struct{}

func (z *ZlibCompression) Compress(data []byte) ([]byte, error) {
    var buf bytes.Buffer
    writer := zlib.NewWriter(&buf)
    defer writer.Close()
    
    if _, err := writer.Write(data); err != nil {
        return nil, err
    }
    
    return buf.Bytes(), nil
}

func (z *ZlibCompression) Decompress(data []byte) ([]byte, error) {
    reader, err := zlib.NewReader(bytes.NewReader(data))
    if err != nil {
        return nil, err
    }
    defer reader.Close()
    
    return ioutil.ReadAll(reader)
}

// Context uses strategy
type FileStorage struct {
    compression CompressionStrategy
}

func (fs *FileStorage) SaveFile(filename string, data []byte) error {
    // Use configured compression strategy
    compressed, err := fs.compression.Compress(data)
    if err != nil {
        return err
    }
    
    return ioutil.WriteFile(filename, compressed, 0644)
}

func (fs *FileStorage) LoadFile(filename string) ([]byte, error) {
    compressed, err := ioutil.ReadFile(filename)
    if err != nil {
        return nil, err
    }
    
    // Use configured compression strategy
    return fs.compression.Decompress(compressed)
}

// Usage - swap strategies at runtime
storage := &FileStorage{compression: &GzipCompression{}}
storage.SaveFile("data.gz", []byte("hello"))

// Switch to different compression
storage.compression = &ZlibCompression{}
storage.SaveFile("data.zlib", []byte("hello"))
```

### Pattern 4: Repository Pattern with Interfaces

Abstraction layer over data storage:

```go
// Domain model
type User struct {
    ID        int64
    Username  string
    Email     string
    CreatedAt time.Time
}

// Repository interface
type UserRepository interface {
    Create(user *User) error
    FindByID(id int64) (*User, error)
    FindByEmail(email string) (*User, error)
    Update(user *User) error
    Delete(id int64) error
    List(limit, offset int) ([]*User, error)
}

// SQL implementation
type SQLUserRepository struct {
    db *sql.DB
}

func (repo *SQLUserRepository) Create(user *User) error {
    query := `
        INSERT INTO users (username, email, created_at)
        VALUES ($1, $2, $3)
        RETURNING id
    `
    return repo.db.QueryRow(query, user.Username, user.Email, time.Now()).Scan(&user.ID)
}

func (repo *SQLUserRepository) FindByID(id int64) (*User, error) {
    user := &User{}
    query := `SELECT id, username, email, created_at FROM users WHERE id = $1`
    err := repo.db.QueryRow(query, id).Scan(&user.ID, &user.Username, &user.Email, &user.CreatedAt)
    return user, err
}

// MongoDB implementation
type MongoUserRepository struct {
    collection *mongo.Collection
}

func (repo *MongoUserRepository) Create(user *User) error {
    user.CreatedAt = time.Now()
    result, err := repo.collection.InsertOne(context.Background(), user)
    if err != nil {
        return err
    }
    user.ID = result.InsertedID.(int64)
    return nil
}

func (repo *MongoUserRepository) FindByID(id int64) (*User, error) {
    user := &User{}
    err := repo.collection.FindOne(
        context.Background(),
        bson.M{"_id": id},
    ).Decode(user)
    return user, err
}

// In-memory implementation (for testing)
type InMemoryUserRepository struct {
    users  map[int64]*User
    nextID int64
}

func NewInMemoryUserRepository() *InMemoryUserRepository {
    return &InMemoryUserRepository{
        users:  make(map[int64]*User),
        nextID: 1,
    }
}

func (repo *InMemoryUserRepository) Create(user *User) error {
    user.ID = repo.nextID
    user.CreatedAt = time.Now()
    repo.nextID++
    
    // Make a copy to avoid external modifications
    userCopy := *user
    repo.users[user.ID] = &userCopy
    return nil
}

func (repo *InMemoryUserRepository) FindByID(id int64) (*User, error) {
    user, exists := repo.users[id]
    if !exists {
        return nil, errors.New("user not found")
    }
    
    // Return a copy
    userCopy := *user
    return &userCopy, nil
}

// Service layer - doesn't care about implementation!
type UserService struct {
    repo UserRepository  // Interface, not concrete type
}

func (s *UserService) RegisterUser(username, email string) (*User, error) {
    user := &User{
        Username: username,
        Email:    email,
    }
    
    if err := s.repo.Create(user); err != nil {
        return nil, err
    }
    
    return user, nil
}

// Usage - easy to swap implementations
func main() {
    // Production: SQL
    sqlRepo := &SQLUserRepository{db: openDatabase()}
    service := &UserService{repo: sqlRepo}
    
    // Or MongoDB
    mongoRepo := &MongoUserRepository{collection: getCollection()}
    service = &UserService{repo: mongoRepo}
    
    // Or testing: in-memory
    memRepo := NewInMemoryUserRepository()
    service = &UserService{repo: memRepo}
    
    // Service code unchanged!
    user, _ := service.RegisterUser("alice", "alice@example.com")
}
```

---

## Interface vs Struct Embedding

Interfaces and structs both support embedding, but with different semantics.

### Struct Embedding (Composition)

```go
// Base struct
type Logger struct {
    prefix string
}

func (l *Logger) Log(message string) {
    fmt.Printf("[%s] %s\n", l.prefix, message)
}

// Embedding struct - gets Logger methods
type Application struct {
    Logger  // Embedded struct
    name   string
}

// Application automatically has Log method!
app := Application{
    Logger: Logger{prefix: "APP"},
    name:   "MyApp",
}

app.Log("Starting")  // Calls Logger.Log
// Output: [APP] Starting

// Can still access embedded struct
app.Logger.prefix = "APPLICATION"
app.Log("Running")
// Output: [APPLICATION] Running
```

### Interface Embedding (Contract Composition)

```go
// Base interfaces
type Reader interface {
    Read(p []byte) (int, error)
}

type Writer interface {
    Write(p []byte) (int, error)
}

// Embedding interfaces - requires BOTH
type ReadWriter interface {
    Reader  // Must implement Read
    Writer  // Must implement Write
}

// Implementation must have both methods
type Buffer struct {
    data []byte
}

func (b *Buffer) Read(p []byte) (int, error) {
    n := copy(p, b.data)
    b.data = b.data[n:]
    return n, nil
}

func (b *Buffer) Write(p []byte) (int, error) {
    b.data = append(b.data, p...)
    return len(p), nil
}

// Buffer satisfies ReadWriter
var rw ReadWriter = &Buffer{}
```

### Combining Both

```go
// Interface
type DataStore interface {
    Save(key string, value []byte) error
    Load(key string) ([]byte, error)
}

// Base implementation
type BaseStore struct {
    data map[string][]byte
}

func (bs *BaseStore) Save(key string, value []byte) error {
    bs.data[key] = value
    return nil
}

func (bs *BaseStore) Load(key string) ([]byte, error) {
    value, exists := bs.data[key]
    if !exists {
        return nil, errors.New("not found")
    }
    return value, nil
}

// Enhanced implementation through embedding
type CachedStore struct {
    BaseStore  // Embedded - inherit Save/Load
    cache     map[string][]byte
}

// Override Load with caching
func (cs *CachedStore) Load(key string) ([]byte, error) {
    // Check cache
    if value, exists := cs.cache[key]; exists {
        return value, nil
    }
    
    // Call base implementation
    value, err := cs.BaseStore.Load(key)
    if err == nil {
        cs.cache[key] = value
    }
    return value, err
}

// CachedStore satisfies DataStore interface
var store DataStore = &CachedStore{
    BaseStore: BaseStore{data: make(map[string][]byte)},
    cache:     make(map[string][]byte),
}
```

---

## Performance and Best Practices

### Performance Considerations

**1. Interface Method Calls**

```go
// Direct struct method call - fastest
type Counter struct {
    value int
}

func (c *Counter) Increment() {
    c.value++
}

counter := &Counter{}
counter.Increment()  // Direct method call

// Interface method call - slightly slower (virtual dispatch)
type Incrementer interface {
    Increment()
}

var inc Incrementer = &Counter{}
inc.Increment()  // Interface call - extra indirection
```

**Benchmark:**

```go
func BenchmarkDirectCall(b *testing.B) {
    counter := &Counter{}
    for i := 0; i < b.N; i++ {
        counter.Increment()
    }
}

func BenchmarkInterfaceCall(b *testing.B) {
    var counter Incrementer = &Counter{}
    for i := 0; i < b.N; i++ {
        counter.Increment()
    }
}

// Results:
// BenchmarkDirectCall      1000000000    0.50 ns/op
// BenchmarkInterfaceCall   500000000     2.50 ns/op
// Interface call: ~5x slower (but still extremely fast!)
```

**2. Interface Storage Size**

```go
// Interface value structure
type iface struct {
    tab  *itab         // Type information
    data unsafe.Pointer // Pointer to actual value
}

// Total: 16 bytes on 64-bit systems

// Small values might be stored directly (optimization)
var i interface{} = 42  // int stored directly

// Large values always use pointer
var j interface{} = [1000]int{}  // Pointer to array
```

**3. Empty Interface Overhead**

```go
// Type assertion has cost
func ProcessValue(v interface{}) {
    // Type assertion
    if str, ok := v.(string); ok {
        // Process string
    }
}

// Prefer concrete types when possible
func ProcessString(s string) {
    // Process string
}
```

### Best Practices

**1. Keep Interfaces Small**

```go
// GOOD: Small, focused interfaces
type Reader interface {
    Read(p []byte) (int, error)
}

type Writer interface {
    Write(p []byte) (int, error)
}

// BAD: Large, monolithic interface
type DataAccess interface {
    Read(p []byte) (int, error)
    Write(p []byte) (int, error)
    Seek(offset int64) (int64, error)
    Close() error
    Sync() error
    Stat() (FileInfo, error)
    // ... many more methods
}
```

**2. Accept Interfaces, Return Structs**

```go
// GOOD: Accept interface (flexible), return struct (concrete)
func ProcessData(r io.Reader) (*ProcessedData, error) {
    // r can be file, network, buffer, anything!
    return &ProcessedData{}, nil
}

// BAD: Return interface (limits future changes)
func ProcessData(r io.Reader) (io.Reader, error) {
    // Returning interface restricts implementation
}
```

**3. Define Interfaces in Consumer Package**

```go
// GOOD: Interface where it's used
// package app
type UserStore interface {
    GetUser(id int64) (*User, error)
}

func ProcessUser(store UserStore, id int64) error {
    user, err := store.GetUser(id)
    // ...
}

// BAD: Interface in provider package
// package database
type UserStore interface {
    GetUser(id int64) (*User, error)
}

// Forces all users to import database package
```

**4. Use Empty Interface Sparingly**

```go
// AVOID when possible
func Process(data interface{}) {
    // Type switching is verbose and error-prone
}

// PREFER concrete types or generics (Go 1.18+)
func Process[T any](data T) {
    // Type-safe, no runtime type checking
}
```

**Summary of Best Practices:**

1. **Small interfaces**: 1-3 methods ideal
2. **Accept interfaces, return structs**: Maximum flexibility
3. **Interface in consumer package**: Avoid dependency
4. **Avoid empty interface**: Use when truly needed
5. **Name interfaces by behavior**: Reader, Writer, Closer
6. **Use standard interfaces**: io.Reader, fmt.Stringer, etc.
7. **Don't force interfaces**: Create when needed, not preemptively
8. **Verify satisfaction**: Use `var _ Interface = (*Type)(nil)`

This completes the Interfaces guide! You now understand interfaces from basics through advanced patterns and performance optimization.