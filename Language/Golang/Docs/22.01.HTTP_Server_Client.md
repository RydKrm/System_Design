# The Complete Guide to Networking in Golang

## Table of Contents

1. [Introduction to Networking in Go](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#introduction)
2. [HTTP Client](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#http-client)
3. [HTTP Server](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#http-server)
4. [TCP Server](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#tcp-server)
5. [Advanced Networking Concepts](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#advanced-concepts)
6. [Best Practices](https://claude.ai/chat/405a99a2-36ec-4ced-a866-5f5f881932a6#best-practices)

---

## Introduction to Networking in Go {#introduction}

Networking is the backbone of modern applications. Whether you're building a REST API, a microservice, a chat application, or a distributed system, you need to understand how to send and receive data over networks. Go was designed with networking in mind, and it provides powerful, easy-to-use standard library packages that make network programming straightforward.

### Why Networking Matters

Imagine you're building an e-commerce platform. Your frontend needs to communicate with your backend API to fetch product information, process payments, and track orders. Your backend needs to communicate with payment gateways, shipping services, and databases. All of this happens over networks. Without proper networking knowledge, you cannot build modern, distributed applications.

### Go's Networking Philosophy

Go takes a pragmatic approach to networking. The standard library includes everything you need for most networking tasks, from simple HTTP requests to complex TCP servers. The philosophy behind Go's networking packages follows several key principles:

**Simplicity First**: Go's networking APIs are designed to make common tasks simple while still providing low-level access when you need it. Creating an HTTP server that handles thousands of concurrent connections requires just a few lines of code.

**Concurrency Built-in**: Go's goroutines and channels make it natural to handle multiple network connections simultaneously. You don't need to manage thread pools or worry about callback hell. Each connection can be handled in its own goroutine, and the Go runtime efficiently manages these lightweight threads.

**Standard Library Power**: Unlike many languages that require third-party frameworks for web servers or HTTP clients, Go includes production-ready networking tools in its standard library. The `net/http` package is powerful enough to run major production services without any external dependencies.

**Performance by Default**: Go's networking stack is designed for performance. It uses efficient I/O multiplexing under the hood, connection pooling, and other optimizations automatically. You get fast network code without having to think about low-level optimizations.

### The Network Stack in Go

Go's networking capabilities are built on several key packages:

**net Package**: This is the foundation. It provides low-level networking primitives for TCP, UDP, and Unix domain sockets. When you need fine-grained control over network connections, this is where you start.

**net/http Package**: Built on top of the `net` package, this provides high-level HTTP client and server functionality. It handles HTTP protocol details, connection management, and provides a clean API for building web services.

**io Package**: Networking in Go heavily uses the `io.Reader` and `io.Writer` interfaces. Understanding these interfaces is crucial because network connections implement them, allowing you to use the same code for files, networks, and other I/O operations.

### Understanding Network Communication

Before diving into code, let's understand how network communication works. Think of network communication like sending letters through the postal service:

**Client-Server Model**: One program (the client) initiates communication by sending a request to another program (the server). The server listens for incoming requests, processes them, and sends back responses. This is like sending a letter to a company and receiving a reply.

**IP Addresses and Ports**: Just as letters need addresses, network communication needs IP addresses. An IP address identifies a computer on the network (like a street address). A port is a number that identifies a specific application on that computer (like an apartment number). Together, they form a complete address like `192.168.1.100:8080`.

**Protocols**: Protocols are agreed-upon rules for communication. HTTP is a protocol for web communication, TCP is a protocol that ensures reliable data delivery, and UDP is a protocol for fast but unreliable delivery. These are like different types of mail services - registered mail (TCP) guarantees delivery, while regular mail (UDP) is faster but less reliable.

**Request-Response Pattern**: In HTTP, the client sends a request (like "give me this web page") and the server sends a response (the web page content). This pattern is fundamental to web services and APIs.

### Real-World Networking Scenarios

Let's look at how networking appears in real backend applications:

**API Communication**: Your Node.js backend needs to fetch user data from a Go microservice. It sends an HTTP GET request to `http://user-service:8080/api/users/123`, and your Go service responds with JSON data.

**Database Connections**: When your application connects to PostgreSQL, it establishes a TCP connection to the database server (usually on port 5432), then sends SQL queries and receives results over that connection.

**Microservices**: In a microservices architecture, different services communicate over the network. An order service might call a payment service, which calls a fraud detection service, all over HTTP or gRPC (which uses HTTP/2).

**Webhooks**: External services like payment gateways send notifications to your server by making HTTP POST requests to your endpoints. Your server needs to listen for these requests and handle them appropriately.

---

## HTTP Client {#http-client}

The HTTP client is how your Go program makes requests to other services over HTTP. Whether you're calling a third-party API, communicating with your own microservices, or fetching data from websites, you'll use Go's HTTP client.

### Understanding HTTP Clients

An HTTP client is a program that initiates HTTP requests. When you open a web browser and visit a website, your browser acts as an HTTP client. In Go, you can programmatically make these same kinds of requests to interact with web services.

Think of an HTTP client as making phone calls. You dial a number (the URL), wait for the other party to answer (the server), have a conversation (send request, receive response), and then hang up. The HTTP client handles all the technical details of establishing the connection, sending the request, and receiving the response.

### The http.Client Type

Go's HTTP client functionality is provided by the `net/http` package. At the heart of this is the `http.Client` type. This struct manages connection pooling, timeouts, redirects, and other HTTP client behavior.

For simple requests, you can use the package-level functions like `http.Get()`, which use a default client. However, for production code, you should create your own client with custom configuration:

```go
package main

import (
    "fmt"
    "io"
    "net/http"
    "time"
)

func main() {
    // Create a custom HTTP client with timeout
    client := &http.Client{
        Timeout: 10 * time.Second,
    }
    
    // Make a GET request
    resp, err := client.Get("https://api.example.com/users")
    if err != nil {
        fmt.Printf("Error making request: %v\n", err)
        return
    }
    defer resp.Body.Close()
    
    // Read the response body
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        fmt.Printf("Error reading response: %v\n", err)
        return
    }
    
    fmt.Printf("Status Code: %d\n", resp.StatusCode)
    fmt.Printf("Response Body: %s\n", string(body))
}
```

Let's break down what's happening here:

**Creating the Client**: We create an `http.Client` with a 10-second timeout. This means if a request takes longer than 10 seconds, it will be cancelled. Without a timeout, a request could hang forever if the server doesn't respond.

**Making the Request**: `client.Get()` makes an HTTP GET request to the specified URL. This is a blocking call - it waits until the response is received or an error occurs.

**Handling the Response**: The response includes a `Body` field which is an `io.ReadCloser`. We must close it when we're done (using `defer`) to avoid resource leaks. We read the entire body using `io.ReadAll()`.

**Error Handling**: Network operations can fail in many ways - the server might be down, the network might be unreachable, or the request might timeout. Always check for errors.

### Making Different Types of HTTP Requests

HTTP supports several request methods, each with a different purpose:

**GET**: Retrieve data from the server. This should not modify anything on the server. It's like asking a librarian for a book - you're just reading, not changing anything.

**POST**: Send data to create a new resource. Like submitting a form to create a new user account.

**PUT**: Send data to update an existing resource completely. Like updating all fields of a user profile.

**PATCH**: Send data to partially update a resource. Like updating just the email address in a user profile.

**DELETE**: Remove a resource. Like deleting a user account.

Let's see how to make each type of request:

```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "time"
)

// User represents a user in our system
type User struct {
    ID       int    `json:"id,omitempty"`
    Username string `json:"username"`
    Email    string `json:"email"`
    Age      int    `json:"age"`
}

type HTTPClient struct {
    client  *http.Client
    baseURL string
}

func NewHTTPClient(baseURL string) *HTTPClient {
    return &HTTPClient{
        client: &http.Client{
            Timeout: 15 * time.Second,
        },
        baseURL: baseURL,
    }
}

// GetUser retrieves a user by ID using GET request
func (c *HTTPClient) GetUser(userID int) (*User, error) {
    url := fmt.Sprintf("%s/api/users/%d", c.baseURL, userID)
    
    resp, err := c.client.Get(url)
    if err != nil {
        return nil, fmt.Errorf("failed to make GET request: %w", err)
    }
    defer resp.Body.Close()
    
    // Check if request was successful
    if resp.StatusCode != http.StatusOK {
        body, _ := io.ReadAll(resp.Body)
        return nil, fmt.Errorf("request failed with status %d: %s", resp.StatusCode, string(body))
    }
    
    // Decode JSON response
    var user User
    if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
        return nil, fmt.Errorf("failed to decode response: %w", err)
    }
    
    return &user, nil
}

// CreateUser creates a new user using POST request
func (c *HTTPClient) CreateUser(user User) (*User, error) {
    url := fmt.Sprintf("%s/api/users", c.baseURL)
    
    // Convert user to JSON
    jsonData, err := json.Marshal(user)
    if err != nil {
        return nil, fmt.Errorf("failed to marshal user: %w", err)
    }
    
    // Create POST request
    resp, err := c.client.Post(url, "application/json", bytes.NewBuffer(jsonData))
    if err != nil {
        return nil, fmt.Errorf("failed to make POST request: %w", err)
    }
    defer resp.Body.Close()
    
    // Check if creation was successful
    if resp.StatusCode != http.StatusCreated {
        body, _ := io.ReadAll(resp.Body)
        return nil, fmt.Errorf("request failed with status %d: %s", resp.StatusCode, string(body))
    }
    
    // Decode the created user from response
    var createdUser User
    if err := json.NewDecoder(resp.Body).Decode(&createdUser); err != nil {
        return nil, fmt.Errorf("failed to decode response: %w", err)
    }
    
    return &createdUser, nil
}

// UpdateUser updates an existing user using PUT request
func (c *HTTPClient) UpdateUser(userID int, user User) (*User, error) {
    url := fmt.Sprintf("%s/api/users/%d", c.baseURL, userID)
    
    // Convert user to JSON
    jsonData, err := json.Marshal(user)
    if err != nil {
        return nil, fmt.Errorf("failed to marshal user: %w", err)
    }
    
    // Create PUT request
    req, err := http.NewRequest(http.MethodPut, url, bytes.NewBuffer(jsonData))
    if err != nil {
        return nil, fmt.Errorf("failed to create request: %w", err)
    }
    req.Header.Set("Content-Type", "application/json")
    
    resp, err := c.client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("failed to make PUT request: %w", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        body, _ := io.ReadAll(resp.Body)
        return nil, fmt.Errorf("request failed with status %d: %s", resp.StatusCode, string(body))
    }
    
    var updatedUser User
    if err := json.NewDecoder(resp.Body).Decode(&updatedUser); err != nil {
        return nil, fmt.Errorf("failed to decode response: %w", err)
    }
    
    return &updatedUser, nil
}

// DeleteUser deletes a user using DELETE request
func (c *HTTPClient) DeleteUser(userID int) error {
    url := fmt.Sprintf("%s/api/users/%d", c.baseURL, userID)
    
    // Create DELETE request
    req, err := http.NewRequest(http.MethodDelete, url, nil)
    if err != nil {
        return fmt.Errorf("failed to create request: %w", err)
    }
    
    resp, err := c.client.Do(req)
    if err != nil {
        return fmt.Errorf("failed to make DELETE request: %w", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusNoContent && resp.StatusCode != http.StatusOK {
        body, _ := io.ReadAll(resp.Body)
        return fmt.Errorf("request failed with status %d: %s", resp.StatusCode, string(body))
    }
    
    return nil
}
```

### Working with Request Headers

Headers provide metadata about the request. Common use cases include authentication, content type specification, and custom application headers:

```go
// AddAuthHeaders adds authentication headers to a request
func (c *HTTPClient) GetUserWithAuth(userID int, token string) (*User, error) {
    url := fmt.Sprintf("%s/api/users/%d", c.baseURL, userID)
    
    // Create request
    req, err := http.NewRequest(http.MethodGet, url, nil)
    if err != nil {
        return nil, fmt.Errorf("failed to create request: %w", err)
    }
    
    // Add headers
    req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("User-Agent", "MyApp/1.0")
    req.Header.Set("X-Request-ID", generateRequestID())
    
    // Make request
    resp, err := c.client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("failed to make request: %w", err)
    }
    defer resp.Body.Close()
    
    // Check for authentication errors
    if resp.StatusCode == http.StatusUnauthorized {
        return nil, fmt.Errorf("unauthorized: invalid or expired token")
    }
    
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("request failed with status %d", resp.StatusCode)
    }
    
    var user User
    if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
        return nil, fmt.Errorf("failed to decode response: %w", err)
    }
    
    return &user, nil
}

func generateRequestID() string {
    return fmt.Sprintf("req_%d", time.Now().UnixNano())
}
```

### Query Parameters

Query parameters allow you to pass data in the URL. They're commonly used for filtering, pagination, and search:

```go
// SearchUsers searches for users with query parameters
func (c *HTTPClient) SearchUsers(query string, page, limit int) ([]User, error) {
    // Build URL with query parameters
    baseURL := fmt.Sprintf("%s/api/users/search", c.baseURL)
    
    req, err := http.NewRequest(http.MethodGet, baseURL, nil)
    if err != nil {
        return nil, fmt.Errorf("failed to create request: %w", err)
    }
    
    // Add query parameters
    q := req.URL.Query()
    q.Add("q", query)
    q.Add("page", fmt.Sprintf("%d", page))
    q.Add("limit", fmt.Sprintf("%d", limit))
    req.URL.RawQuery = q.Encode()
    
    // The URL will look like: /api/users/search?q=john&page=1&limit=10
    
    resp, err := c.client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("failed to make request: %w", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("request failed with status %d", resp.StatusCode)
    }
    
    var users []User
    if err := json.NewDecoder(resp.Body).Decode(&users); err != nil {
        return nil, fmt.Errorf("failed to decode response: %w", err)
    }
    
    return users, nil
}
```

### Handling Response Status Codes

HTTP status codes tell you what happened with your request. Understanding these codes is crucial for proper error handling:

```go
// ProcessResponse handles different HTTP status codes appropriately
func (c *HTTPClient) ProcessResponse(resp *http.Response) error {
    switch resp.StatusCode {
    case http.StatusOK, http.StatusCreated, http.StatusNoContent:
        // Success - 2xx codes
        return nil
        
    case http.StatusBadRequest:
        // 400 - Invalid request
        body, _ := io.ReadAll(resp.Body)
        return fmt.Errorf("bad request: %s", string(body))
        
    case http.StatusUnauthorized:
        // 401 - Authentication required or failed
        return fmt.Errorf("unauthorized: authentication required")
        
    case http.StatusForbidden:
        // 403 - Authenticated but not authorized
        return fmt.Errorf("forbidden: insufficient permissions")
        
    case http.StatusNotFound:
        // 404 - Resource not found
        return fmt.Errorf("resource not found")
        
    case http.StatusConflict:
        // 409 - Conflict (e.g., duplicate resource)
        body, _ := io.ReadAll(resp.Body)
        return fmt.Errorf("conflict: %s", string(body))
        
    case http.StatusTooManyRequests:
        // 429 - Rate limit exceeded
        retryAfter := resp.Header.Get("Retry-After")
        return fmt.Errorf("rate limit exceeded, retry after: %s", retryAfter)
        
    case http.StatusInternalServerError:
        // 500 - Server error
        return fmt.Errorf("server error: internal server error")
        
    case http.StatusServiceUnavailable:
        // 503 - Service temporarily unavailable
        return fmt.Errorf("service unavailable: please try again later")
        
    default:
        return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
    }
}
```

### Custom Transport and Connection Pooling

The HTTP client uses a `Transport` to manage connections. You can customize this for advanced scenarios:

```go
// CreateCustomClient creates an HTTP client with custom transport settings
func CreateCustomClient() *http.Client {
    // Create custom transport
    transport := &http.Transport{
        // Maximum idle connections across all hosts
        MaxIdleConns: 100,
        
        // Maximum idle connections per host
        MaxIdleConnsPerHost: 10,
        
        // How long an idle connection stays in the pool
        IdleConnTimeout: 90 * time.Second,
        
        // Timeout for establishing TCP connection
        DialContext: (&net.Dialer{
            Timeout:   30 * time.Second,
            KeepAlive: 30 * time.Second,
        }).DialContext,
        
        // Timeout for TLS handshake
        TLSHandshakeTimeout: 10 * time.Second,
        
        // Timeout for waiting for server's first response headers
        ResponseHeaderTimeout: 10 * time.Second,
        
        // Disable HTTP/2
        ForceAttemptHTTP2: false,
    }
    
    return &http.Client{
        Transport: transport,
        Timeout:   30 * time.Second,
    }
}
```

### Real-World Example: Payment Gateway Integration

Let's build a complete example that integrates with a payment gateway:

```go
package payment

import (
    "bytes"
    "context"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "time"
)

type PaymentGatewayClient struct {
    client    *http.Client
    baseURL   string
    apiKey    string
    apiSecret string
}

type PaymentRequest struct {
    Amount      float64 `json:"amount"`
    Currency    string  `json:"currency"`
    CustomerID  string  `json:"customer_id"`
    Description string  `json:"description"`
}

type PaymentResponse struct {
    TransactionID string    `json:"transaction_id"`
    Status        string    `json:"status"`
    Amount        float64   `json:"amount"`
    CreatedAt     time.Time `json:"created_at"`
}

type RefundRequest struct {
    TransactionID string  `json:"transaction_id"`
    Amount        float64 `json:"amount"`
    Reason        string  `json:"reason"`
}

type RefundResponse struct {
    RefundID      string    `json:"refund_id"`
    TransactionID string    `json:"transaction_id"`
    Status        string    `json:"status"`
    Amount        float64   `json:"amount"`
    RefundedAt    time.Time `json:"refunded_at"`
}

func NewPaymentGatewayClient(baseURL, apiKey, apiSecret string) *PaymentGatewayClient {
    return &PaymentGatewayClient{
        client: &http.Client{
            Timeout: 30 * time.Second,
            Transport: &http.Transport{
                MaxIdleConns:        100,
                MaxIdleConnsPerHost: 10,
                IdleConnTimeout:     90 * time.Second,
            },
        },
        baseURL:   baseURL,
        apiKey:    apiKey,
        apiSecret: apiSecret,
    }
}

// ProcessPayment processes a payment through the gateway
func (c *PaymentGatewayClient) ProcessPayment(ctx context.Context, req PaymentRequest) (*PaymentResponse, error) {
    url := fmt.Sprintf("%s/api/v1/payments", c.baseURL)
    
    // Marshal request to JSON
    jsonData, err := json.Marshal(req)
    if err != nil {
        return nil, fmt.Errorf("failed to marshal request: %w", err)
    }
    
    // Create HTTP request with context
    httpReq, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewBuffer(jsonData))
    if err != nil {
        return nil, fmt.Errorf("failed to create request: %w", err)
    }
    
    // Set headers
    httpReq.Header.Set("Content-Type", "application/json")
    httpReq.Header.Set("X-API-Key", c.apiKey)
    httpReq.Header.Set("X-API-Secret", c.apiSecret)
    httpReq.Header.Set("Idempotency-Key", generateIdempotencyKey())
    
    // Make request
    resp, err := c.client.Do(httpReq)
    if err != nil {
        return nil, fmt.Errorf("failed to make request: %w", err)
    }
    defer resp.Body.Close()
    
    // Read response body
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("failed to read response: %w", err)
    }
    
    // Check status code
    if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
        return nil, fmt.Errorf("payment failed with status %d: %s", resp.StatusCode, string(body))
    }
    
    // Parse response
    var paymentResp PaymentResponse
    if err := json.Unmarshal(body, &paymentResp); err != nil {
        return nil, fmt.Errorf("failed to parse response: %w", err)
    }
    
    return &paymentResp, nil
}

// RefundPayment processes a refund
func (c *PaymentGatewayClient) RefundPayment(ctx context.Context, req RefundRequest) (*RefundResponse, error) {
    url := fmt.Sprintf("%s/api/v1/refunds", c.baseURL)
    
    jsonData, err := json.Marshal(req)
    if err != nil {
        return nil, fmt.Errorf("failed to marshal request: %w", err)
    }
    
    httpReq, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewBuffer(jsonData))
    if err != nil {
        return nil, fmt.Errorf("failed to create request: %w", err)
    }
    
    httpReq.Header.Set("Content-Type", "application/json")
    httpReq.Header.Set("X-API-Key", c.apiKey)
    httpReq.Header.Set("X-API-Secret", c.apiSecret)
    
    resp, err := c.client.Do(httpReq)
    if err != nil {
        return nil, fmt.Errorf("failed to make request: %w", err)
    }
    defer resp.Body.Close()
    
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("failed to read response: %w", err)
    }
    
    if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
        return nil, fmt.Errorf("refund failed with status %d: %s", resp.StatusCode, string(body))
    }
    
    var refundResp RefundResponse
    if err := json.Unmarshal(body, &refundResp); err != nil {
        return nil, fmt.Errorf("failed to parse response: %w", err)
    }
    
    return &refundResp, nil
}

// GetPaymentStatus retrieves the status of a payment
func (c *PaymentGatewayClient) GetPaymentStatus(ctx context.Context, transactionID string) (*PaymentResponse, error) {
    url := fmt.Sprintf("%s/api/v1/payments/%s", c.baseURL, transactionID)
    
    httpReq, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
    if err != nil {
        return nil, fmt.Errorf("failed to create request: %w", err)
    }
    
    httpReq.Header.Set("X-API-Key", c.apiKey)
    httpReq.Header.Set("X-API-Secret", c.apiSecret)
    
    resp, err := c.client.Do(httpReq)
    if err != nil {
        return nil, fmt.Errorf("failed to make request: %w", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode == http.StatusNotFound {
        return nil, fmt.Errorf("payment not found: %s", transactionID)
    }
    
    if resp.StatusCode != http.StatusOK {
        body, _ := io.ReadAll(resp.Body)
        return nil, fmt.Errorf("request failed with status %d: %s", resp.StatusCode, string(body))
    }
    
    var paymentResp PaymentResponse
    if err := json.NewDecoder(resp.Body).Decode(&paymentResp); err != nil {
        return nil, fmt.Errorf("failed to parse response: %w", err)
    }
    
    return &paymentResp, nil
}

func generateIdempotencyKey() string {
    return fmt.Sprintf("idem_%d", time.Now().UnixNano())
}
```

### Usage Example

```go
func main() {
    // Create payment gateway client
    client := NewPaymentGatewayClient(
        "https://api.paymentgateway.com",
        "your-api-key",
        "your-api-secret",
    )
    
    // Create context with timeout
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    // Process a payment
    paymentReq := PaymentRequest{
        Amount:      99.99,
        Currency:    "USD",
        CustomerID:  "cust_123",
        Description: "Order #12345",
    }
    
    payment, err := client.ProcessPayment(ctx, paymentReq)
    if err != nil {
        fmt.Printf("Payment failed: %v\n", err)
        return
    }
    
    fmt.Printf("Payment successful!\n")
    fmt.Printf("Transaction ID: %s\n", payment.TransactionID)
    fmt.Printf("Status: %s\n", payment.Status)
    fmt.Printf("Amount: %.2f\n", payment.Amount)
    
    // Check payment status
    status, err := client.GetPaymentStatus(ctx, payment.TransactionID)
    if err != nil {
        fmt.Printf("Failed to get status: %v\n", err)
        return
    }
    
    fmt.Printf("Current status: %s\n", status.Status)
}
```

## HTTP Server {#http-server}

An HTTP server listens for incoming requests, processes them, and sends back responses. In Go, building an HTTP server is remarkably simple yet powerful enough for production use. Major companies run Go HTTP servers handling millions of requests per day.

### Understanding HTTP Servers

An HTTP server is like a restaurant. Clients (customers) send requests (orders), the server processes them (kitchen prepares food), and sends back responses (serves the food). Just as a restaurant can handle multiple customers simultaneously, a Go HTTP server can handle thousands of concurrent requests efficiently.

### Creating a Basic HTTP Server

Let's start with the simplest possible HTTP server:

```go
package main

import (
    "fmt"
    "net/http"
)

func main() {
    // Register a handler function for the root path
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Hello, World!")
    })
    
    // Start the server on port 8080
    fmt.Println("Server starting on http://localhost:8080")
    if err := http.ListenAndServe(":8080", nil); err != nil {
        fmt.Printf("Server failed to start: %v\n", err)
    }
}
```

This simple server does several things:

**Handler Registration**: `http.HandleFunc()` registers a function to handle requests to a specific path. When a request comes to "/", our function is called.

**Handler Function**: The handler receives two parameters: `http.ResponseWriter` (for writing the response) and `*http.Request` (containing the request details).

**Starting the Server**: `http.ListenAndServe()` starts the server. The first parameter is the address to listen on (":8080" means port 8080 on all network interfaces). The second parameter is the handler (nil means use the default multiplexer).

### The Handler Interface

Understanding handlers is crucial. A handler is anything that implements this interface:

```go
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
```

You can create handlers as functions (using `http.HandlerFunc`) or as types that implement this interface:

```go
package main

import (
    "fmt"
    "net/http"
)

// HomeHandler is a custom handler type
type HomeHandler struct {
    greeting string
}

// ServeHTTP makes HomeHandler implement http.Handler
func (h *HomeHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "%s! Welcome to our API\n", h.greeting)
}

// UserHandler handles user-related requests
type UserHandler struct {
    userCount int
}

func (h *UserHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    h.userCount++
    fmt.Fprintf(w, "Total users served: %d\n", h.userCount)
}

func main() {
    // Create handler instances
    homeHandler := &HomeHandler{greeting: "Hello"}
    userHandler := &UserHandler{}
    
    // Register handlers
    http.Handle("/", homeHandler)
    http.Handle("/users", userHandler)
    
    fmt.Println("Server starting on :8080")
    http.ListenAndServe(":8080", nil)
}
```

### Building a RESTful API

Let's build a complete RESTful API for managing users. This example demonstrates real-world patterns you'll use in production:

```go
package main

import (
    "encoding/json"
    "fmt"
    "net/http"
    "strconv"
    "strings"
    "sync"
    "time"
)

// User represents a user in our system
type User struct {
    ID        int       `json:"id"`
    Username  string    `json:"username"`
    Email     string    `json:"email"`
    CreatedAt time.Time `json:"created_at"`
}

// UserStore manages users in memory
type UserStore struct {
    mu      sync.RWMutex
    users   map[int]*User
    nextID  int
}

func NewUserStore() *UserStore {
    return &UserStore{
        users:  make(map[int]*User),
        nextID: 1,
    }
}

// Create adds a new user
func (s *UserStore) Create(username, email string) (*User, error) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    // Check if email already exists
    for _, user := range s.users {
        if user.Email == email {
            return nil, fmt.Errorf("email already exists")
        }
    }
    
    user := &User{
        ID:        s.nextID,
        Username:  username,
        Email:     email,
        CreatedAt: time.Now(),
    }
    
    s.users[s.nextID] = user
    s.nextID++
    
    return user, nil
}

// Get retrieves a user by ID
func (s *UserStore) Get(id int) (*User, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    user, exists := s.users[id]
    if !exists {
        return nil, fmt.Errorf("user not found")
    }
    
    return user, nil
}

// GetAll retrieves all users
func (s *UserStore) GetAll() []*User {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    users := make([]*User, 0, len(s.users))
    for _, user := range s.users {
        users = append(users, user)
    }
    
    return users
}

// Update updates a user
func (s *UserStore) Update(id int, username, email string) (*User, error) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    user, exists := s.users[id]
    if !exists {
        return nil, fmt.Errorf("user not found")
    }
    
    user.Username = username
    user.Email = email
    
    return user, nil
}

// Delete removes a user
func (s *UserStore) Delete(id int) error {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    if _, exists := s.users[id]; !exists {
        return fmt.Errorf("user not found")
    }
    
    delete(s.users, id)
    return nil
}

// UserServer handles HTTP requests for users
type UserServer struct {
    store *UserStore
}

func NewUserServer() *UserServer {
    return &UserServer{
        store: NewUserStore(),
    }
}

// ServeHTTP routes requests to appropriate handlers
func (s *UserServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // Set content type for all responses
    w.Header().Set("Content-Type", "application/json")
    
    // Route based on path and method
    switch {
    case r.URL.Path == "/api/users" && r.Method == http.MethodGet:
        s.handleGetUsers(w, r)
    case r.URL.Path == "/api/users" && r.Method == http.MethodPost:
        s.handleCreateUser(w, r)
    case strings.HasPrefix(r.URL.Path, "/api/users/") && r.Method == http.MethodGet:
        s.handleGetUser(w, r)
    case strings.HasPrefix(r.URL.Path, "/api/users/") && r.Method == http.MethodPut:
        s.handleUpdateUser(w, r)
    case strings.HasPrefix(r.URL.Path, "/api/users/") && r.Method == http.MethodDelete:
        s.handleDeleteUser(w, r)
    default:
        s.respondWithError(w, http.StatusNotFound, "endpoint not found")
    }
}

// handleGetUsers returns all users
func (s *UserServer) handleGetUsers(w http.ResponseWriter, r *http.Request) {
    users := s.store.GetAll()
    s.respondWithJSON(w, http.StatusOK, users)
}

// handleGetUser returns a specific user
func (s *UserServer) handleGetUser(w http.ResponseWriter, r *http.Request) {
    // Extract user ID from path
    id, err := s.extractUserID(r.URL.Path)
    if err != nil {
        s.respondWithError(w, http.StatusBadRequest, "invalid user ID")
        return
    }
    
    user, err := s.store.Get(id)
    if err != nil {
        s.respondWithError(w, http.StatusNotFound, err.Error())
        return
    }
    
    s.respondWithJSON(w, http.StatusOK, user)
}

// handleCreateUser creates a new user
func (s *UserServer) handleCreateUser(w http.ResponseWriter, r *http.Request) {
    var input struct {
        Username string `json:"username"`
        Email    string `json:"email"`
    }
    
    // Decode request body
    if err := json.NewDecoder(r.Body).Decode(&input); err != nil {
        s.respondWithError(w, http.StatusBadRequest, "invalid request body")
        return
    }
    
    // Validate input
    if input.Username == "" {
        s.respondWithError(w, http.StatusBadRequest, "username is required")
        return
    }
    if input.Email == "" {
        s.respondWithError(w, http.StatusBadRequest, "email is required")
        return
    }
    
    // Create user
    user, err := s.store.Create(input.Username, input.Email)
    if err != nil {
        s.respondWithError(w, http.StatusConflict, err.Error())
        return
    }
    
    s.respondWithJSON(w, http.StatusCreated, user)
}

// handleUpdateUser updates a user
func (s *UserServer) handleUpdateUser(w http.ResponseWriter, r *http.Request) {
    id, err := s.extractUserID(r.URL.Path)
    if err != nil {
        s.respondWithError(w, http.StatusBadRequest, "invalid user ID")
        return
    }
    
    var input struct {
        Username string `json:"username"`
        Email    string `json:"email"`
    }
    
    if err := json.NewDecoder(r.Body).Decode(&input); err != nil {
        s.respondWithError(w, http.StatusBadRequest, "invalid request body")
        return
    }
    
    user, err := s.store.Update(id, input.Username, input.Email)
    if err != nil {
        s.respondWithError(w, http.StatusNotFound, err.Error())
        return
    }
    
    s.respondWithJSON(w, http.StatusOK, user)
}

// handleDeleteUser deletes a user
func (s *UserServer) handleDeleteUser(w http.ResponseWriter, r *http.Request) {
    id, err := s.extractUserID(r.URL.Path)
    if err != nil {
        s.respondWithError(w, http.StatusBadRequest, "invalid user ID")
        return
    }
    
    if err := s.store.Delete(id); err != nil {
        s.respondWithError(w, http.StatusNotFound, err.Error())
        return
    }
    
    w.WriteHeader(http.StatusNoContent)
}

// Helper methods

func (s *UserServer) extractUserID(path string) (int, error) {
    // Path format: /api/users/123
    parts := strings.Split(path, "/")
    if len(parts) < 4 {
        return 0, fmt.Errorf("invalid path")
    }
    
    id, err := strconv.Atoi(parts[3])
    if err != nil {
        return 0, err
    }
    
    return id, nil
}

func (s *UserServer) respondWithJSON(w http.ResponseWriter, status int, data interface{}) {
    w.WriteHeader(status)
    json.NewEncoder(w).Encode(data)
}

func (s *UserServer) respondWithError(w http.ResponseWriter, status int, message string) {
    s.respondWithJSON(w, status, map[string]string{"error": message})
}

func main() {
    server := NewUserServer()
    
    fmt.Println("Server starting on http://localhost:8080")
    fmt.Println("Available endpoints:")
    fmt.Println("  GET    /api/users       - List all users")
    fmt.Println("  POST   /api/users       - Create a user")
    fmt.Println("  GET    /api/users/{id}  - Get a user")
    fmt.Println("  PUT    /api/users/{id}  - Update a user")
    fmt.Println("  DELETE /api/users/{id}  - Delete a user")
    
    if err := http.ListenAndServe(":8080", server); err != nil {
        fmt.Printf("Server error: %v\n", err)
    }
}
```

### Middleware

Middleware is code that runs before or after your handlers. It's perfect for cross-cutting concerns like logging, authentication, and CORS:

```go
package main

import (
    "fmt"
    "log"
    "net/http"
    "time"
)

// Middleware is a function that wraps a handler
type Middleware func(http.Handler) http.Handler

// LoggingMiddleware logs all requests
func LoggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // Log request
        log.Printf("Started %s %s", r.Method, r.URL.Path)
        
        // Call the next handler
        next.ServeHTTP(w, r)
        
        // Log completion
        log.Printf("Completed in %v", time.Since(start))
    })
}

// AuthMiddleware checks for authentication
func AuthMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Get token from header
        token := r.Header.Get("Authorization")
        
        if token == "" {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        
        // Validate token (simplified example)
        if !isValidToken(token) {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }
        
        // Token is valid, proceed
        next.ServeHTTP(w, r)
    })
}

// CORSMiddleware adds CORS headers
func CORSMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
        
        // Handle preflight request
        if r.Method == http.MethodOptions {
            w.WriteHeader(http.StatusOK)
            return
        }
        
        next.ServeHTTP(w, r)
    })
}

// RecoveryMiddleware recovers from panics
func RecoveryMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                log.Printf("Panic: %v", err)
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
            }
        }()
        
        next.ServeHTTP(w, r)
    })
}

// Chain applies multiple middleware
func Chain(h http.Handler, middleware ...Middleware) http.Handler {
    for i := len(middleware) - 1; i >= 0; i-- {
        h = middleware[i](h)
    }
    return h
}

func isValidToken(token string) bool {
    // Simplified validation
    return token == "Bearer valid-token"
}

func main() {
    // Create your handler
    handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Hello, authenticated user!")
    })
    
    // Apply middleware
    wrappedHandler := Chain(
        handler,
        RecoveryMiddleware,
        LoggingMiddleware,
        CORSMiddleware,
        AuthMiddleware,
    )
    
    http.Handle("/api/protected", wrappedHandler)
    
    // Public endpoint without auth
    publicHandler := Chain(
        http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            fmt.Fprintf(w, "Hello, public!")
        }),
        RecoveryMiddleware,
        LoggingMiddleware,
        CORSMiddleware,
    )
    
    http.Handle("/api/public", publicHandler)
    
    fmt.Println("Server starting on :8080")
    http.ListenAndServe(":8080", nil)
}
```

### Using ServeMux for Routing

The `http.ServeMux` is Go's built-in HTTP request multiplexer (router):

```go
package main

import (
    "encoding/json"
    "fmt"
    "net/http"
)

type Server struct {
    mux *http.ServeMux
}

func NewServer() *Server {
    s := &Server{
        mux: http.NewServeMux(),
    }
    
    // Register routes
    s.mux.HandleFunc("/", s.handleHome)
    s.mux.HandleFunc("/api/health", s.handleHealth)
    s.mux.HandleFunc("/api/users", s.handleUsers)
    s.mux.HandleFunc("/api/products", s.handleProducts)
    
    return s
}

func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    s.mux.ServeHTTP(w, r)
}

func (s *Server) handleHome(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Welcome to our API")
}

func (s *Server) handleHealth(w http.ResponseWriter, r *http.Request) {
    response := map[string]string{
        "status": "healthy",
    }
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}

func (s *Server) handleUsers(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
    case http.MethodGet:
        fmt.Fprintf(w, "Getting users")
    case http.MethodPost:
        fmt.Fprintf(w, "Creating user")
    default:
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}

func (s *Server) handleProducts(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
    case http.MethodGet:
        fmt.Fprintf(w, "Getting products")
    case http.MethodPost:
        fmt.Fprintf(w, "Creating product")
    default:
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}

func main() {
    server := NewServer()
    
    fmt.Println("Server starting on :8080")
    http.ListenAndServe(":8080", server)
}
```

### Handling File Uploads

```go
package main

import (
    "fmt"
    "io"
    "net/http"
    "os"
    "path/filepath"
)

func handleFileUpload(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }
    
    // Parse multipart form with 10MB max memory
    err := r.ParseMultipartForm(10 << 20)
    if err != nil {
        http.Error(w, "File too large", http.StatusBadRequest)
        return
    }
    
    // Get file from form
    file, header, err := r.FormFile("file")
    if err != nil {
        http.Error(w, "Error retrieving file", http.StatusBadRequest)
        return
    }
    defer file.Close()
    
    // Create uploads directory if it doesn't exist
    uploadDir := "./uploads"
    if err := os.MkdirAll(uploadDir, 0755); err != nil {
        http.Error(w, "Error creating upload directory", http.StatusInternalServerError)
        return
    }
    
    // Create destination file
    filename := filepath.Join(uploadDir, header.Filename)
    dst, err := os.Create(filename)
    if err != nil {
        http.Error(w, "Error creating file", http.StatusInternalServerError)
        return
    }
    defer dst.Close()
    
    // Copy file content
    if _, err := io.Copy(dst, file); err != nil {
        http.Error(w, "Error saving file", http.StatusInternalServerError)
        return
    }
    
    fmt.Fprintf(w, "File uploaded successfully: %s\n", header.Filename)
}

func main() {
    http.HandleFunc("/upload", handleFileUpload)
    
    fmt.Println("Server starting on :8080")
    http.ListenAndServe(":8080", nil)
}
```

### Graceful Shutdown

Production servers need to shut down gracefully:

```go
package main

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
)

func main() {
    // Create server
    server := &http.Server{
        Addr: ":8080",
        Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // Simulate slow handler
            time.Sleep(2 * time.Second)
            fmt.Fprintf(w, "Request completed")
        }),
        ReadTimeout:  10 * time.Second,
        WriteTimeout: 10 * time.Second,
        IdleTimeout:  60 * time.Second,
    }
    
    // Start server in a goroutine
    go func() {
        log.Println("Server starting on :8080")
        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatalf("Server error: %v", err)
        }
    }()
    
    // Wait for interrupt signal
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Println("Shutting down server...")
    
    // Create shutdown context with timeout
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    // Attempt graceful shutdown
    if err := server.Shutdown(ctx); err != nil {
        log.Fatalf("Server forced to shutdown: %v", err)
    }
    
    log.Println("Server stopped gracefully")
}
```

### HTTPS Server

For production, you should use HTTPS:

```go
package main

import (
    "fmt"
    "log"
    "net/http"
)

func main() {
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Secure connection!")
    })
    
    // Start HTTPS server
    log.Println("Starting HTTPS server on :443")
    err := http.ListenAndServeTLS(":443", "server.crt", "server.key", nil)
    if err != nil {
        log.Fatalf("Server error: %v", err)
    }
}
```

To generate self-signed certificates for testing:

```bash
openssl req -newkey rsa:2048 -nodes -keyout server.key -x509 -days 365 -out server.crt
```

## TCP Server {#tcp-server}

TCP (Transmission Control Protocol) is a lower-level protocol than HTTP. While HTTP is built on top of TCP, working directly with TCP gives you more control and flexibility. TCP servers are used for custom protocols, real-time applications like chat servers, game servers, and database connections.

### Understanding TCP

TCP provides reliable, ordered, connection-oriented communication. Think of it like a phone call:

**Connection-Oriented**: Before data can be sent, a connection must be established (like dialing a phone number and waiting for someone to answer).

**Reliable**: TCP guarantees that data arrives in order and without corruption. If packets are lost, they're automatically retransmitted.

**Bidirectional**: Once connected, both sides can send and receive data simultaneously (like a conversation).

**Stream-Based**: TCP treats data as a continuous stream of bytes, not as discrete messages. You need to define your own message boundaries.

### Creating a Basic TCP Server

Let's start with a simple echo server that sends back whatever it receives:

```go
package main

import (
    "bufio"
    "fmt"
    "log"
    "net"
)

func main() {
    // Listen on TCP port 8080 on all interfaces
    listener, err := net.Listen("tcp", ":8080")
    if err != nil {
        log.Fatalf("Failed to start server: %v", err)
    }
    defer listener.Close()
    
    log.Println("TCP server listening on :8080")
    
    // Accept connections in a loop
    for {
        conn, err := listener.Accept()
        if err != nil {
            log.Printf("Failed to accept connection: %v", err)
            continue
        }
        
        // Handle connection in a goroutine
        go handleConnection(conn)
    }
}

func handleConnection(conn net.Conn) {
    defer conn.Close()
    
    // Get client address
    clientAddr := conn.RemoteAddr().String()
    log.Printf("New connection from %s", clientAddr)
    
    // Create buffered reader for efficient reading
    reader := bufio.NewReader(conn)
    
    // Read and echo back data
    for {
        // Read until newline
        message, err := reader.ReadString('\n')
        if err != nil {
            log.Printf("Client %s disconnected: %v", clientAddr, err)
            return
        }
        
        log.Printf("Received from %s: %s", clientAddr, message)
        
        // Echo back to client
        _, err = conn.Write([]byte(message))
        if err != nil {
            log.Printf("Failed to write to %s: %v", clientAddr, err)
            return
        }
    }
}
```

You can test this server using telnet:

```bash
telnet localhost 8080
```

### Building a Chat Server

Let's build a more complex example - a multi-client chat server where messages are broadcast to all connected clients:

```go
package main

import (
    "bufio"
    "fmt"
    "log"
    "net"
    "strings"
    "sync"
    "time"
)

// Client represents a connected client
type Client struct {
    conn     net.Conn
    name     string
    outgoing chan string
}

// ChatServer manages all clients and message broadcasting
type ChatServer struct {
    clients    map[*Client]bool
    broadcast  chan string
    register   chan *Client
    unregister chan *Client
    mu         sync.RWMutex
}

func NewChatServer() *ChatServer {
    return &ChatServer{
        clients:    make(map[*Client]bool),
        broadcast:  make(chan string, 100),
        register:   make(chan *Client),
        unregister: make(chan *Client),
    }
}

// Run starts the chat server's main loop
func (s *ChatServer) Run() {
    for {
        select {
        case client := <-s.register:
            s.mu.Lock()
            s.clients[client] = true
            s.mu.Unlock()
            log.Printf("Client registered: %s", client.name)
            
            // Broadcast join message
            s.broadcast <- fmt.Sprintf("*** %s joined the chat ***", client.name)
            
        case client := <-s.unregister:
            s.mu.Lock()
            if _, ok := s.clients[client]; ok {
                delete(s.clients, client)
                close(client.outgoing)
            }
            s.mu.Unlock()
            log.Printf("Client unregistered: %s", client.name)
            
            // Broadcast leave message
            s.broadcast <- fmt.Sprintf("*** %s left the chat ***", client.name)
            
        case message := <-s.broadcast:
            s.mu.RLock()
            for client := range s.clients {
                select {
                case client.outgoing <- message:
                    // Message sent successfully
                default:
                    // Client's channel is full, skip
                    log.Printf("Failed to send to %s (channel full)", client.name)
                }
            }
            s.mu.RUnlock()
        }
    }
}

// HandleClient manages an individual client connection
func (s *ChatServer) HandleClient(conn net.Conn) {
    defer conn.Close()
    
    // Set read deadline for getting username
    conn.SetReadDeadline(time.Now().Add(30 * time.Second))
    
    // Ask for username
    conn.Write([]byte("Enter your name: "))
    reader := bufio.NewReader(conn)
    name, err := reader.ReadString('\n')
    if err != nil {
        log.Printf("Failed to read name: %v", err)
        return
    }
    name = strings.TrimSpace(name)
    
    // Create client
    client := &Client{
        conn:     conn,
        name:     name,
        outgoing: make(chan string, 10),
    }
    
    // Register client
    s.register <- client
    
    // Remove read deadline for regular operation
    conn.SetReadDeadline(time.Time{})
    
    // Start goroutine to write messages to client
    go s.writeMessages(client)
    
    // Send welcome message
    client.outgoing <- fmt.Sprintf("Welcome to the chat, %s!", name)
    client.outgoing <- "Type your messages and press Enter to send."
    
    // Read messages from client
    for {
        message, err := reader.ReadString('\n')
        if err != nil {
            log.Printf("Client %s read error: %v", name, err)
            break
        }
        
        message = strings.TrimSpace(message)
        if message == "" {
            continue
        }
        
        // Handle special commands
        if message == "/quit" {
            break
        }
        
        if message == "/users" {
            s.sendUserList(client)
            continue
        }
        
        // Broadcast message
        formattedMessage := fmt.Sprintf("[%s] %s", name, message)
        s.broadcast <- formattedMessage
    }
    
    // Unregister client
    s.unregister <- client
}

// writeMessages sends messages from the outgoing channel to the client
func (s *ChatServer) writeMessages(client *Client) {
    defer client.conn.Close()
    
    for message := range client.outgoing {
        _, err := client.conn.Write([]byte(message + "\n"))
        if err != nil {
            log.Printf("Failed to write to %s: %v", client.name, err)
            return
        }
    }
}

// sendUserList sends the list of connected users to a client
func (s *ChatServer) sendUserList(client *Client) {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    userList := "Connected users:\n"
    for c := range s.clients {
        userList += fmt.Sprintf("  - %s\n", c.name)
    }
    
    client.outgoing <- userList
}

func main() {
    // Create and start chat server
    server := NewChatServer()
    go server.Run()
    
    // Listen for connections
    listener, err := net.Listen("tcp", ":8080")
    if err != nil {
        log.Fatalf("Failed to start server: %v", err)
    }
    defer listener.Close()
    
    log.Println("Chat server listening on :8080")
    log.Println("Connect using: telnet localhost 8080")
    
    // Accept connections
    for {
        conn, err := listener.Accept()
        if err != nil {
            log.Printf("Failed to accept connection: %v", err)
            continue
        }
        
        go server.HandleClient(conn)
    }
}
```

### Custom Protocol Example: Request-Response Server

Let's build a server with a custom protocol for a key-value store:

```go
package main

import (
    "bufio"
    "fmt"
    "log"
    "net"
    "strings"
    "sync"
)

// Store is a thread-safe key-value store
type Store struct {
    mu   sync.RWMutex
    data map[string]string
}

func NewStore() *Store {
    return &Store{
        data: make(map[string]string),
    }
}

func (s *Store) Set(key, value string) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.data[key] = value
}

func (s *Store) Get(key string) (string, bool) {
    s.mu.RLock()
    defer s.mu.RUnlock()
    value, exists := s.data[key]
    return value, exists
}

func (s *Store) Delete(key string) bool {
    s.mu.Lock()
    defer s.mu.Unlock()
    if _, exists := s.data[key]; exists {
        delete(s.data, key)
        return true
    }
    return false
}

func (s *Store) Keys() []string {
    s.mu.RLock()
    defer s.mu.RUnlock()
    keys := make([]string, 0, len(s.data))
    for k := range s.data {
        keys = append(keys, k)
    }
    return keys
}

// KVServer handles key-value operations
type KVServer struct {
    store *Store
}

func NewKVServer() *KVServer {
    return &KVServer{
        store: NewStore(),
    }
}

// HandleClient processes commands from a client
func (s *KVServer) HandleClient(conn net.Conn) {
    defer conn.Close()
    
    clientAddr := conn.RemoteAddr().String()
    log.Printf("New connection from %s", clientAddr)
    
    // Send welcome message
    conn.Write([]byte("KV Store Server v1.0\n"))
    conn.Write([]byte("Available commands: SET, GET, DELETE, KEYS, QUIT\n"))
    conn.Write([]byte("Format: COMMAND [args...]\n\n"))
    
    scanner := bufio.NewScanner(conn)
    
    for scanner.Scan() {
        line := strings.TrimSpace(scanner.Text())
        if line == "" {
            continue
        }
        
        response := s.processCommand(line)
        conn.Write([]byte(response + "\n"))
        
        if strings.ToUpper(line) == "QUIT" {
            break
        }
    }
    
    if err := scanner.Err(); err != nil {
        log.Printf("Scanner error from %s: %v", clientAddr, err)
    }
    
    log.Printf("Connection closed: %s", clientAddr)
}

// processCommand parses and executes commands
func (s *KVServer) processCommand(command string) string {
    parts := strings.Fields(command)
    if len(parts) == 0 {
        return "ERROR: Empty command"
    }
    
    cmd := strings.ToUpper(parts[0])
    
    switch cmd {
    case "SET":
        if len(parts) < 3 {
            return "ERROR: SET requires key and value"
        }
        key := parts[1]
        value := strings.Join(parts[2:], " ")
        s.store.Set(key, value)
        return "OK"
        
    case "GET":
        if len(parts) < 2 {
            return "ERROR: GET requires key"
        }
        key := parts[1]
        value, exists := s.store.Get(key)
        if !exists {
            return "NULL"
        }
        return value
        
    case "DELETE":
        if len(parts) < 2 {
            return "ERROR: DELETE requires key"
        }
        key := parts[1]
        if s.store.Delete(key) {
            return "OK"
        }
        return "ERROR: Key not found"
        
    case "KEYS":
        keys := s.store.Keys()
        if len(keys) == 0 {
            return "No keys stored"
        }
        return strings.Join(keys, ", ")
        
    case "QUIT":
        return "Goodbye!"
        
    default:
        return fmt.Sprintf("ERROR: Unknown command '%s'", cmd)
    }
}

func main() {
    server := NewKVServer()
    
    listener, err := net.Listen("tcp", ":8080")
    if err != nil {
        log.Fatalf("Failed to start server: %v", err)
    }
    defer listener.Close()
    
    log.Println("KV Store server listening on :8080")
    
    for {
        conn, err := listener.Accept()
        if err != nil {
            log.Printf("Failed to accept connection: %v", err)
            continue
        }
        
        go server.HandleClient(conn)
    }
}
```

### Connection Timeouts and Deadlines

Managing timeouts is crucial for production servers:

```go
package main

import (
    "bufio"
    "fmt"
    "log"
    "net"
    "time"
)

func handleConnectionWithTimeout(conn net.Conn) {
    defer conn.Close()
    
    // Set overall connection deadline (30 seconds total)
    conn.SetDeadline(time.Now().Add(30 * time.Second))
    
    reader := bufio.NewReader(conn)
    
    for {
        // Set read deadline for this operation (5 seconds)
        conn.SetReadDeadline(time.Now().Add(5 * time.Second))
        
        message, err := reader.ReadString('\n')
        if err != nil {
            if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
                log.Println("Read timeout - closing connection")
            } else {
                log.Printf("Read error: %v", err)
            }
            return
        }
        
        // Set write deadline (5 seconds)
        conn.SetWriteDeadline(time.Now().Add(5 * time.Second))
        
        _, err = conn.Write([]byte(fmt.Sprintf("Echo: %s", message)))
        if err != nil {
            if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
                log.Println("Write timeout - closing connection")
            } else {
                log.Printf("Write error: %v", err)
            }
            return
        }
    }
}

func main() {
    listener, err := net.Listen("tcp", ":8080")
    if err != nil {
        log.Fatalf("Failed to start server: %v", err)
    }
    defer listener.Close()
    
    log.Println("Server listening on :8080")
    
    for {
        conn, err := listener.Accept()
        if err != nil {
            log.Printf("Accept error: %v", err)
            continue
        }
        
        go handleConnectionWithTimeout(conn)
    }
}
```

### Binary Protocol Example

For performance-critical applications, binary protocols are more efficient than text:

```go
package main

import (
    "encoding/binary"
    "fmt"
    "io"
    "log"
    "net"
)

// Message format:
// [4 bytes: message length][1 byte: message type][N bytes: payload]

const (
    MessageTypeEcho   byte = 0x01
    MessageTypePing   byte = 0x02
    MessageTypePong   byte = 0x03
    MessageTypeData   byte = 0x04
)

type Message struct {
    Type    byte
    Payload []byte
}

// WriteMessage sends a message over the connection
func WriteMessage(conn net.Conn, msg *Message) error {
    // Calculate total length (type + payload)
    length := uint32(1 + len(msg.Payload))
    
    // Write length (4 bytes)
    if err := binary.Write(conn, binary.BigEndian, length); err != nil {
        return fmt.Errorf("failed to write length: %w", err)
    }
    
    // Write message type (1 byte)
    if err := binary.Write(conn, binary.BigEndian, msg.Type); err != nil {
        return fmt.Errorf("failed to write type: %w", err)
    }
    
    // Write payload
    if len(msg.Payload) > 0 {
        if _, err := conn.Write(msg.Payload); err != nil {
            return fmt.Errorf("failed to write payload: %w", err)
        }
    }
    
    return nil
}

// ReadMessage reads a message from the connection
func ReadMessage(conn net.Conn) (*Message, error) {
    // Read length (4 bytes)
    var length uint32
    if err := binary.Read(conn, binary.BigEndian, &length); err != nil {
        return nil, fmt.Errorf("failed to read length: %w", err)
    }
    
    // Validate length
    if length > 1024*1024 { // Max 1MB
        return nil, fmt.Errorf("message too large: %d bytes", length)
    }
    
    // Read message type (1 byte)
    var msgType byte
    if err := binary.Read(conn, binary.BigEndian, &msgType); err != nil {
        return nil, fmt.Errorf("failed to read type: %w", err)
    }
    
    // Read payload
    payloadLength := length - 1 // Subtract type byte
    payload := make([]byte, payloadLength)
    if payloadLength > 0 {
        if _, err := io.ReadFull(conn, payload); err != nil {
            return nil, fmt.Errorf("failed to read payload: %w", err)
        }
    }
    
    return &Message{
        Type:    msgType,
        Payload: payload,
    }, nil
}

func handleBinaryConnection(conn net.Conn) {
    defer conn.Close()
    
    log.Printf("New connection from %s", conn.RemoteAddr())
    
    for {
        // Read message
        msg, err := ReadMessage(conn)
        if err != nil {
            log.Printf("Read error: %v", err)
            return
        }
        
        // Process message based on type
        switch msg.Type {
        case MessageTypeEcho:
            log.Printf("Echo request: %s", string(msg.Payload))
            // Send echo response
            if err := WriteMessage(conn, msg); err != nil {
                log.Printf("Write error: %v", err)
                return
            }
            
        case MessageTypePing:
            log.Println("Ping received")
            // Send pong
            pong := &Message{Type: MessageTypePong}
            if err := WriteMessage(conn, pong); err != nil {
                log.Printf("Write error: %v", err)
                return
            }
            
        case MessageTypeData:
            log.Printf("Data received: %d bytes", len(msg.Payload))
            // Process data...
            
        default:
            log.Printf("Unknown message type: 0x%02x", msg.Type)
        }
    }
}

func main() {
    listener, err := net.Listen("tcp", ":8080")
    if err != nil {
        log.Fatalf("Failed to start server: %v", err)
    }
    defer listener.Close()
    
    log.Println("Binary protocol server listening on :8080")
    
    for {
        conn, err := listener.Accept()
        if err != nil {
            log.Printf("Accept error: %v", err)
            continue
        }
        
        go handleBinaryConnection(conn)
    }
}
```

---

## Advanced Networking Concepts {#advanced-concepts}

### Context for Cancellation

Use context to cancel long-running operations:

```go
package main

import (
    "context"
    "fmt"
    "io"
    "net/http"
    "time"
)

func makeRequestWithContext(ctx context.Context, url string) error {
    // Create request with context
    req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
    if err != nil {
        return err
    }
    
    // Make request
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    // Read response
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return err
    }
    
    fmt.Printf("Response: %s\n", string(body))
    return nil
}

func main() {
    // Create context with timeout
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    // Make request
    if err := makeRequestWithContext(ctx, "http://example.com"); err != nil {
        fmt.Printf("Request failed: %v\n", err)
    }
}
```

### Connection Pooling

Reusing connections improves performance:

```go
package main

import (
    "net"
    "net/http"
    "time"
)

func createOptimizedHTTPClient() *http.Client {
    transport := &http.Transport{
        // Connection pool settings
        MaxIdleConns:        100,
        MaxIdleConnsPerHost: 10,
        MaxConnsPerHost:     100,
        IdleConnTimeout:     90 * time.Second,
        
        // Timeouts
        DialContext: (&net.Dialer{
            Timeout:   30 * time.Second,
            KeepAlive: 30 * time.Second,
        }).DialContext,
        TLSHandshakeTimeout:   10 * time.Second,
        ResponseHeaderTimeout: 10 * time.Second,
        ExpectContinueTimeout: 1 * time.Second,
    }
    
    return &http.Client{
        Transport: transport,
        Timeout:   30 * time.Second,
    }
}
```

### Rate Limiting

Control request rates to protect your services:

```go
package main

import (
    "fmt"
    "net/http"
    "sync"
    "time"
)

type RateLimiter struct {
    requests map[string]*clientLimit
    mu       sync.RWMutex
    rate     int
    window   time.Duration
}

type clientLimit struct {
    count     int
    resetTime time.Time
}

func NewRateLimiter(rate int, window time.Duration) *RateLimiter {
    return &RateLimiter{
        requests: make(map[string]*clientLimit),
        rate:     rate,
        window:   window,
    }
}

func (rl *RateLimiter) Allow(clientIP string) bool {
    rl.mu.Lock()
    defer rl.mu.Unlock()
    
    now := time.Now()
    
    limit, exists := rl.requests[clientIP]
    if !exists || now.After(limit.resetTime) {
        rl.requests[clientIP] = &clientLimit{
            count:     1,
            resetTime: now.Add(rl.window),
        }
        return true
    }
    
    if limit.count < rl.rate {
        limit.count++
        return true
    }
    
    return false
}

func RateLimitMiddleware(limiter *RateLimiter) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            clientIP := r.RemoteAddr
            
            if !limiter.Allow(clientIP) {
                w.Header().Set("X-RateLimit-Limit", fmt.Sprintf("%d", limiter.rate))
                w.Header().Set("X-RateLimit-Remaining", "0")
                http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
                return
            }
            
            next.ServeHTTP(w, r)
        })
    }
}
```

---

## Best Practices {#best-practices}

### 1. Always Set Timeouts

Never leave timeouts at their defaults:

```go
client := &http.Client{
    Timeout: 30 * time.Second,
    Transport: &http.Transport{
        DialContext: (&net.Dialer{
            Timeout:   10 * time.Second,
            KeepAlive: 30 * time.Second,
        }).DialContext,
        TLSHandshakeTimeout:   10 * time.Second,
        ResponseHeaderTimeout: 10 * time.Second,
    },
}
```

### 2. Close Response Bodies

Always close response bodies to prevent resource leaks:

```go
resp, err := http.Get(url)
if err != nil {
    return err
}
defer resp.Body.Close() // Always defer close

body, err := io.ReadAll(resp.Body)
```

### 3. Use Context for Cancellation

Pass context through your call chain:

```go
func fetchData(ctx context.Context, url string) error {
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return err
    }
    
    resp, err := http.DefaultClient.Do(req)
    // ... handle response
}
```

### 4. Handle Errors Properly

Check and handle all network errors:

```go
resp, err := client.Do(req)
if err != nil {
    // Network error or timeout
    return fmt.Errorf("request failed: %w", err)
}
defer resp.Body.Close()

if resp.StatusCode != http.StatusOK {
    // HTTP error
    body, _ := io.ReadAll(resp.Body)
    return fmt.Errorf("bad status %d: %s", resp.StatusCode, body)
}
```

### 5. Use Structured Logging

Log with context for debugging:

```go
log.Printf("[%s] %s %s - Status: %d, Duration: %v",
    requestID,
    r.Method,
    r.URL.Path,
    statusCode,
    duration,
)
```

### 6. Implement Graceful Shutdown

Allow in-flight requests to complete:

```go
server := &http.Server{Addr: ":8080"}

go func() {
    if err := server.ListenAndServe(); err != http.ErrServerClosed {
        log.Fatal(err)
    }
}()

// Wait for signal
<-quit

ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
defer cancel()

server.Shutdown(ctx)
```

### 7. Use Connection Pooling

Reuse HTTP connections:

```go
// DO: Reuse client
var client = &http.Client{Timeout: 30 * time.Second}

func makeRequest() {
    resp, _ := client.Get(url)
    // ...
}

// DON'T: Create new client each time
func badMakeRequest() {
    client := &http.Client{}
    resp, _ := client.Get(url)
    // ...
}
```

### 8. Validate Input

Always validate data from the network:

```go
func handleCreate(w http.ResponseWriter, r *http.Request) {
    var input struct {
        Email string `json:"email"`
        Age   int    `json:"age"`
    }
    
    if err := json.NewDecoder(r.Body).Decode(&input); err != nil {
        http.Error(w, "Invalid JSON", http.StatusBadRequest)
        return
    }
    
    if !isValidEmail(input.Email) {
        http.Error(w, "Invalid email", http.StatusBadRequest)
        return
    }
    
    if input.Age < 0 || input.Age > 150 {
        http.Error(w, "Invalid age", http.StatusBadRequest)
        return
    }
    
    // Process valid input...
}
```

---

## Summary

Go provides powerful networking capabilities:

**HTTP Client**: Simple yet flexible for API communication **HTTP Server**: Production-ready with minimal code **TCP Server**: Full control for custom protocols **Best Practices**: Timeouts, error handling, graceful shutdown

Key takeaways:

- Always set timeouts
- Handle errors properly
- Use context for cancellation
- Close resources with defer
- Pool connections for performance
- Validate all network input
- Log structured information
- Test thoroughly

With Go's networking packages, you can build everything from simple web services to complex distributed systems efficiently and reliably.