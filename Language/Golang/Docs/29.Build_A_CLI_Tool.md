# Building a CLI Tool in Go: A Complete Guide

## ğŸ“š Introduction

A Command Line Interface (CLI) tool is a program that you run from your terminal to perform tasks. In this guide, we'll build a CLI tool that can handle database migrations, seed data, run tests, and more for your Go projects.

## ğŸ¯ What You'll Learn

- How to structure a CLI application in Go
- Using the Cobra library for building CLI commands
- Managing database migrations
- Running seeds and tests
- Building a production-ready tool

---

## ğŸ“¦ Chapter 1: Project Setup

### Step 1: Initialize Your Project

```bash
# Create a new directory
mkdir myapp-cli
cd myapp-cli

# Initialize Go module
go mod init github.com/yourusername/myapp-cli
```

### Step 2: Install Required Libraries

```bash
# Cobra - For building CLI commands
go get -u github.com/spf13/cobra@latest

# Viper - For configuration management
go get -u github.com/spf13/viper@latest

# Additional useful libraries
go get -u github.com/joho/godotenv      # Load .env files
go get -u github.com/lib/pq             # PostgreSQL driver
go get -u go.mongodb.org/mongo-driver/mongo  # MongoDB driver
```

---

## ğŸ—ï¸ Chapter 2: Project Structure

Create this folder structure:

```
myapp-cli/
â”œâ”€â”€ cmd/
â”‚   â”œâ”€â”€ root.go          # Root command
â”‚   â”œâ”€â”€ migrate.go       # Migration commands
â”‚   â”œâ”€â”€ seed.go          # Seed commands
â”‚   â””â”€â”€ test.go          # Test commands
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â”œâ”€â”€ connection.go
â”‚   â”‚   â””â”€â”€ migrations.go
â”‚   â”œâ”€â”€ seeds/
â”‚   â”‚   â””â”€â”€ seeds.go
â”‚   â””â”€â”€ config/
â”‚       â””â”€â”€ config.go
â”œâ”€â”€ migrations/          # SQL migration files
â”œâ”€â”€ seeds/              # Seed data files
â”œâ”€â”€ main.go             # Entry point
â”œâ”€â”€ .env.example        # Example environment variables
â””â”€â”€ go.mod
```

---

## ğŸ¬ Chapter 3: Building the Main Entry Point

### main.go

```go
package main

import (
    "github.com/yourusername/myapp-cli/cmd"
)

func main() {
    cmd.Execute()
}
```

---

## ğŸ¯ Chapter 4: Creating the Root Command

### cmd/root.go

```go
package cmd

import (
    "fmt"
    "os"
    
    "github.com/spf13/cobra"
    "github.com/joho/godotenv"
)

var rootCmd = &cobra.Command{
    Use:   "myapp",
    Short: "MyApp CLI - Database migrations, seeds, and testing tool",
    Long: `A complete CLI tool for managing your application's database migrations,
running seeds, executing tests, and more.`,
}

// Execute runs the root command
func Execute() {
    if err := rootCmd.Execute(); err != nil {
        fmt.Println(err)
        os.Exit(1)
    }
}

func init() {
    // Load environment variables
    godotenv.Load()
    
    // Add global flags
    rootCmd.PersistentFlags().StringP("env", "e", "development", "Environment (development, staging, production)")
    rootCmd.PersistentFlags().StringP("config", "c", "", "Config file path")
}
```

---

## ğŸ”„ Chapter 5: Database Migration Commands

### cmd/migrate.go

```go
package cmd

import (
    "fmt"
    
    "github.com/spf13/cobra"
    "github.com/yourusername/myapp-cli/internal/database"
)

var migrateCmd = &cobra.Command{
    Use:   "migrate",
    Short: "Database migration commands",
    Long:  "Manage database migrations - create, run, rollback",
}

var migrateUpCmd = &cobra.Command{
    Use:   "up",
    Short: "Run all pending migrations",
    Long:  "Apply all pending database migrations to bring the database up to date",
    Run: func(cmd *cobra.Command, args []string) {
        fmt.Println("ğŸš€ Running migrations...")
        
        db, err := database.Connect()
        if err != nil {
            fmt.Printf("âŒ Error connecting to database: %v\n", err)
            return
        }
        defer db.Close()
        
        err = database.MigrateUp(db)
        if err != nil {
            fmt.Printf("âŒ Migration failed: %v\n", err)
            return
        }
        
        fmt.Println("âœ… Migrations completed successfully!")
    },
}

var migrateDownCmd = &cobra.Command{
    Use:   "down",
    Short: "Rollback the last migration",
    Long:  "Rollback the most recent database migration",
    Run: func(cmd *cobra.Command, args []string) {
        fmt.Println("ğŸ”„ Rolling back migration...")
        
        db, err := database.Connect()
        if err != nil {
            fmt.Printf("âŒ Error connecting to database: %v\n", err)
            return
        }
        defer db.Close()
        
        err = database.MigrateDown(db)
        if err != nil {
            fmt.Printf("âŒ Rollback failed: %v\n", err)
            return
        }
        
        fmt.Println("âœ… Rollback completed successfully!")
    },
}

var migrateCreateCmd = &cobra.Command{
    Use:   "create [name]",
    Short: "Create a new migration file",
    Long:  "Generate a new migration file with timestamp",
    Args:  cobra.ExactArgs(1),
    Run: func(cmd *cobra.Command, args []string) {
        migrationName := args[0]
        fmt.Printf("ğŸ“ Creating migration: %s\n", migrationName)
        
        err := database.CreateMigration(migrationName)
        if err != nil {
            fmt.Printf("âŒ Error creating migration: %v\n", err)
            return
        }
        
        fmt.Println("âœ… Migration file created successfully!")
    },
}

var migrateStatusCmd = &cobra.Command{
    Use:   "status",
    Short: "Show migration status",
    Long:  "Display which migrations have been applied",
    Run: func(cmd *cobra.Command, args []string) {
        fmt.Println("ğŸ“Š Migration Status:")
        
        db, err := database.Connect()
        if err != nil {
            fmt.Printf("âŒ Error connecting to database: %v\n", err)
            return
        }
        defer db.Close()
        
        database.ShowMigrationStatus(db)
    },
}

func init() {
    rootCmd.AddCommand(migrateCmd)
    migrateCmd.AddCommand(migrateUpCmd)
    migrateCmd.AddCommand(migrateDownCmd)
    migrateCmd.AddCommand(migrateCreateCmd)
    migrateCmd.AddCommand(migrateStatusCmd)
    
    // Add flags
    migrateUpCmd.Flags().IntP("steps", "s", 0, "Number of migrations to run (0 = all)")
    migrateDownCmd.Flags().IntP("steps", "s", 1, "Number of migrations to rollback")
}
```

---

## ğŸŒ± Chapter 6: Seed Commands

### cmd/seed.go

```go
package cmd

import (
    "fmt"
    
    "github.com/spf13/cobra"
    "github.com/yourusername/myapp-cli/internal/database"
    "github.com/yourusername/myapp-cli/internal/seeds"
)

var seedCmd = &cobra.Command{
    Use:   "seed",
    Short: "Database seeding commands",
    Long:  "Populate database with seed data",
}

var seedRunCmd = &cobra.Command{
    Use:   "run",
    Short: "Run all seeders",
    Long:  "Execute all seed files to populate the database",
    Run: func(cmd *cobra.Command, args []string) {
        fmt.Println("ğŸŒ± Running seeds...")
        
        db, err := database.Connect()
        if err != nil {
            fmt.Printf("âŒ Error connecting to database: %v\n", err)
            return
        }
        defer db.Close()
        
        err = seeds.RunAll(db)
        if err != nil {
            fmt.Printf("âŒ Seeding failed: %v\n", err)
            return
        }
        
        fmt.Println("âœ… Seeds completed successfully!")
    },
}

var seedCreateCmd = &cobra.Command{
    Use:   "create [name]",
    Short: "Create a new seed file",
    Long:  "Generate a new seed file template",
    Args:  cobra.ExactArgs(1),
    Run: func(cmd *cobra.Command, args []string) {
        seedName := args[0]
        fmt.Printf("ğŸ“ Creating seed: %s\n", seedName)
        
        err := seeds.CreateSeed(seedName)
        if err != nil {
            fmt.Printf("âŒ Error creating seed: %v\n", err)
            return
        }
        
        fmt.Println("âœ… Seed file created successfully!")
    },
}

func init() {
    rootCmd.AddCommand(seedCmd)
    seedCmd.AddCommand(seedRunCmd)
    seedCmd.AddCommand(seedCreateCmd)
    
    // Add flags
    seedRunCmd.Flags().StringP("file", "f", "", "Run specific seed file")
    seedRunCmd.Flags().BoolP("fresh", "", false, "Drop all tables and run seeds")
}
```

---

## ğŸ§ª Chapter 7: Test Runner Commands

### cmd/test.go

```go
package cmd

import (
    "fmt"
    "os"
    "os/exec"
    
    "github.com/spf13/cobra"
)

var testCmd = &cobra.Command{
    Use:   "test",
    Short: "Run tests",
    Long:  "Execute test suites with various options",
}

var testRunCmd = &cobra.Command{
    Use:   "run",
    Short: "Run all tests",
    Long:  "Execute all test suites",
    Run: func(cmd *cobra.Command, args []string) {
        fmt.Println("ğŸ§ª Running tests...")
        
        verbose, _ := cmd.Flags().GetBool("verbose")
        coverage, _ := cmd.Flags().GetBool("coverage")
        
        cmdArgs := []string{"test", "./..."}
        
        if verbose {
            cmdArgs = append(cmdArgs, "-v")
        }
        
        if coverage {
            cmdArgs = append(cmdArgs, "-coverprofile=coverage.out")
        }
        
        testCmd := exec.Command("go", cmdArgs...)
        testCmd.Stdout = os.Stdout
        testCmd.Stderr = os.Stderr
        
        err := testCmd.Run()
        if err != nil {
            fmt.Printf("âŒ Tests failed: %v\n", err)
            return
        }
        
        if coverage {
            fmt.Println("\nğŸ“Š Generating coverage report...")
            exec.Command("go", "tool", "cover", "-html=coverage.out", "-o", "coverage.html").Run()
            fmt.Println("âœ… Coverage report generated: coverage.html")
        }
        
        fmt.Println("âœ… All tests passed!")
    },
}

var testUnitCmd = &cobra.Command{
    Use:   "unit",
    Short: "Run unit tests only",
    Run: func(cmd *cobra.Command, args []string) {
        fmt.Println("ğŸ§ª Running unit tests...")
        testCmd := exec.Command("go", "test", "-short", "./...")
        testCmd.Stdout = os.Stdout
        testCmd.Stderr = os.Stderr
        testCmd.Run()
    },
}

var testIntegrationCmd = &cobra.Command{
    Use:   "integration",
    Short: "Run integration tests only",
    Run: func(cmd *cobra.Command, args []string) {
        fmt.Println("ğŸ§ª Running integration tests...")
        testCmd := exec.Command("go", "test", "-run", "Integration", "./...")
        testCmd.Stdout = os.Stdout
        testCmd.Stderr = os.Stderr
        testCmd.Run()
    },
}

func init() {
    rootCmd.AddCommand(testCmd)
    testCmd.AddCommand(testRunCmd)
    testCmd.AddCommand(testUnitCmd)
    testCmd.AddCommand(testIntegrationCmd)
    
    // Add flags
    testRunCmd.Flags().BoolP("verbose", "v", false, "Verbose output")
    testRunCmd.Flags().BoolP("coverage", "c", false, "Generate coverage report")
}
```

---

## ğŸ”Œ Chapter 8: Database Connection

### internal/database/connection.go

```go
package database

import (
    "database/sql"
    "fmt"
    "os"
    
    _ "github.com/lib/pq"
)

// Connect establishes a database connection
func Connect() (*sql.DB, error) {
    // Get database configuration from environment
    host := os.Getenv("DB_HOST")
    port := os.Getenv("DB_PORT")
    user := os.Getenv("DB_USER")
    password := os.Getenv("DB_PASSWORD")
    dbname := os.Getenv("DB_NAME")
    
    // Build connection string
    connStr := fmt.Sprintf(
        "host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
        host, port, user, password, dbname,
    )
    
    // Open database connection
    db, err := sql.Open("postgres", connStr)
    if err != nil {
        return nil, fmt.Errorf("failed to open database: %w", err)
    }
    
    // Test connection
    if err := db.Ping(); err != nil {
        return nil, fmt.Errorf("failed to ping database: %w", err)
    }
    
    fmt.Println("âœ… Database connected successfully")
    return db, nil
}
```

---

## ğŸ”„ Chapter 9: Migration Management

### internal/database/migrations.go

```go
package database

import (
    "database/sql"
    "fmt"
    "io/ioutil"
    "os"
    "path/filepath"
    "sort"
    "strings"
    "time"
)

// MigrateUp runs all pending migrations
func MigrateUp(db *sql.DB) error {
    // Create migrations table if it doesn't exist
    if err := createMigrationsTable(db); err != nil {
        return err
    }
    
    // Get all migration files
    files, err := getMigrationFiles()
    if err != nil {
        return err
    }
    
    // Get applied migrations
    applied, err := getAppliedMigrations(db)
    if err != nil {
        return err
    }
    
    // Run pending migrations
    for _, file := range files {
        if !contains(applied, file) {
            fmt.Printf("  Running migration: %s\n", file)
            if err := runMigration(db, file, "up"); err != nil {
                return err
            }
        }
    }
    
    return nil
}

// MigrateDown rolls back the last migration
func MigrateDown(db *sql.DB) error {
    // Get applied migrations
    applied, err := getAppliedMigrations(db)
    if err != nil {
        return err
    }
    
    if len(applied) == 0 {
        fmt.Println("No migrations to rollback")
        return nil
    }
    
    // Get the last migration
    lastMigration := applied[len(applied)-1]
    fmt.Printf("  Rolling back: %s\n", lastMigration)
    
    return runMigration(db, lastMigration, "down")
}

// CreateMigration creates a new migration file
func CreateMigration(name string) error {
    timestamp := time.Now().Format("20060102150405")
    filename := fmt.Sprintf("%s_%s", timestamp, name)
    
    // Create migrations directory if it doesn't exist
    if err := os.MkdirAll("migrations", 0755); err != nil {
        return err
    }
    
    // Create up migration file
    upFile := filepath.Join("migrations", filename+"_up.sql")
    upContent := fmt.Sprintf("-- Migration: %s (UP)\n-- Created at: %s\n\n-- Write your UP migration here\n", name, time.Now().Format("2006-01-02 15:04:05"))
    if err := ioutil.WriteFile(upFile, []byte(upContent), 0644); err != nil {
        return err
    }
    
    // Create down migration file
    downFile := filepath.Join("migrations", filename+"_down.sql")
    downContent := fmt.Sprintf("-- Migration: %s (DOWN)\n-- Created at: %s\n\n-- Write your DOWN migration here\n", name, time.Now().Format("2006-01-02 15:04:05"))
    if err := ioutil.WriteFile(downFile, []byte(downContent), 0644); err != nil {
        return err
    }
    
    fmt.Printf("  Created: %s\n", upFile)
    fmt.Printf("  Created: %s\n", downFile)
    
    return nil
}

// ShowMigrationStatus displays the status of all migrations
func ShowMigrationStatus(db *sql.DB) {
    files, _ := getMigrationFiles()
    applied, _ := getAppliedMigrations(db)
    
    fmt.Println("\n  Migration                           Status")
    fmt.Println("  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”€â”€â”€â”€â”€â”€")
    
    for _, file := range files {
        status := "âŒ Pending"
        if contains(applied, file) {
            status = "âœ… Applied"
        }
        fmt.Printf("  %-35s %s\n", file, status)
    }
    fmt.Println()
}

// Helper functions

func createMigrationsTable(db *sql.DB) error {
    query := `
    CREATE TABLE IF NOT EXISTS migrations (
        id SERIAL PRIMARY KEY,
        migration VARCHAR(255) NOT NULL UNIQUE,
        applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )`
    
    _, err := db.Exec(query)
    return err
}

func getMigrationFiles() ([]string, error) {
    files, err := ioutil.ReadDir("migrations")
    if err != nil {
        return nil, err
    }
    
    var migrations []string
    seen := make(map[string]bool)
    
    for _, file := range files {
        if strings.HasSuffix(file.Name(), "_up.sql") {
            baseName := strings.TrimSuffix(file.Name(), "_up.sql")
            if !seen[baseName] {
                migrations = append(migrations, baseName)
                seen[baseName] = true
            }
        }
    }
    
    sort.Strings(migrations)
    return migrations, nil
}

func getAppliedMigrations(db *sql.DB) ([]string, error) {
    rows, err := db.Query("SELECT migration FROM migrations ORDER BY id")
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var migrations []string
    for rows.Next() {
        var migration string
        if err := rows.Scan(&migration); err != nil {
            return nil, err
        }
        migrations = append(migrations, migration)
    }
    
    return migrations, nil
}

func runMigration(db *sql.DB, migration string, direction string) error {
    // Read migration file
    filename := filepath.Join("migrations", fmt.Sprintf("%s_%s.sql", migration, direction))
    content, err := ioutil.ReadFile(filename)
    if err != nil {
        return err
    }
    
    // Execute migration
    if _, err := db.Exec(string(content)); err != nil {
        return err
    }
    
    // Update migrations table
    if direction == "up" {
        _, err = db.Exec("INSERT INTO migrations (migration) VALUES ($1)", migration)
    } else {
        _, err = db.Exec("DELETE FROM migrations WHERE migration = $1", migration)
    }
    
    return err
}

func contains(slice []string, item string) bool {
    for _, s := range slice {
        if s == item {
            return true
        }
    }
    return false
}
```

---

## ğŸŒ± Chapter 10: Seed Management

### internal/seeds/seeds.go

```go
package seeds

import (
    "database/sql"
    "fmt"
    "io/ioutil"
    "os"
    "path/filepath"
    "time"
)

// RunAll executes all seed files
func RunAll(db *sql.DB) error {
    files, err := getSeedFiles()
    if err != nil {
        return err
    }
    
    for _, file := range files {
        fmt.Printf("  Running seed: %s\n", file)
        if err := runSeed(db, file); err != nil {
            return fmt.Errorf("failed to run seed %s: %w", file, err)
        }
    }
    
    return nil
}

// CreateSeed creates a new seed file template
func CreateSeed(name string) error {
    timestamp := time.Now().Format("20060102150405")
    filename := fmt.Sprintf("%s_%s.sql", timestamp, name)
    
    // Create seeds directory if it doesn't exist
    if err := os.MkdirAll("seeds", 0755); err != nil {
        return err
    }
    
    filepath := filepath.Join("seeds", filename)
    content := fmt.Sprintf(`-- Seed: %s
-- Created at: %s

-- Example seed data
-- INSERT INTO users (name, email) VALUES 
--   ('John Doe', 'john@example.com'),
--   ('Jane Smith', 'jane@example.com');
`, name, time.Now().Format("2006-01-02 15:04:05"))
    
    if err := ioutil.WriteFile(filepath, []byte(content), 0644); err != nil {
        return err
    }
    
    fmt.Printf("  Created: %s\n", filepath)
    return nil
}

// Helper functions

func getSeedFiles() ([]string, error) {
    files, err := ioutil.ReadDir("seeds")
    if err != nil {
        return nil, err
    }
    
    var seeds []string
    for _, file := range files {
        if filepath.Ext(file.Name()) == ".sql" {
            seeds = append(seeds, file.Name())
        }
    }
    
    return seeds, nil
}

func runSeed(db *sql.DB, filename string) error {
    filepath := filepath.Join("seeds", filename)
    content, err := ioutil.ReadFile(filepath)
    if err != nil {
        return err
    }
    
    _, err = db.Exec(string(content))
    return err
}
```

---

## ğŸ“ Chapter 11: Configuration File

### .env.example

```env
# Database Configuration
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=password
DB_NAME=myapp_dev

# Application
APP_ENV=development
APP_PORT=8080
```

---

## ğŸš€ Chapter 12: Building and Using Your CLI

### Build the CLI

```bash
# Build for your current platform
go build -o myapp-cli

# Build for multiple platforms
GOOS=linux GOARCH=amd64 go build -o myapp-cli-linux
GOOS=darwin GOARCH=amd64 go build -o myapp-cli-mac
GOOS=windows GOARCH=amd64 go build -o myapp-cli.exe
```

### Using Your CLI

```bash
# Show help
./myapp-cli --help

# Migration commands
./myapp-cli migrate up              # Run all migrations
./myapp-cli migrate down            # Rollback last migration
./myapp-cli migrate create add_users_table
./myapp-cli migrate status          # Show migration status

# Seed commands
./myapp-cli seed run                # Run all seeds
./myapp-cli seed create users       # Create new seed file

# Test commands
./myapp-cli test run                # Run all tests
./myapp-cli test run --verbose      # Run with verbose output
./myapp-cli test run --coverage     # Run with coverage report
./myapp-cli test unit               # Run unit tests only
./myapp-cli test integration        # Run integration tests only
```

---

## ğŸ¨ Chapter 13: Visual Command Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      myapp-cli (root)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                 â”‚                 â”‚
            â–¼                 â–¼                 â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  migrate  â”‚     â”‚   seed    â”‚     â”‚   test    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                 â”‚                 â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”
    â”‚       â”‚       â”‚ â”‚       â”‚       â”‚ â”‚       â”‚       â”‚
    â–¼       â–¼       â–¼ â–¼       â–¼       â–¼ â–¼       â–¼       â–¼
  â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”
  â”‚ up â”‚ â”‚downâ”‚ â”‚createâ”‚run â”‚       â”‚ runâ”‚ â”‚unitâ”‚ â”‚intgâ”‚
  â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜
                  â”‚createâ”‚
                  â””â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“‹ Chapter 14: Example Migration File

### migrations/20240101120000_create_users_table_up.sql

```sql
-- Migration: create_users_table (UP)

CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);
```

### migrations/20240101120000_create_users_table_down.sql

```sql
-- Migration: create_users_table (DOWN)

DROP TABLE IF EXISTS users;
```

---

## ğŸŒ± Chapter 15: Example Seed File

### seeds/20240101120000_users.sql

```sql
-- Seed: users

INSERT INTO users (name, email, password_hash) VALUES 
    ('Admin User', 'admin@example.com', '$2a$10$abcdefghijklmnopqrstuvwxyz'),
    ('Test User', 'test@example.com', '$2a$10$abcdefghijklmnopqrstuvwxyz'),
    ('Demo User', 'demo@example.com', '$2a$10$abcdefghijklmnopqrstuvwxyz');
```

---

## ğŸ¯ Chapter 16: Advanced Features

### Adding More Commands

You can easily extend your CLI with more commands:

```go
// cmd/db.go - Database utilities
var dbCmd = &cobra.Command{
    Use:   "db",
    Short: "Database utility commands",
}

var dbResetCmd = &cobra.Command{
    Use:   "reset",
    Short: "Drop and recreate database",
    Run: func(cmd *cobra.Command, args []string) {
        // Drop all tables
        // Run migrations
        // Run seeds
    },
}

// cmd/generate.go - Code generation
var generateCmd = &cobra.Command{
    Use:   "generate",
    Short: "Generate code templates",
}

var generateModelCmd = &cobra.Command{
    Use:   "model [name]",
    Short: "Generate a new model",
    Args:  cobra.ExactArgs(1),
    Run: func(cmd *cobra.Command, args []string) {
        // Generate model file
    },
}
```

---

## ğŸ”§ Chapter 17: Best Practices

### 1. Error Handling

Always handle errors properly and provide meaningful messages:

```go
if err != nil {
    return fmt.Errorf("failed to connect to database: %w", err)
}
```

### 2. Environment Variables

Use different configurations for different environments:

```go
env := os.Getenv("APP_ENV")
if env == "production" {
    // Production settings
} else {
    // Development settings
}
```

### 3. Logging

Add proper logging for debugging:

```go
import "log"

log.Printf("Running migration: %s", migrationName)
```

### 4. Testing

Write tests for your CLI commands:

```go
func TestMigrateUp(t *testing.T) {
    // Test migration logic
}
```

---

## ğŸ“¦ Chapter 18: Distribution

### Install Globally

```bash
# Install to GOPATH/bin
go install

# Now you can use it anywhere
myapp-cli migrate up
```

### Create Makefile

```makefile
# Makefile
build:
	go build -o myapp-cli

install:
	go install

test:
	go test ./...

clean:
	rm -f myapp-cli

migrate-up:
	./myapp-cli migrate up

migrate-down:
	./myapp-cli migrate down

seed:
	./myapp-cli seed run
```

---

## ğŸ“ Conclusion

You now have a fully functional CLI tool for your Go project! This tool can:

âœ… Run database migrations  
âœ… Create new migrations  
âœ… Seed your database  
âœ… Run tests with coverage  
âœ… Be extended with more commands

### Next Steps

1. Add more commands for your specific needs
2. Implement database backup/restore
3. Add support for multiple databases (MySQL, MongoDB)
4. Create configuration profiles
5. Add colorful output using libraries like `fatih/color`
6. Implement interactive prompts using `manifoldco/promptui`

### Resources

- **Cobra Documentation**: https://github.com/spf13/cobra
- **Go Database/SQL Tutorial**: https://go.dev/doc/database/
- **Testing in Go**: https://go.dev/doc/tutorial/add-a-test

---

**Happy Coding! ğŸš€**

Remember: Start simple, iterate often, and always test your changes!