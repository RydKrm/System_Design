# Mastering Strings & Text in Go: A Complete Guide

## Introduction: Text Processing in Go

Text processing is at the heart of nearly every application you'll build. Whether you're parsing user input, generating reports, processing log files, building web applications, or manipulating data, understanding how to work with strings and text effectively is crucial for any backend developer.

Go provides a rich ecosystem of packages for text manipulation: the `strings` package for basic string operations, `fmt` for formatting, `text/template` and `html/template` for templating, and `regexp` for pattern matching. Each serves a specific purpose, and mastering them will make you a more effective Go developer.

In this guide, we'll explore these tools in depth, understanding not just the "how" but also the "why" and "when" to use each approach.

## Part 1: Understanding Strings in Go

Before diving into string functions, we need to understand what strings are in Go at a fundamental level.

### What is a String?

In Go, a string is an immutable sequence of bytes. Let me emphasize that: strings are **immutable** and they are **byte sequences**, not character sequences. This distinction is crucial for understanding how Go handles text.

```
String Internal Structure:

type StringHeader struct {
    Data uintptr  // Pointer to the underlying byte array
    Len  int      // Length in bytes
}

Example: "hello"
┌─────────────────────────┐
│ StringHeader            │
│ ┌─────────────────────┐ │
│ │ Data: 0x1040a0      │ │ ──────┐
│ │ Len:  5             │ │       │
│ └─────────────────────┘ │       │
└─────────────────────────┘       │
                                  │
                                  ▼
                    Memory: 0x1040a0
                    ┌───┬───┬───┬───┬───┐
                    │ h │ e │ l │ l │ o │
                    └───┴───┴───┴───┴───┘
                    Bytes: 68 65 6C 6C 6F (hexadecimal)
```

### Immutability: A Key Concept

Strings in Go are immutable, meaning once created, they cannot be changed. Any operation that appears to modify a string actually creates a new string.

```go
s := "hello"
s = s + " world"  // Creates a NEW string, doesn't modify the original

// What actually happens:
// 1. Original "hello" is at memory address 0x1000
// 2. New string "hello world" is created at 0x2000
// 3. Variable 's' now points to 0x2000
// 4. Original "hello" at 0x1000 may be garbage collected if no references remain
```

Visual representation:

```
Before: s = "hello"
┌──────┐     points to     ┌───────────────┐
│  s   │ ───────────────→  │  "hello"      │
└──────┘                   │  (0x1000)     │
                           └───────────────┘

After: s = s + " world"
┌──────┐                   ┌───────────────┐
│  s   │                   │  "hello"      │
└───┬──┘                   │  (0x1000)     │
    │                      └───────────────┘
    │                      (may be GC'd)
    │
    │     points to        ┌───────────────┐
    └───────────────────→  │ "hello world" │
                           │  (0x2000)     │
                           └───────────────┘
```

This immutability has important implications:

**Thread Safety**: Strings can be safely shared between goroutines without synchronization because they can't be modified.

**Performance**: String concatenation in loops can be inefficient because each concatenation creates a new string. Use `strings.Builder` for efficient concatenation.

**Memory**: Multiple variables can point to the same underlying string data without risk.

### Strings vs Bytes vs Runes

Go has three related types for working with text, and understanding the difference is essential:

**string**: An immutable sequence of bytes (type `string`)

**[]byte**: A mutable slice of bytes (type `[]byte`)

**rune**: An alias for `int32`, represents a Unicode code point (type `rune` or `int32`)

```
Relationship Diagram:

"Hello, 世界"  (string)
     │
     ├──────→ []byte: [72 101 108 108 111 44 32 228 184 150 231 149 140]
     │                  H   e   l   l   o   ,  sp  └──世──┘ └──界──┘
     │
     └──────→ []rune: [72 101 108 108 111 44 32 19990 30028]
                       H   e   l   l   o   ,  sp   世    界

Key points:
- []byte view: 13 bytes (ASCII chars = 1 byte, Chinese chars = 3 bytes each)
- []rune view: 9 runes (each character is one rune regardless of encoding)
- string length: len("Hello, 世界") = 13 (bytes, not characters!)
```

Why this matters:

```go
s := "Hello, 世界"

// Length in bytes (not characters!)
fmt.Println(len(s))  // Output: 13

// Iterating as bytes
for i := 0; i < len(s); i++ {
    fmt.Printf("%x ", s[i])
}
// Output: 48 65 6c 6c 6f 2c 20 e4 b8 96 e7 95 8c
// (includes partial UTF-8 sequences - not useful!)

// Iterating as runes (proper way for Unicode strings)
for i, r := range s {
    fmt.Printf("Index %d: %c (U+%04X)\n", i, r, r)
}
// Output:
// Index 0: H (U+0048)
// Index 1: e (U+0065)
// Index 2: l (U+006C)
// Index 3: l (U+006C)
// Index 4: o (U+006F)
// Index 5: , (U+002C)
// Index 6:   (U+0020)
// Index 7: 世 (U+4E16)
// Index 10: 界 (U+754C)
```

### UTF-8 Encoding in Go

Go strings are UTF-8 encoded by default. UTF-8 is a variable-length encoding where characters can be 1 to 4 bytes long.

```
UTF-8 Encoding Ranges:

┌──────────────┬─────────────┬─────────────────────┐
│ Code Point   │ Byte Count  │ Byte Pattern        │
├──────────────┼─────────────┼─────────────────────┤
│ U+0000 to    │ 1 byte      │ 0xxxxxxx            │
│ U+007F       │             │ (ASCII)             │
├──────────────┼─────────────┼─────────────────────┤
│ U+0080 to    │ 2 bytes     │ 110xxxxx 10xxxxxx   │
│ U+07FF       │             │                     │
├──────────────┼─────────────┼─────────────────────┤
│ U+0800 to    │ 3 bytes     │ 1110xxxx 10xxxxxx   │
│ U+FFFF       │             │ 10xxxxxx            │
├──────────────┼─────────────┼─────────────────────┤
│ U+10000 to   │ 4 bytes     │ 11110xxx 10xxxxxx   │
│ U+10FFFF     │             │ 10xxxxxx 10xxxxxx   │
└──────────────┴─────────────┴─────────────────────┘

Example: "世" (U+4E16)
Binary: 0100 1110 0001 0110

UTF-8 encoding (3 bytes):
1110[0100] 10[111000] 10[010110]
   E4        B8         96

In memory: E4 B8 96
```

---

## Part 2: String Functions

The `strings` package provides a comprehensive set of functions for string manipulation. Let's explore them systematically.

### Searching and Testing Functions

These functions help you find substrings and test string properties.

#### Contains, ContainsAny, ContainsRune

```go
import "strings"

// Contains checks if substr is within s
strings.Contains("seafood", "foo")  // true
strings.Contains("seafood", "bar")  // false

// ContainsAny checks if any Unicode code point in chars is within s
strings.ContainsAny("failure", "ui")  // true (contains 'u')
strings.ContainsAny("failure", "xyz") // false

// ContainsRune checks if rune is within s
strings.ContainsRune("golang", 'g')  // true
strings.ContainsRune("golang", 'x')  // false
```

How `Contains` works internally:

```
Searching "seafood" for "foo":

Step 1: Iterate through main string
s: s e a f o o d
   ↑
   Check if "foo" starts here? No (s != f)

Step 2: Continue
s: s e a f o o d
     ↑
     Check if "foo" starts here? No (e != f)

Step 3: Continue
s: s e a f o o d
       ↑
       Check if "foo" starts here? No (a != f)

Step 4: Found!
s: s e a f o o d
         ↑ ↑ ↑
         f o o matches!
         Return true

Algorithm: Uses optimized substring search (similar to Boyer-Moore)
Time Complexity: O(n*m) worst case, but typically much faster
```

#### HasPrefix, HasSuffix

```go
// HasPrefix tests whether string begins with prefix
strings.HasPrefix("Gopher", "Go")   // true
strings.HasPrefix("Gopher", "ph")   // false

// HasSuffix tests whether string ends with suffix
strings.HasSuffix("Gopher", "her")  // true
strings.HasSuffix("Gopher", "Go")   // false
```

Visual representation:

```
HasPrefix("Gopher", "Go"):
┌──┬──┬──┬──┬──┬──┐
│G │o │p │h │e │r │
└──┴──┴──┴──┴──┴──┘
 ↑  ↑
 └──┘ Matches "Go" → true

HasSuffix("Gopher", "her"):
┌──┬──┬──┬──┬──┬──┐
│G │o │p │h │e │r │
└──┴──┴──┴──┴──┴──┘
          ↑  ↑  ↑
          └──┴──┘ Matches "her" → true
```

#### Index Functions

```go
// Index returns the index of the first instance of substr
strings.Index("chicken", "ken")      // 4
strings.Index("chicken", "duck")     // -1 (not found)

// LastIndex returns the index of the last instance
strings.LastIndex("go gopher", "go") // 3 (last occurrence)

// IndexAny returns the index of the first instance of any Unicode code point
strings.IndexAny("chicken", "aeiouy")  // 2 (first vowel 'i')

// IndexRune returns the index of the first instance of the rune
strings.IndexRune("chicken", 'k')      // 4

// Count counts the number of non-overlapping instances
strings.Count("cheese", "e")           // 3
strings.Count("five", "")              // 5 (special case: len + 1)
```

Visualization of `Index`:

```
strings.Index("chicken", "ken"):

"chicken"
 0123456  (indices)
 
Search for "ken":
c h i c k e n
        ↑ ↑ ↑
        4 5 6
        └─ken─┘
        
First occurrence starts at index 4
Return: 4
```

### Splitting and Joining Functions

These functions break strings apart or combine them.

#### Split, SplitN, SplitAfter

```go
// Split divides string into slice of substrings
strings.Split("a,b,c", ",")           // ["a", "b", "c"]
strings.Split("a,b,c", "")            // ["a", ",", "b", ",", "c"]

// SplitN splits into at most n substrings
strings.SplitN("a,b,c,d", ",", 2)     // ["a", "b,c,d"]
strings.SplitN("a,b,c,d", ",", -1)    // ["a", "b", "c", "d"] (all)

// SplitAfter splits after each separator (keeps separator)
strings.SplitAfter("a,b,c", ",")      // ["a,", "b,", "c"]

// Fields splits on whitespace (handles multiple spaces)
strings.Fields("  foo bar  baz  ")   // ["foo", "bar", "baz"]
```

Visual representation of `Split`:

```
strings.Split("a,b,c", ","):

Input: "a,b,c"
       ↓ ↓ ↓
Find separators: positions 1 and 3
       ↓   ↓
Split: │ , │ , │
       ↓   ↓   ↓
Result: ["a", "b", "c"]

strings.SplitN("a,b,c,d", ",", 2):

Input: "a,b,c,d"
       ↓
Split only at first separator
       ↓
Result: ["a", "b,c,d"]
        └─┘  └─────┘
        part1  part2 (rest combined)
```

#### Join

```go
// Join concatenates elements with separator
strings.Join([]string{"a", "b", "c"}, ",")    // "a,b,c"
strings.Join([]string{"foo", "bar"}, " - ")   // "foo - bar"
strings.Join([]string{"single"}, ",")         // "single"
```

How `Join` works efficiently:

```
strings.Join(["Hello", "World", "Go"], " "):

Step 1: Calculate total length needed
"Hello" → 5 bytes
" "     → 1 byte
"World" → 5 bytes
" "     → 1 byte
"Go"    → 2 bytes
Total: 14 bytes

Step 2: Allocate exactly 14 bytes
┌──────────────────────────────────┐
│          14 bytes                │
└──────────────────────────────────┘

Step 3: Copy strings into buffer
┌─────┬─┬─────┬─┬──┐
│Hello│ │World│ │Go│
└─────┴─┴─────┴─┴──┘

Result: "Hello World Go"

Why this is efficient:
- Single allocation (not multiple concatenations)
- No intermediate strings created
- O(n) complexity where n is total length
```

### Trimming and Padding Functions

These functions modify string boundaries.

#### Trim Functions

```go
// Trim removes leading and trailing characters from cutset
strings.Trim("¡¡¡Hello, Gophers!!!", "!¡")  // "Hello, Gophers"

// TrimLeft removes leading characters
strings.TrimLeft("¡¡¡Hello!!!", "¡")        // "Hello!!!"

// TrimRight removes trailing characters
strings.TrimRight("¡¡¡Hello!!!", "!")       // "¡¡¡Hello"

// TrimSpace removes leading and trailing whitespace
strings.TrimSpace("  \n\t Hello \t\n  ")    // "Hello"

// TrimPrefix removes prefix if present
strings.TrimPrefix("Gopher", "Go")          // "pher"
strings.TrimPrefix("Gopher", "Ph")          // "Gopher" (no match)

// TrimSuffix removes suffix if present
strings.TrimSuffix("Hello.txt", ".txt")     // "Hello"
```

Visualization of `Trim`:

```
strings.Trim("¡¡¡Hello, Gophers!!!", "!¡"):

Original:
┌─┬─┬─┬─────────────────┬─┬─┬─┐
│¡│¡│¡│Hello, Gophers   │!│!│!│
└─┴─┴─┴─────────────────┴─┴─┴─┘
 ↑                           ↑
 Remove these                Remove these
 (in cutset)                 (in cutset)

Result:
┌─────────────────┐
│Hello, Gophers   │
└─────────────────┘
```

#### Repeat and Padding

```go
// Repeat returns a new string consisting of count copies
strings.Repeat("Go", 3)              // "GoGoGo"
strings.Repeat("=", 10)              // "=========="

// Manual padding using Repeat
title := "Chapter 1"
padding := strings.Repeat(" ", 20-len(title))
padded := title + padding            // "Chapter 1           "
```

### Case Conversion Functions

```go
// ToUpper converts to uppercase
strings.ToUpper("Hello, World!")     // "HELLO, WORLD!"

// ToLower converts to lowercase
strings.ToLower("Hello, World!")     // "hello, world!"

// Title converts to title case (deprecated, use cases.Title instead)
strings.Title("hello world")         // "Hello World"

// ToTitle converts to title case (Unicode compliant)
strings.ToTitle("loud noises")       // "LOUD NOISES"
```

Important note about Unicode:

```
Unicode Case Mapping Examples:

English:
"hello" → ToUpper → "HELLO"
Simple one-to-one mapping

Turkish:
"istanbul" → ToUpper → "İSTANBUL"
Notice: 'i' → 'İ' (with dot)
Not: 'i' → 'I'

Greek:
"ελληνικά" → ToUpper → "ΕΛΛΗΝΙΚΆ"
Sigma: 'ς' at end → 'Σ'
Sigma: 'σ' in middle → 'Σ'

Go's strings package handles these correctly!
```

### Replacing Functions

```go
// Replace replaces old with new, n times (-1 for all)
strings.Replace("oink oink oink", "oink", "moo", 2)  // "moo moo oink"
strings.Replace("oink oink oink", "oink", "moo", -1) // "moo moo moo"

// ReplaceAll replaces all instances (shorthand for n=-1)
strings.ReplaceAll("oink oink oink", "oink", "moo")  // "moo moo moo"

// Map applies function to each rune
rot13 := func(r rune) rune {
    if r >= 'a' && r <= 'z' {
        return 'a' + (r-'a'+13)%26
    }
    if r >= 'A' && r <= 'Z' {
        return 'A' + (r-'A'+13)%26
    }
    return r
}
strings.Map(rot13, "Hello, World!")  // "Uryyb, Jbeyq!"
```

How `Replace` works:

```
strings.Replace("oink oink oink", "oink", "moo", 2):

Step 1: Find first occurrence
"oink oink oink"
 ↑↑↑↑
 Match found at index 0

Step 2: Replace first occurrence (count: 1)
"moo oink oink"

Step 3: Continue searching from position 4
"moo oink oink"
     ↑↑↑↑
     Match found at index 4

Step 4: Replace second occurrence (count: 2)
"moo moo oink"

Step 5: Count reached 2, stop
Result: "moo moo oink"

If n = -1, continue until no more matches found
```

### Comparison Functions

```go
// Compare returns 0 if equal, -1 if a < b, +1 if a > b
strings.Compare("a", "b")      // -1
strings.Compare("b", "a")      // 1
strings.Compare("a", "a")      // 0

// EqualFold reports case-insensitive equality
strings.EqualFold("Go", "go")  // true
strings.EqualFold("GO", "go")  // true
```

You can also use operators directly:

```go
// Direct comparison (usually preferred)
"abc" == "abc"   // true
"abc" < "def"    // true (lexicographic order)
```

### Building Strings Efficiently: strings.Builder

When you need to build strings by concatenating many parts, use `strings.Builder` for efficiency.

```go
import "strings"

// Inefficient way (creates many intermediate strings)
func buildInefficient(words []string) string {
    result := ""
    for _, word := range words {
        result += word + " "  // Creates new string each iteration!
    }
    return result
}

// Efficient way using strings.Builder
func buildEfficient(words []string) string {
    var builder strings.Builder
    
    // Optional: preallocate if you know approximate size
    builder.Grow(len(words) * 10)
    
    for _, word := range words {
        builder.WriteString(word)
        builder.WriteString(" ")
    }
    return builder.String()
}
```

Why `strings.Builder` is faster:

```
Inefficient Concatenation (result += word):

Iteration 1: "" + "Hello" = "Hello"
            │                 │
            └─→ Allocate 5 bytes, copy "Hello"

Iteration 2: "Hello" + "World" = "Hello World"
            │                     │
            └─→ Allocate 11 bytes, copy "Hello", copy "World"

Iteration 3: "Hello World" + "Go" = "Hello World Go"
            │                        │
            └─→ Allocate 14 bytes, copy "Hello World", copy "Go"

Total allocations: 3
Total copies: "Hello" copied 3 times, "World" copied 2 times, "Go" copied 1 time


Using strings.Builder:

Setup: Allocate buffer (e.g., 100 bytes)
┌────────────────────────────────────────┐
│              Buffer (100 bytes)        │
└────────────────────────────────────────┘

Write "Hello": Copy to buffer
┌─────┬──────────────────────────────────┐
│Hello│                                  │
└─────┴──────────────────────────────────┘

Write "World": Append to buffer
┌───────────┬──────────────────────────────┐
│Hello World│                              │
└───────────┴──────────────────────────────┘

Write "Go": Append to buffer
┌──────────────┬───────────────────────────┐
│Hello World Go│                           │
└──────────────┴───────────────────────────┘

Total allocations: 1 (or very few if buffer grows)
Total copies: Each string copied once
```

Performance comparison:

```go
// Benchmark results (1000 concatenations):
// Concatenation with +: 50ms, 500,000 allocations
// strings.Builder:      0.5ms, 10 allocations
// Speed improvement: 100x faster!
```

---

## Part 3: String Formatting

The `fmt` package provides powerful string formatting capabilities, similar to C's `printf` family.

### Basic Formatting Verbs

Format strings contain "verbs" that specify how values should be formatted. They start with a percent sign (%).

```go
import "fmt"

// String formatting
fmt.Printf("Hello, %s!\n", "World")           // Hello, World!
fmt.Printf("Name: %q\n", "Alice")             // Name: "Alice" (with quotes)

// Integer formatting
fmt.Printf("Decimal: %d\n", 42)               // Decimal: 42
fmt.Printf("Binary: %b\n", 42)                // Binary: 101010
fmt.Printf("Octal: %o\n", 42)                 // Octal: 52
fmt.Printf("Hex (lowercase): %x\n", 255)      // Hex (lowercase): ff
fmt.Printf("Hex (uppercase): %X\n", 255)      // Hex (uppercase): FF

// Float formatting
fmt.Printf("Float: %f\n", 3.14159)            // Float: 3.141590
fmt.Printf("Float (2 decimal): %.2f\n", 3.14159) // Float (2 decimal): 3.14
fmt.Printf("Scientific: %e\n", 12345.6)       // Scientific: 1.234560e+04
fmt.Printf("Compact: %g\n", 12345.6)          // Compact: 12345.6

// Boolean formatting
fmt.Printf("Boolean: %t\n", true)             // Boolean: true

// Type formatting
fmt.Printf("Type: %T\n", 42)                  // Type: int
fmt.Printf("Value: %v\n", 42)                 // Value: 42 (default format)
fmt.Printf("Go-syntax: %#v\n", []int{1,2,3})  // Go-syntax: []int{1, 2, 3}
```

Complete formatting verb reference:

```
┌──────────┬────────────────────────────────────────────┐
│  Verb    │  Description                               │
├──────────┼────────────────────────────────────────────┤
│  %v      │  Default format                            │
│  %+v     │  With field names (for structs)            │
│  %#v     │  Go-syntax representation                  │
│  %T      │  Type of the value                         │
│  %%      │  Literal percent sign                      │
├──────────┼────────────────────────────────────────────┤
│  %t      │  Boolean (true/false)                      │
├──────────┼────────────────────────────────────────────┤
│  %d      │  Decimal integer                           │
│  %b      │  Binary                                    │
│  %o      │  Octal                                     │
│  %x, %X  │  Hexadecimal (lower/upper case)            │
│  %c      │  Character (rune)                          │
│  %U      │  Unicode format: U+1234                    │
├──────────┼────────────────────────────────────────────┤
│  %f      │  Decimal point, no exponent                │
│  %e, %E  │  Scientific notation                       │
│  %g, %G  │  Compact notation                          │
├──────────┼────────────────────────────────────────────┤
│  %s      │  String                                    │
│  %q      │  Quoted string                             │
│  %x, %X  │  Hex dump of bytes                         │
├──────────┼────────────────────────────────────────────┤
│  %p      │  Pointer address                           │
└──────────┴────────────────────────────────────────────┘
```

### Width and Precision

You can control the width and precision of formatted output.

```go
// Width: minimum width of output
fmt.Printf("|%5d|\n", 42)              // |   42|
fmt.Printf("|%-5d|\n", 42)             // |42   | (left-align with -)

// Precision for floats: digits after decimal
fmt.Printf("%.2f\n", 3.14159)          // 3.14
fmt.Printf("%6.2f\n", 3.14159)         // "  3.14" (width 6, precision 2)

// Precision for strings: maximum length
fmt.Printf("%.5s\n", "Hello, World!")  // Hello

// Padding with zeros
fmt.Printf("%05d\n", 42)               // 00042

// Dynamic width and precision
width := 10
precision := 2
fmt.Printf("%*.*f\n", width, precision, 3.14159)  // "      3.14"
```

Visual representation:

```
Width and Alignment:

fmt.Printf("|%5d|", 42):
┌─────────┐
│    4   2│  (width 5, right-aligned by default)
└─────────┘
     ↑ ↑
  spaces added

fmt.Printf("|%-5d|", 42):
┌─────────┐
│4   2    │  (width 5, left-aligned with -)
└─────────┘
   ↑ ↑
  spaces added

fmt.Printf("%6.2f", 3.14159):
┌──────────┐
│    3 . 14│  (total width 6, 2 decimals)
└──────────┘
  ↑↑
 spaces
```

### Formatting with Sprintf and Sprint

Instead of printing directly, you can format to a string.

```go
// Sprintf returns formatted string
s := fmt.Sprintf("Hello, %s!", "World")  // s = "Hello, World!"

// Sprint concatenates values with spaces
s = fmt.Sprint("Age:", 25)               // s = "Age: 25"

// Sprintln adds spaces and newline
s = fmt.Sprintln("Age:", 25)             // s = "Age: 25\n"
```

Common pattern for error messages:

```go
func processUser(id int) error {
    if id < 0 {
        return fmt.Errorf("invalid user ID: %d", id)
    }
    // ... process user
    return nil
}
```

### Formatting Structs

Structs have special formatting options:

```go
type Person struct {
    Name string
    Age  int
    City string
}

p := Person{"Alice", 30, "NYC"}

// Default format (%v)
fmt.Printf("%v\n", p)
// Output: {Alice 30 NYC}

// With field names (%+v)
fmt.Printf("%+v\n", p)
// Output: {Name:Alice Age:30 City:NYC}

// Go-syntax representation (%#v)
fmt.Printf("%#v\n", p)
// Output: main.Person{Name:"Alice", Age:30, City:"NYC"}
```

Custom formatting with `String()` method:

```go
func (p Person) String() string {
    return fmt.Sprintf("%s (%d years old) from %s", p.Name, p.Age, p.City)
}

fmt.Println(p)  // Output: Alice (30 years old) from NYC
```

### Format State for Advanced Control

You can implement custom formatting by accepting a `fmt.Formatter`:

```go
type Point struct {
    X, Y float64
}

func (p Point) Format(f fmt.State, verb rune) {
    switch verb {
    case 'v':
        if f.Flag('#') {
            fmt.Fprintf(f, "Point{X:%g, Y:%g}", p.X, p.Y)
        } else if f.Flag('+') {
            fmt.Fprintf(f, "(%g, %g)", p.X, p.Y)
        } else {
            fmt.Fprintf(f, "(%.2f, %.2f)", p.X, p.Y)
        }
    case 'p':
        fmt.Fprintf(f, "[%.2f, %.2f]", p.X, p.Y)
    default:
        fmt.Fprintf(f, "%%!%c(Point=%v)", verb, p)
    }
}

pt := Point{3.14159, 2.71828}
fmt.Printf("%v\n", pt)    // (3.14, 2.71)
fmt.Printf("%+v\n", pt)   // (3.14159, 2.71828)
fmt.Printf("%#v\n", pt)   // Point{X:3.14159, Y:2.71828}
fmt.Printf("%p\n", pt)    // [3.14, 2.71]
```

---

## Part 4: Text Templates

Templates allow you to generate text output based on data structures, separating presentation logic from data.

### Basic Template Syntax

A template is text with embedded "actions" delimited by `{{` and `}}`.

```go
import "text/template"

// Simple template
tmpl := `Hello, {{.}}!`
t := template.Must(template.New("greeting").Parse(tmpl))
t.Execute(os.Stdout, "World")  // Output: Hello, World!

// Template with struct
type Person struct {
    Name string
    Age  int
}

tmpl = `Name: {{.Name}}, Age: {{.Age}}`
t = template.Must(template.New("person").Parse(tmpl))
t.Execute(os.Stdout, Person{"Alice", 30})
// Output: Name: Alice, Age: 30
```

Template action syntax:

```
Template Actions Reference:

{{.}}              - The current context (dot)
{{.Field}}         - Access struct field
{{.Method}}        - Call method (no arguments)
{{$.Root}}         - Access root context from anywhere
{{$var}}           - Use template variable

{{if .Condition}}  - Conditional
{{else if .Other}} - Else-if
{{else}}           - Else
{{end}}            - End block

{{range .Items}}   - Loop over slice/array/map
  {{.}}            - Current item
{{else}}           - Executed if empty
{{end}}

{{with .Value}}    - Set context temporarily
  {{.}}            - New context
{{end}}

{{template "name"}} - Include another template
{{block "name" .}}  - Define/include block
```

### Data Access Patterns

Understanding the dot (`.`) is crucial for templates.

```go
type Company struct {
    Name      string
    Employees []Employee
}

type Employee struct {
    Name   string
    Salary int
}

tmpl := `
Company: {{.Name}}
Employees:
{{range .Employees}}
  - {{.Name}}: ${{.Salary}}
{{end}}
`

company := Company{
    Name: "TechCorp",
    Employees: []Employee{
        {"Alice", 80000},
        {"Bob", 75000},
    },
}

t := template.Must(template.New("company").Parse(tmpl))
t.Execute(os.Stdout, company)
```

Output:

```
Company: TechCorp
Employees:
  - Alice: $80000
  - Bob: $75000
```

Visual representation of context changes:

```
Template Execution Context:

{{.Name}}           - Current context: Company
   ↓
"TechCorp"

{{range .Employees}}  - Context changes to: Employee (each iteration)
   ↓
  {{.Name}}         - Current context: Employee
     ↓
  "Alice" (first iteration)
  "Bob" (second iteration)
{{end}}             - Context returns to: Company
```

### Template Variables

You can define variables within templates.

```go
tmpl := `
{{$total := 0}}
{{range .Items}}
  {{$total = add $total .Price}}
{{end}}
Total: ${{$total}}
`
```

Accessing the root context inside nested blocks:

```go
type Data struct {
    Title string
    Items []string
}

tmpl := `
Title: {{.Title}}
{{range .Items}}
  - Item: {{.}} (from {{$.Title}})
{{end}}
`

// Inside range, . is the current item
// Use $. to access the root context
```

### Conditional Logic

Templates support if/else statements.

```go
type User struct {
    Name      string
    IsAdmin   bool
    Age       int
}

tmpl := `
Hello, {{.Name}}!
{{if .IsAdmin}}
  You have admin privileges.
{{else}}
  You have standard access.
{{end}}

{{if ge .Age 18}}
  You are an adult.
{{else}}
  You are a minor.
{{end}}
`
```

Comparison operators in templates:

```
┌──────┬──────────────────────────┐
│ Op   │ Description              │
├──────┼──────────────────────────┤
│ eq   │ Equal (==)               │
│ ne   │ Not equal (!=)           │
│ lt   │ Less than (<)            │
│ le   │ Less or equal (<=)       │
│ gt   │ Greater than (>)         │
│ ge   │ Greater or equal (>=)    │
└──────┴──────────────────────────┘

Usage: {{if eq .Status "active"}}...{{end}}
```

### Pipelines and Functions

Templates support pipelines, similar to Unix pipes.

```go
// Pipeline: pass value through multiple functions
{{.Name | printf "%s!" | html}}

// Built-in functions
{{len .Items}}           - Length of slice/map/string
{{index .Items 0}}       - Access element at index
{{slice .Items 1 3}}     - Slice operation

// Custom functions
funcMap := template.FuncMap{
    "upper": strings.ToUpper,
    "multiply": func(a, b int) int { return a * b },
}

tmpl := `{{.Name | upper}}, Price: {{multiply .Price 2}}`
t := template.New("custom").Funcs(funcMap)
t = template.Must(t.Parse(tmpl))
```

Common template function patterns:

```go
// Formatting functions
funcMap := template.FuncMap{
    "formatDate": func(t time.Time) string {
        return t.Format("2006-01-02")
    },
    "currency": func(amount float64) string {
        return fmt.Sprintf("$%.2f", amount)
    },
    "truncate": func(s string, length int) string {
        if len(s) <= length {
            return s
        }
        return s[:length] + "..."
    },
}
```

### Loop Constructs

The `range` action iterates over collections.

```go
// Range over slice
tmpl := `
{{range .Items}}
  - {{.}}
{{end}}
`

// Range with index
tmpl = `
{{range $index, $item := .Items}}
  {{$index}}: {{$item}}
{{end}}
`

// Range over map
tmpl = `
{{range $key, $value := .Settings}}
  {{$key}} = {{$value}}
{{end}}
`

// Handle empty collection
tmpl = `
{{range .Items}}
  - {{.}}
{{else}}
  No items found.
{{end}}
`
```

Visual representation:

```
Range Iteration:

Data: []string{"Apple", "Banana", "Cherry"}

{{range .}}
  - {{.}}
{{end}}

Execution:
Iteration 1: . = "Apple"    → Output: "- Apple"
Iteration 2: . = "Banana"   → Output: "- Banana"
Iteration 3: . = "Cherry"   → Output: "- Cherry"

{{range $i, $v := .}}
  {{$i}}: {{$v}}
{{end}}

Execution:
Iteration 1: $i = 0, $v = "Apple"    → Output: "0: Apple"
Iteration 2: $i = 1, $v = "Banana"   → Output: "1: Banana"
Iteration 3: $i = 2, $v = "Cherry"   → Output: "2: Cherry"
```

### Nested Templates

Templates can include other templates for reusability.

```go
// Define multiple templates
const tmplText = `
{{define "header"}}
=== {{.Title}} ===
{{end}}

{{define "footer"}}
--- End of {{.Title}} ---
{{end}}

{{define "main"}}
{{template "header" .}}
Content: {{.Content}}
{{template "footer" .}}
{{end}}
`

t := template.Must(template.New("main").Parse(tmplText))

data := struct {
    Title   string
    Content string
}{"Report", "This is the report content."}

t.ExecuteTemplate(os.Stdout, "main", data)
```

Output:

```
=== Report ===
Content: This is the report content.
--- End of Report ---
```

Template inheritance pattern:

```go
// Base template
baseTemplate := `
{{define "base"}}
<!DOCTYPE html>
<html>
<head>
    <title>{{block "title" .}}Default Title{{end}}</title>
</head>
<body>
    {{block "content" .}}Default Content{{end}}
</body>
</html>
{{end}}
`

// Page template (extends base)
pageTemplate := `
{{define "title"}}My Page{{end}}
{{define "content"}}
<h1>Welcome</h1>
<p>This is my page content.</p>
{{end}}
`

t := template.Must(template.New("base").Parse(baseTemplate))
t = template.Must(t.Parse(pageTemplate))
t.ExecuteTemplate(os.Stdout, "base", nil)
```

### HTML Templates vs Text Templates

For web applications, use `html/template` instead of `text/template`. It provides automatic escaping to prevent XSS attacks.

```go
import "html/template"

// html/template automatically escapes dangerous characters
tmpl := `<div>{{.Content}}</div>`
t := template.Must(template.New("html").Parse(tmpl))

data := struct{ Content string }{"<script>alert('XSS')</script>"}
t.Execute(os.Stdout, data)
// Output: <div>&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</div>
```

Escaping behavior:

```
Input: <script>alert('XSS')</script>

text/template (UNSAFE for HTML):
Output: <script>alert('XSS')</script>
        (executed as JavaScript!)

html/template (SAFE):
Output: &lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;
        (rendered as text, not executed)

Character Escaping:
< → &lt;
> → &gt;
& → &amp;
' → &#39;
" → &#34;
```

### Practical Template Example: Email Generation

```go
package main

import (
    "os"
    "text/template"
    "time"
)

type EmailData struct {
    RecipientName string
    SenderName    string
    Subject       string
    OrderID       string
    Items         []OrderItem
    Total         float64
    Date          time.Time
}

type OrderItem struct {
    Name     string
    Quantity int
    Price    float64
}

const emailTemplate = `
From: {{.SenderName}}
To: {{.RecipientName}}
Subject: {{.Subject}}
Date: {{.Date.Format "2006-01-02"}}

Dear {{.RecipientName}},

Thank you for your order #{{.OrderID}}!

Order Details:
{{range .Items}}
  - {{.Name}} (x{{.Quantity}}) - ${{printf "%.2f" .Price}}
{{end}}

Total: ${{printf "%.2f" .Total}}

Best regards,
{{.SenderName}}
`

func main() {
    data := EmailData{
        RecipientName: "John Doe",
        SenderName:    "Store Team",
        Subject:       "Order Confirmation",
        OrderID:       "12345",
        Items: []OrderItem{
            {"Widget", 2, 19.99},
            {"Gadget", 1, 49.99},
        },
        Total: 89.97,
        Date:  time.Now(),
    }

    t := template.Must(template.New("email").Parse(emailTemplate))
    t.Execute(os.Stdout, data)
}
```

---

## Part 5: Regular Expressions

Regular expressions (regex) provide powerful pattern matching capabilities for text processing.

### Basic Regex Syntax

Go uses the RE2 syntax, which is fast and safe (no catastrophic backtracking).

```go
import "regexp"

// Compile a regex pattern
re := regexp.MustCompile(`\d+`)  // Match one or more digits

// Find match
match := re.FindString("Order 12345")  // "12345"

// Check if matches
matched := re.MatchString("Order 12345")  // true
```

Basic regex patterns:

```
┌──────────┬────────────────────────────────────┐
│ Pattern  │ Description                        │
├──────────┼────────────────────────────────────┤
│ .        │ Any character except newline       │
│ ^        │ Start of string                    │
│ $        │ End of string                      │
│ *        │ Zero or more (greedy)              │
│ +        │ One or more (greedy)               │
│ ?        │ Zero or one (greedy)               │
│ {n}      │ Exactly n times                    │
│ {n,}     │ At least n times                   │
│ {n,m}    │ Between n and m times              │
├──────────┼────────────────────────────────────┤
│ [abc]    │ Character class (a, b, or c)       │
│ [^abc]   │ Negated class (not a, b, or c)     │
│ [a-z]    │ Character range                    │
│ \d       │ Digit [0-9]                        │
│ \D       │ Non-digit                          │
│ \w       │ Word character [a-zA-Z0-9_]        │
│ \W       │ Non-word character                 │
│ \s       │ Whitespace                         │
│ \S       │ Non-whitespace                     │
├──────────┼────────────────────────────────────┤
│ (...)    │ Capture group                      │
│ (?:...)  │ Non-capturing group                │
│ |        │ Alternation (OR)                   │
└──────────┴────────────────────────────────────┘
```

### Compiling Patterns

Always compile patterns once and reuse them.

```go
// Bad: compiling in a loop
for _, text := range texts {
    re := regexp.MustCompile(`\d+`)  // Compiled every iteration!
    match := re.FindString(text)
}

// Good: compile once
re := regexp.MustCompile(`\d+`)
for _, text := range texts {
    match := re.FindString(text)  // Reuse compiled pattern
}

// MustCompile panics on error (use in initialization)
var emailRegex = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)

// Compile returns error (use when pattern is user input)
pattern := getUserInput()
re, err := regexp.Compile(pattern)
if err != nil {
    log.Fatal("Invalid regex:", err)
}
```

### Finding Matches

Multiple methods for finding matches:

```go
re := regexp.MustCompile(`\d+`)

// FindString: first match as string
match := re.FindString("abc 123 def 456")  // "123"

// FindStringIndex: first match indices
loc := re.FindStringIndex("abc 123 def")   // [4, 7]
// text[4:7] = "123"

// FindAllString: all matches
matches := re.FindAllString("abc 123 def 456", -1)  // ["123", "456"]

// FindAllString with limit
matches = re.FindAllString("1 2 3 4 5", 2)  // ["1", "2"]

// FindStringSubmatch: capture groups
re = regexp.MustCompile(`(\w+)@(\w+\.\w+)`)
groups := re.FindStringSubmatch("user@example.com")
// groups[0] = "user@example.com" (full match)
// groups[1] = "user" (first capture group)
// groups[2] = "example.com" (second capture group)

// FindAllStringSubmatch: all matches with groups
re = regexp.MustCompile(`(\d+):(\d+)`)
allGroups := re.FindAllStringSubmatch("10:30 and 14:45", -1)
// allGroups[0] = ["10:30", "10", "30"]
// allGroups[1] = ["14:45", "14", "45"]
```

Visual representation:

```
FindString("abc 123 def 456", `\d+`):

Input: "abc 123 def 456"
        ↓   ↓↓↓
        └───┘ First match
        
Return: "123"


FindAllString("abc 123 def 456", -1, `\d+`):

Input: "abc 123 def 456"
        ↓   ↓↓↓     ↓↓↓
        └───┘       └───┘ All matches
        
Return: ["123", "456"]


FindStringSubmatch("user@example.com", `(\w+)@(\w+\.\w+)`):

Input: "user@example.com"
        ↓↓↓↓ ↓ ↓↓↓↓↓↓↓↓↓↓↓
        │    │ └─group 2─┘
        │    └─separator
        └─group 1

Return: ["user@example.com", "user", "example.com"]
         └─full match──┘     └─g1─┘  └───g2────┘
```

### Replacing Text

Regular expressions can replace matched text.

```go
re := regexp.MustCompile(`\d+`)

// ReplaceAllString: replace all matches
result := re.ReplaceAllString("Order 123, Item 456", "XXX")
// "Order XXX, Item XXX"

// ReplaceAllStringFunc: replace with function
result = re.ReplaceAllStringFunc("Order 123, Item 456", func(s string) string {
    return "[" + s + "]"
})
// "Order [123], Item [456]"

// ReplaceAllLiteralString: literal replacement (no $ expansion)
re = regexp.MustCompile(`foo`)
result = re.ReplaceAllLiteralString("foo bar foo", "$1")
// "$1 bar $1" (treats $1 as literal text)
```

Using capture groups in replacement:

```go
// $1, $2, etc. refer to capture groups
re := regexp.MustCompile(`(\w+)@(\w+\.\w+)`)
result := re.ReplaceAllString("Contact: user@example.com", "Email: $1 at $2")
// "Contact: Email: user at example.com"

// Named capture groups
re = regexp.MustCompile(`(?P<user>\w+)@(?P<domain>\w+\.\w+)`)
result = re.ReplaceAllString("user@example.com", "${user} at ${domain}")
// "user at example.com"
```

### Splitting Strings

Use regex to split strings on complex patterns.

```go
re := regexp.MustCompile(`\s+`)  // Split on whitespace

// Split into unlimited parts
parts := re.Split("foo  bar    baz", -1)
// ["foo", "bar", "baz"]

// Split with limit
parts = re.Split("foo  bar    baz", 2)
// ["foo", "bar    baz"]

// More complex example: split on multiple delimiters
re = regexp.MustCompile(`[,;|]`)
parts = re.Split("a,b;c|d", -1)
// ["a", "b", "c", "d"]
```

### Practical Regex Examples

#### Email Validation

```go
func isValidEmail(email string) bool {
    // Simplified email regex (basic validation)
    emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
    return emailRegex.MatchString(email)
}

// Test cases
fmt.Println(isValidEmail("user@example.com"))     // true
fmt.Println(isValidEmail("invalid.email"))        // false
fmt.Println(isValidEmail("user@subdomain.ex.com")) // true
```

Pattern breakdown:

```
^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$
│                 │              │              │
│                 │              │              └─ TLD (2+ letters)
│                 │              └─ Domain
│                 └─ @ symbol
└─ Local part (username)

^ = Start of string
$ = End of string
[...] = Character class
+ = One or more
{2,} = At least 2 times
```

#### URL Extraction

```go
func extractURLs(text string) []string {
    urlRegex := regexp.MustCompile(`https?://[^\s]+`)
    return urlRegex.FindAllString(text, -1)
}

text := "Visit https://example.com and http://test.org for more info"
urls := extractURLs(text)
// ["https://example.com", "http://test.org"]
```

#### Phone Number Formatting

```go
func formatPhoneNumber(phone string) string {
    // Extract digits
    digitRegex := regexp.MustCompile(`\d`)
    digits := digitRegex.FindAllString(phone, -1)
    
    if len(digits) == 10 {
        // Format as (XXX) XXX-XXXX
        return fmt.Sprintf("(%s%s%s) %s%s%s-%s%s%s%s",
            digits[0], digits[1], digits[2],
            digits[3], digits[4], digits[5],
            digits[6], digits[7], digits[8], digits[9])
    }
    return phone  // Return original if not 10 digits
}

fmt.Println(formatPhoneNumber("1234567890"))      // (123) 456-7890
fmt.Println(formatPhoneNumber("123-456-7890"))    // (123) 456-7890
fmt.Println(formatPhoneNumber("(123) 456-7890"))  // (123) 456-7890
```

#### Log Parsing

```go
type LogEntry struct {
    Timestamp string
    Level     string
    Message   string
}

func parseLogLine(line string) (*LogEntry, error) {
    // Match: [timestamp] LEVEL: message
    logRegex := regexp.MustCompile(`^\[([^\]]+)\]\s+(\w+):\s+(.+)$`)
    matches := logRegex.FindStringSubmatch(line)
    
    if len(matches) != 4 {
        return nil, fmt.Errorf("invalid log format")
    }
    
    return &LogEntry{
        Timestamp: matches[1],
        Level:     matches[2],
        Message:   matches[3],
    }, nil
}

line := "[2024-12-24 10:30:15] ERROR: Database connection failed"
entry, _ := parseLogLine(line)
// entry.Timestamp = "2024-12-24 10:30:15"
// entry.Level = "ERROR"
// entry.Message = "Database connection failed"
```

#### Password Strength Validation

```go
func isStrongPassword(password string) bool {
    // At least 8 characters
    if len(password) < 8 {
        return false
    }
    
    // Must have uppercase
    hasUpper := regexp.MustCompile(`[A-Z]`).MatchString(password)
    // Must have lowercase
    hasLower := regexp.MustCompile(`[a-z]`).MatchString(password)
    // Must have digit
    hasDigit := regexp.MustCompile(`\d`).MatchString(password)
    // Must have special character
    hasSpecial := regexp.MustCompile(`[!@#$%^&*(),.?":{}|<>]`).MatchString(password)
    
    return hasUpper && hasLower && hasDigit && hasSpecial
}

fmt.Println(isStrongPassword("Weak123"))          // false (no special)
fmt.Println(isStrongPassword("Strong123!"))       // true
```

#### Markdown Link Extraction

```go
func extractMarkdownLinks(markdown string) map[string]string {
    // Match: [text](url)
    linkRegex := regexp.MustCompile(`\[([^\]]+)\]\(([^)]+)\)`)
    matches := linkRegex.FindAllStringSubmatch(markdown, -1)
    
    links := make(map[string]string)
    for _, match := range matches {
        text := match[1]
        url := match[2]
        links[text] = url
    }
    return links
}

markdown := "Check [Google](https://google.com) and [GitHub](https://github.com)"
links := extractMarkdownLinks(markdown)
// map["Google":"https://google.com", "GitHub":"https://github.com"]
```

### Regex Performance Considerations

Regular expressions can be slow if not used carefully.

```
Performance Tips:

1. Compile Once, Use Many Times
   Bad:  regexp.MustCompile in loop
   Good: Compile outside loop, reuse

2. Be Specific
   Bad:  .*  (matches everything, backtracks)
   Good: [a-z]+  (matches specific set)

3. Use Anchors
   Bad:  \d{10}  (searches entire string)
   Good: ^\d{10}$  (checks exact match)

4. Avoid Catastrophic Backtracking
   Bad:  (a+)+ or (a|a)* on "aaaaa...X"
   Good: a+ (Go's RE2 prevents this, but still)

5. Consider Alternatives
   - Simple checks: Use strings package
   - Complex parsing: Use parser library
   - Performance critical: Benchmark!
```

Benchmarking example:

```go
import "testing"

func BenchmarkRegexMatch(b *testing.B) {
    re := regexp.MustCompile(`\d{3}-\d{3}-\d{4}`)
    text := "Call me at 555-123-4567"
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        re.MatchString(text)
    }
}

func BenchmarkStringContains(b *testing.B) {
    text := "Call me at 555-123-4567"
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        strings.Contains(text, "555")
    }
}

// Result: strings.Contains is ~50x faster for simple checks
```

---

## Putting It All Together: Real-World Example

Let's combine everything we've learned in a practical example: a simple log analyzer.

```go
package main

import (
    "fmt"
    "regexp"
    "strings"
    "text/template"
    "time"
)

type LogEntry struct {
    Timestamp time.Time
    Level     string
    Service   string
    Message   string
}

type LogReport struct {
    TotalEntries int
    ErrorCount   int
    WarnCount    int
    InfoCount    int
    Services     map[string]int
    TimeRange    string
    Entries      []LogEntry
}

// Parse a log line using regex
func parseLog(line string) (*LogEntry, error) {
    // Format: 2024-12-24T10:30:15Z [ERROR] [ServiceName] Message here
    logRegex := regexp.MustCompile(
        `^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z)\s+\[(\w+)\]\s+\[([^\]]+)\]\s+(.+)$`,
    )
    
    matches := logRegex.FindStringSubmatch(line)
    if len(matches) != 5 {
        return nil, fmt.Errorf("invalid log format")
    }
    
    timestamp, _ := time.Parse(time.RFC3339, matches[1])
    
    return &LogEntry{
        Timestamp: timestamp,
        Level:     matches[2],
        Service:   matches[3],
        Message:   matches[4],
    }, nil
}

// Analyze logs and generate report
func analyzeLogs(logs []string) *LogReport {
    report := &LogReport{
        Services: make(map[string]int),
    }
    
    var minTime, maxTime time.Time
    
    for _, line := range logs {
        entry, err := parseLog(line)
        if err != nil {
            continue
        }
        
        report.TotalEntries++
        report.Entries = append(report.Entries, *entry)
        
        // Count by level
        switch strings.ToUpper(entry.Level) {
        case "ERROR":
            report.ErrorCount++
        case "WARN":
            report.WarnCount++
        case "INFO":
            report.InfoCount++
        }
        
        // Count by service
        report.Services[entry.Service]++
        
        // Track time range
        if minTime.IsZero() || entry.Timestamp.Before(minTime) {
            minTime = entry.Timestamp
        }
        if maxTime.IsZero() || entry.Timestamp.After(maxTime) {
            maxTime = entry.Timestamp
        }
    }
    
    if !minTime.IsZero() {
        report.TimeRange = fmt.Sprintf("%s to %s",
            minTime.Format("2006-01-02 15:04:05"),
            maxTime.Format("2006-01-02 15:04:05"))
    }
    
    return report
}

// Generate HTML report using template
func generateReport(report *LogReport) string {
    const reportTemplate = `
<!DOCTYPE html>
<html>
<head>
    <title>Log Analysis Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .summary { background: #f0f0f0; padding: 15px; border-radius: 5px; }
        .stat { display: inline-block; margin: 10px; padding: 10px; background: white; }
        .error { color: red; }
        .warn { color: orange; }
        .info { color: blue; }
        table { border-collapse: collapse; width: 100%; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #4CAF50; color: white; }
    </style>
</head>
<body>
    <h1>Log Analysis Report</h1>
    
    <div class="summary">
        <h2>Summary</h2>
        <div class="stat">Total Entries: <strong>{{.TotalEntries}}</strong></div>
        <div class="stat error">Errors: <strong>{{.ErrorCount}}</strong></div>
        <div class="stat warn">Warnings: <strong>{{.WarnCount}}</strong></div>
        <div class="stat info">Info: <strong>{{.InfoCount}}</strong></div>
        <p>Time Range: {{.TimeRange}}</p>
    </div>
    
    <h2>Service Distribution</h2>
    <table>
        <tr>
            <th>Service</th>
            <th>Count</th>
        </tr>
        {{range $service, $count := .Services}}
        <tr>
            <td>{{$service}}</td>
            <td>{{$count}}</td>
        </tr>
        {{end}}
    </table>
    
    <h2>Recent Errors</h2>
    <table>
        <tr>
            <th>Time</th>
            <th>Level</th>
            <th>Service</th>
            <th>Message</th>
        </tr>
        {{range .Entries}}
        {{if eq .Level "ERROR"}}
        <tr>
            <td>{{.Timestamp.Format "15:04:05"}}</td>
            <td class="error">{{.Level}}</td>
            <td>{{.Service}}</td>
            <td>{{.Message}}</td>
        </tr>
        {{end}}
        {{end}}
    </table>
</body>
</html>
`
    
    t := template.Must(template.New("report").Parse(reportTemplate))
    
    var builder strings.Builder
    t.Execute(&builder, report)
    
    return builder.String()
}

func main() {
    // Sample log data
    logs := []string{
        "2024-12-24T10:00:00Z [INFO] [WebServer] Server started",
        "2024-12-24T10:05:00Z [ERROR] [Database] Connection timeout",
        "2024-12-24T10:10:00Z [WARN] [Cache] Cache miss rate high",
        "2024-12-24T10:15:00Z [INFO] [WebServer] Request processed",
        "2024-12-24T10:20:00Z [ERROR] [API] Rate limit exceeded",
    }
    
    // Analyze logs
    report := analyzeLogs(logs)
    
    // Generate HTML report
    html := generateReport(report)
    
    fmt.Println(html)
}
```

This example demonstrates:

- **Regex**: Parsing complex log format with capture groups
- **String Functions**: Splitting, comparing, building with `strings.Builder`
- **Formatting**: Using `fmt.Sprintf` for time formatting
- **Templates**: Generating HTML with conditionals, ranges, and formatting
- **Best Practices**: Compiled regex, efficient string building, structured data

## Conclusion

Mastering strings and text manipulation in Go requires understanding several interconnected concepts:

**Strings** are immutable UTF-8 byte sequences with efficient internal representation. Understanding the difference between bytes and runes is crucial for correct Unicode handling.

**String Functions** from the `strings` package provide building blocks for text manipulation. Use `strings.Builder` for efficient concatenation and prefer built-in functions over manual implementations.

**String Formatting** with `fmt` offers powerful output control. Learn the formatting verbs, understand width and precision, and implement custom formatters when needed.

**Text Templates** separate presentation from data, enabling maintainable code generation. Master the template syntax, use pipelines and functions effectively, and prefer `html/template` for web content.

**Regular Expressions** provide pattern matching for complex text processing. Compile patterns once, understand the syntax deeply, and always benchmark performance-critical code.

Together, these tools form the foundation of text processing in Go, enabling you to build robust, efficient applications that handle text correctly and securely. Whether you're parsing logs, generating reports, validating input, or building web applications, these skills will serve you well throughout your development career.