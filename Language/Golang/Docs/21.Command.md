# The Complete Guide to Go Command-Line Applications - Part 1 of 3

## From Basic Arguments to Advanced CLI Tools

---

## Table of Contents - Complete Guide

### Part 1 (This Document)

1. [Introduction: Why Command-Line Applications Matter](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#introduction-why-command-line-applications-matter)
2. [The Necessity of CLI Tools](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#the-necessity-of-cli-tools)
3. [Command-Line Fundamentals](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#command-line-fundamentals)
4. [Command-Line Arguments](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#command-line-arguments)
5. [Command-Line Flags](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#command-line-flags)
6. [Real-World Use Cases](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#real-world-use-cases)

### Part 2

7. Command-Line Subcommands
8. Advanced Flag Patterns
9. Configuration Management
10. Input/Output Handling
11. Interactive CLI Applications
12. CLI Testing

### Part 3

13. Production CLI Best Practices
14. CLI Frameworks (Cobra, urfave/cli)
15. Building Distribution-Ready CLIs
16. Cross-Platform Considerations
17. Advanced Patterns and Techniques
18. Complete Production Examples

---

## Introduction: Why Command-Line Applications Matter

Imagine you need to process thousands of log files, deploy applications to multiple servers, or manage database migrations. While GUIs are great for occasional tasks, command-line tools excel at automation, scripting, and batch processing.

**Without proper CLI design:**

```bash
# Bad: Unclear, hard to remember
./app file1.txt file2.txt yes no 8080 localhost debug

# What does each argument mean?
# Which one is the port?
# Can I skip optional parameters?
# How do I get help?
```

**With proper CLI design:**

```bash
# Good: Self-documenting, flexible
./app process \
  --input file1.txt \
  --output file2.txt \
  --port 8080 \
  --host localhost \
  --log-level debug \
  --verbose

# Clear what each option does
# Can omit optional flags
# Can use --help anytime
# Easy to script and automate
```

**The Power of CLI Tools:**

```
Command-Line Tools Enable:

Automation:
├─ Scripting repetitive tasks
├─ CI/CD pipeline integration
├─ Scheduled jobs (cron)
└─ Batch processing

Composability:
├─ Unix pipeline: cmd1 | cmd2 | cmd3
├─ Input/output redirection
├─ Command chaining with &&, ||
└─ Shell scripting integration

Remote Access:
├─ SSH into servers
├─ Execute over network
├─ No GUI required
└─ Works in any terminal

Efficiency:
├─ Faster than GUI for repetitive tasks
├─ Scriptable for batch operations
├─ Lower resource usage
└─ Direct system access
```

Go is ideal for CLI tools because:

- **Single binary**: No runtime dependencies, easy distribution
- **Cross-platform**: Compile for any OS
- **Fast startup**: No JVM warmup or interpreter overhead
- **Strong stdlib**: Excellent built-in support for CLI development
- **Easy concurrency**: Handle parallel operations naturally

---

## The Necessity of CLI Tools

CLI applications aren't just nice to have—they're essential for professional software development. Let's explore why.

### The Automation Problem

Manual operations don't scale. GUI tools require human interaction, making batch operations impossible.

**Problem: Manual GUI Operations**

```
Scenario: Process 1000 images
├─ Open image editor
├─ File → Open → Select image
├─ Resize to 800x600
├─ File → Save As → Choose format
├─ Repeat 999 more times...
└─ Time: ~2 hours (human gets tired, makes mistakes)

Problems:
✗ Time-consuming
✗ Error-prone
✗ Not reproducible
✗ Can't automate
✗ Requires human presence
```

**Solution: CLI Tool**

```bash
# Process all images in one command
./imageproc resize \
  --input "*.jpg" \
  --output processed/ \
  --width 800 \
  --height 600 \
  --format png \
  --parallel 8

# Time: ~30 seconds
# Errors: None (consistent processing)
# Reproducible: Same command, same results
# Scriptable: Add to automation
```

### The Integration Problem

Modern development requires tool integration—version control, CI/CD, deployment, monitoring. These systems need programmatic interfaces.

**Problem: GUI-Only Tools Can't Integrate**

```
CI/CD Pipeline Needs:
├─ Run tests
├─ Build application
├─ Run security scans
├─ Deploy to staging
├─ Run smoke tests
└─ Deploy to production

With GUI tools:
✗ Can't trigger from CI/CD
✗ Manual intervention required
✗ No automation possible
✗ Blocks deployment pipeline
```

**Solution: CLI Tools Enable Integration**

```yaml
# .github/workflows/deploy.yml
name: Deploy
on: [push]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Run tests
        run: ./myapp test --coverage
      
      - name: Build
        run: ./myapp build --release
      
      - name: Security scan
        run: ./myapp scan --severity high
      
      - name: Deploy
        run: ./myapp deploy --env staging
      
      - name: Smoke tests
        run: ./myapp test --smoke --endpoint staging
      
      - name: Production deploy
        run: ./myapp deploy --env production

# Fully automated, no human intervention
```

### The Scripting Problem

System administration, DevOps, and data processing require scriptable tools.

**Problem: Non-Scriptable Operations**

```
Database Migration Task:
1. Backup current database
2. Run migration scripts
3. Verify data integrity
4. If verification fails, restore backup
5. Update application config
6. Restart services

Without CLI:
✗ Manual steps
✗ High error risk
✗ Can't automate rollback
✗ Inconsistent across environments
```

**Solution: CLI-Based Automation**

```bash
#!/bin/bash
set -e  # Exit on error

echo "Starting migration..."

# Backup
./dbmigrate backup --output backup_$(date +%Y%m%d).sql

# Migrate
./dbmigrate migrate --version 2.0 --no-prompt

# Verify
if ! ./dbmigrate verify --schema 2.0; then
    echo "Verification failed! Rolling back..."
    ./dbmigrate restore --file backup_$(date +%Y%m%d).sql
    exit 1
fi

# Update config
./config set database.version 2.0

# Restart
./service restart myapp

echo "Migration complete!"
```

### The Remote Access Problem

Servers often have no GUI—SSH access with command-line only.

**Problem: GUI Requires Display**

```
SSH into production server:
$ ssh user@production-server

Can't use GUI tools:
✗ No X11 forwarding
✗ No graphical display
✗ No remote desktop
✗ Terminal only
```

**Solution: CLI Works Everywhere**

```bash
# SSH into server
ssh user@production-server

# Check application status
./myapp status

# View logs
./myapp logs --tail 100 --follow

# Restart service
./myapp restart --graceful

# Check metrics
./myapp metrics --format json | jq '.memory_usage'

# Deploy new version
./myapp deploy --version 1.2.3 --zero-downtime

# Everything works over SSH!
```

### The Reproducibility Problem

Operations must be repeatable and documented. Manual steps are hard to reproduce exactly.

**Problem: Manual Process Documentation**

```
Deployment Runbook:
1. Open admin panel at http://admin.example.com
2. Click "Deployments" tab
3. Select environment from dropdown
4. Upload artifact file
5. Check "Rolling update" option
6. Set health check timeout to 60 seconds
7. Click "Deploy"
8. Wait for progress bar
9. Click "Verify" button
10. Check all services are green

Problems:
✗ Steps might be missed
✗ Settings might be wrong
✗ Different people do it differently
✗ Hard to verify it was done correctly
```

**Solution: Script Defines Process**

```bash
#!/bin/bash
# deploy.sh - Reproducible deployment script

./deployer deploy \
  --artifact ./build/app-v1.2.3.tar.gz \
  --environment production \
  --strategy rolling \
  --health-check-timeout 60s \
  --verify \
  --wait

# Script documents exact process
# Same results every time
# Easy to review
# Can be version controlled
```

---

## Command-Line Fundamentals

Understanding how command-line applications work at the operating system level.

### How Command-Line Works

When you run a command, the operating system follows this process:

```
User types: ./myapp --verbose process file.txt

Step 1: Shell parses command line
┌─────────────────────────────────────┐
│ ./myapp --verbose process file.txt  │
└─────────────────────────────────────┘
         │
         ├─ Program: ./myapp
         ├─ Args: ["--verbose", "process", "file.txt"]
         └─ Environment variables available

Step 2: OS loads executable
┌────────────────┐
│ Load ./myapp   │
│ into memory    │
└────────────────┘

Step 3: OS passes arguments
┌─────────────────────────────┐
│ argv[0] = "./myapp"         │
│ argv[1] = "--verbose"       │
│ argv[2] = "process"         │
│ argv[3] = "file.txt"        │
│ argc = 4                    │
└─────────────────────────────┘

Step 4: Program executes
┌─────────────────────────────┐
│ func main() {               │
│   args := os.Args           │
│   // args[0] = "./myapp"    │
│   // args[1] = "--verbose"  │
│   // args[2] = "process"    │
│   // args[3] = "file.txt"   │
│ }                           │
└─────────────────────────────┘

Step 5: Program exits
┌─────────────────────────────┐
│ Exit code:                  │
│   0 = Success               │
│   1-255 = Error             │
└─────────────────────────────┘
```

### Exit Codes

Programs communicate success/failure through exit codes:

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    if err := run(); err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)  // Non-zero indicates error
    }
    // Implicit os.Exit(0) on normal return
}

func run() error {
    // Application logic
    return nil
}
```

**Standard Exit Codes:**

```
0   = Success
1   = General error
2   = Misuse of shell command
64  = Command line usage error
65  = Data format error
66  = Cannot open input
67  = Addressee unknown
68  = Host name unknown
69  = Service unavailable
70  = Internal software error
71  = System error (e.g., can't fork)
72  = Critical OS file missing
73  = Can't create output file
74  = Input/output error
75  = Temporary failure
76  = Remote error in protocol
77  = Permission denied
78  = Configuration error
```

**Usage in Scripts:**

```bash
#!/bin/bash

# Run command and check exit code
./myapp process file.txt

if [ $? -eq 0 ]; then
    echo "Success!"
else
    echo "Failed with exit code: $?"
    exit 1
fi

# Or use &&, ||
./myapp process file.txt && echo "Success" || echo "Failed"

# Chain commands (only proceed if previous succeeds)
./myapp prepare && ./myapp process && ./myapp finalize
```

### Standard Input/Output/Error

CLI programs have three standard streams:

```
Standard Streams:

stdin (0):  Input stream
            ├─ Read user input
            ├─ Read from file: < input.txt
            ├─ Read from pipe: echo "data" | myapp
            └─ Default: keyboard

stdout (1): Output stream
            ├─ Normal program output
            ├─ Redirect to file: > output.txt
            ├─ Pipe to next command: | grep "pattern"
            └─ Default: terminal

stderr (2): Error stream
            ├─ Error messages
            ├─ Diagnostic output
            ├─ Redirect: 2> errors.txt
            └─ Default: terminal (separate from stdout)
```

**Go Implementation:**

```go
package main

import (
    "fmt"
    "io"
    "os"
)

func main() {
    // Write to stdout (normal output)
    fmt.Println("This goes to stdout")
    
    // Write to stderr (errors/diagnostics)
    fmt.Fprintln(os.Stderr, "This goes to stderr")
    
    // Read from stdin
    data, err := io.ReadAll(os.Stdin)
    if err != nil {
        fmt.Fprintf(os.Stderr, "Error reading stdin: %v\n", err)
        os.Exit(1)
    }
    
    // Process and output
    fmt.Printf("Read %d bytes from stdin\n", len(data))
}
```

**Usage Examples:**

```bash
# Redirect stdout to file
./myapp > output.txt

# Redirect stderr to file
./myapp 2> errors.txt

# Redirect both to different files
./myapp > output.txt 2> errors.txt

# Redirect both to same file
./myapp > all.txt 2>&1

# Pipe stdout to next command
./myapp | grep "pattern"

# Pipe stdin from file
./myapp < input.txt

# Combine pipes
cat input.txt | ./myapp | sort | uniq > output.txt
```

---

## Command-Line Arguments

Arguments are positional parameters passed to your program.

### Accessing Arguments in Go

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    // os.Args is a slice of strings
    // os.Args[0] is the program name
    // os.Args[1:] are the arguments
    
    fmt.Printf("Program: %s\n", os.Args[0])
    fmt.Printf("Arguments: %v\n", os.Args[1:])
    fmt.Printf("Argument count: %d\n", len(os.Args)-1)
    
    // Access individual arguments
    if len(os.Args) > 1 {
        firstArg := os.Args[1]
        fmt.Printf("First argument: %s\n", firstArg)
    }
}
```

**Example Usage:**

```bash
$ ./myapp hello world 123
Program: ./myapp
Arguments: [hello world 123]
Argument count: 3
First argument: hello
```

### Simple Argument Processing

```go
package main

import (
    "fmt"
    "os"
    "strconv"
)

func main() {
    if len(os.Args) < 3 {
        fmt.Fprintf(os.Stderr, "Usage: %s <operation> <number1> <number2>\n", os.Args[0])
        fmt.Fprintf(os.Stderr, "Operations: add, subtract, multiply, divide\n")
        os.Exit(1)
    }
    
    operation := os.Args[1]
    
    num1, err := strconv.ParseFloat(os.Args[2], 64)
    if err != nil {
        fmt.Fprintf(os.Stderr, "Invalid number: %s\n", os.Args[2])
        os.Exit(1)
    }
    
    num2, err := strconv.ParseFloat(os.Args[3], 64)
    if err != nil {
        fmt.Fprintf(os.Stderr, "Invalid number: %s\n", os.Args[3])
        os.Exit(1)
    }
    
    var result float64
    
    switch operation {
    case "add":
        result = num1 + num2
    case "subtract":
        result = num1 - num2
    case "multiply":
        result = num1 * num2
    case "divide":
        if num2 == 0 {
            fmt.Fprintf(os.Stderr, "Error: Division by zero\n")
            os.Exit(1)
        }
        result = num1 / num2
    default:
        fmt.Fprintf(os.Stderr, "Unknown operation: %s\n", operation)
        os.Exit(1)
    }
    
    fmt.Printf("%.2f\n", result)
}
```

**Usage:**

```bash
$ ./calc add 10 5
15.00

$ ./calc multiply 7 8
56.00

$ ./calc divide 10 0
Error: Division by zero
```

### Arguments vs Flags

Understanding when to use positional arguments vs named flags:

```
Use Positional Arguments When:
✓ Parameter is required
✓ Order is natural and obvious
✓ Single primary input (like filename)
✓ Simple, well-known commands

Examples:
./cp source.txt dest.txt        # Source and dest are obvious
./cat file.txt                  # File is the obvious input
./rm file.txt                   # File to remove is clear
./git clone <url>               # URL is the main parameter

Use Named Flags When:
✓ Parameters are optional
✓ Many parameters available
✓ Order shouldn't matter
✓ Parameters aren't obvious

Examples:
./myapp --host localhost --port 8080 --timeout 30s
./myapp --verbose --log-level debug --config app.yaml
./myapp --input file.txt --output result.txt --format json

Combine Both:
./kubectl get pods nginx-123 --namespace production
                   ↑            ↑
              Required arg   Optional flags
```

---

## Command-Line Flags

Flags (also called options) provide named parameters that can be in any order.

### Using the flag Package

Go's standard library provides the `flag` package for parsing flags:

```go
package main

import (
    "flag"
    "fmt"
    "os"
)

func main() {
    // Define flags
    var (
        host    = flag.String("host", "localhost", "Server hostname")
        port    = flag.Int("port", 8080, "Server port")
        verbose = flag.Bool("verbose", false, "Enable verbose output")
        timeout = flag.Duration("timeout", 30*time.Second, "Connection timeout")
    )
    
    // Parse flags
    flag.Parse()
    
    // Use flag values
    fmt.Printf("Host: %s\n", *host)
    fmt.Printf("Port: %d\n", *port)
    fmt.Printf("Verbose: %t\n", *verbose)
    fmt.Printf("Timeout: %v\n", *timeout)
    
    // Get remaining arguments (non-flag arguments)
    args := flag.Args()
    fmt.Printf("Arguments: %v\n", args)
}
```

**Usage Examples:**

```bash
# Default values
$ ./myapp
Host: localhost
Port: 8080
Verbose: false
Timeout: 30s
Arguments: []

# Override some flags
$ ./myapp --host example.com --port 9000
Host: example.com
Port: 9000
Verbose: false
Timeout: 30s

# Boolean flags (no value needed)
$ ./myapp --verbose
Verbose: true

# With non-flag arguments
$ ./myapp --port 9000 file1.txt file2.txt
Port: 9000
Arguments: [file1.txt file2.txt]

# Get help
$ ./myapp --help
Usage of ./myapp:
  -host string
        Server hostname (default "localhost")
  -port int
        Server port (default 8080)
  -timeout duration
        Connection timeout (default 30s)
  -verbose
        Enable verbose output
```

### Flag Types

The flag package supports various types:

```go
package main

import (
    "flag"
    "fmt"
    "time"
)

func main() {
    // String flag
    name := flag.String("name", "default", "User name")
    
    // Integer flags
    count := flag.Int("count", 10, "Number of items")
    count64 := flag.Int64("count64", 100, "64-bit count")
    
    // Unsigned integer
    port := flag.Uint("port", 8080, "Port number")
    
    // Float flags
    rate := flag.Float64("rate", 0.5, "Processing rate")
    
    // Boolean flag
    enabled := flag.Bool("enabled", false, "Enable feature")
    
    // Duration flag (parses "1h", "30m", "10s", etc.)
    timeout := flag.Duration("timeout", 30*time.Second, "Timeout duration")
    
    flag.Parse()
    
    fmt.Printf("Name: %s\n", *name)
    fmt.Printf("Count: %d\n", *count)
    fmt.Printf("Count64: %d\n", *count64)
    fmt.Printf("Port: %d\n", *port)
    fmt.Printf("Rate: %.2f\n", *rate)
    fmt.Printf("Enabled: %t\n", *enabled)
    fmt.Printf("Timeout: %v\n", *timeout)
}
```

**Usage:**

```bash
$ ./myapp \
  --name "John Doe" \
  --count 100 \
  --port 9000 \
  --rate 0.75 \
  --enabled \
  --timeout 1m30s

Name: John Doe
Count: 100
Port: 9000
Rate: 0.75
Enabled: true
Timeout: 1m30s
```

### Custom Flag Values

You can define custom flag types:

```go
package main

import (
    "flag"
    "fmt"
    "strings"
)

// StringSlice implements flag.Value for []string
type StringSlice []string

func (s *StringSlice) String() string {
    return strings.Join(*s, ",")
}

func (s *StringSlice) Set(value string) error {
    *s = append(*s, value)
    return nil
}

// LogLevel implements flag.Value for custom enum
type LogLevel string

const (
    LogDebug LogLevel = "debug"
    LogInfo  LogLevel = "info"
    LogWarn  LogLevel = "warn"
    LogError LogLevel = "error"
)

func (l *LogLevel) String() string {
    return string(*l)
}

func (l *LogLevel) Set(value string) error {
    switch value {
    case "debug", "info", "warn", "error":
        *l = LogLevel(value)
        return nil
    default:
        return fmt.Errorf("invalid log level: %s", value)
    }
}

func main() {
    // Custom flag types
    var tags StringSlice
    flag.Var(&tags, "tag", "Add tag (can be specified multiple times)")
    
    var logLevel LogLevel = LogInfo
    flag.Var(&logLevel, "log-level", "Set log level (debug|info|warn|error)")
    
    flag.Parse()
    
    fmt.Printf("Tags: %v\n", tags)
    fmt.Printf("Log Level: %s\n", logLevel)
}
```

**Usage:**

```bash
$ ./myapp --tag dev --tag api --tag v1 --log-level debug
Tags: [dev api v1]
Log Level: debug
```

### Flag Parsing Patterns

**Pattern 1: Flag Struct**

```go
type Config struct {
    Host     string
    Port     int
    Verbose  bool
    LogLevel string
}

func parseFlags() *Config {
    config := &Config{}
    
    flag.StringVar(&config.Host, "host", "localhost", "Server host")
    flag.IntVar(&config.Port, "port", 8080, "Server port")
    flag.BoolVar(&config.Verbose, "verbose", false, "Verbose output")
    flag.StringVar(&config.LogLevel, "log-level", "info", "Log level")
    
    flag.Parse()
    
    return config
}

func main() {
    config := parseFlags()
    fmt.Printf("Config: %+v\n", config)
}
```

**Pattern 2: Custom FlagSet**

```go
func main() {
    // Create custom flag set
    fs := flag.NewFlagSet("myapp", flag.ExitOnError)
    
    host := fs.String("host", "localhost", "Server host")
    port := fs.Int("port", 8080, "Server port")
    
    // Parse specific arguments
    fs.Parse(os.Args[1:])
    
    fmt.Printf("Host: %s, Port: %d\n", *host, *port)
}
```

**Pattern 3: Validation**

```go
func main() {
    port := flag.Int("port", 8080, "Server port")
    
    flag.Parse()
    
    // Validate flags
    if *port < 1 || *port > 65535 {
        fmt.Fprintf(os.Stderr, "Invalid port: %d (must be 1-65535)\n", *port)
        os.Exit(1)
    }
    
    fmt.Printf("Starting server on port %d\n", *port)
}
```

---

## Real-World Use Cases

### Use Case 1: File Processing Tool

```go
package main

import (
    "bufio"
    "flag"
    "fmt"
    "os"
    "strings"
)

type Config struct {
    InputFile  string
    OutputFile string
    Search     string
    Replace    string
    CaseInsensitive bool
    LineNumbers bool
}

func main() {
    config := parseFlags()
    
    if err := run(config); err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)
    }
}

func parseFlags() *Config {
    config := &Config{}
    
    flag.StringVar(&config.InputFile, "input", "", "Input file (required)")
    flag.StringVar(&config.OutputFile, "output", "", "Output file (stdout if not specified)")
    flag.StringVar(&config.Search, "search", "", "Search pattern (required)")
    flag.StringVar(&config.Replace, "replace", "", "Replacement text")
    flag.BoolVar(&config.CaseInsensitive, "ignore-case", false, "Case insensitive search")
    flag.BoolVar(&config.LineNumbers, "line-numbers", false, "Show line numbers")
    
    flag.Parse()
    
    // Validation
    if config.InputFile == "" {
        fmt.Fprintln(os.Stderr, "Error: --input is required")
        flag.Usage()
        os.Exit(1)
    }
    
    if config.Search == "" {
        fmt.Fprintln(os.Stderr, "Error: --search is required")
        flag.Usage()
        os.Exit(1)
    }
    
    return config
}

func run(config *Config) error {
    // Open input file
    input, err := os.Open(config.InputFile)
    if err != nil {
        return fmt.Errorf("failed to open input file: %w", err)
    }
    defer input.Close()
    
    // Open output file or use stdout
    var output *os.File
    if config.OutputFile != "" {
        output, err = os.Create(config.OutputFile)
        if err != nil {
            return fmt.Errorf("failed to create output file: %w", err)
        }
        defer output.Close()
    } else {
        output = os.Stdout
    }
    
    // Process file line by line
    scanner := bufio.NewScanner(input)
    lineNum := 0
    
    for scanner.Scan() {
        lineNum++
        line := scanner.Text()
        
        // Search and optionally replace
        var processedLine string
        if config.Replace != "" {
            if config.CaseInsensitive {
                processedLine = replaceIgnoreCase(line, config.Search, config.Replace)
            } else {
                processedLine = strings.ReplaceAll(line, config.Search, config.Replace)
            }
        } else {
            // Just search
            var found bool
            if config.CaseInsensitive {
                found = strings.Contains(strings.ToLower(line), strings.ToLower(config.Search))
            } else {
                found = strings.Contains(line, config.Search)
            }
            
            if !found {
                continue // Skip lines that don't match
            }
            processedLine = line
        }
        
        // Write output
        if config.LineNumbers {
            fmt.Fprintf(output, "%d: %s\n", lineNum, processedLine)
        } else {
            fmt.Fprintln(output, processedLine)
        }
    }
    
    if err := scanner.Err(); err != nil {
        return fmt.Errorf("error reading file: %w", err)
    }
    
    return nil
}

func replaceIgnoreCase(s, old, new string) string {
    // Simple case-insensitive replace
    oldLower := strings.ToLower(old)
    sLower := strings.ToLower(s)
    
    result := ""
    for len(s) > 0 {
        idx := strings.Index(sLower, oldLower)
        if idx == -1 {
            result += s
            break
        }
        
        result += s[:idx] + new
        s = s[idx+len(old):]
        sLower = sLower[idx+len(old):]
    }
    
    return result
}
```

**Usage:**

```bash
# Search for pattern
./fileproc --input data.txt --search "error"

# Search and replace
./fileproc --input data.txt --output fixed.txt \
  --search "old_value" --replace "new_value"

# Case-insensitive search with line numbers
./fileproc --input log.txt --search "warning" \
  --ignore-case --line-numbers

# Pipe output to other tools
./fileproc --input data.txt --search "ERROR" | wc -l
```

# The Complete Guide to Go Command-Line Applications - Part 2 of 3

## Subcommands, Advanced Patterns, Configuration, and Testing

---

## Table of Contents - Part 2

1. [Command-Line Subcommands](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#command-line-subcommands)
2. [Advanced Flag Patterns](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#advanced-flag-patterns)
3. [Configuration Management](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#configuration-management)
4. [Input/Output Handling](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#input-output-handling)
5. [Interactive CLI Applications](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#interactive-cli-applications)
6. [CLI Testing](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#cli-testing)

---

## Command-Line Subcommands

Subcommands enable complex CLI tools with multiple operations, like `git commit`, `docker run`, `kubectl get`.

### Why Subcommands?

**Without Subcommands - Single Command Tool:**

```bash
# Every operation is a separate binary
./create-user --name john --email john@example.com
./delete-user --id 123
./list-users --active
./update-user --id 123 --name john2

Problems:
✗ Many separate binaries
✗ Inconsistent flag names
✗ Hard to maintain
✗ No unified help
```

**With Subcommands - Unified Tool:**

```bash
# Single binary, multiple commands
./usermgr create --name john --email john@example.com
./usermgr delete --id 123
./usermgr list --active
./usermgr update --id 123 --name john2

Benefits:
✓ Single binary to distribute
✓ Consistent flag handling
✓ Unified help system
✓ Clear command hierarchy
✓ Easy to add new commands
```

### Basic Subcommand Implementation

```go
package main

import (
    "flag"
    "fmt"
    "os"
)

func main() {
    if len(os.Args) < 2 {
        printUsage()
        os.Exit(1)
    }

    // Get subcommand
    subcommand := os.Args[1]

    switch subcommand {
    case "create":
        createCommand(os.Args[2:])
    case "delete":
        deleteCommand(os.Args[2:])
    case "list":
        listCommand(os.Args[2:])
    case "help":
        printUsage()
    default:
        fmt.Fprintf(os.Stderr, "Unknown command: %s\n", subcommand)
        printUsage()
        os.Exit(1)
    }
}

func printUsage() {
    fmt.Fprintf(os.Stderr, `Usage: usermgr <command> [options]

Commands:
  create    Create a new user
  delete    Delete a user
  list      List users
  help      Show this help message

Use "usermgr <command> --help" for more information about a command.
`)
}

func createCommand(args []string) {
    fs := flag.NewFlagSet("create", flag.ExitOnError)
    name := fs.String("name", "", "User name (required)")
    email := fs.String("email", "", "User email (required)")
    admin := fs.Bool("admin", false, "Make user admin")

    fs.Parse(args)

    // Validation
    if *name == "" || *email == "" {
        fmt.Fprintf(os.Stderr, "Error: --name and --email are required\n")
        fs.Usage()
        os.Exit(1)
    }

    // Execute command
    fmt.Printf("Creating user: %s <%s> (admin: %t)\n", *name, *email, *admin)
}

func deleteCommand(args []string) {
    fs := flag.NewFlagSet("delete", flag.ExitOnError)
    id := fs.Int("id", 0, "User ID (required)")
    force := fs.Bool("force", false, "Force deletion without confirmation")

    fs.Parse(args)

    if *id == 0 {
        fmt.Fprintf(os.Stderr, "Error: --id is required\n")
        fs.Usage()
        os.Exit(1)
    }

    if !*force {
        fmt.Print("Are you sure? (yes/no): ")
        var response string
        fmt.Scanln(&response)
        if response != "yes" {
            fmt.Println("Deletion cancelled")
            return
        }
    }

    fmt.Printf("Deleting user ID: %d\n", *id)
}

func listCommand(args []string) {
    fs := flag.NewFlagSet("list", flag.ExitOnError)
    active := fs.Bool("active", false, "Show only active users")
    limit := fs.Int("limit", 10, "Maximum number of users to show")

    fs.Parse(args)

    fmt.Printf("Listing users (active: %t, limit: %d)\n", *active, *limit)
}
```

**Usage:**

```bash
# Show help
$ ./usermgr help
Usage: usermgr <command> [options]
...

# Create user
$ ./usermgr create --name "John Doe" --email john@example.com
Creating user: John Doe <john@example.com> (admin: false)

# Create admin user
$ ./usermgr create --name "Admin" --email admin@example.com --admin
Creating user: Admin <admin@example.com> (admin: true)

# Delete user
$ ./usermgr delete --id 123
Are you sure? (yes/no): yes
Deleting user ID: 123

# Force delete
$ ./usermgr delete --id 456 --force
Deleting user ID: 456

# List users
$ ./usermgr list --active --limit 20
Listing users (active: true, limit: 20)
```

### Structured Subcommand System

For larger applications, use a structured approach:

```go
package main

import (
    "flag"
    "fmt"
    "os"
)

// Command represents a subcommand
type Command struct {
    Name        string
    Description string
    Flags       *flag.FlagSet
    Run         func(args []string) error
}

// Application holds all commands
type Application struct {
    Name     string
    Version  string
    Commands map[string]*Command
}

func NewApplication(name, version string) *Application {
    return &Application{
        Name:     name,
        Version:  version,
        Commands: make(map[string]*Command),
    }
}

func (app *Application) AddCommand(cmd *Command) {
    app.Commands[cmd.Name] = cmd
}

func (app *Application) Run(args []string) error {
    if len(args) < 1 {
        app.printUsage()
        return fmt.Errorf("no command specified")
    }

    cmdName := args[0]

    // Handle special commands
    switch cmdName {
    case "help":
        if len(args) > 1 {
            return app.printCommandHelp(args[1])
        }
        app.printUsage()
        return nil
    case "version":
        fmt.Printf("%s version %s\n", app.Name, app.Version)
        return nil
    }

    // Find and run command
    cmd, exists := app.Commands[cmdName]
    if !exists {
        return fmt.Errorf("unknown command: %s", cmdName)
    }

    // Parse flags and run
    if err := cmd.Flags.Parse(args[1:]); err != nil {
        return err
    }

    return cmd.Run(cmd.Flags.Args())
}

func (app *Application) printUsage() {
    fmt.Fprintf(os.Stderr, "%s version %s\n\n", app.Name, app.Version)
    fmt.Fprintf(os.Stderr, "Usage: %s <command> [options]\n\n", app.Name)
    fmt.Fprintf(os.Stderr, "Commands:\n")

    for name, cmd := range app.Commands {
        fmt.Fprintf(os.Stderr, "  %-12s %s\n", name, cmd.Description)
    }

    fmt.Fprintf(os.Stderr, "  %-12s %s\n", "help", "Show help")
    fmt.Fprintf(os.Stderr, "  %-12s %s\n", "version", "Show version")
    fmt.Fprintf(os.Stderr, "\nUse \"%s help <command>\" for more information.\n", app.Name)
}

func (app *Application) printCommandHelp(cmdName string) error {
    cmd, exists := app.Commands[cmdName]
    if !exists {
        return fmt.Errorf("unknown command: %s", cmdName)
    }

    fmt.Fprintf(os.Stderr, "Usage: %s %s [options]\n\n", app.Name, cmdName)
    fmt.Fprintf(os.Stderr, "%s\n\n", cmd.Description)
    fmt.Fprintf(os.Stderr, "Options:\n")
    cmd.Flags.PrintDefaults()

    return nil
}

func main() {
    app := NewApplication("usermgr", "1.0.0")

    // Create command
    createFlags := flag.NewFlagSet("create", flag.ExitOnError)
    createName := createFlags.String("name", "", "User name (required)")
    createEmail := createFlags.String("email", "", "User email (required)")
    createAdmin := createFlags.Bool("admin", false, "Make user admin")

    app.AddCommand(&Command{
        Name:        "create",
        Description: "Create a new user",
        Flags:       createFlags,
        Run: func(args []string) error {
            if *createName == "" || *createEmail == "" {
                return fmt.Errorf("--name and --email are required")
            }

            fmt.Printf("Creating user: %s <%s> (admin: %t)\n", 
                *createName, *createEmail, *createAdmin)
            return nil
        },
    })

    // Delete command
    deleteFlags := flag.NewFlagSet("delete", flag.ExitOnError)
    deleteID := deleteFlags.Int("id", 0, "User ID (required)")
    deleteForce := deleteFlags.Bool("force", false, "Force deletion")

    app.AddCommand(&Command{
        Name:        "delete",
        Description: "Delete a user",
        Flags:       deleteFlags,
        Run: func(args []string) error {
            if *deleteID == 0 {
                return fmt.Errorf("--id is required")
            }

            if !*deleteForce {
                fmt.Print("Are you sure? (yes/no): ")
                var response string
                fmt.Scanln(&response)
                if response != "yes" {
                    fmt.Println("Cancelled")
                    return nil
                }
            }

            fmt.Printf("Deleting user ID: %d\n", *deleteID)
            return nil
        },
    })

    // List command
    listFlags := flag.NewFlagSet("list", flag.ExitOnError)
    listActive := listFlags.Bool("active", false, "Show only active users")
    listLimit := listFlags.Int("limit", 10, "Maximum number to show")

    app.AddCommand(&Command{
        Name:        "list",
        Description: "List users",
        Flags:       listFlags,
        Run: func(args []string) error {
            fmt.Printf("Listing users (active: %t, limit: %d)\n", 
                *listActive, *listLimit)
            return nil
        },
    })

    // Run application
    if err := app.Run(os.Args[1:]); err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)
    }
}
```

### Nested Subcommands (Git-Style)

For complex tools with command hierarchies like `kubectl get pods`:

```go
package main

import (
    "flag"
    "fmt"
    "os"
    "strings"
)

type CommandTree struct {
    Name        string
    Description string
    Subcommands map[string]*CommandTree
    Flags       *flag.FlagSet
    Run         func(args []string) error
}

func NewCommandTree(name, description string) *CommandTree {
    return &CommandTree{
        Name:        name,
        Description: description,
        Subcommands: make(map[string]*CommandTree),
        Flags:       flag.NewFlagSet(name, flag.ExitOnError),
    }
}

func (ct *CommandTree) AddSubcommand(sub *CommandTree) {
    ct.Subcommands[sub.Name] = sub
}

func (ct *CommandTree) Execute(args []string) error {
    // Parse flags first
    ct.Flags.Parse(args)
    remainingArgs := ct.Flags.Args()

    // If no remaining args and we have a Run function, execute it
    if len(remainingArgs) == 0 {
        if ct.Run != nil {
            return ct.Run(remainingArgs)
        }
        ct.printUsage()
        return nil
    }

    // Check for subcommand
    subcommandName := remainingArgs[0]
    
    if subcommandName == "help" {
        ct.printUsage()
        return nil
    }

    subcommand, exists := ct.Subcommands[subcommandName]
    if !exists {
        if ct.Run != nil {
            return ct.Run(remainingArgs)
        }
        return fmt.Errorf("unknown subcommand: %s", subcommandName)
    }

    return subcommand.Execute(remainingArgs[1:])
}

func (ct *CommandTree) printUsage() {
    fmt.Fprintf(os.Stderr, "Usage: %s [options] [command]\n\n", ct.Name)
    fmt.Fprintf(os.Stderr, "%s\n\n", ct.Description)

    if len(ct.Subcommands) > 0 {
        fmt.Fprintf(os.Stderr, "Commands:\n")
        for name, sub := range ct.Subcommands {
            fmt.Fprintf(os.Stderr, "  %-15s %s\n", name, sub.Description)
        }
        fmt.Fprintf(os.Stderr, "\n")
    }

    if ct.Flags.NFlag() > 0 || ct.Flags.NArg() > 0 {
        fmt.Fprintf(os.Stderr, "Options:\n")
        ct.Flags.PrintDefaults()
    }
}

func main() {
    // Root command
    root := NewCommandTree("kubectl", "Kubernetes command-line tool")
    
    // Global flags
    namespace := root.Flags.String("namespace", "default", "Kubernetes namespace")
    
    // Get command
    getCmd := NewCommandTree("get", "Get resources")
    
    // Get pods subcommand
    getPodsCmd := NewCommandTree("pods", "Get pods")
    allNamespaces := getPodsCmd.Flags.Bool("all-namespaces", false, "List pods in all namespaces")
    selector := getPodsCmd.Flags.String("selector", "", "Label selector")
    
    getPodsCmd.Run = func(args []string) error {
        fmt.Printf("Getting pods in namespace: %s\n", *namespace)
        if *allNamespaces {
            fmt.Println("Showing all namespaces")
        }
        if *selector != "" {
            fmt.Printf("Selector: %s\n", *selector)
        }
        return nil
    }
    
    getCmd.AddSubcommand(getPodsCmd)
    
    // Get services subcommand
    getServicesCmd := NewCommandTree("services", "Get services")
    getServicesCmd.Run = func(args []string) error {
        fmt.Printf("Getting services in namespace: %s\n", *namespace)
        return nil
    }
    
    getCmd.AddSubcommand(getServicesCmd)
    root.AddSubcommand(getCmd)
    
    // Delete command
    deleteCmd := NewCommandTree("delete", "Delete resources")
    force := deleteCmd.Flags.Bool("force", false, "Force deletion")
    
    deletePodCmd := NewCommandTree("pod", "Delete a pod")
    deletePodCmd.Run = func(args []string) error {
        if len(args) == 0 {
            return fmt.Errorf("pod name required")
        }
        fmt.Printf("Deleting pod: %s (force: %t)\n", args[0], *force)
        return nil
    }
    
    deleteCmd.AddSubcommand(deletePodCmd)
    root.AddSubcommand(deleteCmd)
    
    // Execute
    if err := root.Execute(os.Args[1:]); err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)
    }
}
```

**Usage:**

```bash
# Get pods in default namespace
$ ./kubectl get pods
Getting pods in namespace: default

# Get pods in specific namespace
$ ./kubectl --namespace production get pods
Getting pods in namespace: production

# Get pods with selector
$ ./kubectl get pods --selector app=nginx
Getting pods in namespace: default
Selector: app=nginx

# Get pods in all namespaces
$ ./kubectl get pods --all-namespaces
Getting pods in namespace: default
Showing all namespaces

# Delete pod
$ ./kubectl delete pod nginx-123
Deleting pod: nginx-123 (force: false)

# Force delete pod
$ ./kubectl delete pod nginx-123 --force
Deleting pod: nginx-123 (force: true)
```

---

## Advanced Flag Patterns

### Global Flags and Command-Specific Flags

```go
type GlobalFlags struct {
    Verbose bool
    Config  string
    LogFile string
}

type Application struct {
    Global   *GlobalFlags
    Commands map[string]*Command
}

func NewApplication() *Application {
    return &Application{
        Global:   &GlobalFlags{},
        Commands: make(map[string]*Command),
    }
}

func (app *Application) ParseGlobalFlags(args []string) []string {
    fs := flag.NewFlagSet("global", flag.ContinueOnError)
    
    fs.BoolVar(&app.Global.Verbose, "verbose", false, "Verbose output")
    fs.BoolVar(&app.Global.Verbose, "v", false, "Verbose output (shorthand)")
    fs.StringVar(&app.Global.Config, "config", "", "Config file")
    fs.StringVar(&app.Global.LogFile, "log-file", "", "Log file path")
    
    // Parse global flags, stop at first non-flag
    fs.Parse(args)
    
    return fs.Args()
}

func (app *Application) Run(args []string) error {
    // Parse global flags first
    remainingArgs := app.ParseGlobalFlags(args)
    
    if len(remainingArgs) == 0 {
        return fmt.Errorf("no command specified")
    }
    
    // Get command
    cmdName := remainingArgs[0]
    cmd, exists := app.Commands[cmdName]
    if !exists {
        return fmt.Errorf("unknown command: %s", cmdName)
    }
    
    // Run command with remaining args
    return cmd.Run(app, remainingArgs[1:])
}

type Command struct {
    Name string
    Run  func(app *Application, args []string) error
}

func main() {
    app := NewApplication()
    
    app.Commands["process"] = &Command{
        Name: "process",
        Run: func(app *Application, args []string) error {
            // Command-specific flags
            fs := flag.NewFlagSet("process", flag.ExitOnError)
            input := fs.String("input", "", "Input file")
            output := fs.String("output", "", "Output file")
            fs.Parse(args)
            
            // Access global flags
            if app.Global.Verbose {
                fmt.Println("Verbose mode enabled")
            }
            
            fmt.Printf("Processing: %s -> %s\n", *input, *output)
            return nil
        },
    }
    
    if err := app.Run(os.Args[1:]); err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)
    }
}
```

**Usage:**

```bash
# Global flag before command
$ ./app --verbose process --input file.txt --output out.txt
Verbose mode enabled
Processing: file.txt -> out.txt

# Global flag with shorthand
$ ./app -v process --input file.txt
Verbose mode enabled
Processing: file.txt ->
```

### Environment Variable Integration

```go
package main

import (
    "flag"
    "fmt"
    "os"
    "strconv"
)

type Config struct {
    Host     string
    Port     int
    Timeout  int
    LogLevel string
}

func LoadConfig() *Config {
    config := &Config{}
    
    // Priority: 1. Command-line flags, 2. Environment variables, 3. Defaults
    
    // Define flags with defaults
    host := flag.String("host", getEnv("APP_HOST", "localhost"), "Server host")
    port := flag.Int("port", getEnvInt("APP_PORT", 8080), "Server port")
    timeout := flag.Int("timeout", getEnvInt("APP_TIMEOUT", 30), "Timeout in seconds")
    logLevel := flag.String("log-level", getEnv("APP_LOG_LEVEL", "info"), "Log level")
    
    flag.Parse()
    
    config.Host = *host
    config.Port = *port
    config.Timeout = *timeout
    config.LogLevel = *logLevel
    
    return config
}

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func getEnvInt(key string, defaultValue int) int {
    if value := os.Getenv(key); value != "" {
        if intValue, err := strconv.Atoi(value); err == nil {
            return intValue
        }
    }
    return defaultValue
}

func main() {
    config := LoadConfig()
    
    fmt.Printf("Configuration:\n")
    fmt.Printf("  Host: %s\n", config.Host)
    fmt.Printf("  Port: %d\n", config.Port)
    fmt.Printf("  Timeout: %d\n", config.Timeout)
    fmt.Printf("  Log Level: %s\n", config.LogLevel)
}
```

**Usage:**

```bash
# Use defaults
$ ./app
Configuration:
  Host: localhost
  Port: 8080
  Timeout: 30
  Log Level: info

# Use environment variables
$ APP_HOST=example.com APP_PORT=9000 ./app
Configuration:
  Host: example.com
  Port: 9000
  Timeout: 30
  Log Level: info

# Flags override environment variables
$ APP_HOST=example.com ./app --host override.com --port 3000
Configuration:
  Host: override.com
  Port: 3000
  Timeout: 30
  Log Level: info
```

### Required vs Optional Flags

```go
package main

import (
    "flag"
    "fmt"
    "os"
    "strings"
)

type RequiredStringFlag struct {
    Name     string
    Value    *string
    Usage    string
    Required bool
}

func main() {
    var requiredFlags []*RequiredStringFlag
    
    // Required flag
    input := flag.String("input", "", "Input file (required)")
    requiredFlags = append(requiredFlags, &RequiredStringFlag{
        Name:     "input",
        Value:    input,
        Usage:    "Input file",
        Required: true,
    })
    
    // Optional flag
    output := flag.String("output", "", "Output file (optional)")
    
    // Another required flag
    format := flag.String("format", "", "Output format: json|xml|csv (required)")
    requiredFlags = append(requiredFlags, &RequiredStringFlag{
        Name:     "format",
        Value:    format,
        Usage:    "Output format",
        Required: true,
    })
    
    flag.Parse()
    
    // Validate required flags
    var missingFlags []string
    for _, rf := range requiredFlags {
        if *rf.Value == "" {
            missingFlags = append(missingFlags, rf.Name)
        }
    }
    
    if len(missingFlags) > 0 {
        fmt.Fprintf(os.Stderr, "Error: Missing required flags: %s\n", 
            strings.Join(missingFlags, ", "))
        flag.Usage()
        os.Exit(1)
    }
    
    // Validate format
    validFormats := map[string]bool{"json": true, "xml": true, "csv": true}
    if !validFormats[*format] {
        fmt.Fprintf(os.Stderr, "Error: Invalid format: %s\n", *format)
        fmt.Fprintf(os.Stderr, "Valid formats: json, xml, csv\n")
        os.Exit(1)
    }
    
    fmt.Printf("Input: %s\n", *input)
    fmt.Printf("Output: %s\n", *output)
    fmt.Printf("Format: %s\n", *format)
}
```

---

## Configuration Management

### Configuration File Loading

```go
package main

import (
    "encoding/json"
    "flag"
    "fmt"
    "os"
    "path/filepath"
)

type Config struct {
    Server   ServerConfig   `json:"server"`
    Database DatabaseConfig `json:"database"`
    Logging  LoggingConfig  `json:"logging"`
}

type ServerConfig struct {
    Host string `json:"host"`
    Port int    `json:"port"`
}

type DatabaseConfig struct {
    Host     string `json:"host"`
    Port     int    `json:"port"`
    Database string `json:"database"`
    Username string `json:"username"`
    Password string `json:"password"`
}

type LoggingConfig struct {
    Level  string `json:"level"`
    Format string `json:"format"`
    Output string `json:"output"`
}

func LoadConfig(configFile string) (*Config, error) {
    // Default configuration
    config := &Config{
        Server: ServerConfig{
            Host: "localhost",
            Port: 8080,
        },
        Database: DatabaseConfig{
            Host:     "localhost",
            Port:     5432,
            Database: "myapp",
        },
        Logging: LoggingConfig{
            Level:  "info",
            Format: "json",
            Output: "stdout",
        },
    }
    
    // If config file specified, load it
    if configFile != "" {
        file, err := os.Open(configFile)
        if err != nil {
            return nil, fmt.Errorf("failed to open config file: %w", err)
        }
        defer file.Close()
        
        decoder := json.NewDecoder(file)
        if err := decoder.Decode(config); err != nil {
            return nil, fmt.Errorf("failed to parse config file: %w", err)
        }
    }
    
    return config, nil
}

func (c *Config) OverrideWithFlags() {
    // Command-line flags override config file
    flag.StringVar(&c.Server.Host, "host", c.Server.Host, "Server host")
    flag.IntVar(&c.Server.Port, "port", c.Server.Port, "Server port")
    flag.StringVar(&c.Database.Host, "db-host", c.Database.Host, "Database host")
    flag.IntVar(&c.Database.Port, "db-port", c.Database.Port, "Database port")
    flag.StringVar(&c.Logging.Level, "log-level", c.Logging.Level, "Log level")
}

func main() {
    configFile := flag.String("config", "", "Configuration file path")
    flag.Parse()
    
    // Find config file if not specified
    if *configFile == "" {
        // Check common locations
        locations := []string{
            "./config.json",
            filepath.Join(os.Getenv("HOME"), ".myapp", "config.json"),
            "/etc/myapp/config.json",
        }
        
        for _, location := range locations {
            if _, err := os.Stat(location); err == nil {
                *configFile = location
                break
            }
        }
    }
    
    // Load configuration
    config, err := LoadConfig(*configFile)
    if err != nil {
        fmt.Fprintf(os.Stderr, "Error loading config: %v\n", err)
        os.Exit(1)
    }
    
    // Override with flags
    config.OverrideWithFlags()
    flag.Parse() // Parse again after override
    
    // Display configuration
    fmt.Printf("Configuration loaded from: %s\n", *configFile)
    fmt.Printf("Server: %s:%d\n", config.Server.Host, config.Server.Port)
    fmt.Printf("Database: %s@%s:%d/%s\n", 
        config.Database.Username,
        config.Database.Host,
        config.Database.Port,
        config.Database.Database)
    fmt.Printf("Logging: %s (%s)\n", config.Logging.Level, config.Logging.Format)
}
```

**Example config.json:**

```json
{
  "server": {
    "host": "0.0.0.0",
    "port": 3000
  },
  "database": {
    "host": "db.example.com",
    "port": 5432,
    "database": "production",
    "username": "appuser",
    "password": "secret"
  },
  "logging": {
    "level": "debug",
    "format": "json",
    "output": "/var/log/myapp.log"
  }
}
```

**Usage:**

```bash
# Use config file
$ ./app --config config.json
Configuration loaded from: config.json
Server: 0.0.0.0:3000
Database: appuser@db.example.com:5432/production
Logging: debug (json)

# Override config with flags
$ ./app --config config.json --port 9000 --log-level error
Configuration loaded from: config.json
Server: 0.0.0.0:9000
Database: appuser@db.example.com:5432/production
Logging: error (json)
```

---

## Input/Output Handling

### Reading from stdin

```go
package main

import (
    "bufio"
    "fmt"
    "io"
    "os"
    "strings"
)

func main() {
    // Check if stdin is being piped
    stat, _ := os.Stdin.Stat()
    isPiped := (stat.Mode() & os.ModeCharDevice) == 0
    
    if isPiped {
        // Read from pipe
        processStream(os.Stdin)
    } else {
        // Interactive mode
        fmt.Println("Enter text (Ctrl+D to finish):")
        processStream(os.Stdin)
    }
}

func processStream(reader io.Reader) {
    scanner := bufio.NewScanner(reader)
    lineCount := 0
    wordCount := 0
    
    for scanner.Scan() {
        line := scanner.Text()
        lineCount++
        
        words := strings.Fields(line)
        wordCount += len(words)
        
        // Process line (convert to uppercase)
        fmt.Println(strings.ToUpper(line))
    }
    
    if err := scanner.Err(); err != nil {
        fmt.Fprintf(os.Stderr, "Error reading input: %v\n", err)
        os.Exit(1)
    }
    
    // Print statistics to stderr
    fmt.Fprintf(os.Stderr, "Lines: %d, Words: %d\n", lineCount, wordCount)
}
```

**Usage:**

```bash
# Interactive mode
$ ./app
Enter text (Ctrl+D to finish):
hello world
HELLO WORLD
this is a test
THIS IS A TEST
^D
Lines: 2, Words: 6

# Piped input
$ echo "hello world" | ./app
HELLO WORLD
Lines: 1, Words: 2

# From file
$ cat input.txt | ./app > output.txt
Lines: 10, Words: 50
```

### Writing to stdout/stderr

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    // Normal output to stdout
    fmt.Println("Processing data...")
    
    // Results to stdout (for piping)
    fmt.Fprintf(os.Stdout, "result1\n")
    fmt.Fprintf(os.Stdout, "result2\n")
    fmt.Fprintf(os.Stdout, "result3\n")
    
    // Diagnostics to stderr (won't be piped)
    fmt.Fprintf(os.Stderr, "Debug: Processing complete\n")
    fmt.Fprintf(os.Stderr, "Debug: 3 results generated\n")
}
```

**Usage:**

```bash
# Pipe only stdout
$ ./app | grep result
result1
result2
result3
Debug: Processing complete
Debug: 3 results generated

# Redirect stdout, see stderr
$ ./app > output.txt
Debug: Processing complete
Debug: 3 results generated

# Redirect stderr
$ ./app 2> debug.log
Processing data...
result1
result2
result3
```

---

## Interactive CLI Applications

Interactive CLIs provide user-friendly interfaces for complex operations.

### Simple Prompts

```go
package main

import (
    "bufio"
    "fmt"
    "os"
    "strings"
)

func main() {
    reader := bufio.NewReader(os.Stdin)
    
    // Simple text input
    fmt.Print("Enter your name: ")
    name, _ := reader.ReadString('\n')
    name = strings.TrimSpace(name)
    
    // Yes/No confirmation
    fmt.Print("Are you sure? (yes/no): ")
    response, _ := reader.ReadString('\n')
    response = strings.TrimSpace(strings.ToLower(response))
    
    if response == "yes" || response == "y" {
        fmt.Printf("Hello, %s!\n", name)
    } else {
        fmt.Println("Cancelled")
    }
}
```

### Interactive Menu System

```go
package main

import (
    "bufio"
    "fmt"
    "os"
    "strconv"
    "strings"
)

type MenuItem struct {
    Label  string
    Action func() error
}

type Menu struct {
    Title string
    Items []MenuItem
}

func (m *Menu) Display() {
    fmt.Printf("\n=== %s ===\n", m.Title)
    for i, item := range m.Items {
        fmt.Printf("%d. %s\n", i+1, item.Label)
    }
    fmt.Printf("0. Exit\n")
}

func (m *Menu) Run() error {
    reader := bufio.NewReader(os.Stdin)
    
    for {
        m.Display()
        fmt.Print("\nSelect option: ")
        
        input, err := reader.ReadString('\n')
        if err != nil {
            return err
        }
        
        choice := strings.TrimSpace(input)
        
        if choice == "0" {
            fmt.Println("Goodbye!")
            return nil
        }
        
        index, err := strconv.Atoi(choice)
        if err != nil || index < 1 || index > len(m.Items) {
            fmt.Println("Invalid choice, please try again")
            continue
        }
        
        // Execute selected action
        if err := m.Items[index-1].Action(); err != nil {
            fmt.Printf("Error: %v\n", err)
        }
    }
}

func main() {
    menu := &Menu{
        Title: "User Management",
        Items: []MenuItem{
            {
                Label: "Create User",
                Action: createUser,
            },
            {
                Label: "List Users",
                Action: listUsers,
            },
            {
                Label: "Delete User",
                Action: deleteUser,
            },
            {
                Label: "Settings",
                Action: showSettings,
            },
        },
    }
    
    if err := menu.Run(); err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)
    }
}

func createUser() error {
    reader := bufio.NewReader(os.Stdin)
    
    fmt.Print("\nEnter username: ")
    username, _ := reader.ReadString('\n')
    username = strings.TrimSpace(username)
    
    fmt.Print("Enter email: ")
    email, _ := reader.ReadString('\n')
    email = strings.TrimSpace(email)
    
    fmt.Printf("Creating user: %s <%s>\n", username, email)
    return nil
}

func listUsers() error {
    fmt.Println("\nUser List:")
    fmt.Println("1. admin (admin@example.com)")
    fmt.Println("2. john (john@example.com)")
    fmt.Println("3. jane (jane@example.com)")
    return nil
}

func deleteUser() error {
    reader := bufio.NewReader(os.Stdin)
    
    fmt.Print("\nEnter user ID to delete: ")
    id, _ := reader.ReadString('\n')
    id = strings.TrimSpace(id)
    
    fmt.Print("Are you sure? (yes/no): ")
    confirm, _ := reader.ReadString('\n')
    confirm = strings.TrimSpace(strings.ToLower(confirm))
    
    if confirm == "yes" || confirm == "y" {
        fmt.Printf("Deleted user %s\n", id)
    } else {
        fmt.Println("Cancelled")
    }
    
    return nil
}

func showSettings() error {
    fmt.Println("\nCurrent Settings:")
    fmt.Println("  Auto-save: enabled")
    fmt.Println("  Theme: dark")
    fmt.Println("  Notifications: enabled")
    return nil
}
```

**Usage:**

```bash
$ ./app

=== User Management ===
1. Create User
2. List Users
3. Delete User
4. Settings
5. Exit

Select option: 1

Enter username: john
Enter email: john@example.com
Creating user: john <john@example.com>

=== User Management ===
1. Create User
2. List Users
3. Delete User
4. Settings
5. Exit

Select option: 0
Goodbye!
```

### Password Input (Hidden)

```go
package main

import (
    "fmt"
    "os"
    "syscall"
    
    "golang.org/x/term"
)

func ReadPassword(prompt string) (string, error) {
    fmt.Print(prompt)
    
    // Read password without echo
    bytePassword, err := term.ReadPassword(int(syscall.Stdin))
    if err != nil {
        return "", err
    }
    
    fmt.Println() // New line after password
    return string(bytePassword), nil
}

func main() {
    username := ""
    fmt.Print("Username: ")
    fmt.Scanln(&username)
    
    password, err := ReadPassword("Password: ")
    if err != nil {
        fmt.Fprintf(os.Stderr, "Error reading password: %v\n", err)
        os.Exit(1)
    }
    
    if len(password) < 8 {
        fmt.Println("Password too short (minimum 8 characters)")
        os.Exit(1)
    }
    
    fmt.Printf("Logged in as: %s\n", username)
}
```

**Usage:**

```bash
$ ./app
Username: admin
Password: ********
Logged in as: admin
```

### Progress Indicators

```go
package main

import (
    "fmt"
    "time"
)

// Simple progress bar
func ProgressBar(current, total int) {
    percent := float64(current) / float64(total) * 100
    bar := ""
    
    for i := 0; i < 50; i++ {
        if i < int(percent/2) {
            bar += "█"
        } else {
            bar += "░"
        }
    }
    
    fmt.Printf("\r[%s] %.1f%% (%d/%d)", bar, percent, current, total)
    
    if current == total {
        fmt.Println()
    }
}

// Spinner
type Spinner struct {
    frames []string
    index  int
}

func NewSpinner() *Spinner {
    return &Spinner{
        frames: []string{"⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"},
        index:  0,
    }
}

func (s *Spinner) Next() {
    fmt.Printf("\r%s Processing...", s.frames[s.index])
    s.index = (s.index + 1) % len(s.frames)
}

func (s *Spinner) Clear() {
    fmt.Print("\r                    \r")
}

func main() {
    // Progress bar demo
    fmt.Println("Downloading file:")
    total := 100
    for i := 0; i <= total; i++ {
        ProgressBar(i, total)
        time.Sleep(50 * time.Millisecond)
    }
    
    // Spinner demo
    fmt.Println("\nProcessing data:")
    spinner := NewSpinner()
    
    for i := 0; i < 50; i++ {
        spinner.Next()
        time.Sleep(100 * time.Millisecond)
    }
    
    spinner.Clear()
    fmt.Println("Complete!")
}
```

**Output:**

```
Downloading file:
[████████████████████████████████████████████████] 100.0% (100/100)

Processing data:
⠸ Processing...
Complete!
```

### Table Output

```go
package main

import (
    "fmt"
    "strings"
)

type Table struct {
    Headers []string
    Rows    [][]string
}

func (t *Table) Print() {
    // Calculate column widths
    widths := make([]int, len(t.Headers))
    
    for i, header := range t.Headers {
        widths[i] = len(header)
    }
    
    for _, row := range t.Rows {
        for i, cell := range row {
            if len(cell) > widths[i] {
                widths[i] = len(cell)
            }
        }
    }
    
    // Print header
    printRow(t.Headers, widths)
    printSeparator(widths)
    
    // Print rows
    for _, row := range t.Rows {
        printRow(row, widths)
    }
}

func printRow(cells []string, widths []int) {
    for i, cell := range cells {
        fmt.Printf("| %-*s ", widths[i], cell)
    }
    fmt.Println("|")
}

func printSeparator(widths []int) {
    for _, width := range widths {
        fmt.Printf("+-%s-", strings.Repeat("-", width))
    }
    fmt.Println("+")
}

func main() {
    table := &Table{
        Headers: []string{"ID", "Name", "Email", "Status"},
        Rows: [][]string{
            {"1", "John Doe", "john@example.com", "Active"},
            {"2", "Jane Smith", "jane@example.com", "Active"},
            {"3", "Bob Johnson", "bob@example.com", "Inactive"},
        },
    }
    
    table.Print()
}
```

**Output:**

```
| ID | Name        | Email             | Status   |
+----+-------------+-------------------+----------+
| 1  | John Doe    | john@example.com  | Active   |
| 2  | Jane Smith  | jane@example.com  | Active   |
| 3  | Bob Johnson | bob@example.com   | Inactive |
```

---

## CLI Testing

Testing CLI applications ensures they work correctly across different scenarios.

### Testing Flag Parsing

```go
package main

import (
    "flag"
    "testing"
)

// Application code
func ParseFlags(args []string) (*Config, error) {
    fs := flag.NewFlagSet("test", flag.ContinueOnError)
    
    config := &Config{}
    
    fs.StringVar(&config.Host, "host", "localhost", "Server host")
    fs.IntVar(&config.Port, "port", 8080, "Server port")
    fs.BoolVar(&config.Verbose, "verbose", false, "Verbose output")
    
    if err := fs.Parse(args); err != nil {
        return nil, err
    }
    
    return config, nil
}

type Config struct {
    Host    string
    Port    int
    Verbose bool
}

// Tests
func TestParseFlagsDefaults(t *testing.T) {
    config, err := ParseFlags([]string{})
    
    if err != nil {
        t.Fatalf("ParseFlags() error = %v", err)
    }
    
    if config.Host != "localhost" {
        t.Errorf("Host = %v, want localhost", config.Host)
    }
    
    if config.Port != 8080 {
        t.Errorf("Port = %v, want 8080", config.Port)
    }
    
    if config.Verbose {
        t.Errorf("Verbose = %v, want false", config.Verbose)
    }
}

func TestParseFlagsCustomValues(t *testing.T) {
    args := []string{
        "--host", "example.com",
        "--port", "9000",
        "--verbose",
    }
    
    config, err := ParseFlags(args)
    
    if err != nil {
        t.Fatalf("ParseFlags() error = %v", err)
    }
    
    if config.Host != "example.com" {
        t.Errorf("Host = %v, want example.com", config.Host)
    }
    
    if config.Port != 9000 {
        t.Errorf("Port = %v, want 9000", config.Port)
    }
    
    if !config.Verbose {
        t.Errorf("Verbose = %v, want true", config.Verbose)
    }
}

func TestParseFlagsInvalidPort(t *testing.T) {
    args := []string{"--port", "invalid"}
    
    _, err := ParseFlags(args)
    
    if err == nil {
        t.Error("ParseFlags() expected error for invalid port")
    }
}
```

### Testing Command Execution

```go
package main

import (
    "bytes"
    "strings"
    "testing"
)

// Application code
type Command struct {
    Name   string
    Output *bytes.Buffer
}

func (c *Command) Execute(args []string) error {
    c.Output.WriteString("Executing command: " + c.Name + "\n")
    c.Output.WriteString("Args: " + strings.Join(args, ", ") + "\n")
    return nil
}

// Tests
func TestCommandExecute(t *testing.T) {
    output := &bytes.Buffer{}
    cmd := &Command{
        Name:   "test",
        Output: output,
    }
    
    err := cmd.Execute([]string{"arg1", "arg2"})
    
    if err != nil {
        t.Fatalf("Execute() error = %v", err)
    }
    
    expected := "Executing command: test\nArgs: arg1, arg2\n"
    if output.String() != expected {
        t.Errorf("Output = %q, want %q", output.String(), expected)
    }
}
```

### Testing Exit Codes

```go
package main

import (
    "os"
    "os/exec"
    "testing"
)

// Build the application for testing
func TestMain(m *testing.M) {
    // Build the binary
    build := exec.Command("go", "build", "-o", "testapp", ".")
    if err := build.Run(); err != nil {
        panic(err)
    }
    
    // Run tests
    code := m.Run()
    
    // Cleanup
    os.Remove("testapp")
    
    os.Exit(code)
}

func TestExitCodeSuccess(t *testing.T) {
    cmd := exec.Command("./testapp", "success")
    err := cmd.Run()
    
    if err != nil {
        t.Errorf("Expected exit code 0, got error: %v", err)
    }
}

func TestExitCodeError(t *testing.T) {
    cmd := exec.Command("./testapp", "error")
    err := cmd.Run()
    
    if err == nil {
        t.Error("Expected non-zero exit code")
        return
    }
    
    exitErr, ok := err.(*exec.ExitError)
    if !ok {
        t.Fatalf("Expected ExitError, got: %T", err)
    }
    
    if exitErr.ExitCode() != 1 {
        t.Errorf("Expected exit code 1, got: %d", exitErr.ExitCode())
    }
}
```

### Testing Stdin/Stdout

```go
package main

import (
    "bytes"
    "io"
    "os"
    "strings"
    "testing"
)

// Application code
func ProcessInput(input io.Reader, output io.Writer) error {
    data, err := io.ReadAll(input)
    if err != nil {
        return err
    }
    
    // Convert to uppercase
    result := strings.ToUpper(string(data))
    
    _, err = output.Write([]byte(result))
    return err
}

// Tests
func TestProcessInput(t *testing.T) {
    tests := []struct {
        name     string
        input    string
        expected string
    }{
        {
            name:     "simple text",
            input:    "hello world",
            expected: "HELLO WORLD",
        },
        {
            name:     "mixed case",
            input:    "Hello WORLD",
            expected: "HELLO WORLD",
        },
        {
            name:     "empty input",
            input:    "",
            expected: "",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            input := strings.NewReader(tt.input)
            output := &bytes.Buffer{}
            
            err := ProcessInput(input, output)
            
            if err != nil {
                t.Fatalf("ProcessInput() error = %v", err)
            }
            
            if output.String() != tt.expected {
                t.Errorf("ProcessInput() = %q, want %q", 
                    output.String(), tt.expected)
            }
        })
    }
}

func TestProcessInputRealFiles(t *testing.T) {
    // Create temp input file
    inputFile, err := os.CreateTemp("", "input-*.txt")
    if err != nil {
        t.Fatal(err)
    }
    defer os.Remove(inputFile.Name())
    
    inputFile.WriteString("test data")
    inputFile.Close()
    
    // Create temp output file
    outputFile, err := os.CreateTemp("", "output-*.txt")
    if err != nil {
        t.Fatal(err)
    }
    defer os.Remove(outputFile.Name())
    
    // Process
    input, _ := os.Open(inputFile.Name())
    defer input.Close()
    
    err = ProcessInput(input, outputFile)
    if err != nil {
        t.Fatalf("ProcessInput() error = %v", err)
    }
    
    outputFile.Close()
    
    // Verify output
    result, _ := os.ReadFile(outputFile.Name())
    expected := "TEST DATA"
    
    if string(result) != expected {
        t.Errorf("Output = %q, want %q", string(result), expected)
    }
}
```

### Integration Testing

```go
package main

import (
    "bytes"
    "os"
    "os/exec"
    "strings"
    "testing"
)

func TestCLIIntegration(t *testing.T) {
    tests := []struct {
        name           string
        args           []string
        stdin          string
        expectedStdout string
        expectedStderr string
        expectedExit   int
    }{
        {
            name:           "help command",
            args:           []string{"--help"},
            expectedStdout: "Usage:",
            expectedExit:   0,
        },
        {
            name:           "version command",
            args:           []string{"--version"},
            expectedStdout: "version",
            expectedExit:   0,
        },
        {
            name:         "invalid flag",
            args:         []string{"--invalid"},
            expectedExit: 1,
        },
        {
            name:           "process with stdin",
            args:           []string{"process"},
            stdin:          "hello",
            expectedStdout: "HELLO",
            expectedExit:   0,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            cmd := exec.Command("./testapp", tt.args...)
            
            var stdout, stderr bytes.Buffer
            cmd.Stdout = &stdout
            cmd.Stderr = &stderr
            
            if tt.stdin != "" {
                cmd.Stdin = strings.NewReader(tt.stdin)
            }
            
            err := cmd.Run()
            
            // Check exit code
            exitCode := 0
            if err != nil {
                if exitErr, ok := err.(*exec.ExitError); ok {
                    exitCode = exitErr.ExitCode()
                }
            }
            
            if exitCode != tt.expectedExit {
                t.Errorf("Exit code = %d, want %d", exitCode, tt.expectedExit)
            }
            
            // Check stdout
            if tt.expectedStdout != "" {
                if !strings.Contains(stdout.String(), tt.expectedStdout) {
                    t.Errorf("Stdout = %q, should contain %q", 
                        stdout.String(), tt.expectedStdout)
                }
            }
            
            // Check stderr
            if tt.expectedStderr != "" {
                if !strings.Contains(stderr.String(), tt.expectedStderr) {
                    t.Errorf("Stderr = %q, should contain %q", 
                        stderr.String(), tt.expectedStderr)
                }
            }
        })
    }
}
```

### Mocking for CLI Testing

```go
package main

import (
    "bytes"
    "testing"
)

// Interface for testability
type UserService interface {
    CreateUser(name, email string) error
    GetUser(id int) (*User, error)
}

type User struct {
    ID    int
    Name  string
    Email string
}

// Mock implementation
type MockUserService struct {
    CreateUserFunc func(name, email string) error
    GetUserFunc    func(id int) (*User, error)
}

func (m *MockUserService) CreateUser(name, email string) error {
    if m.CreateUserFunc != nil {
        return m.CreateUserFunc(name, email)
    }
    return nil
}

func (m *MockUserService) GetUser(id int) (*User, error) {
    if m.GetUserFunc != nil {
        return m.GetUserFunc(id)
    }
    return &User{ID: id, Name: "Test", Email: "test@example.com"}, nil
}

// CLI Command
type CLI struct {
    service UserService
    output  *bytes.Buffer
}

func (c *CLI) CreateUserCommand(name, email string) error {
    if err := c.service.CreateUser(name, email); err != nil {
        return err
    }
    
    c.output.WriteString("User created successfully\n")
    return nil
}

// Test
func TestCLICreateUserCommand(t *testing.T) {
    output := &bytes.Buffer{}
    
    mockService := &MockUserService{
        CreateUserFunc: func(name, email string) error {
            if name == "" {
                return fmt.Errorf("name required")
            }
            return nil
        },
    }
    
    cli := &CLI{
        service: mockService,
        output:  output,
    }
    
    // Test success
    err := cli.CreateUserCommand("John", "john@example.com")
    if err != nil {
        t.Errorf("CreateUserCommand() error = %v", err)
    }
    
    if !strings.Contains(output.String(), "successfully") {
        t.Errorf("Output = %q, should contain 'successfully'", output.String())
    }
    
    // Test error
    output.Reset()
    err = cli.CreateUserCommand("", "")
    if err == nil {
        t.Error("CreateUserCommand() expected error for empty name")
    }
}
```

---

## Summary

Part 2 covered:

✅ **Subcommands** - Git-style command hierarchies with structured systems ✅ **Advanced Flag Patterns** - Global flags, environment variables, required flags ✅ **Configuration Management** - File loading with priority (flags > env > config > defaults) ✅ **Input/Output Handling** - Stdin/stdout/stderr, piping, redirections ✅ **Interactive CLI** - Menus, prompts, password input, progress bars, tables ✅ **CLI Testing** - Flag parsing, exit codes, stdin/stdout, integration tests, mocking

**Part 3 will cover:**

- Production CLI best practices
- CLI frameworks (Cobra, urfave/cli)
- Building distribution-ready CLIs
- Cross-platform considerations
- Complete production examples

All with the same comprehensive, in-depth approach!

# The Complete Guide to Go Command-Line Applications - Part 3 of 3

## Production Best Practices, Frameworks, and Distribution

---

## Table of Contents - Part 3

1. [Production CLI Best Practices](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#production-cli-best-practices)
2. [CLI Frameworks - Cobra](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#cli-frameworks---cobra)
3. [CLI Frameworks - urfave/cli](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#cli-frameworks---urfavecli)
4. [Building Distribution-Ready CLIs](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#building-distribution-ready-clis)
5. [Cross-Platform Considerations](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#cross-platform-considerations)
6. [Advanced Features](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#advanced-features)
7. [Complete Production Examples](https://claude.ai/chat/bb595a44-b16a-4c1c-8222-20cf75dccbcd#complete-production-examples)

---

## Production CLI Best Practices

### CLI Design Principles

**1. Follow UNIX Philosophy**

```go
// GOOD: Do one thing well
// Each command has a single, clear purpose

./app convert --input file.json --output file.yaml
./app validate --input file.yaml
./app merge --files file1.yaml file2.yaml --output merged.yaml

// BAD: Swiss army knife that does everything
./app --convert --validate --merge --input file.json --output out.yaml
```

**2. Consistent Flag Naming**

```go
package main

// GOOD: Consistent naming across commands
// create command
--name       // user name
--email      // user email
--verbose    // detailed output

// delete command  
--name       // user name (same flag name)
--force      // skip confirmation
--verbose    // detailed output (consistent)

// BAD: Inconsistent naming
// create command
--name       // user name
--mail       // email (should be --email)
--debug      // detailed output

// delete command
--username   // should be --name
--no-confirm // should be --force
--verbose    // at least this one is consistent
```

**3. Provide Good Help Text**

```go
package main

import (
    "flag"
    "fmt"
    "os"
)

func main() {
    // GOOD: Descriptive help text
    flag.Usage = func() {
        fmt.Fprintf(os.Stderr, `Usage: myapp [OPTIONS] COMMAND [ARGS]

A tool for managing users in the system.

Commands:
  create      Create a new user
  delete      Delete an existing user
  list        List all users
  update      Update user information

Options:
  -v, --verbose       Enable verbose output
  -c, --config FILE   Configuration file path
  --log-level LEVEL   Set log level (debug|info|warn|error)

Examples:
  # Create a new user
  myapp create --name john --email john@example.com

  # List all active users
  myapp list --status active

  # Delete a user with confirmation
  myapp delete --id 123

For more information about a command:
  myapp COMMAND --help

Documentation: https://docs.example.com/myapp
`)
    }
    
    flag.Parse()
}
```

**4. Sensible Defaults**

```go
package main

import "flag"

type Config struct {
    Host     string
    Port     int
    Timeout  int
    MaxRetry int
    LogLevel string
}

func NewConfig() *Config {
    return &Config{
        Host:     "localhost",      // GOOD: Sensible default
        Port:     8080,              // GOOD: Standard HTTP alternate
        Timeout:  30,                // GOOD: Reasonable timeout
        MaxRetry: 3,                 // GOOD: Retry a few times
        LogLevel: "info",            // GOOD: Not too verbose, not too quiet
    }
}

// BAD Examples:
// Host: ""                  // Empty string - no default
// Port: 0                   // Invalid port
// Timeout: 1                // Too short
// MaxRetry: 100             // Too many
// LogLevel: "debug"         // Too verbose for production
```

**5. Exit Codes**

```go
package main

import (
    "fmt"
    "os"
)

const (
    ExitSuccess       = 0   // Success
    ExitGeneralError  = 1   // General error
    ExitUsageError    = 2   // Command line usage error
    ExitDataError     = 65  // Data format error
    ExitNoInput       = 66  // Cannot open input
    ExitPermissionErr = 77  // Permission denied
    ExitConfigError   = 78  // Configuration error
)

func main() {
    if err := run(); err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        
        // Exit with appropriate code
        switch err.(type) {
        case *UsageError:
            os.Exit(ExitUsageError)
        case *ConfigError:
            os.Exit(ExitConfigError)
        case *PermissionError:
            os.Exit(ExitPermissionErr)
        default:
            os.Exit(ExitGeneralError)
        }
    }
}

type UsageError struct{ msg string }
func (e *UsageError) Error() string { return e.msg }

type ConfigError struct{ msg string }
func (e *ConfigError) Error() string { return e.msg }

type PermissionError struct{ msg string }
func (e *PermissionError) Error() string { return e.msg }

func run() error {
    // Application logic
    return nil
}
```

**6. Logging Strategy**

```go
package main

import (
    "log"
    "os"
)

type Logger struct {
    verbose bool
    debug   bool
}

func NewLogger(verbose, debug bool) *Logger {
    return &Logger{
        verbose: verbose,
        debug:   debug,
    }
}

func (l *Logger) Debug(format string, args ...interface{}) {
    if l.debug {
        log.Printf("[DEBUG] "+format, args...)
    }
}

func (l *Logger) Info(format string, args ...interface{}) {
    if l.verbose {
        log.Printf("[INFO] "+format, args...)
    }
}

func (l *Logger) Warn(format string, args ...interface{}) {
    log.Printf("[WARN] "+format, args...)
}

func (l *Logger) Error(format string, args ...interface{}) {
    log.Printf("[ERROR] "+format, args...)
}

func (l *Logger) Fatal(format string, args ...interface{}) {
    log.Printf("[FATAL] "+format, args...)
    os.Exit(1)
}

// Usage
func main() {
    verbose := true
    debug := false
    
    logger := NewLogger(verbose, debug)
    
    logger.Debug("This won't be printed (debug=false)")
    logger.Info("Starting application...")
    logger.Warn("Configuration file not found, using defaults")
    logger.Error("Failed to connect to database")
}
```

**7. Signal Handling**

```go
package main

import (
    "context"
    "fmt"
    "os"
    "os/signal"
    "syscall"
    "time"
)

func main() {
    // Create context that cancels on interrupt
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    // Setup signal handling
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
    
    // Start background work
    go func() {
        <-sigChan
        fmt.Println("\nReceived interrupt signal, shutting down gracefully...")
        cancel()
    }()
    
    // Run application
    if err := run(ctx); err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)
    }
}

func run(ctx context.Context) error {
    fmt.Println("Application running. Press Ctrl+C to stop.")
    
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            fmt.Println("Cleaning up...")
            time.Sleep(500 * time.Millisecond) // Simulate cleanup
            fmt.Println("Shutdown complete")
            return nil
            
        case <-ticker.C:
            fmt.Println("Working...")
        }
    }
}
```

---

## CLI Frameworks - Cobra

Cobra is the most popular CLI framework for Go, used by Kubernetes, Hugo, Docker, and many others.

### Installing Cobra

```bash
go get -u github.com/spf13/cobra@latest
```

### Basic Cobra Application

```go
package main

import (
    "fmt"
    "os"
    
    "github.com/spf13/cobra"
)

var (
    // Global flags
    verbose bool
    config  string
)

func main() {
    if err := rootCmd.Execute(); err != nil {
        fmt.Fprintln(os.Stderr, err)
        os.Exit(1)
    }
}

var rootCmd = &cobra.Command{
    Use:   "myapp",
    Short: "MyApp is a user management tool",
    Long: `A comprehensive user management tool that allows you to
create, delete, list, and update users in your system.`,
    Version: "1.0.0",
}

func init() {
    // Global flags
    rootCmd.PersistentFlags().BoolVarP(&verbose, "verbose", "v", false, "verbose output")
    rootCmd.PersistentFlags().StringVarP(&config, "config", "c", "", "config file")
}
```

### Adding Subcommands

```go
package main

import (
    "fmt"
    
    "github.com/spf13/cobra"
)

var createCmd = &cobra.Command{
    Use:   "create",
    Short: "Create a new user",
    Long:  "Create a new user with the specified name and email address.",
    RunE: func(cmd *cobra.Command, args []string) error {
        name, _ := cmd.Flags().GetString("name")
        email, _ := cmd.Flags().GetString("email")
        admin, _ := cmd.Flags().GetBool("admin")
        
        if name == "" || email == "" {
            return fmt.Errorf("--name and --email are required")
        }
        
        fmt.Printf("Creating user: %s <%s> (admin: %t)\n", name, email, admin)
        return nil
    },
}

var deleteCmd = &cobra.Command{
    Use:   "delete [user-id]",
    Short: "Delete a user",
    Long:  "Delete a user by their ID.",
    Args:  cobra.ExactArgs(1), // Require exactly 1 argument
    RunE: func(cmd *cobra.Command, args []string) error {
        userID := args[0]
        force, _ := cmd.Flags().GetBool("force")
        
        if !force {
            fmt.Print("Are you sure? (yes/no): ")
            var response string
            fmt.Scanln(&response)
            if response != "yes" {
                fmt.Println("Cancelled")
                return nil
            }
        }
        
        fmt.Printf("Deleting user: %s\n", userID)
        return nil
    },
}

var listCmd = &cobra.Command{
    Use:   "list",
    Short: "List all users",
    RunE: func(cmd *cobra.Command, args []string) error {
        active, _ := cmd.Flags().GetBool("active")
        limit, _ := cmd.Flags().GetInt("limit")
        
        fmt.Printf("Listing users (active: %t, limit: %d)\n", active, limit)
        return nil
    },
}

func init() {
    // Add commands to root
    rootCmd.AddCommand(createCmd)
    rootCmd.AddCommand(deleteCmd)
    rootCmd.AddCommand(listCmd)
    
    // Create command flags
    createCmd.Flags().StringP("name", "n", "", "User name (required)")
    createCmd.Flags().StringP("email", "e", "", "User email (required)")
    createCmd.Flags().Bool("admin", false, "Make user an admin")
    createCmd.MarkFlagRequired("name")
    createCmd.MarkFlagRequired("email")
    
    // Delete command flags
    deleteCmd.Flags().BoolP("force", "f", false, "Force deletion without confirmation")
    
    // List command flags
    listCmd.Flags().Bool("active", false, "Show only active users")
    listCmd.Flags().IntP("limit", "l", 10, "Maximum number of users to show")
}
```

**Usage:**

```bash
# Help
$ myapp --help
A comprehensive user management tool...

# Create user
$ myapp create --name "John Doe" --email john@example.com
Creating user: John Doe <john@example.com> (admin: false)

# Create with short flags
$ myapp create -n "Jane" -e jane@example.com --admin
Creating user: Jane <jane@example.com> (admin: true)

# Delete with confirmation
$ myapp delete 123
Are you sure? (yes/no): yes
Deleting user: 123

# Force delete
$ myapp delete 456 --force
Deleting user: 456

# List users
$ myapp list --active --limit 20
Listing users (active: true, limit: 20)

# Version
$ myapp --version
myapp version 1.0.0
```

### Cobra with PreRun/PostRun Hooks

```go
package main

import (
    "fmt"
    "time"
    
    "github.com/spf13/cobra"
)

var processCmd = &cobra.Command{
    Use:   "process",
    Short: "Process data",
    PreRunE: func(cmd *cobra.Command, args []string) error {
        // Validate before running
        input, _ := cmd.Flags().GetString("input")
        if input == "" {
            return fmt.Errorf("--input is required")
        }
        
        fmt.Println("Validating inputs...")
        return nil
    },
    RunE: func(cmd *cobra.Command, args []string) error {
        input, _ := cmd.Flags().GetString("input")
        
        fmt.Printf("Processing: %s\n", input)
        time.Sleep(1 * time.Second) // Simulate work
        
        return nil
    },
    PostRunE: func(cmd *cobra.Command, args []string) error {
        // Cleanup after running
        fmt.Println("Cleaning up...")
        return nil
    },
}

func init() {
    rootCmd.AddCommand(processCmd)
    processCmd.Flags().StringP("input", "i", "", "Input file")
}
```

### Cobra with Nested Subcommands

```go
package main

import (
    "fmt"
    
    "github.com/spf13/cobra"
)

// kubectl-style nested commands
var getCmd = &cobra.Command{
    Use:   "get",
    Short: "Get resources",
}

var getPodsCmd = &cobra.Command{
    Use:   "pods",
    Short: "Get pods",
    RunE: func(cmd *cobra.Command, args []string) error {
        namespace, _ := cmd.Flags().GetString("namespace")
        fmt.Printf("Getting pods in namespace: %s\n", namespace)
        return nil
    },
}

var getServicesCmd = &cobra.Command{
    Use:   "services",
    Short: "Get services",
    RunE: func(cmd *cobra.Command, args []string) error {
        namespace, _ := cmd.Flags().GetString("namespace")
        fmt.Printf("Getting services in namespace: %s\n", namespace)
        return nil
    },
}

func init() {
    // Add nested structure
    rootCmd.AddCommand(getCmd)
    getCmd.AddCommand(getPodsCmd)
    getCmd.AddCommand(getServicesCmd)
    
    // Flags
    getCmd.PersistentFlags().StringP("namespace", "n", "default", "Kubernetes namespace")
}
```

**Usage:**

```bash
$ myapp get pods
Getting pods in namespace: default

$ myapp get pods --namespace production
Getting pods in namespace: production

$ myapp get services -n staging
Getting services in namespace: staging
```

---

## CLI Frameworks - urfave/cli

urfave/cli is another popular, lightweight CLI framework.

### Installing urfave/cli

```bash
go get -u github.com/urfave/cli/v2
```

### Basic urfave/cli Application

```go
package main

import (
    "fmt"
    "log"
    "os"
    
    "github.com/urfave/cli/v2"
)

func main() {
    app := &cli.App{
        Name:    "myapp",
        Usage:   "A user management tool",
        Version: "1.0.0",
        Flags: []cli.Flag{
            &cli.BoolFlag{
                Name:    "verbose",
                Aliases: []string{"v"},
                Usage:   "enable verbose output",
            },
            &cli.StringFlag{
                Name:    "config",
                Aliases: []string{"c"},
                Usage:   "load configuration from `FILE`",
            },
        },
        Commands: []*cli.Command{
            {
                Name:    "create",
                Aliases: []string{"c"},
                Usage:   "create a new user",
                Flags: []cli.Flag{
                    &cli.StringFlag{
                        Name:     "name",
                        Aliases:  []string{"n"},
                        Usage:    "user name",
                        Required: true,
                    },
                    &cli.StringFlag{
                        Name:     "email",
                        Aliases:  []string{"e"},
                        Usage:    "user email",
                        Required: true,
                    },
                    &cli.BoolFlag{
                        Name:  "admin",
                        Usage: "make user an admin",
                    },
                },
                Action: func(c *cli.Context) error {
                    name := c.String("name")
                    email := c.String("email")
                    admin := c.Bool("admin")
                    
                    fmt.Printf("Creating user: %s <%s> (admin: %t)\n", name, email, admin)
                    return nil
                },
            },
            {
                Name:      "delete",
                Aliases:   []string{"d"},
                Usage:     "delete a user",
                ArgsUsage: "[user-id]",
                Flags: []cli.Flag{
                    &cli.BoolFlag{
                        Name:    "force",
                        Aliases: []string{"f"},
                        Usage:   "force deletion without confirmation",
                    },
                },
                Action: func(c *cli.Context) error {
                    if c.NArg() == 0 {
                        return fmt.Errorf("user-id is required")
                    }
                    
                    userID := c.Args().First()
                    force := c.Bool("force")
                    
                    if !force {
                        fmt.Print("Are you sure? (yes/no): ")
                        var response string
                        fmt.Scanln(&response)
                        if response != "yes" {
                            fmt.Println("Cancelled")
                            return nil
                        }
                    }
                    
                    fmt.Printf("Deleting user: %s\n", userID)
                    return nil
                },
            },
            {
                Name:    "list",
                Aliases: []string{"ls"},
                Usage:   "list all users",
                Flags: []cli.Flag{
                    &cli.BoolFlag{
                        Name:  "active",
                        Usage: "show only active users",
                    },
                    &cli.IntFlag{
                        Name:    "limit",
                        Aliases: []string{"l"},
                        Value:   10,
                        Usage:   "maximum number of users to show",
                    },
                },
                Action: func(c *cli.Context) error {
                    active := c.Bool("active")
                    limit := c.Int("limit")
                    
                    fmt.Printf("Listing users (active: %t, limit: %d)\n", active, limit)
                    return nil
                },
            },
        },
    }
    
    if err := app.Run(os.Args); err != nil {
        log.Fatal(err)
    }
}
```

### urfave/cli with Categories

```go
package main

import (
    "fmt"
    "os"
    
    "github.com/urfave/cli/v2"
)

func main() {
    app := &cli.App{
        Name:  "myapp",
        Usage: "A comprehensive tool",
        Commands: []*cli.Command{
            {
                Name:     "create",
                Category: "User Management",
                Usage:    "create a new user",
                Action:   func(c *cli.Context) error { return nil },
            },
            {
                Name:     "delete",
                Category: "User Management",
                Usage:    "delete a user",
                Action:   func(c *cli.Context) error { return nil },
            },
            {
                Name:     "backup",
                Category: "Database",
                Usage:    "backup database",
                Action:   func(c *cli.Context) error { return nil },
            },
            {
                Name:     "restore",
                Category: "Database",
                Usage:    "restore database",
                Action:   func(c *cli.Context) error { return nil },
            },
        },
    }
    
    app.Run(os.Args)
}
```

**Output:**

```
NAME:
   myapp - A comprehensive tool

USAGE:
   myapp [global options] command [command options] [arguments...]

COMMANDS:
   User Management:
     create   create a new user
     delete   delete a user

   Database:
     backup   backup database
     restore  restore database

   help, h  Shows a list of commands or help for one command
```

---

## Building Distribution-Ready CLIs

### Version Information

```go
package main

import (
    "fmt"
    "runtime"
)

var (
    // Set by build flags: -ldflags "-X main.version=1.0.0"
    version   = "dev"
    commit    = "none"
    date      = "unknown"
    goVersion = runtime.Version()
)

func printVersion() {
    fmt.Printf("Version:    %s\n", version)
    fmt.Printf("Commit:     %s\n", commit)
    fmt.Printf("Build Date: %s\n", date)
    fmt.Printf("Go Version: %s\n", goVersion)
    fmt.Printf("OS/Arch:    %s/%s\n", runtime.GOOS, runtime.GOARCH)
}
```

**Build with version info:**

```bash
# Build with version information
go build -ldflags "\
  -X main.version=1.2.3 \
  -X main.commit=$(git rev-parse HEAD) \
  -X main.date=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
  -o myapp

# Run
$ ./myapp --version
Version:    1.2.3
Commit:     a1b2c3d4e5f6g7h8i9j0
Build Date: 2024-01-15T10:30:00Z
Go Version: go1.21.0
OS/Arch:    linux/amd64
```

### Makefile for Building

```makefile
# Makefile
BINARY_NAME=myapp
VERSION=$(shell git describe --tags --always --dirty)
COMMIT=$(shell git rev-parse HEAD)
DATE=$(shell date -u +"%Y-%m-%dT%H:%M:%SZ")
LDFLAGS=-ldflags "-X main.version=${VERSION} -X main.commit=${COMMIT} -X main.date=${DATE}"

.PHONY: build
build:
	go build ${LDFLAGS} -o ${BINARY_NAME}

.PHONY: build-all
build-all:
	# Build for multiple platforms
	GOOS=linux GOARCH=amd64 go build ${LDFLAGS} -o dist/${BINARY_NAME}-linux-amd64
	GOOS=linux GOARCH=arm64 go build ${LDFLAGS} -o dist/${BINARY_NAME}-linux-arm64
	GOOS=darwin GOARCH=amd64 go build ${LDFLAGS} -o dist/${BINARY_NAME}-darwin-amd64
	GOOS=darwin GOARCH=arm64 go build ${LDFLAGS} -o dist/${BINARY_NAME}-darwin-arm64
	GOOS=windows GOARCH=amd64 go build ${LDFLAGS} -o dist/${BINARY_NAME}-windows-amd64.exe

.PHONY: install
install:
	go install ${LDFLAGS}

.PHONY: test
test:
	go test -v ./...

.PHONY: clean
clean:
	rm -f ${BINARY_NAME}
	rm -rf dist/

.PHONY: release
release: clean build-all
	# Create release archives
	cd dist && \
	tar -czf ${BINARY_NAME}-linux-amd64.tar.gz ${BINARY_NAME}-linux-amd64 && \
	tar -czf ${BINARY_NAME}-darwin-amd64.tar.gz ${BINARY_NAME}-darwin-amd64 && \
	zip ${BINARY_NAME}-windows-amd64.zip ${BINARY_NAME}-windows-amd64.exe
```

**Usage:**

```bash
# Build for current platform
make build

# Build for all platforms
make build-all

# Install to $GOPATH/bin
make install

# Run tests
make test

# Clean build artifacts
make clean

# Create release archives
make release
```

### GoReleaser Configuration

```yaml
# .goreleaser.yml
project_name: myapp

before:
  hooks:
    - go mod tidy
    - go test ./...

builds:
  - env:
      - CGO_ENABLED=0
    goos:
      - linux
      - darwin
      - windows
    goarch:
      - amd64
      - arm64
    ldflags:
      - -s -w
      - -X main.version={{.Version}}
      - -X main.commit={{.Commit}}
      - -X main.date={{.Date}}

archives:
  - format: tar.gz
    name_template: >-
      {{ .ProjectName }}_
      {{- .Version }}_
      {{- title .Os }}_
      {{- if eq .Arch "amd64" }}x86_64
      {{- else }}{{ .Arch }}{{ end }}
    format_overrides:
      - goos: windows
        format: zip

checksum:
  name_template: 'checksums.txt'

snapshot:
  name_template: "{{ incpatch .Version }}-next"

changelog:
  sort: asc
  filters:
    exclude:
      - '^docs:'
      - '^test:'

release:
  github:
    owner: myuser
    name: myapp
```

**Usage:**

```bash
# Install goreleaser
go install github.com/goreleaser/goreleaser@latest

# Test release (no publish)
goreleaser release --snapshot --clean

# Create release
git tag -a v1.0.0 -m "Release v1.0.0"
git push origin v1.0.0
goreleaser release --clean
```

---

## Cross-Platform Considerations

### Path Handling

```go
package main

import (
    "path/filepath"
    "os"
    "runtime"
)

func getConfigPath() string {
    var configDir string
    
    switch runtime.GOOS {
    case "windows":
        configDir = os.Getenv("APPDATA")
        if configDir == "" {
            configDir = filepath.Join(os.Getenv("USERPROFILE"), "AppData", "Roaming")
        }
    case "darwin":
        configDir = filepath.Join(os.Getenv("HOME"), "Library", "Application Support")
    default: // linux, bsd, etc
        configDir = os.Getenv("XDG_CONFIG_HOME")
        if configDir == "" {
            configDir = filepath.Join(os.Getenv("HOME"), ".config")
        }
    }
    
    return filepath.Join(configDir, "myapp", "config.json")
}

func getDataPath() string {
    var dataDir string
    
    switch runtime.GOOS {
    case "windows":
        dataDir = os.Getenv("LOCALAPPDATA")
        if dataDir == "" {
            dataDir = filepath.Join(os.Getenv("USERPROFILE"), "AppData", "Local")
        }
    case "darwin":
        dataDir = filepath.Join(os.Getenv("HOME"), "Library", "Application Support")
    default:
        dataDir = os.Getenv("XDG_DATA_HOME")
        if dataDir == "" {
            dataDir = filepath.Join(os.Getenv("HOME"), ".local", "share")
        }
    }
    
    return filepath.Join(dataDir, "myapp")
}

// Always use filepath.Join, never string concatenation
func buildPath(parts ...string) string {
    return filepath.Join(parts...)
}

// Good
path := buildPath("data", "users", "john.json")
// Windows: data\users\john.json
// Unix:    data/users/john.json

// Bad - don't do this
path := "data/users/john.json" // Only works on Unix
```

### Platform-Specific Code

```go
// file_windows.go
// +build windows

package main

import "os/exec"

func openBrowser(url string) error {
    return exec.Command("rundll32", "url.dll,FileProtocolHandler", url).Start()
}
```

```go
// file_darwin.go
// +build darwin

package main

import "os/exec"

func openBrowser(url string) error {
    return exec.Command("open", url).Start()
}
```

```go
// file_linux.go
// +build linux

package main

import "os/exec"

func openBrowser(url string) error {
    return exec.Command("xdg-open", url).Start()
}
```

### Console Colors (Cross-Platform)

```go
package main

import (
    "fmt"
    "runtime"
)

type Color string

const (
    Reset   Color = "\033[0m"
    Red     Color = "\033[31m"
    Green   Color = "\033[32m"
    Yellow  Color = "\033[33m"
    Blue    Color = "\033[34m"
    Magenta Color = "\033[35m"
    Cyan    Color = "\033[36m"
    White   Color = "\033[37m"
)

func colorize(color Color, text string) string {
    // Disable colors on Windows without ANSI support
    if runtime.GOOS == "windows" {
        // Check if Windows 10+ with ANSI support
        // For simplicity, we'll just disable colors
        return text
    }
    
    return string(color) + text + string(Reset)
}

func main() {
    fmt.Println(colorize(Green, "Success!"))
    fmt.Println(colorize(Red, "Error!"))
    fmt.Println(colorize(Yellow, "Warning!"))
}
```

---

## Advanced Features

### Auto-Completion (Bash)

```go
package main

import (
    "github.com/spf13/cobra"
)

var completionCmd = &cobra.Command{
    Use:   "completion [bash|zsh|fish|powershell]",
    Short: "Generate completion script",
    Long: `To load completions:

Bash:
  $ source <(myapp completion bash)
  
  # To load completions for each session, execute once:
  # Linux:
  $ myapp completion bash > /etc/bash_completion.d/myapp
  # macOS:
  $ myapp completion bash > /usr/local/etc/bash_completion.d/myapp

Zsh:
  # If shell completion is not already enabled:
  $ echo "autoload -U compinit; compinit" >> ~/.zshrc
  
  $ myapp completion zsh > "${fpath[1]}/_myapp"
  $ source ~/.zshrc

Fish:
  $ myapp completion fish | source
  
  # To load completions for each session:
  $ myapp completion fish > ~/.config/fish/completions/myapp.fish

PowerShell:
  PS> myapp completion powershell | Out-String | Invoke-Expression
  
  # To load completions for every session:
  PS> myapp completion powershell > myapp.ps1
  # and source this file from your PowerShell profile.
`,
    DisableFlagsInUseLine: true,
    ValidArgs:             []string{"bash", "zsh", "fish", "powershell"},
    Args:                  cobra.ExactValidArgs(1),
    Run: func(cmd *cobra.Command, args []string) {
        switch args[0] {
        case "bash":
            cmd.Root().GenBashCompletion(os.Stdout)
        case "zsh":
            cmd.Root().GenZshCompletion(os.Stdout)
        case "fish":
            cmd.Root().GenFishCompletion(os.Stdout, true)
        case "powershell":
            cmd.Root().GenPowerShellCompletionWithDesc(os.Stdout)
        }
    },
}

func init() {
    rootCmd.AddCommand(completionCmd)
}
```

### Dynamic Completions

```go
package main

import (
    "github.com/spf13/cobra"
)

var getCmd = &cobra.Command{
    Use:   "get [resource]",
    Short: "Get a resource",
    ValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
        if len(args) == 0 {
            // Complete resource types
            return []string{"user", "group", "role"}, cobra.ShellCompDirectiveNoFileComp
        }
        
        if len(args) == 1 {
            // Complete resource names based on type
            switch args[0] {
            case "user":
                return getUserNames(), cobra.ShellCompDirectiveNoFileComp
            case "group":
                return getGroupNames(), cobra.ShellCompDirectiveNoFileComp
            case "role":
                return getRoleNames(), cobra.ShellCompDirectiveNoFileComp
            }
        }
        
        return nil, cobra.ShellCompDirectiveNoFileComp
    },
    Run: func(cmd *cobra.Command, args []string) {
        // Implementation
    },
}

func getUserNames() []string {
    // In real application, fetch from database/API
    return []string{"admin", "john", "jane"}
}

func getGroupNames() []string {
    return []string{"admins", "users", "developers"}
}

func getRoleNames() []string {
    return []string{"admin", "editor", "viewer"}
}
```

---

## Complete Production Examples

### Example 1: Database Migration Tool

A production-ready database migration CLI tool.

```go
package main

import (
    "database/sql"
    "fmt"
    "os"
    "path/filepath"
    "sort"
    "strings"
    "time"
    
    _ "github.com/lib/pq"
    "github.com/spf13/cobra"
)

var (
    dbHost     string
    dbPort     int
    dbUser     string
    dbPassword string
    dbName     string
)

func main() {
    if err := rootCmd.Execute(); err != nil {
        fmt.Fprintln(os.Stderr, err)
        os.Exit(1)
    }
}

var rootCmd = &cobra.Command{
    Use:   "migrate",
    Short: "Database migration tool",
    Long:  "A powerful database migration tool for PostgreSQL",
}

func init() {
    rootCmd.PersistentFlags().StringVar(&dbHost, "host", "localhost", "Database host")
    rootCmd.PersistentFlags().IntVar(&dbPort, "port", 5432, "Database port")
    rootCmd.PersistentFlags().StringVar(&dbUser, "user", "postgres", "Database user")
    rootCmd.PersistentFlags().StringVar(&dbPassword, "password", "", "Database password")
    rootCmd.PersistentFlags().StringVar(&dbName, "database", "", "Database name (required)")
    rootCmd.MarkPersistentFlagRequired("database")
    
    rootCmd.AddCommand(upCmd)
    rootCmd.AddCommand(downCmd)
    rootCmd.AddCommand(statusCmd)
    rootCmd.AddCommand(createCmd)
}

// Connect to database
func connect() (*sql.DB, error) {
    connStr := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
        dbHost, dbPort, dbUser, dbPassword, dbName)
    
    db, err := sql.Open("postgres", connStr)
    if err != nil {
        return nil, err
    }
    
    if err := db.Ping(); err != nil {
        return nil, err
    }
    
    return db, nil
}

// Ensure migrations table exists
func ensureMigrationsTable(db *sql.DB) error {
    query := `
        CREATE TABLE IF NOT EXISTS schema_migrations (
            version BIGINT PRIMARY KEY,
            applied_at TIMESTAMP NOT NULL DEFAULT NOW()
        )
    `
    _, err := db.Exec(query)
    return err
}

// Get applied migrations
func getAppliedMigrations(db *sql.DB) (map[int64]bool, error) {
    applied := make(map[int64]bool)
    
    rows, err := db.Query("SELECT version FROM schema_migrations ORDER BY version")
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    for rows.Next() {
        var version int64
        if err := rows.Scan(&version); err != nil {
            return nil, err
        }
        applied[version] = true
    }
    
    return applied, nil
}

// Migration represents a database migration
type Migration struct {
    Version int64
    Name    string
    UpSQL   string
    DownSQL string
}

// Load migrations from files
func loadMigrations() ([]*Migration, error) {
    var migrations []*Migration
    
    files, err := filepath.Glob("migrations/*.sql")
    if err != nil {
        return nil, err
    }
    
    for _, file := range files {
        // Parse filename: 001_create_users.sql
        basename := filepath.Base(file)
        parts := strings.SplitN(basename, "_", 2)
        if len(parts) != 2 {
            continue
        }
        
        var version int64
        if _, err := fmt.Sscanf(parts[0], "%d", &version); err != nil {
            continue
        }
        
        name := strings.TrimSuffix(parts[1], ".sql")
        
        content, err := os.ReadFile(file)
        if err != nil {
            return nil, err
        }
        
        // Split into up and down sections
        sections := strings.Split(string(content), "-- DOWN")
        upSQL := strings.TrimSpace(sections[0])
        upSQL = strings.TrimPrefix(upSQL, "-- UP")
        upSQL = strings.TrimSpace(upSQL)
        
        var downSQL string
        if len(sections) > 1 {
            downSQL = strings.TrimSpace(sections[1])
        }
        
        migrations = append(migrations, &Migration{
            Version: version,
            Name:    name,
            UpSQL:   upSQL,
            DownSQL: downSQL,
        })
    }
    
    // Sort by version
    sort.Slice(migrations, func(i, j int) bool {
        return migrations[i].Version < migrations[j].Version
    })
    
    return migrations, nil
}

var upCmd = &cobra.Command{
    Use:   "up",
    Short: "Apply pending migrations",
    RunE: func(cmd *cobra.Command, args []string) error {
        db, err := connect()
        if err != nil {
            return fmt.Errorf("failed to connect: %w", err)
        }
        defer db.Close()
        
        if err := ensureMigrationsTable(db); err != nil {
            return fmt.Errorf("failed to create migrations table: %w", err)
        }
        
        applied, err := getAppliedMigrations(db)
        if err != nil {
            return fmt.Errorf("failed to get applied migrations: %w", err)
        }
        
        migrations, err := loadMigrations()
        if err != nil {
            return fmt.Errorf("failed to load migrations: %w", err)
        }
        
        count := 0
        for _, migration := range migrations {
            if applied[migration.Version] {
                continue
            }
            
            fmt.Printf("Applying migration %d: %s...\n", migration.Version, migration.Name)
            
            // Start transaction
            tx, err := db.Begin()
            if err != nil {
                return fmt.Errorf("failed to start transaction: %w", err)
            }
            
            // Execute migration
            if _, err := tx.Exec(migration.UpSQL); err != nil {
                tx.Rollback()
                return fmt.Errorf("migration %d failed: %w", migration.Version, err)
            }
            
            // Record migration
            if _, err := tx.Exec("INSERT INTO schema_migrations (version) VALUES ($1)", migration.Version); err != nil {
                tx.Rollback()
                return fmt.Errorf("failed to record migration: %w", err)
            }
            
            if err := tx.Commit(); err != nil {
                return fmt.Errorf("failed to commit transaction: %w", err)
            }
            
            fmt.Printf("✓ Migration %d applied successfully\n", migration.Version)
            count++
        }
        
        if count == 0 {
            fmt.Println("No pending migrations")
        } else {
            fmt.Printf("\n%d migration(s) applied successfully\n", count)
        }
        
        return nil
    },
}

var downCmd = &cobra.Command{
    Use:   "down",
    Short: "Rollback last migration",
    RunE: func(cmd *cobra.Command, args []string) error {
        db, err := connect()
        if err != nil {
            return fmt.Errorf("failed to connect: %w", err)
        }
        defer db.Close()
        
        applied, err := getAppliedMigrations(db)
        if err != nil {
            return fmt.Errorf("failed to get applied migrations: %w", err)
        }
        
        migrations, err := loadMigrations()
        if err != nil {
            return fmt.Errorf("failed to load migrations: %w", err)
        }
        
        // Find last applied migration
        var lastMigration *Migration
        for i := len(migrations) - 1; i >= 0; i-- {
            if applied[migrations[i].Version] {
                lastMigration = migrations[i]
                break
            }
        }
        
        if lastMigration == nil {
            fmt.Println("No migrations to rollback")
            return nil
        }
        
        fmt.Printf("Rolling back migration %d: %s...\n", lastMigration.Version, lastMigration.Name)
        
        if lastMigration.DownSQL == "" {
            return fmt.Errorf("migration %d has no down SQL", lastMigration.Version)
        }
        
        // Start transaction
        tx, err := db.Begin()
        if err != nil {
            return fmt.Errorf("failed to start transaction: %w", err)
        }
        
        // Execute rollback
        if _, err := tx.Exec(lastMigration.DownSQL); err != nil {
            tx.Rollback()
            return fmt.Errorf("rollback failed: %w", err)
        }
        
        // Remove migration record
        if _, err := tx.Exec("DELETE FROM schema_migrations WHERE version = $1", lastMigration.Version); err != nil {
            tx.Rollback()
            return fmt.Errorf("failed to remove migration record: %w", err)
        }
        
        if err := tx.Commit(); err != nil {
            return fmt.Errorf("failed to commit transaction: %w", err)
        }
        
        fmt.Printf("✓ Migration %d rolled back successfully\n", lastMigration.Version)
        
        return nil
    },
}

var statusCmd = &cobra.Command{
    Use:   "status",
    Short: "Show migration status",
    RunE: func(cmd *cobra.Command, args []string) error {
        db, err := connect()
        if err != nil {
            return fmt.Errorf("failed to connect: %w", err)
        }
        defer db.Close()
        
        if err := ensureMigrationsTable(db); err != nil {
            return fmt.Errorf("failed to create migrations table: %w", err)
        }
        
        applied, err := getAppliedMigrations(db)
        if err != nil {
            return fmt.Errorf("failed to get applied migrations: %w", err)
        }
        
        migrations, err := loadMigrations()
        if err != nil {
            return fmt.Errorf("failed to load migrations: %w", err)
        }
        
        fmt.Println("Migration Status:")
        fmt.Println("================")
        
        for _, migration := range migrations {
            status := "[ ]"
            if applied[migration.Version] {
                status = "[✓]"
            }
            fmt.Printf("%s %d: %s\n", status, migration.Version, migration.Name)
        }
        
        pendingCount := len(migrations) - len(applied)
        fmt.Printf("\nApplied: %d, Pending: %d\n", len(applied), pendingCount)
        
        return nil
    },
}

var createCmd = &cobra.Command{
    Use:   "create [name]",
    Short: "Create a new migration file",
    Args:  cobra.ExactArgs(1),
    RunE: func(cmd *cobra.Command, args []string) error {
        name := args[0]
        
        // Create migrations directory if it doesn't exist
        if err := os.MkdirAll("migrations", 0755); err != nil {
            return fmt.Errorf("failed to create migrations directory: %w", err)
        }
        
        // Get next version number
        migrations, err := loadMigrations()
        if err != nil {
            return fmt.Errorf("failed to load migrations: %w", err)
        }
        
        version := int64(1)
        if len(migrations) > 0 {
            version = migrations[len(migrations)-1].Version + 1
        }
        
        // Create migration file
        filename := fmt.Sprintf("migrations/%03d_%s.sql", version, name)
        
        template := `-- UP
-- Write your migration SQL here

-- DOWN
-- Write your rollback SQL here
`
        
        if err := os.WriteFile(filename, []byte(template), 0644); err != nil {
            return fmt.Errorf("failed to create migration file: %w", err)
        }
        
        fmt.Printf("Created migration: %s\n", filename)
        
        return nil
    },
}
```

**Usage:**

```bash
# Create a new migration
$ migrate create create_users
Created migration: migrations/001_create_users.sql

# Check status
$ migrate --database mydb status
Migration Status:
================
[ ] 1: create_users
[ ] 2: create_posts

Applied: 0, Pending: 2

# Apply migrations
$ migrate --database mydb up
Applying migration 1: create_users...
✓ Migration 1 applied successfully
Applying migration 2: create_posts...
✓ Migration 2 applied successfully

2 migration(s) applied successfully

# Check status again
$ migrate --database mydb status
Migration Status:
================
[✓] 1: create_users
[✓] 2: create_posts

Applied: 2, Pending: 0

# Rollback last migration
$ migrate --database mydb down
Rolling back migration 2: create_posts...
✓ Migration 2 rolled back successfully
```

### Example 2: API Client CLI

A production-ready API client with authentication, retries, and error handling.

```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "os"
    "path/filepath"
    "time"
    
    "github.com/spf13/cobra"
)

var (
    apiURL      string
    apiKey      string
    configFile  string
    outputJSON  bool
    verbose     bool
)

type Config struct {
    APIURL string `json:"api_url"`
    APIKey string `json:"api_key"`
}

func main() {
    if err := rootCmd.Execute(); err != nil {
        fmt.Fprintln(os.Stderr, err)
        os.Exit(1)
    }
}

var rootCmd = &cobra.Command{
    Use:   "apicli",
    Short: "API client CLI",
    PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
        // Load config file if specified
        if configFile != "" {
            config, err := loadConfig(configFile)
            if err != nil {
                return err
            }
            
            if apiURL == "" {
                apiURL = config.APIURL
            }
            if apiKey == "" {
                apiKey = config.APIKey
            }
        }
        
        // Check required flags
        if apiURL == "" {
            return fmt.Errorf("--api-url or config file required")
        }
        
        return nil
    },
}

func init() {
    rootCmd.PersistentFlags().StringVar(&apiURL, "api-url", "", "API base URL")
    rootCmd.PersistentFlags().StringVar(&apiKey, "api-key", "", "API key")
    rootCmd.PersistentFlags().StringVar(&configFile, "config", "", "Config file path")
    rootCmd.PersistentFlags().BoolVar(&outputJSON, "json", false, "Output in JSON format")
    rootCmd.PersistentFlags().BoolVarP(&verbose, "verbose", "v", false, "Verbose output")
    
    rootCmd.AddCommand(usersCmd)
    rootCmd.AddCommand(postsCmd)
    rootCmd.AddCommand(loginCmd)
}

func loadConfig(path string) (*Config, error) {
    data, err := os.ReadFile(path)
    if err != nil {
        return nil, err
    }
    
    var config Config
    if err := json.Unmarshal(data, &config); err != nil {
        return nil, err
    }
    
    return &config, nil
}

type APIClient struct {
    BaseURL    string
    APIKey     string
    HTTPClient *http.Client
}

func NewAPIClient() *APIClient {
    return &APIClient{
        BaseURL: apiURL,
        APIKey:  apiKey,
        HTTPClient: &http.Client{
            Timeout: 30 * time.Second,
        },
    }
}

func (c *APIClient) request(method, path string, body interface{}) ([]byte, error) {
    var bodyReader io.Reader
    
    if body != nil {
        jsonData, err := json.Marshal(body)
        if err != nil {
            return nil, err
        }
        bodyReader = bytes.NewReader(jsonData)
        
        if verbose {
            fmt.Fprintf(os.Stderr, "Request body: %s\n", string(jsonData))
        }
    }
    
    url := c.BaseURL + path
    
    if verbose {
        fmt.Fprintf(os.Stderr, "%s %s\n", method, url)
    }
    
    req, err := http.NewRequest(method, url, bodyReader)
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("Content-Type", "application/json")
    if c.APIKey != "" {
        req.Header.Set("Authorization", "Bearer "+c.APIKey)
    }
    
    resp, err := c.HTTPClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    responseBody, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, err
    }
    
    if verbose {
        fmt.Fprintf(os.Stderr, "Response status: %s\n", resp.Status)
        fmt.Fprintf(os.Stderr, "Response body: %s\n", string(responseBody))
    }
    
    if resp.StatusCode >= 400 {
        return nil, fmt.Errorf("API error (%d): %s", resp.StatusCode, string(responseBody))
    }
    
    return responseBody, nil
}

var usersCmd = &cobra.Command{
    Use:   "users",
    Short: "Manage users",
}

var usersListCmd = &cobra.Command{
    Use:   "list",
    Short: "List users",
    RunE: func(cmd *cobra.Command, args []string) error {
        client := NewAPIClient()
        
        data, err := client.request("GET", "/users", nil)
        if err != nil {
            return err
        }
        
        if outputJSON {
            fmt.Println(string(data))
        } else {
            var users []map[string]interface{}
            if err := json.Unmarshal(data, &users); err != nil {
                return err
            }
            
            fmt.Printf("%-5s %-20s %-30s\n", "ID", "Name", "Email")
            fmt.Println(strings.Repeat("-", 60))
            
            for _, user := range users {
                fmt.Printf("%-5v %-20s %-30s\n",
                    user["id"],
                    user["name"],
                    user["email"])
            }
        }
        
        return nil
    },
}

var usersGetCmd = &cobra.Command{
    Use:   "get [id]",
    Short: "Get user by ID",
    Args:  cobra.ExactArgs(1),
    RunE: func(cmd *cobra.Command, args []string) error {
        client := NewAPIClient()
        
        data, err := client.request("GET", "/users/"+args[0], nil)
        if err != nil {
            return err
        }
        
        if outputJSON {
            fmt.Println(string(data))
        } else {
            var user map[string]interface{}
            if err := json.Unmarshal(data, &user); err != nil {
                return err
            }
            
            fmt.Printf("ID:    %v\n", user["id"])
            fmt.Printf("Name:  %s\n", user["name"])
            fmt.Printf("Email: %s\n", user["email"])
        }
        
        return nil
    },
}

var usersCreateCmd = &cobra.Command{
    Use:   "create",
    Short: "Create a new user",
    RunE: func(cmd *cobra.Command, args []string) error {
        name, _ := cmd.Flags().GetString("name")
        email, _ := cmd.Flags().GetString("email")
        
        client := NewAPIClient()
        
        body := map[string]string{
            "name":  name,
            "email": email,
        }
        
        data, err := client.request("POST", "/users", body)
        if err != nil {
            return err
        }
        
        fmt.Println("User created successfully")
        
        if outputJSON {
            fmt.Println(string(data))
        }
        
        return nil
    },
}

func init() {
    usersCmd.AddCommand(usersListCmd)
    usersCmd.AddCommand(usersGetCmd)
    usersCmd.AddCommand(usersCreateCmd)
    
    usersCreateCmd.Flags().String("name", "", "User name (required)")
    usersCreateCmd.Flags().String("email", "", "User email (required)")
    usersCreateCmd.MarkFlagRequired("name")
    usersCreateCmd.MarkFlagRequired("email")
}

var loginCmd = &cobra.Command{
    Use:   "login",
    Short: "Login and save credentials",
    RunE: func(cmd *cobra.Command, args []string) error {
        username, _ := cmd.Flags().GetString("username")
        password, _ := cmd.Flags().GetString("password")
        
        client := NewAPIClient()
        
        body := map[string]string{
            "username": username,
            "password": password,
        }
        
        data, err := client.request("POST", "/auth/login", body)
        if err != nil {
            return err
        }
        
        var response map[string]interface{}
        if err := json.Unmarshal(data, &response); err != nil {
            return err
        }
        
        token := response["token"].(string)
        
        // Save config
        configDir := filepath.Join(os.Getenv("HOME"), ".apicli")
        os.MkdirAll(configDir, 0700)
        
        config := Config{
            APIURL: apiURL,
            APIKey: token,
        }
        
        configData, err := json.MarshalIndent(config, "", "  ")
        if err != nil {
            return err
        }
        
        configPath := filepath.Join(configDir, "config.json")
        if err := os.WriteFile(configPath, configData, 0600); err != nil {
            return err
        }
        
        fmt.Printf("Login successful. Config saved to %s\n", configPath)
        
        return nil
    },
}

func init() {
    loginCmd.Flags().String("username", "", "Username (required)")
    loginCmd.Flags().String("password", "", "Password (required)")
    loginCmd.MarkFlagRequired("username")
    loginCmd.MarkFlagRequired("password")
}
```

**Usage:**

```bash
# Login
$ apicli --api-url https://api.example.com login \
  --username admin --password secret
Login successful. Config saved to ~/.apicli/config.json

# List users (uses saved config)
$ apicli users list
ID    Name                 Email
------------------------------------------------------------
1     John Doe             john@example.com
2     Jane Smith           jane@example.com

# Get specific user
$ apicli users get 1
ID:    1
Name:  John Doe
Email: john@example.com

# Create user
$ apicli users create --name "Bob" --email bob@example.com
User created successfully

# JSON output
$ apicli users list --json
[{"id":1,"name":"John Doe","email":"john@example.com"}]

# Verbose mode
$ apicli -v users list
GET https://api.example.com/users
Response status: 200 OK
...
```

---

## Summary

This completes the comprehensive Go Command-Line Applications guide!

### **Part 1 - Fundamentals:**

✅ Introduction and necessity ✅ CLI fundamentals (args, exit codes, streams) ✅ Command-line arguments ✅ Command-line flags ✅ Real-world examples

### **Part 2 - Advanced Patterns:**

✅ Subcommands (basic, structured, nested) ✅ Advanced flag patterns ✅ Configuration management ✅ I/O handling ✅ Interactive CLI ✅ Comprehensive testing

### **Part 3 - Production:**

✅ Production best practices (7 key principles) ✅ CLI frameworks (Cobra and urfave/cli) ✅ Building and distribution (Makefile, GoReleaser) ✅ Cross-platform considerations ✅ Advanced features (auto-completion) ✅ **2 Complete production examples:**

- Database migration tool
- API client CLI

## **Key Takeaways:**

1. **Design Principles:** Follow UNIX philosophy, consistent naming, good help text
2. **Error Handling:** Proper exit codes, clear error messages
3. **Configuration:** File < Environment < Flags priority
4. **Testing:** Unit, integration, and E2E tests
5. **Distribution:** Cross-compilation, versioning, releases
6. **Frameworks:** Cobra for complex tools, urfave/cli for simpler ones
7. **Production Ready:** Logging, signal handling, graceful shutdown

Your CLI tools are now production-ready with industry best practices! 🚀