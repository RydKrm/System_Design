# **Redis Pub/Sub**

---

When you first meet Redis, it feels like a polite little key-value store, handing you strings, lists, sets, and hashes on request. But then you discover its more talkative side — Pub/Sub — and suddenly Redis is less like a filing cabinet and more like a radio tower.

The idea is simple but powerful: one part of your system can "publish" messages without caring who’s listening, and another part can "subscribe" to channels and hear every word. There’s no queue, no storage — messages vanish into the air the moment they’re sent. It’s like live news on a TV channel: if you’re tuned in, you get it; if not, you miss it.

---

**The Scene**
Picture a chat system. You’ve got users scattered across the world, and you want them to see messages instantly. Your backend could be a swarm of servers, each handling different groups of users. Now, instead of each server calling every other server to spread the news — a chaotic mess — you set up Redis in the middle.

Server A publishes:

```
PUBLISH room:123 "Hello everyone!"
```

Redis takes that message and instantly whispers it to any connection subscribed to `room:123`. If Server B is subscribed, it gets the message immediately. If Server C is also listening, it hears it too. There’s no polling, no asking “hey, do you have something for me?” — Redis just pushes the data.

---

**Under the Hood**
Pub/Sub in Redis is purely in-memory and ephemeral. This means if a subscriber disconnects or is slow, it won’t get past messages. Redis isn’t a Kafka or RabbitMQ; there’s no persistence, no replays. Messages are like snowflakes landing on your palm — here for a moment, gone the next.

Internally, Redis maintains a mapping of channels to subscribers. Every time you publish to a channel, Redis loops through all active subscribers and writes the message to their open TCP connections. If you’re using a client library, you’re not just doing normal command/response — the library opens a special subscription mode where it sits there, waiting for Redis to push messages in.

---

**Patterns and Wildcards**
Sometimes you don’t know the exact channel name in advance. Maybe you have `room:1`, `room:2`, `room:3`, and so on. You can use pattern subscriptions:

```
PSUBSCRIBE room:*
```

This way, you’re not subscribing to a single room — you’re tuning into the whole neighborhood. Redis will match any channel name fitting your pattern and push those messages to you.

---

**Scaling the Idea**
Pub/Sub is wonderful in small doses, but when you scale out, you face a tricky question: what if you have thousands of channels and millions of subscribers? Redis can handle a lot, but you’ll eventually hit a point where one Redis instance can’t keep up with the message fan-out.

This is where strategies come into play. One approach is **channel sharding** — distributing different channels across different Redis instances so no single one is overloaded. Another approach is **combining Pub/Sub with persistence**, using Redis Streams or another broker if you need to replay messages later.

For huge distributed systems, you might combine Pub/Sub with something like **Redis Cluster** or even route messages through a **fan-out microservice** that receives from one Redis and publishes to others. Think of it like daisy-chaining radio towers.

---

**A Real-World Flow**
Let’s take a multiplayer game lobby. When a player joins a match, your game server subscribes to a channel named after that match. Players sending moves or chat messages result in your server publishing to that channel. Every other server hosting players in that match gets the messages instantly and can forward them to connected clients.

When the match ends, the servers unsubscribe, freeing Redis from tracking those channels. It’s fast, ephemeral, and low-latency — perfect for something where old messages don’t matter.

---

**The Developer’s Mindset**
Working with Redis Pub/Sub is like working with live radio signals. You can’t rewind, you can’t store, and you can’t guarantee every listener heard the message — but the simplicity is liberating. No queues to manage, no complex acknowledgements, no retry logic. It’s about *now*. If you need reliability or history, you step into a different Redis feature like Streams.

In practice, you often pair Pub/Sub with something else. The Pub/Sub channel delivers real-time notifications, and a database or cache holds the actual state so latecomers can catch up.

---

So, Redis Pub/Sub isn’t about persistence or durability — it’s about speed and immediacy. It’s the system equivalent of shouting into a crowded room: if someone’s listening, they’ll hear you instantly; if they’re not, your words fade into the air. And when you understand that, you stop trying to make it something it’s not — and start using it for the things it does best.

---

Got it — you want the **exact same architecture, flow, and structure** from that Go example, but fully rewritten in **Node.js**, without changing the logic, channel names, or messaging style.
We’ll keep the same Docker Compose setup, message schema, service behavior, and naming conventions.

Here’s the Node.js version you could actually ship.

---

## 1. Redis Infra (same as before)

No changes here — still Redis 7 via Docker.

**`infra/docker-compose.yml`**

```yaml
version: "3.9"
services:
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    command: ["redis-server", "--save", "", "--appendonly", "no"]
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 2s
      timeout: 1s
      retries: 30
  order-service:
    build: ../order-service
    environment:
      - REDIS_ADDR=redis:6379
    depends_on:
      redis:
        condition: service_healthy
  inventory-service:
    build: ../inventory-service
    environment:
      - REDIS_ADDR=redis:6379
    depends_on:
      redis:
        condition: service_healthy
```

---

## 2. Order Service (Publisher)

**`order-service/package.json`**

```json
{
  "name": "order-service",
  "version": "1.0.0",
  "main": "main.js",
  "type": "module",
  "dependencies": {
    "express": "^4.19.2",
    "ioredis": "^5.4.1",
    "body-parser": "^1.20.2"
  }
}
```

**`order-service/main.js`**

```javascript
import express from "express";
import Redis from "ioredis";
import bodyParser from "body-parser";
import process from "process";

// Env helper
function getenv(key, def) {
  return process.env[key] || def;
}

// Simple ID generator
function generateID() {
  const now = new Date();
  return now.toISOString().replace(/[-:.TZ]/g, "");
}

// Graceful shutdown
function waitForSignal(onShutdown) {
  process.on("SIGINT", () => {
    console.log("SIGINT received, shutting down...");
    onShutdown();
    process.exit(0);
  });
  process.on("SIGTERM", () => {
    console.log("SIGTERM received, shutting down...");
    onShutdown();
    process.exit(0);
  });
}

const redisAddr = getenv("REDIS_ADDR", "127.0.0.1:6379");
const [host, port] = redisAddr.split(":");
const redis = new Redis({ host, port: parseInt(port, 10) });

const app = express();
app.use(bodyParser.json());

app.post("/orders", async (req, res) => {
  try {
    const order = {
      id: generateID(),
      user_id: req.body.user_id,
      items: req.body.items || [],
      total_cents: req.body.total_cents || 0,
      created_at: new Date().toISOString()
    };

    const eventPayload = {
      event: "orders.created",
      at: new Date().toISOString(),
      order_id: order.id,
      user_id: order.user_id,
      items: order.items,
      total_cents: order.total_cents
    };

    const channel = "ecom.v1.orders.created";
    await redis.publish(channel, JSON.stringify(eventPayload));

    res.status(201).json(order);
  } catch (err) {
    console.error("Error creating order:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
});

const server = app.listen(8080, () => {
  console.log("order-service listening on :8080");
});

waitForSignal(() => {
  server.close();
  redis.disconnect();
});
```

---

## 3. Inventory Service (Subscriber)

**`inventory-service/package.json`**

```json
{
  "name": "inventory-service",
  "version": "1.0.0",
  "main": "main.js",
  "type": "module",
  "dependencies": {
    "ioredis": "^5.4.1"
  }
}
```

**`inventory-service/main.js`**

```javascript
import Redis from "ioredis";
import process from "process";

// Env helper
function getenv(key, def) {
  return process.env[key] || def;
}

function handleMessage(payload) {
  try {
    const ev = JSON.parse(payload);
    if (!ev.items) return;
    ev.items.forEach(item => {
      console.log(`decrement stock SKU=${item.sku} by ${item.quantity} for order=${ev.order_id}`);
    });
  } catch (err) {
    console.error("bad payload:", err);
  }
}

const redisAddr = getenv("REDIS_ADDR", "127.0.0.1:6379");
const [host, port] = redisAddr.split(":");

const subscriber = new Redis({ host, port: parseInt(port, 10) });

const channel = "ecom.v1.orders.created";

subscriber.subscribe(channel, (err) => {
  if (err) {
    console.error("subscribe failed:", err);
    process.exit(1);
  }
  console.log(`inventory-service listening on channel "${channel}"`);
});

subscriber.on("message", (chan, message) => {
  if (chan === channel) {
    handleMessage(message);
  }
});

process.on("SIGINT", () => {
  console.log("shutdown signal received");
  subscriber.disconnect();
  process.exit(0);
});

process.on("SIGTERM", () => {
  console.log("shutdown signal received");
  subscriber.disconnect();
  process.exit(0);
});
```

---

## 4. Running it

**Local without Docker for Node services:**

```bash
docker run -d --name redis -p 6379:6379 redis:7-alpine
cd order-service && npm install && node main.js
cd ../inventory-service && npm install && node main.js
```

**With Docker Compose:**

```bash
docker compose up --build
```

---

## 5. Testing

```bash
curl -X POST http://localhost:8080/orders \
  -H "Content-Type: application/json" \
  -d '{
        "user_id": "u_42",
        "items": [
          {"sku": "SKU-APPLE-RED-64", "quantity": 2},
          {"sku": "SKU-CASE-BLACK", "quantity": 1}
        ],
        "total_cents": 129900
      }'
```

You should see **inventory-service** instantly log:

```
decrement stock SKU=SKU-APPLE-RED-64 by 2 for order=...
decrement stock SKU=SKU-CASE-BLACK by 1 for order=...
```

---
